{
	"info": {
		"_postman_id": "15c28185-5423-42ba-ab32-4ddbd7d8e14c",
		"name": "Rapi Sandbox testing - PROD",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Get payment refund by id",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"var forge =\r",
							"/******/ (function(modules) { // webpackBootstrap\r",
							"/******/ \t// The module cache\r",
							"/******/ \tvar installedModules = {};\r",
							"/******/\r",
							"/******/ \t// The require function\r",
							"/******/ \tfunction __webpack_require__(moduleId) {\r",
							"/******/\r",
							"/******/ \t\t// Check if module is in cache\r",
							"/******/ \t\tif(installedModules[moduleId]) {\r",
							"/******/ \t\t\treturn installedModules[moduleId].exports;\r",
							"/******/ \t\t}\r",
							"/******/ \t\t// Create a new module (and put it into the cache)\r",
							"/******/ \t\tvar module = installedModules[moduleId] = {\r",
							"/******/ \t\t\ti: moduleId,\r",
							"/******/ \t\t\tl: false,\r",
							"/******/ \t\t\texports: {}\r",
							"/******/ \t\t};\r",
							"/******/\r",
							"/******/ \t\t// Execute the module function\r",
							"/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r",
							"/******/\r",
							"/******/ \t\t// Flag the module as loaded\r",
							"/******/ \t\tmodule.l = true;\r",
							"/******/\r",
							"/******/ \t\t// Return the exports of the module\r",
							"/******/ \t\treturn module.exports;\r",
							"/******/ \t}\r",
							"/******/\r",
							"/******/\r",
							"/******/ \t// expose the modules object (__webpack_modules__)\r",
							"/******/ \t__webpack_require__.m = modules;\r",
							"/******/\r",
							"/******/ \t// expose the module cache\r",
							"/******/ \t__webpack_require__.c = installedModules;\r",
							"/******/\r",
							"/******/ \t// define getter function for harmony exports\r",
							"/******/ \t__webpack_require__.d = function(exports, name, getter) {\r",
							"/******/ \t\tif(!__webpack_require__.o(exports, name)) {\r",
							"/******/ \t\t\tObject.defineProperty(exports, name, {\r",
							"/******/ \t\t\t\tconfigurable: false,\r",
							"/******/ \t\t\t\tenumerable: true,\r",
							"/******/ \t\t\t\tget: getter\r",
							"/******/ \t\t\t});\r",
							"/******/ \t\t}\r",
							"/******/ \t};\r",
							"/******/\r",
							"/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r",
							"/******/ \t__webpack_require__.n = function(module) {\r",
							"/******/ \t\tvar getter = module && module.__esModule ?\r",
							"/******/ \t\t\tfunction getDefault() { return module['default']; } :\r",
							"/******/ \t\t\tfunction getModuleExports() { return module; };\r",
							"/******/ \t\t__webpack_require__.d(getter, 'a', getter);\r",
							"/******/ \t\treturn getter;\r",
							"/******/ \t};\r",
							"/******/\r",
							"/******/ \t// Object.prototype.hasOwnProperty.call\r",
							"/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r",
							"/******/\r",
							"/******/ \t// __webpack_public_path__\r",
							"/******/ \t__webpack_require__.p = \"\";\r",
							"/******/\r",
							"/******/ \t// Load entry module and return exports\r",
							"/******/ \treturn __webpack_require__(__webpack_require__.s = 34);\r",
							"/******/ })\r",
							"/************************************************************************/\r",
							"/******/ ([\r",
							"/* 0 */\r",
							"/***/ (function(module, exports) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2016 Digital Bazaar, Inc.\r",
							" */\r",
							"module.exports = {\r",
							"  // default options\r",
							"  options: {\r",
							"    usePureJavaScript: false\r",
							"  }\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 1 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Utility functions for web applications.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2018 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"var baseN = __webpack_require__(36);\r",
							"\r",
							"/* Utilities API */\r",
							"var util = module.exports = forge.util = forge.util || {};\r",
							"\r",
							"// define setImmediate and nextTick\r",
							"(function() {\r",
							"  // use native nextTick\r",
							"  if(typeof process !== 'undefined' && process.nextTick) {\r",
							"    util.nextTick = process.nextTick;\r",
							"    if(typeof setImmediate === 'function') {\r",
							"      util.setImmediate = setImmediate;\r",
							"    } else {\r",
							"      // polyfill setImmediate with nextTick, older versions of node\r",
							"      // (those w/o setImmediate) won't totally starve IO\r",
							"      util.setImmediate = util.nextTick;\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // polyfill nextTick with native setImmediate\r",
							"  if(typeof setImmediate === 'function') {\r",
							"    util.setImmediate = function() { return setImmediate.apply(undefined, arguments); };\r",
							"    util.nextTick = function(callback) {\r",
							"      return setImmediate(callback);\r",
							"    };\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  /* Note: A polyfill upgrade pattern is used here to allow combining\r",
							"  polyfills. For example, MutationObserver is fast, but blocks UI updates,\r",
							"  so it needs to allow UI updates periodically, so it falls back on\r",
							"  postMessage or setTimeout. */\r",
							"\r",
							"  // polyfill with setTimeout\r",
							"  util.setImmediate = function(callback) {\r",
							"    setTimeout(callback, 0);\r",
							"  };\r",
							"\r",
							"  // upgrade polyfill to use postMessage\r",
							"  if(typeof window !== 'undefined' &&\r",
							"    typeof window.postMessage === 'function') {\r",
							"    var msg = 'forge.setImmediate';\r",
							"    var callbacks = [];\r",
							"    util.setImmediate = function(callback) {\r",
							"      callbacks.push(callback);\r",
							"      // only send message when one hasn't been sent in\r",
							"      // the current turn of the event loop\r",
							"      if(callbacks.length === 1) {\r",
							"        window.postMessage(msg, '*');\r",
							"      }\r",
							"    };\r",
							"    function handler(event) {\r",
							"      if(event.source === window && event.data === msg) {\r",
							"        event.stopPropagation();\r",
							"        var copy = callbacks.slice();\r",
							"        callbacks.length = 0;\r",
							"        copy.forEach(function(callback) {\r",
							"          callback();\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"    window.addEventListener('message', handler, true);\r",
							"  }\r",
							"\r",
							"  // upgrade polyfill to use MutationObserver\r",
							"  if(typeof MutationObserver !== 'undefined') {\r",
							"    // polyfill with MutationObserver\r",
							"    var now = Date.now();\r",
							"    var attr = true;\r",
							"    var div = document.createElement('div');\r",
							"    var callbacks = [];\r",
							"    new MutationObserver(function() {\r",
							"      var copy = callbacks.slice();\r",
							"      callbacks.length = 0;\r",
							"      copy.forEach(function(callback) {\r",
							"        callback();\r",
							"      });\r",
							"    }).observe(div, {attributes: true});\r",
							"    var oldSetImmediate = util.setImmediate;\r",
							"    util.setImmediate = function(callback) {\r",
							"      if(Date.now() - now > 15) {\r",
							"        now = Date.now();\r",
							"        oldSetImmediate(callback);\r",
							"      } else {\r",
							"        callbacks.push(callback);\r",
							"        // only trigger observer when it hasn't been triggered in\r",
							"        // the current turn of the event loop\r",
							"        if(callbacks.length === 1) {\r",
							"          div.setAttribute('a', attr = !attr);\r",
							"        }\r",
							"      }\r",
							"    };\r",
							"  }\r",
							"\r",
							"  util.nextTick = util.setImmediate;\r",
							"})();\r",
							"\r",
							"// check if running under Node.js\r",
							"util.isNodejs =\r",
							"  typeof process !== 'undefined' && process.versions && process.versions.node;\r",
							"\r",
							"// define isArray\r",
							"util.isArray = Array.isArray || function(x) {\r",
							"  return Object.prototype.toString.call(x) === '[object Array]';\r",
							"};\r",
							"\r",
							"// define isArrayBuffer\r",
							"util.isArrayBuffer = function(x) {\r",
							"  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;\r",
							"};\r",
							"\r",
							"// define isArrayBufferView\r",
							"util.isArrayBufferView = function(x) {\r",
							"  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for\r",
							" * algorithms where bit manipulation, JavaScript limitations, and/or algorithm\r",
							" * design only allow for byte operations of a limited size.\r",
							" *\r",
							" * @param n number of bits.\r",
							" *\r",
							" * Throw Error if n invalid.\r",
							" */\r",
							"function _checkBitsParam(n) {\r",
							"  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {\r",
							"    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);\r",
							"  }\r",
							"}\r",
							"\r",
							"// TODO: set ByteBuffer to best available backing\r",
							"util.ByteBuffer = ByteStringBuffer;\r",
							"\r",
							"/** Buffer w/BinaryString backing */\r",
							"\r",
							"/**\r",
							" * Constructor for a binary string backed byte buffer.\r",
							" *\r",
							" * @param [b] the bytes to wrap (either encoded as string, one byte per\r",
							" *          character, or as an ArrayBuffer or Typed Array).\r",
							" */\r",
							"function ByteStringBuffer(b) {\r",
							"  // TODO: update to match DataBuffer API\r",
							"\r",
							"  // the data in this buffer\r",
							"  this.data = '';\r",
							"  // the pointer for reading from this buffer\r",
							"  this.read = 0;\r",
							"\r",
							"  if(typeof b === 'string') {\r",
							"    this.data = b;\r",
							"  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\r",
							"    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {\r",
							"      this.data = b.toString('binary');\r",
							"    } else {\r",
							"      // convert native buffer to forge buffer\r",
							"      // FIXME: support native buffers internally instead\r",
							"      var arr = new Uint8Array(b);\r",
							"      try {\r",
							"        this.data = String.fromCharCode.apply(null, arr);\r",
							"      } catch(e) {\r",
							"        for(var i = 0; i < arr.length; ++i) {\r",
							"          this.putByte(arr[i]);\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"  } else if(b instanceof ByteStringBuffer ||\r",
							"    (typeof b === 'object' && typeof b.data === 'string' &&\r",
							"    typeof b.read === 'number')) {\r",
							"    // copy existing buffer\r",
							"    this.data = b.data;\r",
							"    this.read = b.read;\r",
							"  }\r",
							"\r",
							"  // used for v8 optimization\r",
							"  this._constructedStringLength = 0;\r",
							"}\r",
							"util.ByteStringBuffer = ByteStringBuffer;\r",
							"\r",
							"/* Note: This is an optimization for V8-based browsers. When V8 concatenates\r",
							"  a string, the strings are only joined logically using a \"cons string\" or\r",
							"  \"constructed/concatenated string\". These containers keep references to one\r",
							"  another and can result in very large memory usage. For example, if a 2MB\r",
							"  string is constructed by concatenating 4 bytes together at a time, the\r",
							"  memory usage will be ~44MB; so ~22x increase. The strings are only joined\r",
							"  together when an operation requiring their joining takes place, such as\r",
							"  substr(). This function is called when adding data to this buffer to ensure\r",
							"  these types of strings are periodically joined to reduce the memory\r",
							"  footprint. */\r",
							"var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\r",
							"util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\r",
							"  this._constructedStringLength += x;\r",
							"  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\r",
							"    // this substr() should cause the constructed string to join\r",
							"    this.data.substr(0, 1);\r",
							"    this._constructedStringLength = 0;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the number of bytes in this buffer.\r",
							" *\r",
							" * @return the number of bytes in this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.length = function() {\r",
							"  return this.data.length - this.read;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets whether or not this buffer is empty.\r",
							" *\r",
							" * @return true if this buffer is empty, false if not.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.isEmpty = function() {\r",
							"  return this.length() <= 0;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putByte = function(b) {\r",
							"  return this.putBytes(String.fromCharCode(b));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer N times.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" * @param n the number of bytes of value b to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\r",
							"  b = String.fromCharCode(b);\r",
							"  var d = this.data;\r",
							"  while(n > 0) {\r",
							"    if(n & 1) {\r",
							"      d += b;\r",
							"    }\r",
							"    n >>>= 1;\r",
							"    if(n > 0) {\r",
							"      b += b;\r",
							"    }\r",
							"  }\r",
							"  this.data = d;\r",
							"  this._optimizeConstructedString(n);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts bytes in this buffer.\r",
							" *\r",
							" * @param bytes the bytes (as a UTF-8 encoded string) to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putBytes = function(bytes) {\r",
							"  this.data += bytes;\r",
							"  this._optimizeConstructedString(bytes.length);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a UTF-16 encoded string into this buffer.\r",
							" *\r",
							" * @param str the string to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putString = function(str) {\r",
							"  return this.putBytes(util.encodeUtf8(str));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt16 = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt24 = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt32 = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i >> 24 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt16Le = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt24Le = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt32Le = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 24 & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts an n-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt = function(i, n) {\r",
							"  _checkBitsParam(n);\r",
							"  var bytes = '';\r",
							"  do {\r",
							"    n -= 8;\r",
							"    bytes += String.fromCharCode((i >> n) & 0xFF);\r",
							"  } while(n > 0);\r",
							"  return this.putBytes(bytes);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a signed n-bit integer in this buffer in big-endian order. Two's\r",
							" * complement representation is used.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\r",
							"  // putInt checks n\r",
							"  if(i < 0) {\r",
							"    i += 2 << (n - 1);\r",
							"  }\r",
							"  return this.putInt(i, n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts the given buffer into this buffer.\r",
							" *\r",
							" * @param buffer the buffer to put into this one.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putBuffer = function(buffer) {\r",
							"  return this.putBytes(buffer.getBytes());\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte from this buffer and advances the read pointer by 1.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getByte = function() {\r",
							"  return this.data.charCodeAt(this.read++);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in big-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt16 = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 1));\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in big-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt24 = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) << 16 ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 2));\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in big-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt32 = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) << 24 ^\r",
							"    this.data.charCodeAt(this.read + 1) << 16 ^\r",
							"    this.data.charCodeAt(this.read + 2) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 3));\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in little-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt16Le = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8);\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in little-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt24Le = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 2) << 16);\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in little-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt32Le = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 2) << 16 ^\r",
							"    this.data.charCodeAt(this.read + 3) << 24);\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an n-bit integer from this buffer in big-endian order and advances the\r",
							" * read pointer by ceil(n/8).\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt = function(n) {\r",
							"  _checkBitsParam(n);\r",
							"  var rval = 0;\r",
							"  do {\r",
							"    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\r",
							"    rval = (rval << 8) + this.data.charCodeAt(this.read++);\r",
							"    n -= 8;\r",
							"  } while(n > 0);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a signed n-bit integer from this buffer in big-endian order, using\r",
							" * two's complement, and advances the read pointer by n/8.\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getSignedInt = function(n) {\r",
							"  // getInt checks n\r",
							"  var x = this.getInt(n);\r",
							"  var max = 2 << (n - 2);\r",
							"  if(x >= max) {\r",
							"    x -= max << 1;\r",
							"  }\r",
							"  return x;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Reads bytes out into a UTF-8 string and clears them from the buffer.\r",
							" *\r",
							" * @param count the number of bytes to read, undefined or null for all.\r",
							" *\r",
							" * @return a UTF-8 string of bytes.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getBytes = function(count) {\r",
							"  var rval;\r",
							"  if(count) {\r",
							"    // read count bytes\r",
							"    count = Math.min(this.length(), count);\r",
							"    rval = this.data.slice(this.read, this.read + count);\r",
							"    this.read += count;\r",
							"  } else if(count === 0) {\r",
							"    rval = '';\r",
							"  } else {\r",
							"    // read all bytes, optimize to only copy when needed\r",
							"    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\r",
							"    this.clear();\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a UTF-8 encoded string of the bytes from this buffer without modifying\r",
							" * the read pointer.\r",
							" *\r",
							" * @param count the number of bytes to get, omit to get all.\r",
							" *\r",
							" * @return a string full of UTF-8 encoded characters.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.bytes = function(count) {\r",
							"  return (typeof(count) === 'undefined' ?\r",
							"    this.data.slice(this.read) :\r",
							"    this.data.slice(this.read, this.read + count));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.at = function(i) {\r",
							"  return this.data.charCodeAt(this.read + i);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.setAt = function(i, b) {\r",
							"  this.data = this.data.substr(0, this.read + i) +\r",
							"    String.fromCharCode(b) +\r",
							"    this.data.substr(this.read + i + 1);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the last byte without modifying the read pointer.\r",
							" *\r",
							" * @return the last byte.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.last = function() {\r",
							"  return this.data.charCodeAt(this.data.length - 1);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a copy of this buffer.\r",
							" *\r",
							" * @return the copy.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.copy = function() {\r",
							"  var c = util.createBuffer(this.data);\r",
							"  c.read = this.read;\r",
							"  return c;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compacts this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.compact = function() {\r",
							"  if(this.read > 0) {\r",
							"    this.data = this.data.slice(this.read);\r",
							"    this.read = 0;\r",
							"  }\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.clear = function() {\r",
							"  this.data = '';\r",
							"  this.read = 0;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Shortens this buffer by triming bytes off of the end of this buffer.\r",
							" *\r",
							" * @param count the number of bytes to trim off.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.truncate = function(count) {\r",
							"  var len = Math.max(0, this.length() - count);\r",
							"  this.data = this.data.substr(this.read, len);\r",
							"  this.read = 0;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a hexadecimal string.\r",
							" *\r",
							" * @return a hexadecimal string.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.toHex = function() {\r",
							"  var rval = '';\r",
							"  for(var i = this.read; i < this.data.length; ++i) {\r",
							"    var b = this.data.charCodeAt(i);\r",
							"    if(b < 16) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += b.toString(16);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a UTF-16 string (standard JavaScript string).\r",
							" *\r",
							" * @return a UTF-16 string.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.toString = function() {\r",
							"  return util.decodeUtf8(this.bytes());\r",
							"};\r",
							"\r",
							"/** End Buffer w/BinaryString backing */\r",
							"\r",
							"/** Buffer w/UInt8Array backing */\r",
							"\r",
							"/**\r",
							" * FIXME: Experimental. Do not use yet.\r",
							" *\r",
							" * Constructor for an ArrayBuffer-backed byte buffer.\r",
							" *\r",
							" * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a\r",
							" * TypedArray.\r",
							" *\r",
							" * If a string is given, its encoding should be provided as an option,\r",
							" * otherwise it will default to 'binary'. A 'binary' string is encoded such\r",
							" * that each character is one byte in length and size.\r",
							" *\r",
							" * If an ArrayBuffer, DataView, or TypedArray is given, it will be used\r",
							" * *directly* without any copying. Note that, if a write to the buffer requires\r",
							" * more space, the buffer will allocate a new backing ArrayBuffer to\r",
							" * accommodate. The starting read and write offsets for the buffer may be\r",
							" * given as options.\r",
							" *\r",
							" * @param [b] the initial bytes for this buffer.\r",
							" * @param options the options to use:\r",
							" *          [readOffset] the starting read offset to use (default: 0).\r",
							" *          [writeOffset] the starting write offset to use (default: the\r",
							" *            length of the first parameter).\r",
							" *          [growSize] the minimum amount, in bytes, to grow the buffer by to\r",
							" *            accommodate writes (default: 1024).\r",
							" *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the\r",
							" *            first parameter, if it is a string (default: 'binary').\r",
							" */\r",
							"function DataBuffer(b, options) {\r",
							"  // default options\r",
							"  options = options || {};\r",
							"\r",
							"  // pointers for read from/write to buffer\r",
							"  this.read = options.readOffset || 0;\r",
							"  this.growSize = options.growSize || 1024;\r",
							"\r",
							"  var isArrayBuffer = util.isArrayBuffer(b);\r",
							"  var isArrayBufferView = util.isArrayBufferView(b);\r",
							"  if(isArrayBuffer || isArrayBufferView) {\r",
							"    // use ArrayBuffer directly\r",
							"    if(isArrayBuffer) {\r",
							"      this.data = new DataView(b);\r",
							"    } else {\r",
							"      // TODO: adjust read/write offset based on the type of view\r",
							"      // or specify that this must be done in the options ... that the\r",
							"      // offsets are byte-based\r",
							"      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\r",
							"    }\r",
							"    this.write = ('writeOffset' in options ?\r",
							"      options.writeOffset : this.data.byteLength);\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // initialize to empty array buffer and add any given bytes using putBytes\r",
							"  this.data = new DataView(new ArrayBuffer(0));\r",
							"  this.write = 0;\r",
							"\r",
							"  if(b !== null && b !== undefined) {\r",
							"    this.putBytes(b);\r",
							"  }\r",
							"\r",
							"  if('writeOffset' in options) {\r",
							"    this.write = options.writeOffset;\r",
							"  }\r",
							"}\r",
							"util.DataBuffer = DataBuffer;\r",
							"\r",
							"/**\r",
							" * Gets the number of bytes in this buffer.\r",
							" *\r",
							" * @return the number of bytes in this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.length = function() {\r",
							"  return this.write - this.read;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets whether or not this buffer is empty.\r",
							" *\r",
							" * @return true if this buffer is empty, false if not.\r",
							" */\r",
							"util.DataBuffer.prototype.isEmpty = function() {\r",
							"  return this.length() <= 0;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Ensures this buffer has enough empty space to accommodate the given number\r",
							" * of bytes. An optional parameter may be given that indicates a minimum\r",
							" * amount to grow the buffer if necessary. If the parameter is not given,\r",
							" * the buffer will be grown by some previously-specified default amount\r",
							" * or heuristic.\r",
							" *\r",
							" * @param amount the number of bytes to accommodate.\r",
							" * @param [growSize] the minimum amount, in bytes, to grow the buffer by if\r",
							" *          necessary.\r",
							" */\r",
							"util.DataBuffer.prototype.accommodate = function(amount, growSize) {\r",
							"  if(this.length() >= amount) {\r",
							"    return this;\r",
							"  }\r",
							"  growSize = Math.max(growSize || this.growSize, amount);\r",
							"\r",
							"  // grow buffer\r",
							"  var src = new Uint8Array(\r",
							"    this.data.buffer, this.data.byteOffset, this.data.byteLength);\r",
							"  var dst = new Uint8Array(this.length() + growSize);\r",
							"  dst.set(src);\r",
							"  this.data = new DataView(dst.buffer);\r",
							"\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putByte = function(b) {\r",
							"  this.accommodate(1);\r",
							"  this.data.setUint8(this.write++, b);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer N times.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" * @param n the number of bytes of value b to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.fillWithByte = function(b, n) {\r",
							"  this.accommodate(n);\r",
							"  for(var i = 0; i < n; ++i) {\r",
							"    this.data.setUint8(b);\r",
							"  }\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts bytes in this buffer. The bytes may be given as a string, an\r",
							" * ArrayBuffer, a DataView, or a TypedArray.\r",
							" *\r",
							" * @param bytes the bytes to put.\r",
							" * @param [encoding] the encoding for the first parameter ('binary', 'utf8',\r",
							" *          'utf16', 'hex'), if it is a string (default: 'binary').\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putBytes = function(bytes, encoding) {\r",
							"  if(util.isArrayBufferView(bytes)) {\r",
							"    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\r",
							"    var len = src.byteLength - src.byteOffset;\r",
							"    this.accommodate(len);\r",
							"    var dst = new Uint8Array(this.data.buffer, this.write);\r",
							"    dst.set(src);\r",
							"    this.write += len;\r",
							"    return this;\r",
							"  }\r",
							"\r",
							"  if(util.isArrayBuffer(bytes)) {\r",
							"    var src = new Uint8Array(bytes);\r",
							"    this.accommodate(src.byteLength);\r",
							"    var dst = new Uint8Array(this.data.buffer);\r",
							"    dst.set(src, this.write);\r",
							"    this.write += src.byteLength;\r",
							"    return this;\r",
							"  }\r",
							"\r",
							"  // bytes is a util.DataBuffer or equivalent\r",
							"  if(bytes instanceof util.DataBuffer ||\r",
							"    (typeof bytes === 'object' &&\r",
							"    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&\r",
							"    util.isArrayBufferView(bytes.data))) {\r",
							"    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\r",
							"    this.accommodate(src.byteLength);\r",
							"    var dst = new Uint8Array(bytes.data.byteLength, this.write);\r",
							"    dst.set(src);\r",
							"    this.write += src.byteLength;\r",
							"    return this;\r",
							"  }\r",
							"\r",
							"  if(bytes instanceof util.ByteStringBuffer) {\r",
							"    // copy binary string and process as the same as a string parameter below\r",
							"    bytes = bytes.data;\r",
							"    encoding = 'binary';\r",
							"  }\r",
							"\r",
							"  // string conversion\r",
							"  encoding = encoding || 'binary';\r",
							"  if(typeof bytes === 'string') {\r",
							"    var view;\r",
							"\r",
							"    // decode from string\r",
							"    if(encoding === 'hex') {\r",
							"      this.accommodate(Math.ceil(bytes.length / 2));\r",
							"      view = new Uint8Array(this.data.buffer, this.write);\r",
							"      this.write += util.binary.hex.decode(bytes, view, this.write);\r",
							"      return this;\r",
							"    }\r",
							"    if(encoding === 'base64') {\r",
							"      this.accommodate(Math.ceil(bytes.length / 4) * 3);\r",
							"      view = new Uint8Array(this.data.buffer, this.write);\r",
							"      this.write += util.binary.base64.decode(bytes, view, this.write);\r",
							"      return this;\r",
							"    }\r",
							"\r",
							"    // encode text as UTF-8 bytes\r",
							"    if(encoding === 'utf8') {\r",
							"      // encode as UTF-8 then decode string as raw binary\r",
							"      bytes = util.encodeUtf8(bytes);\r",
							"      encoding = 'binary';\r",
							"    }\r",
							"\r",
							"    // decode string as raw binary\r",
							"    if(encoding === 'binary' || encoding === 'raw') {\r",
							"      // one byte per character\r",
							"      this.accommodate(bytes.length);\r",
							"      view = new Uint8Array(this.data.buffer, this.write);\r",
							"      this.write += util.binary.raw.decode(view);\r",
							"      return this;\r",
							"    }\r",
							"\r",
							"    // encode text as UTF-16 bytes\r",
							"    if(encoding === 'utf16') {\r",
							"      // two bytes per character\r",
							"      this.accommodate(bytes.length * 2);\r",
							"      view = new Uint16Array(this.data.buffer, this.write);\r",
							"      this.write += util.text.utf16.encode(view);\r",
							"      return this;\r",
							"    }\r",
							"\r",
							"    throw new Error('Invalid encoding: ' + encoding);\r",
							"  }\r",
							"\r",
							"  throw Error('Invalid parameter: ' + bytes);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts the given buffer into this buffer.\r",
							" *\r",
							" * @param buffer the buffer to put into this one.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putBuffer = function(buffer) {\r",
							"  this.putBytes(buffer);\r",
							"  buffer.clear();\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a string into this buffer.\r",
							" *\r",
							" * @param str the string to put.\r",
							" * @param [encoding] the encoding for the string (default: 'utf16').\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putString = function(str) {\r",
							"  return this.putBytes(str, 'utf16');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt16 = function(i) {\r",
							"  this.accommodate(2);\r",
							"  this.data.setInt16(this.write, i);\r",
							"  this.write += 2;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt24 = function(i) {\r",
							"  this.accommodate(3);\r",
							"  this.data.setInt16(this.write, i >> 8 & 0xFFFF);\r",
							"  this.data.setInt8(this.write, i >> 16 & 0xFF);\r",
							"  this.write += 3;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt32 = function(i) {\r",
							"  this.accommodate(4);\r",
							"  this.data.setInt32(this.write, i);\r",
							"  this.write += 4;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt16Le = function(i) {\r",
							"  this.accommodate(2);\r",
							"  this.data.setInt16(this.write, i, true);\r",
							"  this.write += 2;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt24Le = function(i) {\r",
							"  this.accommodate(3);\r",
							"  this.data.setInt8(this.write, i >> 16 & 0xFF);\r",
							"  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);\r",
							"  this.write += 3;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt32Le = function(i) {\r",
							"  this.accommodate(4);\r",
							"  this.data.setInt32(this.write, i, true);\r",
							"  this.write += 4;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts an n-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt = function(i, n) {\r",
							"  _checkBitsParam(n);\r",
							"  this.accommodate(n / 8);\r",
							"  do {\r",
							"    n -= 8;\r",
							"    this.data.setInt8(this.write++, (i >> n) & 0xFF);\r",
							"  } while(n > 0);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a signed n-bit integer in this buffer in big-endian order. Two's\r",
							" * complement representation is used.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putSignedInt = function(i, n) {\r",
							"  _checkBitsParam(n);\r",
							"  this.accommodate(n / 8);\r",
							"  if(i < 0) {\r",
							"    i += 2 << (n - 1);\r",
							"  }\r",
							"  return this.putInt(i, n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte from this buffer and advances the read pointer by 1.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.DataBuffer.prototype.getByte = function() {\r",
							"  return this.data.getInt8(this.read++);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in big-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt16 = function() {\r",
							"  var rval = this.data.getInt16(this.read);\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in big-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt24 = function() {\r",
							"  var rval = (\r",
							"    this.data.getInt16(this.read) << 8 ^\r",
							"    this.data.getInt8(this.read + 2));\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in big-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt32 = function() {\r",
							"  var rval = this.data.getInt32(this.read);\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in little-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt16Le = function() {\r",
							"  var rval = this.data.getInt16(this.read, true);\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in little-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt24Le = function() {\r",
							"  var rval = (\r",
							"    this.data.getInt8(this.read) ^\r",
							"    this.data.getInt16(this.read + 1, true) << 8);\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in little-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt32Le = function() {\r",
							"  var rval = this.data.getInt32(this.read, true);\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an n-bit integer from this buffer in big-endian order and advances the\r",
							" * read pointer by n/8.\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt = function(n) {\r",
							"  _checkBitsParam(n);\r",
							"  var rval = 0;\r",
							"  do {\r",
							"    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\r",
							"    rval = (rval << 8) + this.data.getInt8(this.read++);\r",
							"    n -= 8;\r",
							"  } while(n > 0);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a signed n-bit integer from this buffer in big-endian order, using\r",
							" * two's complement, and advances the read pointer by n/8.\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.DataBuffer.prototype.getSignedInt = function(n) {\r",
							"  // getInt checks n\r",
							"  var x = this.getInt(n);\r",
							"  var max = 2 << (n - 2);\r",
							"  if(x >= max) {\r",
							"    x -= max << 1;\r",
							"  }\r",
							"  return x;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Reads bytes out into a UTF-8 string and clears them from the buffer.\r",
							" *\r",
							" * @param count the number of bytes to read, undefined or null for all.\r",
							" *\r",
							" * @return a UTF-8 string of bytes.\r",
							" */\r",
							"util.DataBuffer.prototype.getBytes = function(count) {\r",
							"  // TODO: deprecate this method, it is poorly named and\r",
							"  // this.toString('binary') replaces it\r",
							"  // add a toTypedArray()/toArrayBuffer() function\r",
							"  var rval;\r",
							"  if(count) {\r",
							"    // read count bytes\r",
							"    count = Math.min(this.length(), count);\r",
							"    rval = this.data.slice(this.read, this.read + count);\r",
							"    this.read += count;\r",
							"  } else if(count === 0) {\r",
							"    rval = '';\r",
							"  } else {\r",
							"    // read all bytes, optimize to only copy when needed\r",
							"    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\r",
							"    this.clear();\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a UTF-8 encoded string of the bytes from this buffer without modifying\r",
							" * the read pointer.\r",
							" *\r",
							" * @param count the number of bytes to get, omit to get all.\r",
							" *\r",
							" * @return a string full of UTF-8 encoded characters.\r",
							" */\r",
							"util.DataBuffer.prototype.bytes = function(count) {\r",
							"  // TODO: deprecate this method, it is poorly named, add \"getString()\"\r",
							"  return (typeof(count) === 'undefined' ?\r",
							"    this.data.slice(this.read) :\r",
							"    this.data.slice(this.read, this.read + count));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.DataBuffer.prototype.at = function(i) {\r",
							"  return this.data.getUint8(this.read + i);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.setAt = function(i, b) {\r",
							"  this.data.setUint8(i, b);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the last byte without modifying the read pointer.\r",
							" *\r",
							" * @return the last byte.\r",
							" */\r",
							"util.DataBuffer.prototype.last = function() {\r",
							"  return this.data.getUint8(this.write - 1);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a copy of this buffer.\r",
							" *\r",
							" * @return the copy.\r",
							" */\r",
							"util.DataBuffer.prototype.copy = function() {\r",
							"  return new util.DataBuffer(this);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compacts this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.compact = function() {\r",
							"  if(this.read > 0) {\r",
							"    var src = new Uint8Array(this.data.buffer, this.read);\r",
							"    var dst = new Uint8Array(src.byteLength);\r",
							"    dst.set(src);\r",
							"    this.data = new DataView(dst);\r",
							"    this.write -= this.read;\r",
							"    this.read = 0;\r",
							"  }\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.clear = function() {\r",
							"  this.data = new DataView(new ArrayBuffer(0));\r",
							"  this.read = this.write = 0;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Shortens this buffer by triming bytes off of the end of this buffer.\r",
							" *\r",
							" * @param count the number of bytes to trim off.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.truncate = function(count) {\r",
							"  this.write = Math.max(0, this.length() - count);\r",
							"  this.read = Math.min(this.read, this.write);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a hexadecimal string.\r",
							" *\r",
							" * @return a hexadecimal string.\r",
							" */\r",
							"util.DataBuffer.prototype.toHex = function() {\r",
							"  var rval = '';\r",
							"  for(var i = this.read; i < this.data.byteLength; ++i) {\r",
							"    var b = this.data.getUint8(i);\r",
							"    if(b < 16) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += b.toString(16);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a string, using the given encoding. If no\r",
							" * encoding is given, 'utf8' (UTF-8) is used.\r",
							" *\r",
							" * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',\r",
							" *          'base64' (default: 'utf8').\r",
							" *\r",
							" * @return a string representation of the bytes in this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.toString = function(encoding) {\r",
							"  var view = new Uint8Array(this.data, this.read, this.length());\r",
							"  encoding = encoding || 'utf8';\r",
							"\r",
							"  // encode to string\r",
							"  if(encoding === 'binary' || encoding === 'raw') {\r",
							"    return util.binary.raw.encode(view);\r",
							"  }\r",
							"  if(encoding === 'hex') {\r",
							"    return util.binary.hex.encode(view);\r",
							"  }\r",
							"  if(encoding === 'base64') {\r",
							"    return util.binary.base64.encode(view);\r",
							"  }\r",
							"\r",
							"  // decode to text\r",
							"  if(encoding === 'utf8') {\r",
							"    return util.text.utf8.decode(view);\r",
							"  }\r",
							"  if(encoding === 'utf16') {\r",
							"    return util.text.utf16.decode(view);\r",
							"  }\r",
							"\r",
							"  throw new Error('Invalid encoding: ' + encoding);\r",
							"};\r",
							"\r",
							"/** End Buffer w/UInt8Array backing */\r",
							"\r",
							"/**\r",
							" * Creates a buffer that stores bytes. A value may be given to put into the\r",
							" * buffer that is either a string of bytes or a UTF-16 string that will\r",
							" * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).\r",
							" *\r",
							" * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode\r",
							" *          as UTF-8.\r",
							" * @param [encoding] (default: 'raw', other: 'utf8').\r",
							" */\r",
							"util.createBuffer = function(input, encoding) {\r",
							"  // TODO: deprecate, use new ByteBuffer() instead\r",
							"  encoding = encoding || 'raw';\r",
							"  if(input !== undefined && encoding === 'utf8') {\r",
							"    input = util.encodeUtf8(input);\r",
							"  }\r",
							"  return new util.ByteBuffer(input);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Fills a string with a particular value. If you want the string to be a byte\r",
							" * string, pass in String.fromCharCode(theByte).\r",
							" *\r",
							" * @param c the character to fill the string with, use String.fromCharCode\r",
							" *          to fill the string with a byte value.\r",
							" * @param n the number of characters of value c to fill with.\r",
							" *\r",
							" * @return the filled string.\r",
							" */\r",
							"util.fillString = function(c, n) {\r",
							"  var s = '';\r",
							"  while(n > 0) {\r",
							"    if(n & 1) {\r",
							"      s += c;\r",
							"    }\r",
							"    n >>>= 1;\r",
							"    if(n > 0) {\r",
							"      c += c;\r",
							"    }\r",
							"  }\r",
							"  return s;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Performs a per byte XOR between two byte strings and returns the result as a\r",
							" * string of bytes.\r",
							" *\r",
							" * @param s1 first string of bytes.\r",
							" * @param s2 second string of bytes.\r",
							" * @param n the number of bytes to XOR.\r",
							" *\r",
							" * @return the XOR'd result.\r",
							" */\r",
							"util.xorBytes = function(s1, s2, n) {\r",
							"  var s3 = '';\r",
							"  var b = '';\r",
							"  var t = '';\r",
							"  var i = 0;\r",
							"  var c = 0;\r",
							"  for(; n > 0; --n, ++i) {\r",
							"    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\r",
							"    if(c >= 10) {\r",
							"      s3 += t;\r",
							"      t = '';\r",
							"      c = 0;\r",
							"    }\r",
							"    t += String.fromCharCode(b);\r",
							"    ++c;\r",
							"  }\r",
							"  s3 += t;\r",
							"  return s3;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a hex string into a 'binary' encoded string of bytes.\r",
							" *\r",
							" * @param hex the hexadecimal string to convert.\r",
							" *\r",
							" * @return the binary-encoded string of bytes.\r",
							" */\r",
							"util.hexToBytes = function(hex) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.hex.decode instead.\"\r",
							"  var rval = '';\r",
							"  var i = 0;\r",
							"  if(hex.length & 1 == 1) {\r",
							"    // odd number of characters, convert first character alone\r",
							"    i = 1;\r",
							"    rval += String.fromCharCode(parseInt(hex[0], 16));\r",
							"  }\r",
							"  // convert 2 characters (1 byte) at a time\r",
							"  for(; i < hex.length; i += 2) {\r",
							"    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a 'binary' encoded string of bytes to hex.\r",
							" *\r",
							" * @param bytes the byte string to convert.\r",
							" *\r",
							" * @return the string of hexadecimal characters.\r",
							" */\r",
							"util.bytesToHex = function(bytes) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.hex.encode instead.\"\r",
							"  return util.createBuffer(bytes).toHex();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an 32-bit integer to 4-big-endian byte string.\r",
							" *\r",
							" * @param i the integer.\r",
							" *\r",
							" * @return the byte string.\r",
							" */\r",
							"util.int32ToBytes = function(i) {\r",
							"  return (\r",
							"    String.fromCharCode(i >> 24 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"// base64 characters, reverse mapping\r",
							"var _base64 =\r",
							"  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r",
							"var _base64Idx = [\r",
							"/*43 -43 = 0*/\r",
							"/*'+',  1,  2,  3,'/' */\r",
							"   62, -1, -1, -1, 63,\r",
							"\r",
							"/*'0','1','2','3','4','5','6','7','8','9' */\r",
							"   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\r",
							"\r",
							"/*15, 16, 17,'=', 19, 20, 21 */\r",
							"  -1, -1, -1, 64, -1, -1, -1,\r",
							"\r",
							"/*65 - 43 = 22*/\r",
							"/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */\r",
							"   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,\r",
							"\r",
							"/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */\r",
							"   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\r",
							"\r",
							"/*91 - 43 = 48 */\r",
							"/*48, 49, 50, 51, 52, 53 */\r",
							"  -1, -1, -1, -1, -1, -1,\r",
							"\r",
							"/*97 - 43 = 54*/\r",
							"/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */\r",
							"   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\r",
							"\r",
							"/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */\r",
							"   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\r",
							"];\r",
							"\r",
							"// base58 characters (Bitcoin alphabet)\r",
							"var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\r",
							"\r",
							"/**\r",
							" * Base64 encodes a 'binary' encoded string of bytes.\r",
							" *\r",
							" * @param input the binary encoded string of bytes to base64-encode.\r",
							" * @param maxline the maximum number of encoded characters per line to use,\r",
							" *          defaults to none.\r",
							" *\r",
							" * @return the base64-encoded output.\r",
							" */\r",
							"util.encode64 = function(input, maxline) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.base64.encode instead.\"\r",
							"  var line = '';\r",
							"  var output = '';\r",
							"  var chr1, chr2, chr3;\r",
							"  var i = 0;\r",
							"  while(i < input.length) {\r",
							"    chr1 = input.charCodeAt(i++);\r",
							"    chr2 = input.charCodeAt(i++);\r",
							"    chr3 = input.charCodeAt(i++);\r",
							"\r",
							"    // encode 4 character group\r",
							"    line += _base64.charAt(chr1 >> 2);\r",
							"    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\r",
							"    if(isNaN(chr2)) {\r",
							"      line += '==';\r",
							"    } else {\r",
							"      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\r",
							"      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\r",
							"    }\r",
							"\r",
							"    if(maxline && line.length > maxline) {\r",
							"      output += line.substr(0, maxline) + '\\r\\n';\r",
							"      line = line.substr(maxline);\r",
							"    }\r",
							"  }\r",
							"  output += line;\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Base64 decodes a string into a 'binary' encoded string of bytes.\r",
							" *\r",
							" * @param input the base64-encoded input.\r",
							" *\r",
							" * @return the binary encoded string.\r",
							" */\r",
							"util.decode64 = function(input) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.base64.decode instead.\"\r",
							"\r",
							"  // remove all non-base64 characters\r",
							"  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\r",
							"\r",
							"  var output = '';\r",
							"  var enc1, enc2, enc3, enc4;\r",
							"  var i = 0;\r",
							"\r",
							"  while(i < input.length) {\r",
							"    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"\r",
							"    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));\r",
							"    if(enc3 !== 64) {\r",
							"      // decoded at least 2 bytes\r",
							"      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));\r",
							"      if(enc4 !== 64) {\r",
							"        // decoded 3 bytes\r",
							"        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript\r",
							" * string). Non-ASCII characters will be encoded as multiple bytes according\r",
							" * to UTF-8.\r",
							" *\r",
							" * @param str the string to encode.\r",
							" *\r",
							" * @return the UTF-8 encoded string.\r",
							" */\r",
							"util.encodeUtf8 = function(str) {\r",
							"  return unescape(encodeURIComponent(str));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a UTF-8 encoded string into a UTF-16 string.\r",
							" *\r",
							" * @param str the string to decode.\r",
							" *\r",
							" * @return the UTF-16 encoded string (standard JavaScript string).\r",
							" */\r",
							"util.decodeUtf8 = function(str) {\r",
							"  return decodeURIComponent(escape(str));\r",
							"};\r",
							"\r",
							"// binary encoding/decoding tools\r",
							"// FIXME: Experimental. Do not use yet.\r",
							"util.binary = {\r",
							"  raw: {},\r",
							"  hex: {},\r",
							"  base64: {},\r",
							"  base58: {},\r",
							"  baseN : {\r",
							"    encode: baseN.encode,\r",
							"    decode: baseN.decode\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a Uint8Array as a binary-encoded string. This encoding uses\r",
							" * a value between 0 and 255 for each character.\r",
							" *\r",
							" * @param bytes the Uint8Array to encode.\r",
							" *\r",
							" * @return the binary-encoded string.\r",
							" */\r",
							"util.binary.raw.encode = function(bytes) {\r",
							"  return String.fromCharCode.apply(null, bytes);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a binary-encoded string to a Uint8Array. This encoding uses\r",
							" * a value between 0 and 255 for each character.\r",
							" *\r",
							" * @param str the binary-encoded string to decode.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.binary.raw.decode = function(str, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(str.length);\r",
							"  }\r",
							"  offset = offset || 0;\r",
							"  var j = offset;\r",
							"  for(var i = 0; i < str.length; ++i) {\r",
							"    out[j++] = str.charCodeAt(i);\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or\r",
							" * ByteBuffer as a string of hexadecimal characters.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the string of hexadecimal characters.\r",
							" */\r",
							"util.binary.hex.encode = util.bytesToHex;\r",
							"\r",
							"/**\r",
							" * Decodes a hex-encoded string to a Uint8Array.\r",
							" *\r",
							" * @param hex the hexadecimal string to convert.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.binary.hex.decode = function(hex, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(Math.ceil(hex.length / 2));\r",
							"  }\r",
							"  offset = offset || 0;\r",
							"  var i = 0, j = offset;\r",
							"  if(hex.length & 1) {\r",
							"    // odd number of characters, convert first character alone\r",
							"    i = 1;\r",
							"    out[j++] = parseInt(hex[0], 16);\r",
							"  }\r",
							"  // convert 2 characters (1 byte) at a time\r",
							"  for(; i < hex.length; i += 2) {\r",
							"    out[j++] = parseInt(hex.substr(i, 2), 16);\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Base64-encodes a Uint8Array.\r",
							" *\r",
							" * @param input the Uint8Array to encode.\r",
							" * @param maxline the maximum number of encoded characters per line to use,\r",
							" *          defaults to none.\r",
							" *\r",
							" * @return the base64-encoded output string.\r",
							" */\r",
							"util.binary.base64.encode = function(input, maxline) {\r",
							"  var line = '';\r",
							"  var output = '';\r",
							"  var chr1, chr2, chr3;\r",
							"  var i = 0;\r",
							"  while(i < input.byteLength) {\r",
							"    chr1 = input[i++];\r",
							"    chr2 = input[i++];\r",
							"    chr3 = input[i++];\r",
							"\r",
							"    // encode 4 character group\r",
							"    line += _base64.charAt(chr1 >> 2);\r",
							"    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\r",
							"    if(isNaN(chr2)) {\r",
							"      line += '==';\r",
							"    } else {\r",
							"      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\r",
							"      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\r",
							"    }\r",
							"\r",
							"    if(maxline && line.length > maxline) {\r",
							"      output += line.substr(0, maxline) + '\\r\\n';\r",
							"      line = line.substr(maxline);\r",
							"    }\r",
							"  }\r",
							"  output += line;\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a base64-encoded string to a Uint8Array.\r",
							" *\r",
							" * @param input the base64-encoded input string.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.binary.base64.decode = function(input, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(Math.ceil(input.length / 4) * 3);\r",
							"  }\r",
							"\r",
							"  // remove all non-base64 characters\r",
							"  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\r",
							"\r",
							"  offset = offset || 0;\r",
							"  var enc1, enc2, enc3, enc4;\r",
							"  var i = 0, j = offset;\r",
							"\r",
							"  while(i < input.length) {\r",
							"    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"\r",
							"    out[j++] = (enc1 << 2) | (enc2 >> 4);\r",
							"    if(enc3 !== 64) {\r",
							"      // decoded at least 2 bytes\r",
							"      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);\r",
							"      if(enc4 !== 64) {\r",
							"        // decoded 3 bytes\r",
							"        out[j++] = ((enc3 & 3) << 6) | enc4;\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // make sure result is the exact decoded length\r",
							"  return output ? (j - offset) : out.subarray(0, j);\r",
							"};\r",
							"\r",
							"// add support for base58 encoding/decoding with Bitcoin alphabet\r",
							"util.binary.base58.encode = function(input, maxline) {\r",
							"  return util.binary.baseN.encode(input, _base58, maxline);\r",
							"};\r",
							"util.binary.base58.decode = function(input, maxline) {\r",
							"  return util.binary.baseN.decode(input, _base58, maxline);\r",
							"};\r",
							"\r",
							"// text encoding/decoding tools\r",
							"// FIXME: Experimental. Do not use yet.\r",
							"util.text = {\r",
							"  utf8: {},\r",
							"  utf16: {}\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes the given string as UTF-8 in a Uint8Array.\r",
							" *\r",
							" * @param str the string to encode.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.text.utf8.encode = function(str, output, offset) {\r",
							"  str = util.encodeUtf8(str);\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(str.length);\r",
							"  }\r",
							"  offset = offset || 0;\r",
							"  var j = offset;\r",
							"  for(var i = 0; i < str.length; ++i) {\r",
							"    out[j++] = str.charCodeAt(i);\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes the UTF-8 contents from a Uint8Array.\r",
							" *\r",
							" * @param bytes the Uint8Array to decode.\r",
							" *\r",
							" * @return the resulting string.\r",
							" */\r",
							"util.text.utf8.decode = function(bytes) {\r",
							"  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes the given string as UTF-16 in a Uint8Array.\r",
							" *\r",
							" * @param str the string to encode.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.text.utf16.encode = function(str, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(str.length * 2);\r",
							"  }\r",
							"  var view = new Uint16Array(out.buffer);\r",
							"  offset = offset || 0;\r",
							"  var j = offset;\r",
							"  var k = offset;\r",
							"  for(var i = 0; i < str.length; ++i) {\r",
							"    view[k++] = str.charCodeAt(i);\r",
							"    j += 2;\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes the UTF-16 contents from a Uint8Array.\r",
							" *\r",
							" * @param bytes the Uint8Array to decode.\r",
							" *\r",
							" * @return the resulting string.\r",
							" */\r",
							"util.text.utf16.decode = function(bytes) {\r",
							"  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deflates the given data using a flash interface.\r",
							" *\r",
							" * @param api the flash interface.\r",
							" * @param bytes the data.\r",
							" * @param raw true to return only raw deflate data, false to include zlib\r",
							" *          header and trailer.\r",
							" *\r",
							" * @return the deflated data as a string.\r",
							" */\r",
							"util.deflate = function(api, bytes, raw) {\r",
							"  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\r",
							"\r",
							"  // strip zlib header and trailer if necessary\r",
							"  if(raw) {\r",
							"    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\r",
							"    // there is a 4-byte DICT (alder-32) block before the data if\r",
							"    // its 5th bit is set\r",
							"    var start = 2;\r",
							"    var flg = bytes.charCodeAt(1);\r",
							"    if(flg & 0x20) {\r",
							"      start = 6;\r",
							"    }\r",
							"    // zlib trailer is 4 bytes of adler-32\r",
							"    bytes = bytes.substring(start, bytes.length - 4);\r",
							"  }\r",
							"\r",
							"  return bytes;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Inflates the given data using a flash interface.\r",
							" *\r",
							" * @param api the flash interface.\r",
							" * @param bytes the data.\r",
							" * @param raw true if the incoming data has no zlib header or trailer and is\r",
							" *          raw DEFLATE data.\r",
							" *\r",
							" * @return the inflated data as a string, null on error.\r",
							" */\r",
							"util.inflate = function(api, bytes, raw) {\r",
							"  // TODO: add zlib header and trailer if necessary/possible\r",
							"  var rval = api.inflate(util.encode64(bytes)).rval;\r",
							"  return (rval === null) ? null : util.decode64(rval);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets a storage object.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param obj the storage object, null to remove.\r",
							" */\r",
							"var _setStorageObject = function(api, id, obj) {\r",
							"  if(!api) {\r",
							"    throw new Error('WebStorage not available.');\r",
							"  }\r",
							"\r",
							"  var rval;\r",
							"  if(obj === null) {\r",
							"    rval = api.removeItem(id);\r",
							"  } else {\r",
							"    // json-encode and base64-encode object\r",
							"    obj = util.encode64(JSON.stringify(obj));\r",
							"    rval = api.setItem(id, obj);\r",
							"  }\r",
							"\r",
							"  // handle potential flash error\r",
							"  if(typeof(rval) !== 'undefined' && rval.rval !== true) {\r",
							"    var error = new Error(rval.error.message);\r",
							"    error.id = rval.error.id;\r",
							"    error.name = rval.error.name;\r",
							"    throw error;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a storage object.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" *\r",
							" * @return the storage object entry or null if none exists.\r",
							" */\r",
							"var _getStorageObject = function(api, id) {\r",
							"  if(!api) {\r",
							"    throw new Error('WebStorage not available.');\r",
							"  }\r",
							"\r",
							"  // get the existing entry\r",
							"  var rval = api.getItem(id);\r",
							"\r",
							"  /* Note: We check api.init because we can't do (api == localStorage)\r",
							"    on IE because of \"Class doesn't support Automation\" exception. Only\r",
							"    the flash api has an init method so this works too, but we need a\r",
							"    better solution in the future. */\r",
							"\r",
							"  // flash returns item wrapped in an object, handle special case\r",
							"  if(api.init) {\r",
							"    if(rval.rval === null) {\r",
							"      if(rval.error) {\r",
							"        var error = new Error(rval.error.message);\r",
							"        error.id = rval.error.id;\r",
							"        error.name = rval.error.name;\r",
							"        throw error;\r",
							"      }\r",
							"      // no error, but also no item\r",
							"      rval = null;\r",
							"    } else {\r",
							"      rval = rval.rval;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // handle decoding\r",
							"  if(rval !== null) {\r",
							"    // base64-decode and json-decode data\r",
							"    rval = JSON.parse(util.decode64(rval));\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Stores an item in local storage.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param data the data for the item (any javascript object/primitive).\r",
							" */\r",
							"var _setItem = function(api, id, key, data) {\r",
							"  // get storage object\r",
							"  var obj = _getStorageObject(api, id);\r",
							"  if(obj === null) {\r",
							"    // create a new storage object\r",
							"    obj = {};\r",
							"  }\r",
							"  // update key\r",
							"  obj[key] = data;\r",
							"\r",
							"  // set storage object\r",
							"  _setStorageObject(api, id, obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an item from local storage.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" *\r",
							" * @return the item.\r",
							" */\r",
							"var _getItem = function(api, id, key) {\r",
							"  // get storage object\r",
							"  var rval = _getStorageObject(api, id);\r",
							"  if(rval !== null) {\r",
							"    // return data at key\r",
							"    rval = (key in rval) ? rval[key] : null;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Removes an item from local storage.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" */\r",
							"var _removeItem = function(api, id, key) {\r",
							"  // get storage object\r",
							"  var obj = _getStorageObject(api, id);\r",
							"  if(obj !== null && key in obj) {\r",
							"    // remove key\r",
							"    delete obj[key];\r",
							"\r",
							"    // see if entry has no keys remaining\r",
							"    var empty = true;\r",
							"    for(var prop in obj) {\r",
							"      empty = false;\r",
							"      break;\r",
							"    }\r",
							"    if(empty) {\r",
							"      // remove entry entirely if no keys are left\r",
							"      obj = null;\r",
							"    }\r",
							"\r",
							"    // set storage object\r",
							"    _setStorageObject(api, id, obj);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears the local disk storage identified by the given ID.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" */\r",
							"var _clearItems = function(api, id) {\r",
							"  _setStorageObject(api, id, null);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Calls a storage function.\r",
							" *\r",
							" * @param func the function to call.\r",
							" * @param args the arguments for the function.\r",
							" * @param location the location argument.\r",
							" *\r",
							" * @return the return value from the function.\r",
							" */\r",
							"var _callStorageFunction = function(func, args, location) {\r",
							"  var rval = null;\r",
							"\r",
							"  // default storage types\r",
							"  if(typeof(location) === 'undefined') {\r",
							"    location = ['web', 'flash'];\r",
							"  }\r",
							"\r",
							"  // apply storage types in order of preference\r",
							"  var type;\r",
							"  var done = false;\r",
							"  var exception = null;\r",
							"  for(var idx in location) {\r",
							"    type = location[idx];\r",
							"    try {\r",
							"      if(type === 'flash' || type === 'both') {\r",
							"        if(args[0] === null) {\r",
							"          throw new Error('Flash local storage not available.');\r",
							"        }\r",
							"        rval = func.apply(this, args);\r",
							"        done = (type === 'flash');\r",
							"      }\r",
							"      if(type === 'web' || type === 'both') {\r",
							"        args[0] = localStorage;\r",
							"        rval = func.apply(this, args);\r",
							"        done = true;\r",
							"      }\r",
							"    } catch(ex) {\r",
							"      exception = ex;\r",
							"    }\r",
							"    if(done) {\r",
							"      break;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(!done) {\r",
							"    throw exception;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Stores an item on local disk.\r",
							" *\r",
							" * The available types of local storage include 'flash', 'web', and 'both'.\r",
							" *\r",
							" * The type 'flash' refers to flash local storage (SharedObject). In order\r",
							" * to use flash local storage, the 'api' parameter must be valid. The type\r",
							" * 'web' refers to WebStorage, if supported by the browser. The type 'both'\r",
							" * refers to storing using both 'flash' and 'web', not just one or the\r",
							" * other.\r",
							" *\r",
							" * The location array should list the storage types to use in order of\r",
							" * preference:\r",
							" *\r",
							" * ['flash']: flash only storage\r",
							" * ['web']: web only storage\r",
							" * ['both']: try to store in both\r",
							" * ['flash','web']: store in flash first, but if not available, 'web'\r",
							" * ['web','flash']: store in web first, but if not available, 'flash'\r",
							" *\r",
							" * The location array defaults to: ['web', 'flash']\r",
							" *\r",
							" * @param api the flash interface, null to use only WebStorage.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param data the data for the item (any javascript object/primitive).\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" */\r",
							"util.setItem = function(api, id, key, data, location) {\r",
							"  _callStorageFunction(_setItem, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an item on local disk.\r",
							" *\r",
							" * Set setItem() for details on storage types.\r",
							" *\r",
							" * @param api the flash interface, null to use only WebStorage.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" *\r",
							" * @return the item.\r",
							" */\r",
							"util.getItem = function(api, id, key, location) {\r",
							"  return _callStorageFunction(_getItem, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Removes an item on local disk.\r",
							" *\r",
							" * Set setItem() for details on storage types.\r",
							" *\r",
							" * @param api the flash interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" */\r",
							"util.removeItem = function(api, id, key, location) {\r",
							"  _callStorageFunction(_removeItem, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears the local disk storage identified by the given ID.\r",
							" *\r",
							" * Set setItem() for details on storage types.\r",
							" *\r",
							" * @param api the flash interface if flash is available.\r",
							" * @param id the storage ID to use.\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" */\r",
							"util.clearItems = function(api, id, location) {\r",
							"  _callStorageFunction(_clearItems, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses the scheme, host, and port from an http(s) url.\r",
							" *\r",
							" * @param str the url string.\r",
							" *\r",
							" * @return the parsed url object or null if the url is invalid.\r",
							" */\r",
							"util.parseUrl = function(str) {\r",
							"  // FIXME: this regex looks a bit broken\r",
							"  var regex = /^(https?):\\/\\/([^:&^\\/]*):?(\\d*)(.*)$/g;\r",
							"  regex.lastIndex = 0;\r",
							"  var m = regex.exec(str);\r",
							"  var url = (m === null) ? null : {\r",
							"    full: str,\r",
							"    scheme: m[1],\r",
							"    host: m[2],\r",
							"    port: m[3],\r",
							"    path: m[4]\r",
							"  };\r",
							"  if(url) {\r",
							"    url.fullHost = url.host;\r",
							"    if(url.port) {\r",
							"      if(url.port !== 80 && url.scheme === 'http') {\r",
							"        url.fullHost += ':' + url.port;\r",
							"      } else if(url.port !== 443 && url.scheme === 'https') {\r",
							"        url.fullHost += ':' + url.port;\r",
							"      }\r",
							"    } else if(url.scheme === 'http') {\r",
							"      url.port = 80;\r",
							"    } else if(url.scheme === 'https') {\r",
							"      url.port = 443;\r",
							"    }\r",
							"    url.full = url.scheme + '://' + url.fullHost;\r",
							"  }\r",
							"  return url;\r",
							"};\r",
							"\r",
							"/* Storage for query variables */\r",
							"var _queryVariables = null;\r",
							"\r",
							"/**\r",
							" * Returns the window location query variables. Query is parsed on the first\r",
							" * call and the same object is returned on subsequent calls. The mapping\r",
							" * is from keys to an array of values. Parameters without values will have\r",
							" * an object key set but no value added to the value array. Values are\r",
							" * unescaped.\r",
							" *\r",
							" * ...?k1=v1&k2=v2:\r",
							" * {\r",
							" *   \"k1\": [\"v1\"],\r",
							" *   \"k2\": [\"v2\"]\r",
							" * }\r",
							" *\r",
							" * ...?k1=v1&k1=v2:\r",
							" * {\r",
							" *   \"k1\": [\"v1\", \"v2\"]\r",
							" * }\r",
							" *\r",
							" * ...?k1=v1&k2:\r",
							" * {\r",
							" *   \"k1\": [\"v1\"],\r",
							" *   \"k2\": []\r",
							" * }\r",
							" *\r",
							" * ...?k1=v1&k1:\r",
							" * {\r",
							" *   \"k1\": [\"v1\"]\r",
							" * }\r",
							" *\r",
							" * ...?k1&k1:\r",
							" * {\r",
							" *   \"k1\": []\r",
							" * }\r",
							" *\r",
							" * @param query the query string to parse (optional, default to cached\r",
							" *          results from parsing window location search query).\r",
							" *\r",
							" * @return object mapping keys to variables.\r",
							" */\r",
							"util.getQueryVariables = function(query) {\r",
							"  var parse = function(q) {\r",
							"    var rval = {};\r",
							"    var kvpairs = q.split('&');\r",
							"    for(var i = 0; i < kvpairs.length; i++) {\r",
							"      var pos = kvpairs[i].indexOf('=');\r",
							"      var key;\r",
							"      var val;\r",
							"      if(pos > 0) {\r",
							"        key = kvpairs[i].substring(0, pos);\r",
							"        val = kvpairs[i].substring(pos + 1);\r",
							"      } else {\r",
							"        key = kvpairs[i];\r",
							"        val = null;\r",
							"      }\r",
							"      if(!(key in rval)) {\r",
							"        rval[key] = [];\r",
							"      }\r",
							"      // disallow overriding object prototype keys\r",
							"      if(!(key in Object.prototype) && val !== null) {\r",
							"        rval[key].push(unescape(val));\r",
							"      }\r",
							"    }\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"   var rval;\r",
							"   if(typeof(query) === 'undefined') {\r",
							"     // set cached variables if needed\r",
							"     if(_queryVariables === null) {\r",
							"       if(typeof(window) !== 'undefined' && window.location && window.location.search) {\r",
							"          // parse window search query\r",
							"          _queryVariables = parse(window.location.search.substring(1));\r",
							"       } else {\r",
							"          // no query variables available\r",
							"          _queryVariables = {};\r",
							"       }\r",
							"     }\r",
							"     rval = _queryVariables;\r",
							"   } else {\r",
							"     // parse given query\r",
							"     rval = parse(query);\r",
							"   }\r",
							"   return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses a fragment into a path and query. This method will take a URI\r",
							" * fragment and break it up as if it were the main URI. For example:\r",
							" *    /bar/baz?a=1&b=2\r",
							" * results in:\r",
							" *    {\r",
							" *       path: [\"bar\", \"baz\"],\r",
							" *       query: {\"k1\": [\"v1\"], \"k2\": [\"v2\"]}\r",
							" *    }\r",
							" *\r",
							" * @return object with a path array and query object.\r",
							" */\r",
							"util.parseFragment = function(fragment) {\r",
							"  // default to whole fragment\r",
							"  var fp = fragment;\r",
							"  var fq = '';\r",
							"  // split into path and query if possible at the first '?'\r",
							"  var pos = fragment.indexOf('?');\r",
							"  if(pos > 0) {\r",
							"    fp = fragment.substring(0, pos);\r",
							"    fq = fragment.substring(pos + 1);\r",
							"  }\r",
							"  // split path based on '/' and ignore first element if empty\r",
							"  var path = fp.split('/');\r",
							"  if(path.length > 0 && path[0] === '') {\r",
							"    path.shift();\r",
							"  }\r",
							"  // convert query into object\r",
							"  var query = (fq === '') ? {} : util.getQueryVariables(fq);\r",
							"\r",
							"  return {\r",
							"    pathString: fp,\r",
							"    queryString: fq,\r",
							"    path: path,\r",
							"    query: query\r",
							"  };\r",
							"};\r",
							"\r",
							"/**\r",
							" * Makes a request out of a URI-like request string. This is intended to\r",
							" * be used where a fragment id (after a URI '#') is parsed as a URI with\r",
							" * path and query parts. The string should have a path beginning and\r",
							" * delimited by '/' and optional query parameters following a '?'. The\r",
							" * query should be a standard URL set of key value pairs delimited by\r",
							" * '&'. For backwards compatibility the initial '/' on the path is not\r",
							" * required. The request object has the following API, (fully described\r",
							" * in the method code):\r",
							" *    {\r",
							" *       path: <the path string part>.\r",
							" *       query: <the query string part>,\r",
							" *       getPath(i): get part or all of the split path array,\r",
							" *       getQuery(k, i): get part or all of a query key array,\r",
							" *       getQueryLast(k, _default): get last element of a query key array.\r",
							" *    }\r",
							" *\r",
							" * @return object with request parameters.\r",
							" */\r",
							"util.makeRequest = function(reqString) {\r",
							"  var frag = util.parseFragment(reqString);\r",
							"  var req = {\r",
							"    // full path string\r",
							"    path: frag.pathString,\r",
							"    // full query string\r",
							"    query: frag.queryString,\r",
							"    /**\r",
							"     * Get path or element in path.\r",
							"     *\r",
							"     * @param i optional path index.\r",
							"     *\r",
							"     * @return path or part of path if i provided.\r",
							"     */\r",
							"    getPath: function(i) {\r",
							"      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];\r",
							"    },\r",
							"    /**\r",
							"     * Get query, values for a key, or value for a key index.\r",
							"     *\r",
							"     * @param k optional query key.\r",
							"     * @param i optional query key index.\r",
							"     *\r",
							"     * @return query, values for a key, or value for a key index.\r",
							"     */\r",
							"    getQuery: function(k, i) {\r",
							"      var rval;\r",
							"      if(typeof(k) === 'undefined') {\r",
							"        rval = frag.query;\r",
							"      } else {\r",
							"        rval = frag.query[k];\r",
							"        if(rval && typeof(i) !== 'undefined') {\r",
							"           rval = rval[i];\r",
							"        }\r",
							"      }\r",
							"      return rval;\r",
							"    },\r",
							"    getQueryLast: function(k, _default) {\r",
							"      var rval;\r",
							"      var vals = req.getQuery(k);\r",
							"      if(vals) {\r",
							"        rval = vals[vals.length - 1];\r",
							"      } else {\r",
							"        rval = _default;\r",
							"      }\r",
							"      return rval;\r",
							"    }\r",
							"  };\r",
							"  return req;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Makes a URI out of a path, an object with query parameters, and a\r",
							" * fragment. Uses jQuery.param() internally for query string creation.\r",
							" * If the path is an array, it will be joined with '/'.\r",
							" *\r",
							" * @param path string path or array of strings.\r",
							" * @param query object with query parameters. (optional)\r",
							" * @param fragment fragment string. (optional)\r",
							" *\r",
							" * @return string object with request parameters.\r",
							" */\r",
							"util.makeLink = function(path, query, fragment) {\r",
							"  // join path parts if needed\r",
							"  path = jQuery.isArray(path) ? path.join('/') : path;\r",
							"\r",
							"  var qstr = jQuery.param(query || {});\r",
							"  fragment = fragment || '';\r",
							"  return path +\r",
							"    ((qstr.length > 0) ? ('?' + qstr) : '') +\r",
							"    ((fragment.length > 0) ? ('#' + fragment) : '');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Follows a path of keys deep into an object hierarchy and set a value.\r",
							" * If a key does not exist or it's value is not an object, create an\r",
							" * object in it's place. This can be destructive to a object tree if\r",
							" * leaf nodes are given as non-final path keys.\r",
							" * Used to avoid exceptions from missing parts of the path.\r",
							" *\r",
							" * @param object the starting object.\r",
							" * @param keys an array of string keys.\r",
							" * @param value the value to set.\r",
							" */\r",
							"util.setPath = function(object, keys, value) {\r",
							"  // need to start at an object\r",
							"  if(typeof(object) === 'object' && object !== null) {\r",
							"    var i = 0;\r",
							"    var len = keys.length;\r",
							"    while(i < len) {\r",
							"      var next = keys[i++];\r",
							"      if(i == len) {\r",
							"        // last\r",
							"        object[next] = value;\r",
							"      } else {\r",
							"        // more\r",
							"        var hasNext = (next in object);\r",
							"        if(!hasNext ||\r",
							"          (hasNext && typeof(object[next]) !== 'object') ||\r",
							"          (hasNext && object[next] === null)) {\r",
							"          object[next] = {};\r",
							"        }\r",
							"        object = object[next];\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Follows a path of keys deep into an object hierarchy and return a value.\r",
							" * If a key does not exist, create an object in it's place.\r",
							" * Used to avoid exceptions from missing parts of the path.\r",
							" *\r",
							" * @param object the starting object.\r",
							" * @param keys an array of string keys.\r",
							" * @param _default value to return if path not found.\r",
							" *\r",
							" * @return the value at the path if found, else default if given, else\r",
							" *         undefined.\r",
							" */\r",
							"util.getPath = function(object, keys, _default) {\r",
							"  var i = 0;\r",
							"  var len = keys.length;\r",
							"  var hasNext = true;\r",
							"  while(hasNext && i < len &&\r",
							"    typeof(object) === 'object' && object !== null) {\r",
							"    var next = keys[i++];\r",
							"    hasNext = next in object;\r",
							"    if(hasNext) {\r",
							"      object = object[next];\r",
							"    }\r",
							"  }\r",
							"  return (hasNext ? object : _default);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Follow a path of keys deep into an object hierarchy and delete the\r",
							" * last one. If a key does not exist, do nothing.\r",
							" * Used to avoid exceptions from missing parts of the path.\r",
							" *\r",
							" * @param object the starting object.\r",
							" * @param keys an array of string keys.\r",
							" */\r",
							"util.deletePath = function(object, keys) {\r",
							"  // need to start at an object\r",
							"  if(typeof(object) === 'object' && object !== null) {\r",
							"    var i = 0;\r",
							"    var len = keys.length;\r",
							"    while(i < len) {\r",
							"      var next = keys[i++];\r",
							"      if(i == len) {\r",
							"        // last\r",
							"        delete object[next];\r",
							"      } else {\r",
							"        // more\r",
							"        if(!(next in object) ||\r",
							"          (typeof(object[next]) !== 'object') ||\r",
							"          (object[next] === null)) {\r",
							"           break;\r",
							"        }\r",
							"        object = object[next];\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Check if an object is empty.\r",
							" *\r",
							" * Taken from:\r",
							" * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\r",
							" *\r",
							" * @param object the object to check.\r",
							" */\r",
							"util.isEmpty = function(obj) {\r",
							"  for(var prop in obj) {\r",
							"    if(obj.hasOwnProperty(prop)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"  return true;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Format with simple printf-style interpolation.\r",
							" *\r",
							" * %%: literal '%'\r",
							" * %s,%o: convert next argument into a string.\r",
							" *\r",
							" * @param format the string to format.\r",
							" * @param ... arguments to interpolate into the format string.\r",
							" */\r",
							"util.format = function(format) {\r",
							"  var re = /%./g;\r",
							"  // current match\r",
							"  var match;\r",
							"  // current part\r",
							"  var part;\r",
							"  // current arg index\r",
							"  var argi = 0;\r",
							"  // collected parts to recombine later\r",
							"  var parts = [];\r",
							"  // last index found\r",
							"  var last = 0;\r",
							"  // loop while matches remain\r",
							"  while((match = re.exec(format))) {\r",
							"    part = format.substring(last, re.lastIndex - 2);\r",
							"    // don't add empty strings (ie, parts between %s%s)\r",
							"    if(part.length > 0) {\r",
							"      parts.push(part);\r",
							"    }\r",
							"    last = re.lastIndex;\r",
							"    // switch on % code\r",
							"    var code = match[0][1];\r",
							"    switch(code) {\r",
							"    case 's':\r",
							"    case 'o':\r",
							"      // check if enough arguments were given\r",
							"      if(argi < arguments.length) {\r",
							"        parts.push(arguments[argi++ + 1]);\r",
							"      } else {\r",
							"        parts.push('<?>');\r",
							"      }\r",
							"      break;\r",
							"    // FIXME: do proper formating for numbers, etc\r",
							"    //case 'f':\r",
							"    //case 'd':\r",
							"    case '%':\r",
							"      parts.push('%');\r",
							"      break;\r",
							"    default:\r",
							"      parts.push('<%' + code + '?>');\r",
							"    }\r",
							"  }\r",
							"  // add trailing part of format string\r",
							"  parts.push(format.substring(last));\r",
							"  return parts.join('');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Formats a number.\r",
							" *\r",
							" * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\r",
							" */\r",
							"util.formatNumber = function(number, decimals, dec_point, thousands_sep) {\r",
							"  // http://kevin.vanzonneveld.net\r",
							"  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r",
							"  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r",
							"  // +     bugfix by: Michael White (http://crestidg.com)\r",
							"  // +     bugfix by: Benjamin Lupton\r",
							"  // +     bugfix by: Allan Jensen (http://www.winternet.no)\r",
							"  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r",
							"  // *     example 1: number_format(1234.5678, 2, '.', '');\r",
							"  // *     returns 1: 1234.57\r",
							"\r",
							"  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\r",
							"  var d = dec_point === undefined ? ',' : dec_point;\r",
							"  var t = thousands_sep === undefined ?\r",
							"   '.' : thousands_sep, s = n < 0 ? '-' : '';\r",
							"  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';\r",
							"  var j = (i.length > 3) ? i.length % 3 : 0;\r",
							"  return s + (j ? i.substr(0, j) + t : '') +\r",
							"    i.substr(j).replace(/(\\d{3})(?=\\d)/g, '$1' + t) +\r",
							"    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Formats a byte size.\r",
							" *\r",
							" * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\r",
							" */\r",
							"util.formatSize = function(size) {\r",
							"  if(size >= 1073741824) {\r",
							"    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';\r",
							"  } else if(size >= 1048576) {\r",
							"    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';\r",
							"  } else if(size >= 1024) {\r",
							"    size = util.formatNumber(size / 1024, 0) + ' KiB';\r",
							"  } else {\r",
							"    size = util.formatNumber(size, 0) + ' bytes';\r",
							"  }\r",
							"  return size;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an IPv4 or IPv6 string representation into bytes (in network order).\r",
							" *\r",
							" * @param ip the IPv4 or IPv6 address to convert.\r",
							" *\r",
							" * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't\r",
							" *         be parsed.\r",
							" */\r",
							"util.bytesFromIP = function(ip) {\r",
							"  if(ip.indexOf('.') !== -1) {\r",
							"    return util.bytesFromIPv4(ip);\r",
							"  }\r",
							"  if(ip.indexOf(':') !== -1) {\r",
							"    return util.bytesFromIPv6(ip);\r",
							"  }\r",
							"  return null;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an IPv4 string representation into bytes (in network order).\r",
							" *\r",
							" * @param ip the IPv4 address to convert.\r",
							" *\r",
							" * @return the 4-byte address or null if the address can't be parsed.\r",
							" */\r",
							"util.bytesFromIPv4 = function(ip) {\r",
							"  ip = ip.split('.');\r",
							"  if(ip.length !== 4) {\r",
							"    return null;\r",
							"  }\r",
							"  var b = util.createBuffer();\r",
							"  for(var i = 0; i < ip.length; ++i) {\r",
							"    var num = parseInt(ip[i], 10);\r",
							"    if(isNaN(num)) {\r",
							"      return null;\r",
							"    }\r",
							"    b.putByte(num);\r",
							"  }\r",
							"  return b.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an IPv6 string representation into bytes (in network order).\r",
							" *\r",
							" * @param ip the IPv6 address to convert.\r",
							" *\r",
							" * @return the 16-byte address or null if the address can't be parsed.\r",
							" */\r",
							"util.bytesFromIPv6 = function(ip) {\r",
							"  var blanks = 0;\r",
							"  ip = ip.split(':').filter(function(e) {\r",
							"    if(e.length === 0) ++blanks;\r",
							"    return true;\r",
							"  });\r",
							"  var zeros = (8 - ip.length + blanks) * 2;\r",
							"  var b = util.createBuffer();\r",
							"  for(var i = 0; i < 8; ++i) {\r",
							"    if(!ip[i] || ip[i].length === 0) {\r",
							"      b.fillWithByte(0, zeros);\r",
							"      zeros = 0;\r",
							"      continue;\r",
							"    }\r",
							"    var bytes = util.hexToBytes(ip[i]);\r",
							"    if(bytes.length < 2) {\r",
							"      b.putByte(0);\r",
							"    }\r",
							"    b.putBytes(bytes);\r",
							"  }\r",
							"  return b.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts 4-bytes into an IPv4 string representation or 16-bytes into\r",
							" * an IPv6 string representation. The bytes must be in network order.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,\r",
							" *         respectively, are given, otherwise null.\r",
							" */\r",
							"util.bytesToIP = function(bytes) {\r",
							"  if(bytes.length === 4) {\r",
							"    return util.bytesToIPv4(bytes);\r",
							"  }\r",
							"  if(bytes.length === 16) {\r",
							"    return util.bytesToIPv6(bytes);\r",
							"  }\r",
							"  return null;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts 4-bytes into an IPv4 string representation. The bytes must be\r",
							" * in network order.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the IPv4 string representation or null for an invalid # of bytes.\r",
							" */\r",
							"util.bytesToIPv4 = function(bytes) {\r",
							"  if(bytes.length !== 4) {\r",
							"    return null;\r",
							"  }\r",
							"  var ip = [];\r",
							"  for(var i = 0; i < bytes.length; ++i) {\r",
							"    ip.push(bytes.charCodeAt(i));\r",
							"  }\r",
							"  return ip.join('.');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts 16-bytes into an IPv16 string representation. The bytes must be\r",
							" * in network order.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the IPv16 string representation or null for an invalid # of bytes.\r",
							" */\r",
							"util.bytesToIPv6 = function(bytes) {\r",
							"  if(bytes.length !== 16) {\r",
							"    return null;\r",
							"  }\r",
							"  var ip = [];\r",
							"  var zeroGroups = [];\r",
							"  var zeroMaxGroup = 0;\r",
							"  for(var i = 0; i < bytes.length; i += 2) {\r",
							"    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\r",
							"    // canonicalize zero representation\r",
							"    while(hex[0] === '0' && hex !== '0') {\r",
							"      hex = hex.substr(1);\r",
							"    }\r",
							"    if(hex === '0') {\r",
							"      var last = zeroGroups[zeroGroups.length - 1];\r",
							"      var idx = ip.length;\r",
							"      if(!last || idx !== last.end + 1) {\r",
							"        zeroGroups.push({start: idx, end: idx});\r",
							"      } else {\r",
							"        last.end = idx;\r",
							"        if((last.end - last.start) >\r",
							"          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {\r",
							"          zeroMaxGroup = zeroGroups.length - 1;\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    ip.push(hex);\r",
							"  }\r",
							"  if(zeroGroups.length > 0) {\r",
							"    var group = zeroGroups[zeroMaxGroup];\r",
							"    // only shorten group of length > 0\r",
							"    if(group.end - group.start > 0) {\r",
							"      ip.splice(group.start, group.end - group.start + 1, '');\r",
							"      if(group.start === 0) {\r",
							"        ip.unshift('');\r",
							"      }\r",
							"      if(group.end === 7) {\r",
							"        ip.push('');\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"  return ip.join(':');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Estimates the number of processes that can be run concurrently. If\r",
							" * creating Web Workers, keep in mind that the main JavaScript process needs\r",
							" * its own core.\r",
							" *\r",
							" * @param options the options to use:\r",
							" *          update true to force an update (not use the cached value).\r",
							" * @param callback(err, max) called once the operation completes.\r",
							" */\r",
							"util.estimateCores = function(options, callback) {\r",
							"  if(typeof options === 'function') {\r",
							"    callback = options;\r",
							"    options = {};\r",
							"  }\r",
							"  options = options || {};\r",
							"  if('cores' in util && !options.update) {\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"  if(typeof navigator !== 'undefined' &&\r",
							"    'hardwareConcurrency' in navigator &&\r",
							"    navigator.hardwareConcurrency > 0) {\r",
							"    util.cores = navigator.hardwareConcurrency;\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"  if(typeof Worker === 'undefined') {\r",
							"    // workers not available\r",
							"    util.cores = 1;\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"  if(typeof Blob === 'undefined') {\r",
							"    // can't estimate, default to 2\r",
							"    util.cores = 2;\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"\r",
							"  // create worker concurrency estimation code as blob\r",
							"  var blobUrl = URL.createObjectURL(new Blob(['(',\r",
							"    function() {\r",
							"      self.addEventListener('message', function(e) {\r",
							"        // run worker for 4 ms\r",
							"        var st = Date.now();\r",
							"        var et = st + 4;\r",
							"        while(Date.now() < et);\r",
							"        self.postMessage({st: st, et: et});\r",
							"      });\r",
							"    }.toString(),\r",
							"  ')()'], {type: 'application/javascript'}));\r",
							"\r",
							"  // take 5 samples using 16 workers\r",
							"  sample([], 5, 16);\r",
							"\r",
							"  function sample(max, samples, numWorkers) {\r",
							"    if(samples === 0) {\r",
							"      // get overlap average\r",
							"      var avg = Math.floor(max.reduce(function(avg, x) {\r",
							"        return avg + x;\r",
							"      }, 0) / max.length);\r",
							"      util.cores = Math.max(1, avg);\r",
							"      URL.revokeObjectURL(blobUrl);\r",
							"      return callback(null, util.cores);\r",
							"    }\r",
							"    map(numWorkers, function(err, results) {\r",
							"      max.push(reduce(numWorkers, results));\r",
							"      sample(max, samples - 1, numWorkers);\r",
							"    });\r",
							"  }\r",
							"\r",
							"  function map(numWorkers, callback) {\r",
							"    var workers = [];\r",
							"    var results = [];\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      var worker = new Worker(blobUrl);\r",
							"      worker.addEventListener('message', function(e) {\r",
							"        results.push(e.data);\r",
							"        if(results.length === numWorkers) {\r",
							"          for(var i = 0; i < numWorkers; ++i) {\r",
							"            workers[i].terminate();\r",
							"          }\r",
							"          callback(null, results);\r",
							"        }\r",
							"      });\r",
							"      workers.push(worker);\r",
							"    }\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      workers[i].postMessage(i);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  function reduce(numWorkers, results) {\r",
							"    // find overlapping time windows\r",
							"    var overlaps = [];\r",
							"    for(var n = 0; n < numWorkers; ++n) {\r",
							"      var r1 = results[n];\r",
							"      var overlap = overlaps[n] = [];\r",
							"      for(var i = 0; i < numWorkers; ++i) {\r",
							"        if(n === i) {\r",
							"          continue;\r",
							"        }\r",
							"        var r2 = results[i];\r",
							"        if((r1.st > r2.st && r1.st < r2.et) ||\r",
							"          (r2.st > r1.st && r2.st < r1.et)) {\r",
							"          overlap.push(i);\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    // get maximum overlaps ... don't include overlapping worker itself\r",
							"    // as the main JS process was also being scheduled during the work and\r",
							"    // would have to be subtracted from the estimate anyway\r",
							"    return overlaps.reduce(function(max, overlap) {\r",
							"      return Math.max(max, overlap.length);\r",
							"    }, 0);\r",
							"  }\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 2 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * An API for getting cryptographically-secure random bytes. The bytes are\r",
							" * generated using the Fortuna algorithm devised by Bruce Schneier and\r",
							" * Niels Ferguson.\r",
							" *\r",
							" * Getting strong random bytes is not yet easy to do in javascript. The only\r",
							" * truish random entropy that can be collected is from the mouse, keyboard, or\r",
							" * from timing with respect to page loads, etc. This generator makes a poor\r",
							" * attempt at providing random bytes when those sources haven't yet provided\r",
							" * enough entropy to initially seed or to reseed the PRNG.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2009-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(23);\r",
							"__webpack_require__(24);\r",
							"__webpack_require__(1);\r",
							"\r",
							"(function() {\r",
							"\r",
							"// forge.random already defined\r",
							"if(forge.random && forge.random.getBytes) {\r",
							"  module.exports = forge.random;\r",
							"  return;\r",
							"}\r",
							"\r",
							"(function(jQuery) {\r",
							"\r",
							"// the default prng plugin, uses AES-128\r",
							"var prng_aes = {};\r",
							"var _prng_aes_output = new Array(4);\r",
							"var _prng_aes_buffer = forge.util.createBuffer();\r",
							"prng_aes.formatKey = function(key) {\r",
							"  // convert the key into 32-bit integers\r",
							"  var tmp = forge.util.createBuffer(key);\r",
							"  key = new Array(4);\r",
							"  key[0] = tmp.getInt32();\r",
							"  key[1] = tmp.getInt32();\r",
							"  key[2] = tmp.getInt32();\r",
							"  key[3] = tmp.getInt32();\r",
							"\r",
							"  // return the expanded key\r",
							"  return forge.aes._expandKey(key, false);\r",
							"};\r",
							"prng_aes.formatSeed = function(seed) {\r",
							"  // convert seed into 32-bit integers\r",
							"  var tmp = forge.util.createBuffer(seed);\r",
							"  seed = new Array(4);\r",
							"  seed[0] = tmp.getInt32();\r",
							"  seed[1] = tmp.getInt32();\r",
							"  seed[2] = tmp.getInt32();\r",
							"  seed[3] = tmp.getInt32();\r",
							"  return seed;\r",
							"};\r",
							"prng_aes.cipher = function(key, seed) {\r",
							"  forge.aes._updateBlock(key, seed, _prng_aes_output, false);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[0]);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[1]);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[2]);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[3]);\r",
							"  return _prng_aes_buffer.getBytes();\r",
							"};\r",
							"prng_aes.increment = function(seed) {\r",
							"  // FIXME: do we care about carry or signed issues?\r",
							"  ++seed[3];\r",
							"  return seed;\r",
							"};\r",
							"prng_aes.md = forge.md.sha256;\r",
							"\r",
							"/**\r",
							" * Creates a new PRNG.\r",
							" */\r",
							"function spawnPrng() {\r",
							"  var ctx = forge.prng.create(prng_aes);\r",
							"\r",
							"  /**\r",
							"   * Gets random bytes. If a native secure crypto API is unavailable, this\r",
							"   * method tries to make the bytes more unpredictable by drawing from data that\r",
							"   * can be collected from the user of the browser, eg: mouse movement.\r",
							"   *\r",
							"   * If a callback is given, this method will be called asynchronously.\r",
							"   *\r",
							"   * @param count the number of random bytes to get.\r",
							"   * @param [callback(err, bytes)] called once the operation completes.\r",
							"   *\r",
							"   * @return the random bytes in a string.\r",
							"   */\r",
							"  ctx.getBytes = function(count, callback) {\r",
							"    return ctx.generate(count, callback);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Gets random bytes asynchronously. If a native secure crypto API is\r",
							"   * unavailable, this method tries to make the bytes more unpredictable by\r",
							"   * drawing from data that can be collected from the user of the browser,\r",
							"   * eg: mouse movement.\r",
							"   *\r",
							"   * @param count the number of random bytes to get.\r",
							"   *\r",
							"   * @return the random bytes in a string.\r",
							"   */\r",
							"  ctx.getBytesSync = function(count) {\r",
							"    return ctx.generate(count);\r",
							"  };\r",
							"\r",
							"  return ctx;\r",
							"}\r",
							"\r",
							"// create default prng context\r",
							"var _ctx = spawnPrng();\r",
							"\r",
							"// add other sources of entropy only if window.crypto.getRandomValues is not\r",
							"// available -- otherwise this source will be automatically used by the prng\r",
							"var getRandomValues = null;\r",
							"if(typeof window !== 'undefined') {\r",
							"  var _crypto = window.crypto || window.msCrypto;\r",
							"  if(_crypto && _crypto.getRandomValues) {\r",
							"    getRandomValues = function(arr) {\r",
							"      return _crypto.getRandomValues(arr);\r",
							"    };\r",
							"  }\r",
							"}\r",
							"if(forge.options.usePureJavaScript ||\r",
							"  (!forge.util.isNodejs && !getRandomValues)) {\r",
							"  // if this is a web worker, do not use weak entropy, instead register to\r",
							"  // receive strong entropy asynchronously from the main thread\r",
							"  if(typeof window === 'undefined' || window.document === undefined) {\r",
							"    // FIXME:\r",
							"  }\r",
							"\r",
							"  // get load time entropy\r",
							"  _ctx.collectInt(+new Date(), 32);\r",
							"\r",
							"  // add some entropy from navigator object\r",
							"  if(typeof(navigator) !== 'undefined') {\r",
							"    var _navBytes = '';\r",
							"    for(var key in navigator) {\r",
							"      try {\r",
							"        if(typeof(navigator[key]) == 'string') {\r",
							"          _navBytes += navigator[key];\r",
							"        }\r",
							"      } catch(e) {\r",
							"        /* Some navigator keys might not be accessible, e.g. the geolocation\r",
							"          attribute throws an exception if touched in Mozilla chrome://\r",
							"          context.\r",
							"\r",
							"          Silently ignore this and just don't use this as a source of\r",
							"          entropy. */\r",
							"      }\r",
							"    }\r",
							"    _ctx.collect(_navBytes);\r",
							"    _navBytes = null;\r",
							"  }\r",
							"\r",
							"  // add mouse and keyboard collectors if jquery is available\r",
							"  if(jQuery) {\r",
							"    // set up mouse entropy capture\r",
							"    jQuery().mousemove(function(e) {\r",
							"      // add mouse coords\r",
							"      _ctx.collectInt(e.clientX, 16);\r",
							"      _ctx.collectInt(e.clientY, 16);\r",
							"    });\r",
							"\r",
							"    // set up keyboard entropy capture\r",
							"    jQuery().keypress(function(e) {\r",
							"      _ctx.collectInt(e.charCode, 8);\r",
							"    });\r",
							"  }\r",
							"}\r",
							"\r",
							"/* Random API */\r",
							"if(!forge.random) {\r",
							"  forge.random = _ctx;\r",
							"} else {\r",
							"  // extend forge.random with _ctx\r",
							"  for(var key in _ctx) {\r",
							"    forge.random[key] = _ctx[key];\r",
							"  }\r",
							"}\r",
							"\r",
							"// expose spawn PRNG\r",
							"forge.random.createInstance = spawnPrng;\r",
							"\r",
							"module.exports = forge.random;\r",
							"\r",
							"})(typeof(jQuery) !== 'undefined' ? jQuery : null);\r",
							"\r",
							"})();\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 3 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of Abstract Syntax Notation Number One.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2015 Digital Bazaar, Inc.\r",
							" *\r",
							" * An API for storing data using the Abstract Syntax Notation Number One\r",
							" * format using DER (Distinguished Encoding Rules) encoding. This encoding is\r",
							" * commonly used to store data for PKI, i.e. X.509 Certificates, and this\r",
							" * implementation exists for that purpose.\r",
							" *\r",
							" * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract\r",
							" * syntax of information without restricting the way the information is encoded\r",
							" * for transmission. It provides a standard that allows for open systems\r",
							" * communication. ASN.1 defines the syntax of information data and a number of\r",
							" * simple data types as well as a notation for describing them and specifying\r",
							" * values for them.\r",
							" *\r",
							" * The RSA algorithm creates public and private keys that are often stored in\r",
							" * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This\r",
							" * class provides the most basic functionality required to store and load DSA\r",
							" * keys that are encoded according to ASN.1.\r",
							" *\r",
							" * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)\r",
							" * and DER (Distinguished Encoding Rules). DER is just a subset of BER that\r",
							" * has stricter requirements for how data must be encoded.\r",
							" *\r",
							" * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)\r",
							" * and a byte array for the value of this ASN1 structure which may be data or a\r",
							" * list of ASN.1 structures.\r",
							" *\r",
							" * Each ASN.1 structure using BER is (Tag-Length-Value):\r",
							" *\r",
							" * | byte 0 | bytes X | bytes Y |\r",
							" * |--------|---------|----------\r",
							" * |  tag   | length  |  value  |\r",
							" *\r",
							" * ASN.1 allows for tags to be of \"High-tag-number form\" which allows a tag to\r",
							" * be two or more octets, but that is not supported by this class. A tag is\r",
							" * only 1 byte. Bits 1-5 give the tag number (ie the data type within a\r",
							" * particular 'class'), 6 indicates whether or not the ASN.1 value is\r",
							" * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If\r",
							" * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,\r",
							" * then the class is APPLICATION. If only bit 8 is set, then the class is\r",
							" * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.\r",
							" * The tag numbers for the data types for the class UNIVERSAL are listed below:\r",
							" *\r",
							" * UNIVERSAL 0 Reserved for use by the encoding rules\r",
							" * UNIVERSAL 1 Boolean type\r",
							" * UNIVERSAL 2 Integer type\r",
							" * UNIVERSAL 3 Bitstring type\r",
							" * UNIVERSAL 4 Octetstring type\r",
							" * UNIVERSAL 5 Null type\r",
							" * UNIVERSAL 6 Object identifier type\r",
							" * UNIVERSAL 7 Object descriptor type\r",
							" * UNIVERSAL 8 External type and Instance-of type\r",
							" * UNIVERSAL 9 Real type\r",
							" * UNIVERSAL 10 Enumerated type\r",
							" * UNIVERSAL 11 Embedded-pdv type\r",
							" * UNIVERSAL 12 UTF8String type\r",
							" * UNIVERSAL 13 Relative object identifier type\r",
							" * UNIVERSAL 14-15 Reserved for future editions\r",
							" * UNIVERSAL 16 Sequence and Sequence-of types\r",
							" * UNIVERSAL 17 Set and Set-of types\r",
							" * UNIVERSAL 18-22, 25-30 Character string types\r",
							" * UNIVERSAL 23-24 Time types\r",
							" *\r",
							" * The length of an ASN.1 structure is specified after the tag identifier.\r",
							" * There is a definite form and an indefinite form. The indefinite form may\r",
							" * be used if the encoding is constructed and not all immediately available.\r",
							" * The indefinite form is encoded using a length byte with only the 8th bit\r",
							" * set. The end of the constructed object is marked using end-of-contents\r",
							" * octets (two zero bytes).\r",
							" *\r",
							" * The definite form looks like this:\r",
							" *\r",
							" * The length may take up 1 or more bytes, it depends on the length of the\r",
							" * value of the ASN.1 structure. DER encoding requires that if the ASN.1\r",
							" * structure has a value that has a length greater than 127, more than 1 byte\r",
							" * will be used to store its length, otherwise just one byte will be used.\r",
							" * This is strict.\r",
							" *\r",
							" * In the case that the length of the ASN.1 value is less than 127, 1 octet\r",
							" * (byte) is used to store the \"short form\" length. The 8th bit has a value of\r",
							" * 0 indicating the length is \"short form\" and not \"long form\" and bits 7-1\r",
							" * give the length of the data. (The 8th bit is the left-most, most significant\r",
							" * bit: also known as big endian or network format).\r",
							" *\r",
							" * In the case that the length of the ASN.1 value is greater than 127, 2 to\r",
							" * 127 octets (bytes) are used to store the \"long form\" length. The first\r",
							" * byte's 8th bit is set to 1 to indicate the length is \"long form.\" Bits 7-1\r",
							" * give the number of additional octets. All following octets are in base 256\r",
							" * with the most significant digit first (typical big-endian binary unsigned\r",
							" * integer storage). So, for instance, if the length of a value was 257, the\r",
							" * first byte would be set to:\r",
							" *\r",
							" * 10000010 = 130 = 0x82.\r",
							" *\r",
							" * This indicates there are 2 octets (base 256) for the length. The second and\r",
							" * third bytes (the octets just mentioned) would store the length in base 256:\r",
							" *\r",
							" * octet 2: 00000001 = 1 * 256^1 = 256\r",
							" * octet 3: 00000001 = 1 * 256^0 = 1\r",
							" * total = 257\r",
							" *\r",
							" * The algorithm for converting a js integer value of 257 to base-256 is:\r",
							" *\r",
							" * var value = 257;\r",
							" * var bytes = [];\r",
							" * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first\r",
							" * bytes[1] = value & 0xFF;        // least significant byte last\r",
							" *\r",
							" * On the ASN.1 UNIVERSAL Object Identifier (OID) type:\r",
							" *\r",
							" * An OID can be written like: \"value1.value2.value3...valueN\"\r",
							" *\r",
							" * The DER encoding rules:\r",
							" *\r",
							" * The first byte has the value 40 * value1 + value2.\r",
							" * The following bytes, if any, encode the remaining values. Each value is\r",
							" * encoded in base 128, most significant digit first (big endian), with as\r",
							" * few digits as possible, and the most significant bit of each byte set\r",
							" * to 1 except the last in each value's encoding. For example: Given the\r",
							" * OID \"1.2.840.113549\", its DER encoding is (remember each byte except the\r",
							" * last one in each encoding is OR'd with 0x80):\r",
							" *\r",
							" * byte 1: 40 * 1 + 2 = 42 = 0x2A.\r",
							" * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648\r",
							" * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D\r",
							" *\r",
							" * The final value is: 0x2A864886F70D.\r",
							" * The full OID (including ASN.1 tag and length of 6 bytes) is:\r",
							" * 0x06062A864886F70D\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(6);\r",
							"\r",
							"/* ASN.1 API */\r",
							"var asn1 = module.exports = forge.asn1 = forge.asn1 || {};\r",
							"\r",
							"/**\r",
							" * ASN.1 classes.\r",
							" */\r",
							"asn1.Class = {\r",
							"  UNIVERSAL:        0x00,\r",
							"  APPLICATION:      0x40,\r",
							"  CONTEXT_SPECIFIC: 0x80,\r",
							"  PRIVATE:          0xC0\r",
							"};\r",
							"\r",
							"/**\r",
							" * ASN.1 types. Not all types are supported by this implementation, only\r",
							" * those necessary to implement a simple PKI are implemented.\r",
							" */\r",
							"asn1.Type = {\r",
							"  NONE:             0,\r",
							"  BOOLEAN:          1,\r",
							"  INTEGER:          2,\r",
							"  BITSTRING:        3,\r",
							"  OCTETSTRING:      4,\r",
							"  NULL:             5,\r",
							"  OID:              6,\r",
							"  ODESC:            7,\r",
							"  EXTERNAL:         8,\r",
							"  REAL:             9,\r",
							"  ENUMERATED:      10,\r",
							"  EMBEDDED:        11,\r",
							"  UTF8:            12,\r",
							"  ROID:            13,\r",
							"  SEQUENCE:        16,\r",
							"  SET:             17,\r",
							"  PRINTABLESTRING: 19,\r",
							"  IA5STRING:       22,\r",
							"  UTCTIME:         23,\r",
							"  GENERALIZEDTIME: 24,\r",
							"  BMPSTRING:       30\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new asn1 object.\r",
							" *\r",
							" * @param tagClass the tag class for the object.\r",
							" * @param type the data type (tag number) for the object.\r",
							" * @param constructed true if the asn1 object is in constructed form.\r",
							" * @param value the value for the object, if it is not constructed.\r",
							" * @param [options] the options to use:\r",
							" *          [bitStringContents] the plain BIT STRING content including padding\r",
							" *            byte.\r",
							" *\r",
							" * @return the asn1 object.\r",
							" */\r",
							"asn1.create = function(tagClass, type, constructed, value, options) {\r",
							"  /* An asn1 object has a tagClass, a type, a constructed flag, and a\r",
							"    value. The value's type depends on the constructed flag. If\r",
							"    constructed, it will contain a list of other asn1 objects. If not,\r",
							"    it will contain the ASN.1 value as an array of bytes formatted\r",
							"    according to the ASN.1 data type. */\r",
							"\r",
							"  // remove undefined values\r",
							"  if(forge.util.isArray(value)) {\r",
							"    var tmp = [];\r",
							"    for(var i = 0; i < value.length; ++i) {\r",
							"      if(value[i] !== undefined) {\r",
							"        tmp.push(value[i]);\r",
							"      }\r",
							"    }\r",
							"    value = tmp;\r",
							"  }\r",
							"\r",
							"  var obj = {\r",
							"    tagClass: tagClass,\r",
							"    type: type,\r",
							"    constructed: constructed,\r",
							"    composed: constructed || forge.util.isArray(value),\r",
							"    value: value\r",
							"  };\r",
							"  if(options && 'bitStringContents' in options) {\r",
							"    // TODO: copy byte buffer if it's a buffer not a string\r",
							"    obj.bitStringContents = options.bitStringContents;\r",
							"    // TODO: add readonly flag to avoid this overhead\r",
							"    // save copy to detect changes\r",
							"    obj.original = asn1.copy(obj);\r",
							"  }\r",
							"  return obj;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Copies an asn1 object.\r",
							" *\r",
							" * @param obj the asn1 object.\r",
							" * @param [options] copy options:\r",
							" *          [excludeBitStringContents] true to not copy bitStringContents\r",
							" *\r",
							" * @return the a copy of the asn1 object.\r",
							" */\r",
							"asn1.copy = function(obj, options) {\r",
							"  var copy;\r",
							"\r",
							"  if(forge.util.isArray(obj)) {\r",
							"    copy = [];\r",
							"    for(var i = 0; i < obj.length; ++i) {\r",
							"      copy.push(asn1.copy(obj[i], options));\r",
							"    }\r",
							"    return copy;\r",
							"  }\r",
							"\r",
							"  if(typeof obj === 'string') {\r",
							"    // TODO: copy byte buffer if it's a buffer not a string\r",
							"    return obj;\r",
							"  }\r",
							"\r",
							"  copy = {\r",
							"    tagClass: obj.tagClass,\r",
							"    type: obj.type,\r",
							"    constructed: obj.constructed,\r",
							"    composed: obj.composed,\r",
							"    value: asn1.copy(obj.value, options)\r",
							"  };\r",
							"  if(options && !options.excludeBitStringContents) {\r",
							"    // TODO: copy byte buffer if it's a buffer not a string\r",
							"    copy.bitStringContents = obj.bitStringContents;\r",
							"  }\r",
							"  return copy;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compares asn1 objects for equality.\r",
							" *\r",
							" * Note this function does not run in constant time.\r",
							" *\r",
							" * @param obj1 the first asn1 object.\r",
							" * @param obj2 the second asn1 object.\r",
							" * @param [options] compare options:\r",
							" *          [includeBitStringContents] true to compare bitStringContents\r",
							" *\r",
							" * @return true if the asn1 objects are equal.\r",
							" */\r",
							"asn1.equals = function(obj1, obj2, options) {\r",
							"  if(forge.util.isArray(obj1)) {\r",
							"    if(!forge.util.isArray(obj2)) {\r",
							"      return false;\r",
							"    }\r",
							"    if(obj1.length !== obj2.length) {\r",
							"      return false;\r",
							"    }\r",
							"    for(var i = 0; i < obj1.length; ++i) {\r",
							"      if(!asn1.equals(obj1[i], obj2[i])) {\r",
							"        return false;\r",
							"      }\r",
							"    }\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  if(typeof obj1 !== typeof obj2) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  if(typeof obj1 === 'string') {\r",
							"    return obj1 === obj2;\r",
							"  }\r",
							"\r",
							"  var equal = obj1.tagClass === obj2.tagClass &&\r",
							"    obj1.type === obj2.type &&\r",
							"    obj1.constructed === obj2.constructed &&\r",
							"    obj1.composed === obj2.composed &&\r",
							"    asn1.equals(obj1.value, obj2.value);\r",
							"  if(options && options.includeBitStringContents) {\r",
							"    equal = equal && (obj1.bitStringContents === obj2.bitStringContents);\r",
							"  }\r",
							"\r",
							"  return equal;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the length of a BER-encoded ASN.1 value.\r",
							" *\r",
							" * In case the length is not specified, undefined is returned.\r",
							" *\r",
							" * @param b the BER-encoded ASN.1 byte buffer, starting with the first\r",
							" *          length byte.\r",
							" *\r",
							" * @return the length of the BER-encoded ASN.1 value or undefined.\r",
							" */\r",
							"asn1.getBerValueLength = function(b) {\r",
							"  // TODO: move this function and related DER/BER functions to a der.js\r",
							"  // file; better abstract ASN.1 away from der/ber.\r",
							"  var b2 = b.getByte();\r",
							"  if(b2 === 0x80) {\r",
							"    return undefined;\r",
							"  }\r",
							"\r",
							"  // see if the length is \"short form\" or \"long form\" (bit 8 set)\r",
							"  var length;\r",
							"  var longForm = b2 & 0x80;\r",
							"  if(!longForm) {\r",
							"    // length is just the first byte\r",
							"    length = b2;\r",
							"  } else {\r",
							"    // the number of bytes the length is specified in bits 7 through 1\r",
							"    // and each length byte is in big-endian base-256\r",
							"    length = b.getInt((b2 & 0x7F) << 3);\r",
							"  }\r",
							"  return length;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Check if the byte buffer has enough bytes. Throws an Error if not.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param remaining the bytes remaining in the current parsing state.\r",
							" * @param n the number of bytes the buffer must have.\r",
							" */\r",
							"function _checkBufferLength(bytes, remaining, n) {\r",
							"  if(n > remaining) {\r",
							"    var error = new Error('Too few bytes to parse DER.');\r",
							"    error.available = bytes.length();\r",
							"    error.remaining = remaining;\r",
							"    error.requested = n;\r",
							"    throw error;\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Gets the length of a BER-encoded ASN.1 value.\r",
							" *\r",
							" * In case the length is not specified, undefined is returned.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param remaining the bytes remaining in the current parsing state.\r",
							" *\r",
							" * @return the length of the BER-encoded ASN.1 value or undefined.\r",
							" */\r",
							"var _getValueLength = function(bytes, remaining) {\r",
							"  // TODO: move this function and related DER/BER functions to a der.js\r",
							"  // file; better abstract ASN.1 away from der/ber.\r",
							"  // fromDer already checked that this byte exists\r",
							"  var b2 = bytes.getByte();\r",
							"  remaining--;\r",
							"  if(b2 === 0x80) {\r",
							"    return undefined;\r",
							"  }\r",
							"\r",
							"  // see if the length is \"short form\" or \"long form\" (bit 8 set)\r",
							"  var length;\r",
							"  var longForm = b2 & 0x80;\r",
							"  if(!longForm) {\r",
							"    // length is just the first byte\r",
							"    length = b2;\r",
							"  } else {\r",
							"    // the number of bytes the length is specified in bits 7 through 1\r",
							"    // and each length byte is in big-endian base-256\r",
							"    var longFormBytes = b2 & 0x7F;\r",
							"    _checkBufferLength(bytes, remaining, longFormBytes);\r",
							"    length = bytes.getInt(longFormBytes << 3);\r",
							"  }\r",
							"  // FIXME: this will only happen for 32 bit getInt with high bit set\r",
							"  if(length < 0) {\r",
							"    throw new Error('Negative length: ' + length);\r",
							"  }\r",
							"  return length;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses an asn1 object from a byte buffer in DER format.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param [strict] true to be strict when checking value lengths, false to\r",
							" *          allow truncated values (default: true).\r",
							" * @param [options] object with options or boolean strict flag\r",
							" *          [strict] true to be strict when checking value lengths, false to\r",
							" *            allow truncated values (default: true).\r",
							" *          [decodeBitStrings] true to attempt to decode the content of\r",
							" *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that\r",
							" *            without schema support to understand the data context this can\r",
							" *            erroneously decode values that happen to be valid ASN.1. This\r",
							" *            flag will be deprecated or removed as soon as schema support is\r",
							" *            available. (default: true)\r",
							" *\r",
							" * @return the parsed asn1 object.\r",
							" */\r",
							"asn1.fromDer = function(bytes, options) {\r",
							"  if(options === undefined) {\r",
							"    options = {\r",
							"      strict: true,\r",
							"      decodeBitStrings: true\r",
							"    };\r",
							"  }\r",
							"  if(typeof options === 'boolean') {\r",
							"    options = {\r",
							"      strict: options,\r",
							"      decodeBitStrings: true\r",
							"    };\r",
							"  }\r",
							"  if(!('strict' in options)) {\r",
							"    options.strict = true;\r",
							"  }\r",
							"  if(!('decodeBitStrings' in options)) {\r",
							"    options.decodeBitStrings = true;\r",
							"  }\r",
							"\r",
							"  // wrap in buffer if needed\r",
							"  if(typeof bytes === 'string') {\r",
							"    bytes = forge.util.createBuffer(bytes);\r",
							"  }\r",
							"\r",
							"  return _fromDer(bytes, bytes.length(), 0, options);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Internal function to parse an asn1 object from a byte buffer in DER format.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param remaining the number of bytes remaining for this chunk.\r",
							" * @param depth the current parsing depth.\r",
							" * @param options object with same options as fromDer().\r",
							" *\r",
							" * @return the parsed asn1 object.\r",
							" */\r",
							"function _fromDer(bytes, remaining, depth, options) {\r",
							"  // temporary storage for consumption calculations\r",
							"  var start;\r",
							"\r",
							"  // minimum length for ASN.1 DER structure is 2\r",
							"  _checkBufferLength(bytes, remaining, 2);\r",
							"\r",
							"  // get the first byte\r",
							"  var b1 = bytes.getByte();\r",
							"  // consumed one byte\r",
							"  remaining--;\r",
							"\r",
							"  // get the tag class\r",
							"  var tagClass = (b1 & 0xC0);\r",
							"\r",
							"  // get the type (bits 1-5)\r",
							"  var type = b1 & 0x1F;\r",
							"\r",
							"  // get the variable value length and adjust remaining bytes\r",
							"  start = bytes.length();\r",
							"  var length = _getValueLength(bytes, remaining);\r",
							"  remaining -= start - bytes.length();\r",
							"\r",
							"  // ensure there are enough bytes to get the value\r",
							"  if(length !== undefined && length > remaining) {\r",
							"    if(options.strict) {\r",
							"      var error = new Error('Too few bytes to read ASN.1 value.');\r",
							"      error.available = bytes.length();\r",
							"      error.remaining = remaining;\r",
							"      error.requested = length;\r",
							"      throw error;\r",
							"    }\r",
							"    // Note: be lenient with truncated values and use remaining state bytes\r",
							"    length = remaining;\r",
							"  }\r",
							"\r",
							"  // value storage\r",
							"  var value;\r",
							"  // possible BIT STRING contents storage\r",
							"  var bitStringContents;\r",
							"\r",
							"  // constructed flag is bit 6 (32 = 0x20) of the first byte\r",
							"  var constructed = ((b1 & 0x20) === 0x20);\r",
							"  if(constructed) {\r",
							"    // parse child asn1 objects from the value\r",
							"    value = [];\r",
							"    if(length === undefined) {\r",
							"      // asn1 object of indefinite length, read until end tag\r",
							"      for(;;) {\r",
							"        _checkBufferLength(bytes, remaining, 2);\r",
							"        if(bytes.bytes(2) === String.fromCharCode(0, 0)) {\r",
							"          bytes.getBytes(2);\r",
							"          remaining -= 2;\r",
							"          break;\r",
							"        }\r",
							"        start = bytes.length();\r",
							"        value.push(_fromDer(bytes, remaining, depth + 1, options));\r",
							"        remaining -= start - bytes.length();\r",
							"      }\r",
							"    } else {\r",
							"      // parsing asn1 object of definite length\r",
							"      while(length > 0) {\r",
							"        start = bytes.length();\r",
							"        value.push(_fromDer(bytes, length, depth + 1, options));\r",
							"        remaining -= start - bytes.length();\r",
							"        length -= start - bytes.length();\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // if a BIT STRING, save the contents including padding\r",
							"  if(value === undefined && tagClass === asn1.Class.UNIVERSAL &&\r",
							"    type === asn1.Type.BITSTRING) {\r",
							"    bitStringContents = bytes.bytes(length);\r",
							"  }\r",
							"\r",
							"  // determine if a non-constructed value should be decoded as a composed\r",
							"  // value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)\r",
							"  // can be used this way.\r",
							"  if(value === undefined && options.decodeBitStrings &&\r",
							"    tagClass === asn1.Class.UNIVERSAL &&\r",
							"    // FIXME: OCTET STRINGs not yet supported here\r",
							"    // .. other parts of forge expect to decode OCTET STRINGs manually\r",
							"    (type === asn1.Type.BITSTRING /*|| type === asn1.Type.OCTETSTRING*/) &&\r",
							"    length > 1) {\r",
							"    // save read position\r",
							"    var savedRead = bytes.read;\r",
							"    var savedRemaining = remaining;\r",
							"    var unused = 0;\r",
							"    if(type === asn1.Type.BITSTRING) {\r",
							"      /* The first octet gives the number of bits by which the length of the\r",
							"        bit string is less than the next multiple of eight (this is called\r",
							"        the \"number of unused bits\").\r",
							"\r",
							"        The second and following octets give the value of the bit string\r",
							"        converted to an octet string. */\r",
							"      _checkBufferLength(bytes, remaining, 1);\r",
							"      unused = bytes.getByte();\r",
							"      remaining--;\r",
							"    }\r",
							"    // if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs\r",
							"    if(unused === 0) {\r",
							"      try {\r",
							"        // attempt to parse child asn1 object from the value\r",
							"        // (stored in array to signal composed value)\r",
							"        start = bytes.length();\r",
							"        var subOptions = {\r",
							"          // enforce strict mode to avoid parsing ASN.1 from plain data\r",
							"          verbose: options.verbose,\r",
							"          strict: true,\r",
							"          decodeBitStrings: true\r",
							"        };\r",
							"        var composed = _fromDer(bytes, remaining, depth + 1, subOptions);\r",
							"        var used = start - bytes.length();\r",
							"        remaining -= used;\r",
							"        if(type == asn1.Type.BITSTRING) {\r",
							"          used++;\r",
							"        }\r",
							"\r",
							"        // if the data all decoded and the class indicates UNIVERSAL or\r",
							"        // CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object\r",
							"        var tc = composed.tagClass;\r",
							"        if(used === length &&\r",
							"          (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {\r",
							"          value = [composed];\r",
							"        }\r",
							"      } catch(ex) {\r",
							"      }\r",
							"    }\r",
							"    if(value === undefined) {\r",
							"      // restore read position\r",
							"      bytes.read = savedRead;\r",
							"      remaining = savedRemaining;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(value === undefined) {\r",
							"    // asn1 not constructed or composed, get raw value\r",
							"    // TODO: do DER to OID conversion and vice-versa in .toDer?\r",
							"\r",
							"    if(length === undefined) {\r",
							"      if(options.strict) {\r",
							"        throw new Error('Non-constructed ASN.1 object of indefinite length.');\r",
							"      }\r",
							"      // be lenient and use remaining state bytes\r",
							"      length = remaining;\r",
							"    }\r",
							"\r",
							"    if(type === asn1.Type.BMPSTRING) {\r",
							"      value = '';\r",
							"      for(; length > 0; length -= 2) {\r",
							"        _checkBufferLength(bytes, remaining, 2);\r",
							"        value += String.fromCharCode(bytes.getInt16());\r",
							"        remaining -= 2;\r",
							"      }\r",
							"    } else {\r",
							"      value = bytes.getBytes(length);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // add BIT STRING contents if available\r",
							"  var asn1Options = bitStringContents === undefined ?  null : {\r",
							"    bitStringContents: bitStringContents\r",
							"  };\r",
							"\r",
							"  // create and return asn1 object\r",
							"  return asn1.create(tagClass, type, constructed, value, asn1Options);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts the given asn1 object to a buffer of bytes in DER format.\r",
							" *\r",
							" * @param asn1 the asn1 object to convert to bytes.\r",
							" *\r",
							" * @return the buffer of bytes.\r",
							" */\r",
							"asn1.toDer = function(obj) {\r",
							"  var bytes = forge.util.createBuffer();\r",
							"\r",
							"  // build the first byte\r",
							"  var b1 = obj.tagClass | obj.type;\r",
							"\r",
							"  // for storing the ASN.1 value\r",
							"  var value = forge.util.createBuffer();\r",
							"\r",
							"  // use BIT STRING contents if available and data not changed\r",
							"  var useBitStringContents = false;\r",
							"  if('bitStringContents' in obj) {\r",
							"    useBitStringContents = true;\r",
							"    if(obj.original) {\r",
							"      useBitStringContents = asn1.equals(obj, obj.original);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(useBitStringContents) {\r",
							"    value.putBytes(obj.bitStringContents);\r",
							"  } else if(obj.composed) {\r",
							"    // if composed, use each child asn1 object's DER bytes as value\r",
							"    // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed\r",
							"    // from other asn1 objects\r",
							"    if(obj.constructed) {\r",
							"      b1 |= 0x20;\r",
							"    } else {\r",
							"      // type is a bit string, add unused bits of 0x00\r",
							"      value.putByte(0x00);\r",
							"    }\r",
							"\r",
							"    // add all of the child DER bytes together\r",
							"    for(var i = 0; i < obj.value.length; ++i) {\r",
							"      if(obj.value[i] !== undefined) {\r",
							"        value.putBuffer(asn1.toDer(obj.value[i]));\r",
							"      }\r",
							"    }\r",
							"  } else {\r",
							"    // use asn1.value directly\r",
							"    if(obj.type === asn1.Type.BMPSTRING) {\r",
							"      for(var i = 0; i < obj.value.length; ++i) {\r",
							"        value.putInt16(obj.value.charCodeAt(i));\r",
							"      }\r",
							"    } else {\r",
							"      // ensure integer is minimally-encoded\r",
							"      // TODO: should all leading bytes be stripped vs just one?\r",
							"      // .. ex '00 00 01' => '01'?\r",
							"      if(obj.type === asn1.Type.INTEGER &&\r",
							"        obj.value.length > 1 &&\r",
							"        // leading 0x00 for positive integer\r",
							"        ((obj.value.charCodeAt(0) === 0 &&\r",
							"        (obj.value.charCodeAt(1) & 0x80) === 0) ||\r",
							"        // leading 0xFF for negative integer\r",
							"        (obj.value.charCodeAt(0) === 0xFF &&\r",
							"        (obj.value.charCodeAt(1) & 0x80) === 0x80))) {\r",
							"        value.putBytes(obj.value.substr(1));\r",
							"      } else {\r",
							"        value.putBytes(obj.value);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // add tag byte\r",
							"  bytes.putByte(b1);\r",
							"\r",
							"  // use \"short form\" encoding\r",
							"  if(value.length() <= 127) {\r",
							"    // one byte describes the length\r",
							"    // bit 8 = 0 and bits 7-1 = length\r",
							"    bytes.putByte(value.length() & 0x7F);\r",
							"  } else {\r",
							"    // use \"long form\" encoding\r",
							"    // 2 to 127 bytes describe the length\r",
							"    // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes\r",
							"    // other bytes: length in base 256, big-endian\r",
							"    var len = value.length();\r",
							"    var lenBytes = '';\r",
							"    do {\r",
							"      lenBytes += String.fromCharCode(len & 0xFF);\r",
							"      len = len >>> 8;\r",
							"    } while(len > 0);\r",
							"\r",
							"    // set first byte to # bytes used to store the length and turn on\r",
							"    // bit 8 to indicate long-form length is used\r",
							"    bytes.putByte(lenBytes.length | 0x80);\r",
							"\r",
							"    // concatenate length bytes in reverse since they were generated\r",
							"    // little endian and we need big endian\r",
							"    for(var i = lenBytes.length - 1; i >= 0; --i) {\r",
							"      bytes.putByte(lenBytes.charCodeAt(i));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // concatenate value bytes\r",
							"  bytes.putBuffer(value);\r",
							"  return bytes;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an OID dot-separated string to a byte buffer. The byte buffer\r",
							" * contains only the DER-encoded value, not any tag or length bytes.\r",
							" *\r",
							" * @param oid the OID dot-separated string.\r",
							" *\r",
							" * @return the byte buffer.\r",
							" */\r",
							"asn1.oidToDer = function(oid) {\r",
							"  // split OID into individual values\r",
							"  var values = oid.split('.');\r",
							"  var bytes = forge.util.createBuffer();\r",
							"\r",
							"  // first byte is 40 * value1 + value2\r",
							"  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));\r",
							"  // other bytes are each value in base 128 with 8th bit set except for\r",
							"  // the last byte for each value\r",
							"  var last, valueBytes, value, b;\r",
							"  for(var i = 2; i < values.length; ++i) {\r",
							"    // produce value bytes in reverse because we don't know how many\r",
							"    // bytes it will take to store the value\r",
							"    last = true;\r",
							"    valueBytes = [];\r",
							"    value = parseInt(values[i], 10);\r",
							"    do {\r",
							"      b = value & 0x7F;\r",
							"      value = value >>> 7;\r",
							"      // if value is not last, then turn on 8th bit\r",
							"      if(!last) {\r",
							"        b |= 0x80;\r",
							"      }\r",
							"      valueBytes.push(b);\r",
							"      last = false;\r",
							"    } while(value > 0);\r",
							"\r",
							"    // add value bytes in reverse (needs to be in big endian)\r",
							"    for(var n = valueBytes.length - 1; n >= 0; --n) {\r",
							"      bytes.putByte(valueBytes[n]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return bytes;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a DER-encoded byte buffer to an OID dot-separated string. The\r",
							" * byte buffer should contain only the DER-encoded value, not any tag or\r",
							" * length bytes.\r",
							" *\r",
							" * @param bytes the byte buffer.\r",
							" *\r",
							" * @return the OID dot-separated string.\r",
							" */\r",
							"asn1.derToOid = function(bytes) {\r",
							"  var oid;\r",
							"\r",
							"  // wrap in buffer if needed\r",
							"  if(typeof bytes === 'string') {\r",
							"    bytes = forge.util.createBuffer(bytes);\r",
							"  }\r",
							"\r",
							"  // first byte is 40 * value1 + value2\r",
							"  var b = bytes.getByte();\r",
							"  oid = Math.floor(b / 40) + '.' + (b % 40);\r",
							"\r",
							"  // other bytes are each value in base 128 with 8th bit set except for\r",
							"  // the last byte for each value\r",
							"  var value = 0;\r",
							"  while(bytes.length() > 0) {\r",
							"    b = bytes.getByte();\r",
							"    value = value << 7;\r",
							"    // not the last byte for the value\r",
							"    if(b & 0x80) {\r",
							"      value += b & 0x7F;\r",
							"    } else {\r",
							"      // last byte\r",
							"      oid += '.' + (value + b);\r",
							"      value = 0;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return oid;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a UTCTime value to a date.\r",
							" *\r",
							" * Note: GeneralizedTime has 4 digits for the year and is used for X.509\r",
							" * dates past 2049. Parsing that structure hasn't been implemented yet.\r",
							" *\r",
							" * @param utc the UTCTime value to convert.\r",
							" *\r",
							" * @return the date.\r",
							" */\r",
							"asn1.utcTimeToDate = function(utc) {\r",
							"  /* The following formats can be used:\r",
							"\r",
							"    YYMMDDhhmmZ\r",
							"    YYMMDDhhmm+hh'mm'\r",
							"    YYMMDDhhmm-hh'mm'\r",
							"    YYMMDDhhmmssZ\r",
							"    YYMMDDhhmmss+hh'mm'\r",
							"    YYMMDDhhmmss-hh'mm'\r",
							"\r",
							"    Where:\r",
							"\r",
							"    YY is the least significant two digits of the year\r",
							"    MM is the month (01 to 12)\r",
							"    DD is the day (01 to 31)\r",
							"    hh is the hour (00 to 23)\r",
							"    mm are the minutes (00 to 59)\r",
							"    ss are the seconds (00 to 59)\r",
							"    Z indicates that local time is GMT, + indicates that local time is\r",
							"    later than GMT, and - indicates that local time is earlier than GMT\r",
							"    hh' is the absolute value of the offset from GMT in hours\r",
							"    mm' is the absolute value of the offset from GMT in minutes */\r",
							"  var date = new Date();\r",
							"\r",
							"  // if YY >= 50 use 19xx, if YY < 50 use 20xx\r",
							"  var year = parseInt(utc.substr(0, 2), 10);\r",
							"  year = (year >= 50) ? 1900 + year : 2000 + year;\r",
							"  var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month\r",
							"  var DD = parseInt(utc.substr(4, 2), 10);\r",
							"  var hh = parseInt(utc.substr(6, 2), 10);\r",
							"  var mm = parseInt(utc.substr(8, 2), 10);\r",
							"  var ss = 0;\r",
							"\r",
							"  // not just YYMMDDhhmmZ\r",
							"  if(utc.length > 11) {\r",
							"    // get character after minutes\r",
							"    var c = utc.charAt(10);\r",
							"    var end = 10;\r",
							"\r",
							"    // see if seconds are present\r",
							"    if(c !== '+' && c !== '-') {\r",
							"      // get seconds\r",
							"      ss = parseInt(utc.substr(10, 2), 10);\r",
							"      end += 2;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // update date\r",
							"  date.setUTCFullYear(year, MM, DD);\r",
							"  date.setUTCHours(hh, mm, ss, 0);\r",
							"\r",
							"  if(end) {\r",
							"    // get +/- after end of time\r",
							"    c = utc.charAt(end);\r",
							"    if(c === '+' || c === '-') {\r",
							"      // get hours+minutes offset\r",
							"      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);\r",
							"      var mmoffset = parseInt(utc.substr(end + 4, 2), 10);\r",
							"\r",
							"      // calculate offset in milliseconds\r",
							"      var offset = hhoffset * 60 + mmoffset;\r",
							"      offset *= 60000;\r",
							"\r",
							"      // apply offset\r",
							"      if(c === '+') {\r",
							"        date.setTime(+date - offset);\r",
							"      } else {\r",
							"        date.setTime(+date + offset);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return date;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a GeneralizedTime value to a date.\r",
							" *\r",
							" * @param gentime the GeneralizedTime value to convert.\r",
							" *\r",
							" * @return the date.\r",
							" */\r",
							"asn1.generalizedTimeToDate = function(gentime) {\r",
							"  /* The following formats can be used:\r",
							"\r",
							"    YYYYMMDDHHMMSS\r",
							"    YYYYMMDDHHMMSS.fff\r",
							"    YYYYMMDDHHMMSSZ\r",
							"    YYYYMMDDHHMMSS.fffZ\r",
							"    YYYYMMDDHHMMSS+hh'mm'\r",
							"    YYYYMMDDHHMMSS.fff+hh'mm'\r",
							"    YYYYMMDDHHMMSS-hh'mm'\r",
							"    YYYYMMDDHHMMSS.fff-hh'mm'\r",
							"\r",
							"    Where:\r",
							"\r",
							"    YYYY is the year\r",
							"    MM is the month (01 to 12)\r",
							"    DD is the day (01 to 31)\r",
							"    hh is the hour (00 to 23)\r",
							"    mm are the minutes (00 to 59)\r",
							"    ss are the seconds (00 to 59)\r",
							"    .fff is the second fraction, accurate to three decimal places\r",
							"    Z indicates that local time is GMT, + indicates that local time is\r",
							"    later than GMT, and - indicates that local time is earlier than GMT\r",
							"    hh' is the absolute value of the offset from GMT in hours\r",
							"    mm' is the absolute value of the offset from GMT in minutes */\r",
							"  var date = new Date();\r",
							"\r",
							"  var YYYY = parseInt(gentime.substr(0, 4), 10);\r",
							"  var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month\r",
							"  var DD = parseInt(gentime.substr(6, 2), 10);\r",
							"  var hh = parseInt(gentime.substr(8, 2), 10);\r",
							"  var mm = parseInt(gentime.substr(10, 2), 10);\r",
							"  var ss = parseInt(gentime.substr(12, 2), 10);\r",
							"  var fff = 0;\r",
							"  var offset = 0;\r",
							"  var isUTC = false;\r",
							"\r",
							"  if(gentime.charAt(gentime.length - 1) === 'Z') {\r",
							"    isUTC = true;\r",
							"  }\r",
							"\r",
							"  var end = gentime.length - 5, c = gentime.charAt(end);\r",
							"  if(c === '+' || c === '-') {\r",
							"    // get hours+minutes offset\r",
							"    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);\r",
							"    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);\r",
							"\r",
							"    // calculate offset in milliseconds\r",
							"    offset = hhoffset * 60 + mmoffset;\r",
							"    offset *= 60000;\r",
							"\r",
							"    // apply offset\r",
							"    if(c === '+') {\r",
							"      offset *= -1;\r",
							"    }\r",
							"\r",
							"    isUTC = true;\r",
							"  }\r",
							"\r",
							"  // check for second fraction\r",
							"  if(gentime.charAt(14) === '.') {\r",
							"    fff = parseFloat(gentime.substr(14), 10) * 1000;\r",
							"  }\r",
							"\r",
							"  if(isUTC) {\r",
							"    date.setUTCFullYear(YYYY, MM, DD);\r",
							"    date.setUTCHours(hh, mm, ss, fff);\r",
							"\r",
							"    // apply offset\r",
							"    date.setTime(+date + offset);\r",
							"  } else {\r",
							"    date.setFullYear(YYYY, MM, DD);\r",
							"    date.setHours(hh, mm, ss, fff);\r",
							"  }\r",
							"\r",
							"  return date;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a date to a UTCTime value.\r",
							" *\r",
							" * Note: GeneralizedTime has 4 digits for the year and is used for X.509\r",
							" * dates past 2049. Converting to a GeneralizedTime hasn't been\r",
							" * implemented yet.\r",
							" *\r",
							" * @param date the date to convert.\r",
							" *\r",
							" * @return the UTCTime value.\r",
							" */\r",
							"asn1.dateToUtcTime = function(date) {\r",
							"  // TODO: validate; currently assumes proper format\r",
							"  if(typeof date === 'string') {\r",
							"    return date;\r",
							"  }\r",
							"\r",
							"  var rval = '';\r",
							"\r",
							"  // create format YYMMDDhhmmssZ\r",
							"  var format = [];\r",
							"  format.push(('' + date.getUTCFullYear()).substr(2));\r",
							"  format.push('' + (date.getUTCMonth() + 1));\r",
							"  format.push('' + date.getUTCDate());\r",
							"  format.push('' + date.getUTCHours());\r",
							"  format.push('' + date.getUTCMinutes());\r",
							"  format.push('' + date.getUTCSeconds());\r",
							"\r",
							"  // ensure 2 digits are used for each format entry\r",
							"  for(var i = 0; i < format.length; ++i) {\r",
							"    if(format[i].length < 2) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += format[i];\r",
							"  }\r",
							"  rval += 'Z';\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a date to a GeneralizedTime value.\r",
							" *\r",
							" * @param date the date to convert.\r",
							" *\r",
							" * @return the GeneralizedTime value as a string.\r",
							" */\r",
							"asn1.dateToGeneralizedTime = function(date) {\r",
							"  // TODO: validate; currently assumes proper format\r",
							"  if(typeof date === 'string') {\r",
							"    return date;\r",
							"  }\r",
							"\r",
							"  var rval = '';\r",
							"\r",
							"  // create format YYYYMMDDHHMMSSZ\r",
							"  var format = [];\r",
							"  format.push('' + date.getUTCFullYear());\r",
							"  format.push('' + (date.getUTCMonth() + 1));\r",
							"  format.push('' + date.getUTCDate());\r",
							"  format.push('' + date.getUTCHours());\r",
							"  format.push('' + date.getUTCMinutes());\r",
							"  format.push('' + date.getUTCSeconds());\r",
							"\r",
							"  // ensure 2 digits are used for each format entry\r",
							"  for(var i = 0; i < format.length; ++i) {\r",
							"    if(format[i].length < 2) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += format[i];\r",
							"  }\r",
							"  rval += 'Z';\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a javascript integer to a DER-encoded byte buffer to be used\r",
							" * as the value for an INTEGER type.\r",
							" *\r",
							" * @param x the integer.\r",
							" *\r",
							" * @return the byte buffer.\r",
							" */\r",
							"asn1.integerToDer = function(x) {\r",
							"  var rval = forge.util.createBuffer();\r",
							"  if(x >= -0x80 && x < 0x80) {\r",
							"    return rval.putSignedInt(x, 8);\r",
							"  }\r",
							"  if(x >= -0x8000 && x < 0x8000) {\r",
							"    return rval.putSignedInt(x, 16);\r",
							"  }\r",
							"  if(x >= -0x800000 && x < 0x800000) {\r",
							"    return rval.putSignedInt(x, 24);\r",
							"  }\r",
							"  if(x >= -0x80000000 && x < 0x80000000) {\r",
							"    return rval.putSignedInt(x, 32);\r",
							"  }\r",
							"  var error = new Error('Integer too large; max is 32-bits.');\r",
							"  error.integer = x;\r",
							"  throw error;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a DER-encoded byte buffer to a javascript integer. This is\r",
							" * typically used to decode the value of an INTEGER type.\r",
							" *\r",
							" * @param bytes the byte buffer.\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"asn1.derToInteger = function(bytes) {\r",
							"  // wrap in buffer if needed\r",
							"  if(typeof bytes === 'string') {\r",
							"    bytes = forge.util.createBuffer(bytes);\r",
							"  }\r",
							"\r",
							"  var n = bytes.length() * 8;\r",
							"  if(n > 32) {\r",
							"    throw new Error('Integer too large; max is 32-bits.');\r",
							"  }\r",
							"  return bytes.getSignedInt(n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Validates that the given ASN.1 object is at least a super set of the\r",
							" * given ASN.1 structure. Only tag classes and types are checked. An\r",
							" * optional map may also be provided to capture ASN.1 values while the\r",
							" * structure is checked.\r",
							" *\r",
							" * To capture an ASN.1 value, set an object in the validator's 'capture'\r",
							" * parameter to the key to use in the capture map. To capture the full\r",
							" * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including\r",
							" * the leading unused bits counter byte, specify 'captureBitStringContents'.\r",
							" * To capture BIT STRING bytes, without the leading unused bits counter byte,\r",
							" * specify 'captureBitStringValue'.\r",
							" *\r",
							" * Objects in the validator may set a field 'optional' to true to indicate\r",
							" * that it isn't necessary to pass validation.\r",
							" *\r",
							" * @param obj the ASN.1 object to validate.\r",
							" * @param v the ASN.1 structure validator.\r",
							" * @param capture an optional map to capture values in.\r",
							" * @param errors an optional array for storing validation errors.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"asn1.validate = function(obj, v, capture, errors) {\r",
							"  var rval = false;\r",
							"\r",
							"  // ensure tag class and type are the same if specified\r",
							"  if((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') &&\r",
							"    (obj.type === v.type || typeof(v.type) === 'undefined')) {\r",
							"    // ensure constructed flag is the same if specified\r",
							"    if(obj.constructed === v.constructed ||\r",
							"      typeof(v.constructed) === 'undefined') {\r",
							"      rval = true;\r",
							"\r",
							"      // handle sub values\r",
							"      if(v.value && forge.util.isArray(v.value)) {\r",
							"        var j = 0;\r",
							"        for(var i = 0; rval && i < v.value.length; ++i) {\r",
							"          rval = v.value[i].optional || false;\r",
							"          if(obj.value[j]) {\r",
							"            rval = asn1.validate(obj.value[j], v.value[i], capture, errors);\r",
							"            if(rval) {\r",
							"              ++j;\r",
							"            } else if(v.value[i].optional) {\r",
							"              rval = true;\r",
							"            }\r",
							"          }\r",
							"          if(!rval && errors) {\r",
							"            errors.push(\r",
							"              '[' + v.name + '] ' +\r",
							"              'Tag class \"' + v.tagClass + '\", type \"' +\r",
							"              v.type + '\" expected value length \"' +\r",
							"              v.value.length + '\", got \"' +\r",
							"              obj.value.length + '\"');\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(rval && capture) {\r",
							"        if(v.capture) {\r",
							"          capture[v.capture] = obj.value;\r",
							"        }\r",
							"        if(v.captureAsn1) {\r",
							"          capture[v.captureAsn1] = obj;\r",
							"        }\r",
							"        if(v.captureBitStringContents && 'bitStringContents' in obj) {\r",
							"          capture[v.captureBitStringContents] = obj.bitStringContents;\r",
							"        }\r",
							"        if(v.captureBitStringValue && 'bitStringContents' in obj) {\r",
							"          var value;\r",
							"          if(obj.bitStringContents.length < 2) {\r",
							"            capture[v.captureBitStringValue] = '';\r",
							"          } else {\r",
							"            // FIXME: support unused bits with data shifting\r",
							"            var unused = obj.bitStringContents.charCodeAt(0);\r",
							"            if(unused !== 0) {\r",
							"              throw new Error(\r",
							"                'captureBitStringValue only supported for zero unused bits');\r",
							"            }\r",
							"            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    } else if(errors) {\r",
							"      errors.push(\r",
							"        '[' + v.name + '] ' +\r",
							"        'Expected constructed \"' + v.constructed + '\", got \"' +\r",
							"        obj.constructed + '\"');\r",
							"    }\r",
							"  } else if(errors) {\r",
							"    if(obj.tagClass !== v.tagClass) {\r",
							"      errors.push(\r",
							"        '[' + v.name + '] ' +\r",
							"        'Expected tag class \"' + v.tagClass + '\", got \"' +\r",
							"        obj.tagClass + '\"');\r",
							"    }\r",
							"    if(obj.type !== v.type) {\r",
							"      errors.push(\r",
							"        '[' + v.name + '] ' +\r",
							"        'Expected type \"' + v.type + '\", got \"' + obj.type + '\"');\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"// regex for testing for non-latin characters\r",
							"var _nonLatinRegex = /[^\\\\u0000-\\\\u00ff]/;\r",
							"\r",
							"/**\r",
							" * Pretty prints an ASN.1 object to a string.\r",
							" *\r",
							" * @param obj the object to write out.\r",
							" * @param level the level in the tree.\r",
							" * @param indentation the indentation to use.\r",
							" *\r",
							" * @return the string.\r",
							" */\r",
							"asn1.prettyPrint = function(obj, level, indentation) {\r",
							"  var rval = '';\r",
							"\r",
							"  // set default level and indentation\r",
							"  level = level || 0;\r",
							"  indentation = indentation || 2;\r",
							"\r",
							"  // start new line for deep levels\r",
							"  if(level > 0) {\r",
							"    rval += '\\n';\r",
							"  }\r",
							"\r",
							"  // create indent\r",
							"  var indent = '';\r",
							"  for(var i = 0; i < level * indentation; ++i) {\r",
							"    indent += ' ';\r",
							"  }\r",
							"\r",
							"  // print class:type\r",
							"  rval += indent + 'Tag: ';\r",
							"  switch(obj.tagClass) {\r",
							"  case asn1.Class.UNIVERSAL:\r",
							"    rval += 'Universal:';\r",
							"    break;\r",
							"  case asn1.Class.APPLICATION:\r",
							"    rval += 'Application:';\r",
							"    break;\r",
							"  case asn1.Class.CONTEXT_SPECIFIC:\r",
							"    rval += 'Context-Specific:';\r",
							"    break;\r",
							"  case asn1.Class.PRIVATE:\r",
							"    rval += 'Private:';\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  if(obj.tagClass === asn1.Class.UNIVERSAL) {\r",
							"    rval += obj.type;\r",
							"\r",
							"    // known types\r",
							"    switch(obj.type) {\r",
							"    case asn1.Type.NONE:\r",
							"      rval += ' (None)';\r",
							"      break;\r",
							"    case asn1.Type.BOOLEAN:\r",
							"      rval += ' (Boolean)';\r",
							"      break;\r",
							"    case asn1.Type.INTEGER:\r",
							"      rval += ' (Integer)';\r",
							"      break;\r",
							"    case asn1.Type.BITSTRING:\r",
							"      rval += ' (Bit string)';\r",
							"      break;\r",
							"    case asn1.Type.OCTETSTRING:\r",
							"      rval += ' (Octet string)';\r",
							"      break;\r",
							"    case asn1.Type.NULL:\r",
							"      rval += ' (Null)';\r",
							"      break;\r",
							"    case asn1.Type.OID:\r",
							"      rval += ' (Object Identifier)';\r",
							"      break;\r",
							"    case asn1.Type.ODESC:\r",
							"      rval += ' (Object Descriptor)';\r",
							"      break;\r",
							"    case asn1.Type.EXTERNAL:\r",
							"      rval += ' (External or Instance of)';\r",
							"      break;\r",
							"    case asn1.Type.REAL:\r",
							"      rval += ' (Real)';\r",
							"      break;\r",
							"    case asn1.Type.ENUMERATED:\r",
							"      rval += ' (Enumerated)';\r",
							"      break;\r",
							"    case asn1.Type.EMBEDDED:\r",
							"      rval += ' (Embedded PDV)';\r",
							"      break;\r",
							"    case asn1.Type.UTF8:\r",
							"      rval += ' (UTF8)';\r",
							"      break;\r",
							"    case asn1.Type.ROID:\r",
							"      rval += ' (Relative Object Identifier)';\r",
							"      break;\r",
							"    case asn1.Type.SEQUENCE:\r",
							"      rval += ' (Sequence)';\r",
							"      break;\r",
							"    case asn1.Type.SET:\r",
							"      rval += ' (Set)';\r",
							"      break;\r",
							"    case asn1.Type.PRINTABLESTRING:\r",
							"      rval += ' (Printable String)';\r",
							"      break;\r",
							"    case asn1.Type.IA5String:\r",
							"      rval += ' (IA5String (ASCII))';\r",
							"      break;\r",
							"    case asn1.Type.UTCTIME:\r",
							"      rval += ' (UTC time)';\r",
							"      break;\r",
							"    case asn1.Type.GENERALIZEDTIME:\r",
							"      rval += ' (Generalized time)';\r",
							"      break;\r",
							"    case asn1.Type.BMPSTRING:\r",
							"      rval += ' (BMP String)';\r",
							"      break;\r",
							"    }\r",
							"  } else {\r",
							"    rval += obj.type;\r",
							"  }\r",
							"\r",
							"  rval += '\\n';\r",
							"  rval += indent + 'Constructed: ' + obj.constructed + '\\n';\r",
							"\r",
							"  if(obj.composed) {\r",
							"    var subvalues = 0;\r",
							"    var sub = '';\r",
							"    for(var i = 0; i < obj.value.length; ++i) {\r",
							"      if(obj.value[i] !== undefined) {\r",
							"        subvalues += 1;\r",
							"        sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);\r",
							"        if((i + 1) < obj.value.length) {\r",
							"          sub += ',';\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    rval += indent + 'Sub values: ' + subvalues + sub;\r",
							"  } else {\r",
							"    rval += indent + 'Value: ';\r",
							"    if(obj.type === asn1.Type.OID) {\r",
							"      var oid = asn1.derToOid(obj.value);\r",
							"      rval += oid;\r",
							"      if(forge.pki && forge.pki.oids) {\r",
							"        if(oid in forge.pki.oids) {\r",
							"          rval += ' (' + forge.pki.oids[oid] + ') ';\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    if(obj.type === asn1.Type.INTEGER) {\r",
							"      try {\r",
							"        rval += asn1.derToInteger(obj.value);\r",
							"      } catch(ex) {\r",
							"        rval += '0x' + forge.util.bytesToHex(obj.value);\r",
							"      }\r",
							"    } else if(obj.type === asn1.Type.BITSTRING) {\r",
							"      // TODO: shift bits as needed to display without padding\r",
							"      if(obj.value.length > 1) {\r",
							"        // remove unused bits field\r",
							"        rval += '0x' + forge.util.bytesToHex(obj.value.slice(1));\r",
							"      } else {\r",
							"        rval += '(none)';\r",
							"      }\r",
							"      // show unused bit count\r",
							"      if(obj.value.length > 0) {\r",
							"        var unused = obj.value.charCodeAt(0);\r",
							"        if(unused == 1) {\r",
							"          rval += ' (1 unused bit shown)';\r",
							"        } else if(unused > 1) {\r",
							"          rval += ' (' + unused + ' unused bits shown)';\r",
							"        }\r",
							"      }\r",
							"    } else if(obj.type === asn1.Type.OCTETSTRING) {\r",
							"      if(!_nonLatinRegex.test(obj.value)) {\r",
							"        rval += '(' + obj.value + ') ';\r",
							"      }\r",
							"      rval += '0x' + forge.util.bytesToHex(obj.value);\r",
							"    } else if(obj.type === asn1.Type.UTF8) {\r",
							"      rval += forge.util.decodeUtf8(obj.value);\r",
							"    } else if(obj.type === asn1.Type.PRINTABLESTRING ||\r",
							"      obj.type === asn1.Type.IA5String) {\r",
							"      rval += obj.value;\r",
							"    } else if(_nonLatinRegex.test(obj.value)) {\r",
							"      rval += '0x' + forge.util.bytesToHex(obj.value);\r",
							"    } else if(obj.value.length === 0) {\r",
							"      rval += '[null]';\r",
							"    } else {\r",
							"      rval += obj.value;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 4 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge message digests.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2017 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"module.exports = forge.md = forge.md || {};\r",
							"forge.md.algorithms = forge.md.algorithms || {};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 5 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Advanced Encryption Standard (AES) implementation.\r",
							" *\r",
							" * This implementation is based on the public domain library 'jscrypto' which\r",
							" * was written by:\r",
							" *\r",
							" * Emily Stark (estark@stanford.edu)\r",
							" * Mike Hamburg (mhamburg@stanford.edu)\r",
							" * Dan Boneh (dabo@cs.stanford.edu)\r",
							" *\r",
							" * Parts of this code are based on the OpenSSL implementation of AES:\r",
							" * http://www.openssl.org\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(13);\r",
							"__webpack_require__(18);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* AES API */\r",
							"module.exports = forge.aes = forge.aes || {};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('AES-<mode>', key);\r",
							" * cipher.start({iv: iv});\r",
							" *\r",
							" * Creates an AES cipher object to encrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes, an array of bytes,\r",
							" * a byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.startEncrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: false,\r",
							"    mode: mode\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('AES-<mode>', key);\r",
							" *\r",
							" * Creates an AES cipher object to encrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes, an array of bytes, a\r",
							" * byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.createEncryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: false,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\r",
							" * decipher.start({iv: iv});\r",
							" *\r",
							" * Creates an AES cipher object to decrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes, an array of bytes,\r",
							" * a byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.startDecrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: true,\r",
							"    mode: mode\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\r",
							" *\r",
							" * Creates an AES cipher object to decrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes, an array of bytes, a\r",
							" * byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.createDecryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: true,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new AES cipher algorithm object.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" * @param mode the mode factory function.\r",
							" *\r",
							" * @return the AES algorithm object.\r",
							" */\r",
							"forge.aes.Algorithm = function(name, mode) {\r",
							"  if(!init) {\r",
							"    initialize();\r",
							"  }\r",
							"  var self = this;\r",
							"  self.name = name;\r",
							"  self.mode = new mode({\r",
							"    blockSize: 16,\r",
							"    cipher: {\r",
							"      encrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._w, inBlock, outBlock, false);\r",
							"      },\r",
							"      decrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._w, inBlock, outBlock, true);\r",
							"      }\r",
							"    }\r",
							"  });\r",
							"  self._init = false;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Initializes this AES algorithm by expanding its key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the key to use with this algorithm.\r",
							" *          decrypt true if the algorithm should be initialized for decryption,\r",
							" *            false for encryption.\r",
							" */\r",
							"forge.aes.Algorithm.prototype.initialize = function(options) {\r",
							"  if(this._init) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  var key = options.key;\r",
							"  var tmp;\r",
							"\r",
							"  /* Note: The key may be a string of bytes, an array of bytes, a byte\r",
							"    buffer, or an array of 32-bit integers. If the key is in bytes, then\r",
							"    it must be 16, 24, or 32 bytes in length. If it is in 32-bit\r",
							"    integers, it must be 4, 6, or 8 integers long. */\r",
							"\r",
							"  if(typeof key === 'string' &&\r",
							"    (key.length === 16 || key.length === 24 || key.length === 32)) {\r",
							"    // convert key string into byte buffer\r",
							"    key = forge.util.createBuffer(key);\r",
							"  } else if(forge.util.isArray(key) &&\r",
							"    (key.length === 16 || key.length === 24 || key.length === 32)) {\r",
							"    // convert key integer array into byte buffer\r",
							"    tmp = key;\r",
							"    key = forge.util.createBuffer();\r",
							"    for(var i = 0; i < tmp.length; ++i) {\r",
							"      key.putByte(tmp[i]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // convert key byte buffer into 32-bit integer array\r",
							"  if(!forge.util.isArray(key)) {\r",
							"    tmp = key;\r",
							"    key = [];\r",
							"\r",
							"    // key lengths of 16, 24, 32 bytes allowed\r",
							"    var len = tmp.length();\r",
							"    if(len === 16 || len === 24 || len === 32) {\r",
							"      len = len >>> 2;\r",
							"      for(var i = 0; i < len; ++i) {\r",
							"        key.push(tmp.getInt32());\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // key must be an array of 32-bit integers by now\r",
							"  if(!forge.util.isArray(key) ||\r",
							"    !(key.length === 4 || key.length === 6 || key.length === 8)) {\r",
							"    throw new Error('Invalid key parameter.');\r",
							"  }\r",
							"\r",
							"  // encryption operation is always used for these modes\r",
							"  var mode = this.mode.name;\r",
							"  var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);\r",
							"\r",
							"  // do key expansion\r",
							"  this._w = _expandKey(key, options.decrypt && !encryptOp);\r",
							"  this._init = true;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Expands a key. Typically only used for testing.\r",
							" *\r",
							" * @param key the symmetric key to expand, as an array of 32-bit words.\r",
							" * @param decrypt true to expand for decryption, false for encryption.\r",
							" *\r",
							" * @return the expanded key.\r",
							" */\r",
							"forge.aes._expandKey = function(key, decrypt) {\r",
							"  if(!init) {\r",
							"    initialize();\r",
							"  }\r",
							"  return _expandKey(key, decrypt);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Updates a single block. Typically only used for testing.\r",
							" *\r",
							" * @param w the expanded key to use.\r",
							" * @param input an array of block-size 32-bit words.\r",
							" * @param output an array of block-size 32-bit words.\r",
							" * @param decrypt true to decrypt, false to encrypt.\r",
							" */\r",
							"forge.aes._updateBlock = _updateBlock;\r",
							"\r",
							"/** Register AES algorithms **/\r",
							"\r",
							"registerAlgorithm('AES-ECB', forge.cipher.modes.ecb);\r",
							"registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);\r",
							"registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);\r",
							"registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);\r",
							"registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);\r",
							"registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);\r",
							"\r",
							"function registerAlgorithm(name, mode) {\r",
							"  var factory = function() {\r",
							"    return new forge.aes.Algorithm(name, mode);\r",
							"  };\r",
							"  forge.cipher.registerAlgorithm(name, factory);\r",
							"}\r",
							"\r",
							"/** AES implementation **/\r",
							"\r",
							"var init = false; // not yet initialized\r",
							"var Nb = 4;       // number of words comprising the state (AES = 4)\r",
							"var sbox;         // non-linear substitution table used in key expansion\r",
							"var isbox;        // inversion of sbox\r",
							"var rcon;         // round constant word array\r",
							"var mix;          // mix-columns table\r",
							"var imix;         // inverse mix-columns table\r",
							"\r",
							"/**\r",
							" * Performs initialization, ie: precomputes tables to optimize for speed.\r",
							" *\r",
							" * One way to understand how AES works is to imagine that 'addition' and\r",
							" * 'multiplication' are interfaces that require certain mathematical\r",
							" * properties to hold true (ie: they are associative) but they might have\r",
							" * different implementations and produce different kinds of results ...\r",
							" * provided that their mathematical properties remain true. AES defines\r",
							" * its own methods of addition and multiplication but keeps some important\r",
							" * properties the same, ie: associativity and distributivity. The\r",
							" * explanation below tries to shed some light on how AES defines addition\r",
							" * and multiplication of bytes and 32-bit words in order to perform its\r",
							" * encryption and decryption algorithms.\r",
							" *\r",
							" * The basics:\r",
							" *\r",
							" * The AES algorithm views bytes as binary representations of polynomials\r",
							" * that have either 1 or 0 as the coefficients. It defines the addition\r",
							" * or subtraction of two bytes as the XOR operation. It also defines the\r",
							" * multiplication of two bytes as a finite field referred to as GF(2^8)\r",
							" * (Note: 'GF' means \"Galois Field\" which is a field that contains a finite\r",
							" * number of elements so GF(2^8) has 256 elements).\r",
							" *\r",
							" * This means that any two bytes can be represented as binary polynomials;\r",
							" * when they multiplied together and modularly reduced by an irreducible\r",
							" * polynomial of the 8th degree, the results are the field GF(2^8). The\r",
							" * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.\r",
							" * This multiplication is associative with 0x01 as the identity:\r",
							" *\r",
							" * (b * 0x01 = GF(b, 0x01) = b).\r",
							" *\r",
							" * The operation GF(b, 0x02) can be performed at the byte level by left\r",
							" * shifting b once and then XOR'ing it (to perform the modular reduction)\r",
							" * with 0x11b if b is >= 128. Repeated application of the multiplication\r",
							" * of 0x02 can be used to implement the multiplication of any two bytes.\r",
							" *\r",
							" * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can\r",
							" * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these\r",
							" * factors can each be multiplied by 0x57 and then added together. To do\r",
							" * the multiplication, values for 0x57 multiplied by each of these 3 factors\r",
							" * can be precomputed and stored in a table. To add them, the values from\r",
							" * the table are XOR'd together.\r",
							" *\r",
							" * AES also defines addition and multiplication of words, that is 4-byte\r",
							" * numbers represented as polynomials of 3 degrees where the coefficients\r",
							" * are the values of the bytes.\r",
							" *\r",
							" * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.\r",
							" *\r",
							" * Addition is performed by XOR'ing like powers of x. Multiplication\r",
							" * is performed in two steps, the first is an algebriac expansion as\r",
							" * you would do normally (where addition is XOR). But the result is\r",
							" * a polynomial larger than 3 degrees and thus it cannot fit in a word. So\r",
							" * next the result is modularly reduced by an AES-specific polynomial of\r",
							" * degree 4 which will always produce a polynomial of less than 4 degrees\r",
							" * such that it will fit in a word. In AES, this polynomial is x^4 + 1.\r",
							" *\r",
							" * The modular product of two polynomials 'a' and 'b' is thus:\r",
							" *\r",
							" * d(x) = d3x^3 + d2x^2 + d1x + d0\r",
							" * with\r",
							" * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)\r",
							" * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)\r",
							" * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)\r",
							" * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)\r",
							" *\r",
							" * As a matrix:\r",
							" *\r",
							" * [d0] = [a0 a3 a2 a1][b0]\r",
							" * [d1]   [a1 a0 a3 a2][b1]\r",
							" * [d2]   [a2 a1 a0 a3][b2]\r",
							" * [d3]   [a3 a2 a1 a0][b3]\r",
							" *\r",
							" * Special polynomials defined by AES (0x02 == {02}):\r",
							" * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}\r",
							" * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.\r",
							" *\r",
							" * These polynomials are used in the MixColumns() and InverseMixColumns()\r",
							" * operations, respectively, to cause each element in the state to affect\r",
							" * the output (referred to as diffusing).\r",
							" *\r",
							" * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the\r",
							" * polynomial x3.\r",
							" *\r",
							" * The ShiftRows() method modifies the last 3 rows in the state (where\r",
							" * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.\r",
							" * The 1st byte in the second row is moved to the end of the row. The 1st\r",
							" * and 2nd bytes in the third row are moved to the end of the row. The 1st,\r",
							" * 2nd, and 3rd bytes are moved in the fourth row.\r",
							" *\r",
							" * More details on how AES arithmetic works:\r",
							" *\r",
							" * In the polynomial representation of binary numbers, XOR performs addition\r",
							" * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)\r",
							" * corresponds with the multiplication of polynomials modulo an irreducible\r",
							" * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply\r",
							" * polynomial 'a' with polynomial 'b' and then do a modular reduction by\r",
							" * an AES-specific irreducible polynomial of degree 8.\r",
							" *\r",
							" * A polynomial is irreducible if its only divisors are one and itself. For\r",
							" * the AES algorithm, this irreducible polynomial is:\r",
							" *\r",
							" * m(x) = x^8 + x^4 + x^3 + x + 1,\r",
							" *\r",
							" * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:\r",
							" * 100011011 = 283 = 0x11b.\r",
							" *\r",
							" * For example, GF(0x57, 0x83) = 0xc1 because\r",
							" *\r",
							" * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1\r",
							" * 0x85 = 131 = 10000101 = x^7 + x + 1\r",
							" *\r",
							" * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)\r",
							" * =  x^13 + x^11 + x^9 + x^8 + x^7 +\r",
							" *    x^7 + x^5 + x^3 + x^2 + x +\r",
							" *    x^6 + x^4 + x^2 + x + 1\r",
							" * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y\r",
							" *    y modulo (x^8 + x^4 + x^3 + x + 1)\r",
							" * =  x^7 + x^6 + 1.\r",
							" *\r",
							" * The modular reduction by m(x) guarantees the result will be a binary\r",
							" * polynomial of less than degree 8, so that it can fit in a byte.\r",
							" *\r",
							" * The operation to multiply a binary polynomial b with x (the polynomial\r",
							" * x in binary representation is 00000010) is:\r",
							" *\r",
							" * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1\r",
							" *\r",
							" * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the\r",
							" * most significant bit is 0 in b) then the result is already reduced. If\r",
							" * it is 1, then we can reduce it by subtracting m(x) via an XOR.\r",
							" *\r",
							" * It follows that multiplication by x (00000010 or 0x02) can be implemented\r",
							" * by performing a left shift followed by a conditional bitwise XOR with\r",
							" * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by\r",
							" * higher powers of x can be implemented by repeated application of xtime().\r",
							" *\r",
							" * By adding intermediate results, multiplication by any constant can be\r",
							" * implemented. For instance:\r",
							" *\r",
							" * GF(0x57, 0x13) = 0xfe because:\r",
							" *\r",
							" * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)\r",
							" *\r",
							" * Note: We XOR with 0x11b instead of 0x1b because in javascript our\r",
							" * datatype for b can be larger than 1 byte, so a left shift will not\r",
							" * automatically eliminate bits that overflow a byte ... by XOR'ing the\r",
							" * overflow bit with 1 (the extra one from 0x11b) we zero it out.\r",
							" *\r",
							" * GF(0x57, 0x02) = xtime(0x57) = 0xae\r",
							" * GF(0x57, 0x04) = xtime(0xae) = 0x47\r",
							" * GF(0x57, 0x08) = xtime(0x47) = 0x8e\r",
							" * GF(0x57, 0x10) = xtime(0x8e) = 0x07\r",
							" *\r",
							" * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))\r",
							" *\r",
							" * And by the distributive property (since XOR is addition and GF() is\r",
							" * multiplication):\r",
							" *\r",
							" * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)\r",
							" * = 0x57 ^ 0xae ^ 0x07\r",
							" * = 0xfe.\r",
							" */\r",
							"function initialize() {\r",
							"  init = true;\r",
							"\r",
							"  /* Populate the Rcon table. These are the values given by\r",
							"    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)\r",
							"    in the field of GF(2^8), where i starts at 1.\r",
							"\r",
							"    rcon[0] = [0x00, 0x00, 0x00, 0x00]\r",
							"    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1\r",
							"    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2\r",
							"    ...\r",
							"    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B\r",
							"    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36\r",
							"\r",
							"    We only store the first byte because it is the only one used.\r",
							"  */\r",
							"  rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36];\r",
							"\r",
							"  // compute xtime table which maps i onto GF(i, 0x02)\r",
							"  var xtime = new Array(256);\r",
							"  for(var i = 0; i < 128; ++i) {\r",
							"    xtime[i] = i << 1;\r",
							"    xtime[i + 128] = (i + 128) << 1 ^ 0x11B;\r",
							"  }\r",
							"\r",
							"  // compute all other tables\r",
							"  sbox = new Array(256);\r",
							"  isbox = new Array(256);\r",
							"  mix = new Array(4);\r",
							"  imix = new Array(4);\r",
							"  for(var i = 0; i < 4; ++i) {\r",
							"    mix[i] = new Array(256);\r",
							"    imix[i] = new Array(256);\r",
							"  }\r",
							"  var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;\r",
							"  for(var i = 0; i < 256; ++i) {\r",
							"    /* We need to generate the SubBytes() sbox and isbox tables so that\r",
							"      we can perform byte substitutions. This requires us to traverse\r",
							"      all of the elements in GF, find their multiplicative inverses,\r",
							"      and apply to each the following affine transformation:\r",
							"\r",
							"      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^\r",
							"            b(i + 7) mod 8 ^ ci\r",
							"      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the\r",
							"      ith bit of a byte c with the value {63} or {01100011}.\r",
							"\r",
							"      It is possible to traverse every possible value in a Galois field\r",
							"      using what is referred to as a 'generator'. There are many\r",
							"      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully\r",
							"      traverse GF we iterate 255 times, multiplying by our generator\r",
							"      each time.\r",
							"\r",
							"      On each iteration we can determine the multiplicative inverse for\r",
							"      the current element.\r",
							"\r",
							"      Suppose there is an element in GF 'e'. For a given generator 'g',\r",
							"      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns\r",
							"      out that if use the inverse of a generator as another generator\r",
							"      it will produce all of the corresponding multiplicative inverses\r",
							"      at the same time. For this reason, we choose 5 as our inverse\r",
							"      generator because it only requires 2 multiplies and 1 add and its\r",
							"      inverse, 82, requires relatively few operations as well.\r",
							"\r",
							"      In order to apply the affine transformation, the multiplicative\r",
							"      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a\r",
							"      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and\r",
							"      'x'. Then 's' is left shifted and the high bit of 's' is made the\r",
							"      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd\r",
							"      with 's' and stored in 'x'. On each subsequent iteration the same\r",
							"      operation is performed. When 4 iterations are complete, 'x' is\r",
							"      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.\r",
							"      For example:\r",
							"\r",
							"      s = 01000001\r",
							"      x = 01000001\r",
							"\r",
							"      iteration 1: s = 10000010, x ^= s\r",
							"      iteration 2: s = 00000101, x ^= s\r",
							"      iteration 3: s = 00001010, x ^= s\r",
							"      iteration 4: s = 00010100, x ^= s\r",
							"      x ^= 0x63\r",
							"\r",
							"      This can be done with a loop where s = (s << 1) | (s >> 7). However,\r",
							"      it can also be done by using a single 16-bit (in this case 32-bit)\r",
							"      number 'sx'. Since XOR is an associative operation, we can set 'sx'\r",
							"      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.\r",
							"      The most significant bits will flow into the high 8 bit positions\r",
							"      and be correctly XOR'd with one another. All that remains will be\r",
							"      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits\r",
							"      afterwards.\r",
							"\r",
							"      At the same time we're populating sbox and isbox we can precompute\r",
							"      the multiplication we'll need to do to do MixColumns() later.\r",
							"    */\r",
							"\r",
							"    // apply affine transformation\r",
							"    sx = ei ^ (ei << 1) ^ (ei << 2) ^ (ei << 3) ^ (ei << 4);\r",
							"    sx = (sx >> 8) ^ (sx & 255) ^ 0x63;\r",
							"\r",
							"    // update tables\r",
							"    sbox[e] = sx;\r",
							"    isbox[sx] = e;\r",
							"\r",
							"    /* Mixing columns is done using matrix multiplication. The columns\r",
							"      that are to be mixed are each a single word in the current state.\r",
							"      The state has Nb columns (4 columns). Therefore each column is a\r",
							"      4 byte word. So to mix the columns in a single column 'c' where\r",
							"      its rows are r0, r1, r2, and r3, we use the following matrix\r",
							"      multiplication:\r",
							"\r",
							"      [2 3 1 1]*[r0,c]=[r'0,c]\r",
							"      [1 2 3 1] [r1,c] [r'1,c]\r",
							"      [1 1 2 3] [r2,c] [r'2,c]\r",
							"      [3 1 1 2] [r3,c] [r'3,c]\r",
							"\r",
							"      r0, r1, r2, and r3 are each 1 byte of one of the words in the\r",
							"      state (a column). To do matrix multiplication for each mixed\r",
							"      column c' we multiply the corresponding row from the left matrix\r",
							"      with the corresponding column from the right matrix. In total, we\r",
							"      get 4 equations:\r",
							"\r",
							"      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c\r",
							"      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c\r",
							"      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c\r",
							"      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c\r",
							"\r",
							"      As usual, the multiplication is as previously defined and the\r",
							"      addition is XOR. In order to optimize mixing columns we can store\r",
							"      the multiplication results in tables. If you think of the whole\r",
							"      column as a word (it might help to visualize by mentally rotating\r",
							"      the equations above by counterclockwise 90 degrees) then you can\r",
							"      see that it would be useful to map the multiplications performed on\r",
							"      each byte (r0, r1, r2, r3) onto a word as well. For instance, we\r",
							"      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the\r",
							"      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two\r",
							"      respectively in the middle). This means that a table can be\r",
							"      constructed that uses r0 as an index to the word. We can do the\r",
							"      same with r1, r2, and r3, creating a total of 4 tables.\r",
							"\r",
							"      To construct a full c', we can just look up each byte of c in\r",
							"      their respective tables and XOR the results together.\r",
							"\r",
							"      Also, to build each table we only have to calculate the word\r",
							"      for 2,1,1,3 for every byte ... which we can do on each iteration\r",
							"      of this loop since we will iterate over every byte. After we have\r",
							"      calculated 2,1,1,3 we can get the results for the other tables\r",
							"      by cycling the byte at the end to the beginning. For instance\r",
							"      we can take the result of table 2,1,1,3 and produce table 3,2,1,1\r",
							"      by moving the right most byte to the left most position just like\r",
							"      how you can imagine the 3 moved out of 2,1,1,3 and to the front\r",
							"      to produce 3,2,1,1.\r",
							"\r",
							"      There is another optimization in that the same multiples of\r",
							"      the current element we need in order to advance our generator\r",
							"      to the next iteration can be reused in performing the 2,1,1,3\r",
							"      calculation. We also calculate the inverse mix column tables,\r",
							"      with e,9,d,b being the inverse of 2,1,1,3.\r",
							"\r",
							"      When we're done, and we need to actually mix columns, the first\r",
							"      byte of each state word should be put through mix[0] (2,1,1,3),\r",
							"      the second through mix[1] (3,2,1,1) and so forth. Then they should\r",
							"      be XOR'd together to produce the fully mixed column.\r",
							"    */\r",
							"\r",
							"    // calculate mix and imix table values\r",
							"    sx2 = xtime[sx];\r",
							"    e2 = xtime[e];\r",
							"    e4 = xtime[e2];\r",
							"    e8 = xtime[e4];\r",
							"    me =\r",
							"      (sx2 << 24) ^  // 2\r",
							"      (sx << 16) ^   // 1\r",
							"      (sx << 8) ^    // 1\r",
							"      (sx ^ sx2);    // 3\r",
							"    ime =\r",
							"      (e2 ^ e4 ^ e8) << 24 ^  // E (14)\r",
							"      (e ^ e8) << 16 ^        // 9\r",
							"      (e ^ e4 ^ e8) << 8 ^    // D (13)\r",
							"      (e ^ e2 ^ e8);          // B (11)\r",
							"    // produce each of the mix tables by rotating the 2,1,1,3 value\r",
							"    for(var n = 0; n < 4; ++n) {\r",
							"      mix[n][e] = me;\r",
							"      imix[n][sx] = ime;\r",
							"      // cycle the right most byte to the left most position\r",
							"      // ie: 2,1,1,3 becomes 3,2,1,1\r",
							"      me = me << 24 | me >>> 8;\r",
							"      ime = ime << 24 | ime >>> 8;\r",
							"    }\r",
							"\r",
							"    // get next element and inverse\r",
							"    if(e === 0) {\r",
							"      // 1 is the inverse of 1\r",
							"      e = ei = 1;\r",
							"    } else {\r",
							"      // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)\r",
							"      // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)\r",
							"      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];\r",
							"      ei ^= xtime[xtime[ei]];\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Generates a key schedule using the AES key expansion algorithm.\r",
							" *\r",
							" * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion\r",
							" * routine to generate a key schedule. The Key Expansion generates a total\r",
							" * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,\r",
							" * and each of the Nr rounds requires Nb words of key data. The resulting\r",
							" * key schedule consists of a linear array of 4-byte words, denoted [wi ],\r",
							" * with i in the range 0  i < Nb(Nr + 1).\r",
							" *\r",
							" * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)\r",
							" * AES-128 (Nb=4, Nk=4, Nr=10)\r",
							" * AES-192 (Nb=4, Nk=6, Nr=12)\r",
							" * AES-256 (Nb=4, Nk=8, Nr=14)\r",
							" * Note: Nr=Nk+6.\r",
							" *\r",
							" * Nb is the number of columns (32-bit words) comprising the State (or\r",
							" * number of bytes in a block). For AES, Nb=4.\r",
							" *\r",
							" * @param key the key to schedule (as an array of 32-bit words).\r",
							" * @param decrypt true to modify the key schedule to decrypt, false not to.\r",
							" *\r",
							" * @return the generated key schedule.\r",
							" */\r",
							"function _expandKey(key, decrypt) {\r",
							"  // copy the key's words to initialize the key schedule\r",
							"  var w = key.slice(0);\r",
							"\r",
							"  /* RotWord() will rotate a word, moving the first byte to the last\r",
							"    byte's position (shifting the other bytes left).\r",
							"\r",
							"    We will be getting the value of Rcon at i / Nk. 'i' will iterate\r",
							"    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in\r",
							"    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from\r",
							"    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will\r",
							"    increase by 1. We use a counter iNk to keep track of this.\r",
							"   */\r",
							"\r",
							"  // go through the rounds expanding the key\r",
							"  var temp, iNk = 1;\r",
							"  var Nk = w.length;\r",
							"  var Nr1 = Nk + 6 + 1;\r",
							"  var end = Nb * Nr1;\r",
							"  for(var i = Nk; i < end; ++i) {\r",
							"    temp = w[i - 1];\r",
							"    if(i % Nk === 0) {\r",
							"      // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]\r",
							"      temp =\r",
							"        sbox[temp >>> 16 & 255] << 24 ^\r",
							"        sbox[temp >>> 8 & 255] << 16 ^\r",
							"        sbox[temp & 255] << 8 ^\r",
							"        sbox[temp >>> 24] ^ (rcon[iNk] << 24);\r",
							"      iNk++;\r",
							"    } else if(Nk > 6 && (i % Nk === 4)) {\r",
							"      // temp = SubWord(temp)\r",
							"      temp =\r",
							"        sbox[temp >>> 24] << 24 ^\r",
							"        sbox[temp >>> 16 & 255] << 16 ^\r",
							"        sbox[temp >>> 8 & 255] << 8 ^\r",
							"        sbox[temp & 255];\r",
							"    }\r",
							"    w[i] = w[i - Nk] ^ temp;\r",
							"  }\r",
							"\r",
							"   /* When we are updating a cipher block we always use the code path for\r",
							"     encryption whether we are decrypting or not (to shorten code and\r",
							"     simplify the generation of look up tables). However, because there\r",
							"     are differences in the decryption algorithm, other than just swapping\r",
							"     in different look up tables, we must transform our key schedule to\r",
							"     account for these changes:\r",
							"\r",
							"     1. The decryption algorithm gets its key rounds in reverse order.\r",
							"     2. The decryption algorithm adds the round key before mixing columns\r",
							"       instead of afterwards.\r",
							"\r",
							"     We don't need to modify our key schedule to handle the first case,\r",
							"     we can just traverse the key schedule in reverse order when decrypting.\r",
							"\r",
							"     The second case requires a little work.\r",
							"\r",
							"     The tables we built for performing rounds will take an input and then\r",
							"     perform SubBytes() and MixColumns() or, for the decrypt version,\r",
							"     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires\r",
							"     us to AddRoundKey() before InvMixColumns(). This means we'll need to\r",
							"     apply some transformations to the round key to inverse-mix its columns\r",
							"     so they'll be correct for moving AddRoundKey() to after the state has\r",
							"     had its columns inverse-mixed.\r",
							"\r",
							"     To inverse-mix the columns of the state when we're decrypting we use a\r",
							"     lookup table that will apply InvSubBytes() and InvMixColumns() at the\r",
							"     same time. However, the round key's bytes are not inverse-substituted\r",
							"     in the decryption algorithm. To get around this problem, we can first\r",
							"     substitute the bytes in the round key so that when we apply the\r",
							"     transformation via the InvSubBytes()+InvMixColumns() table, it will\r",
							"     undo our substitution leaving us with the original value that we\r",
							"     want -- and then inverse-mix that value.\r",
							"\r",
							"     This change will correctly alter our key schedule so that we can XOR\r",
							"     each round key with our already transformed decryption state. This\r",
							"     allows us to use the same code path as the encryption algorithm.\r",
							"\r",
							"     We make one more change to the decryption key. Since the decryption\r",
							"     algorithm runs in reverse from the encryption algorithm, we reverse\r",
							"     the order of the round keys to avoid having to iterate over the key\r",
							"     schedule backwards when running the encryption algorithm later in\r",
							"     decryption mode. In addition to reversing the order of the round keys,\r",
							"     we also swap each round key's 2nd and 4th rows. See the comments\r",
							"     section where rounds are performed for more details about why this is\r",
							"     done. These changes are done inline with the other substitution\r",
							"     described above.\r",
							"  */\r",
							"  if(decrypt) {\r",
							"    var tmp;\r",
							"    var m0 = imix[0];\r",
							"    var m1 = imix[1];\r",
							"    var m2 = imix[2];\r",
							"    var m3 = imix[3];\r",
							"    var wnew = w.slice(0);\r",
							"    end = w.length;\r",
							"    for(var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {\r",
							"      // do not sub the first or last round key (round keys are Nb\r",
							"      // words) as no column mixing is performed before they are added,\r",
							"      // but do change the key order\r",
							"      if(i === 0 || i === (end - Nb)) {\r",
							"        wnew[i] = w[wi];\r",
							"        wnew[i + 1] = w[wi + 3];\r",
							"        wnew[i + 2] = w[wi + 2];\r",
							"        wnew[i + 3] = w[wi + 1];\r",
							"      } else {\r",
							"        // substitute each round key byte because the inverse-mix\r",
							"        // table will inverse-substitute it (effectively cancel the\r",
							"        // substitution because round key bytes aren't sub'd in\r",
							"        // decryption mode) and swap indexes 3 and 1\r",
							"        for(var n = 0; n < Nb; ++n) {\r",
							"          tmp = w[wi + n];\r",
							"          wnew[i + (3&-n)] =\r",
							"            m0[sbox[tmp >>> 24]] ^\r",
							"            m1[sbox[tmp >>> 16 & 255]] ^\r",
							"            m2[sbox[tmp >>> 8 & 255]] ^\r",
							"            m3[sbox[tmp & 255]];\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    w = wnew;\r",
							"  }\r",
							"\r",
							"  return w;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a single block (16 bytes) using AES. The update will either\r",
							" * encrypt or decrypt the block.\r",
							" *\r",
							" * @param w the key schedule.\r",
							" * @param input the input block (an array of 32-bit words).\r",
							" * @param output the updated output block.\r",
							" * @param decrypt true to decrypt the block, false to encrypt it.\r",
							" */\r",
							"function _updateBlock(w, input, output, decrypt) {\r",
							"  /*\r",
							"  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\r",
							"  begin\r",
							"    byte state[4,Nb]\r",
							"    state = in\r",
							"    AddRoundKey(state, w[0, Nb-1])\r",
							"    for round = 1 step 1 to Nr1\r",
							"      SubBytes(state)\r",
							"      ShiftRows(state)\r",
							"      MixColumns(state)\r",
							"      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r",
							"    end for\r",
							"    SubBytes(state)\r",
							"    ShiftRows(state)\r",
							"    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"    out = state\r",
							"  end\r",
							"\r",
							"  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\r",
							"  begin\r",
							"    byte state[4,Nb]\r",
							"    state = in\r",
							"    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"    for round = Nr-1 step -1 downto 1\r",
							"      InvShiftRows(state)\r",
							"      InvSubBytes(state)\r",
							"      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r",
							"      InvMixColumns(state)\r",
							"    end for\r",
							"    InvShiftRows(state)\r",
							"    InvSubBytes(state)\r",
							"    AddRoundKey(state, w[0, Nb-1])\r",
							"    out = state\r",
							"  end\r",
							"  */\r",
							"\r",
							"  // Encrypt: AddRoundKey(state, w[0, Nb-1])\r",
							"  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"  var Nr = w.length / 4 - 1;\r",
							"  var m0, m1, m2, m3, sub;\r",
							"  if(decrypt) {\r",
							"    m0 = imix[0];\r",
							"    m1 = imix[1];\r",
							"    m2 = imix[2];\r",
							"    m3 = imix[3];\r",
							"    sub = isbox;\r",
							"  } else {\r",
							"    m0 = mix[0];\r",
							"    m1 = mix[1];\r",
							"    m2 = mix[2];\r",
							"    m3 = mix[3];\r",
							"    sub = sbox;\r",
							"  }\r",
							"  var a, b, c, d, a2, b2, c2;\r",
							"  a = input[0] ^ w[0];\r",
							"  b = input[decrypt ? 3 : 1] ^ w[1];\r",
							"  c = input[2] ^ w[2];\r",
							"  d = input[decrypt ? 1 : 3] ^ w[3];\r",
							"  var i = 3;\r",
							"\r",
							"  /* In order to share code we follow the encryption algorithm when both\r",
							"    encrypting and decrypting. To account for the changes required in the\r",
							"    decryption algorithm, we use different lookup tables when decrypting\r",
							"    and use a modified key schedule to account for the difference in the\r",
							"    order of transformations applied when performing rounds. We also get\r",
							"    key rounds in reverse order (relative to encryption). */\r",
							"  for(var round = 1; round < Nr; ++round) {\r",
							"    /* As described above, we'll be using table lookups to perform the\r",
							"      column mixing. Each column is stored as a word in the state (the\r",
							"      array 'input' has one column as a word at each index). In order to\r",
							"      mix a column, we perform these transformations on each row in c,\r",
							"      which is 1 byte in each word. The new column for c0 is c'0:\r",
							"\r",
							"               m0      m1      m2      m3\r",
							"      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0\r",
							"      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0\r",
							"      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0\r",
							"      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0\r",
							"\r",
							"      So using mix tables where c0 is a word with r0 being its upper\r",
							"      8 bits and r3 being its lower 8 bits:\r",
							"\r",
							"      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]\r",
							"      ...\r",
							"      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]\r",
							"\r",
							"      Therefore to mix the columns in each word in the state we\r",
							"      do the following (& 255 omitted for brevity):\r",
							"      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"\r",
							"      However, before mixing, the algorithm requires us to perform\r",
							"      ShiftRows(). The ShiftRows() transformation cyclically shifts the\r",
							"      last 3 rows of the state over different offsets. The first row\r",
							"      (r = 0) is not shifted.\r",
							"\r",
							"      s'_r,c = s_r,(c + shift(r, Nb) mod Nb\r",
							"      for 0 < r < 4 and 0 <= c < Nb and\r",
							"      shift(1, 4) = 1\r",
							"      shift(2, 4) = 2\r",
							"      shift(3, 4) = 3.\r",
							"\r",
							"      This causes the first byte in r = 1 to be moved to the end of\r",
							"      the row, the first 2 bytes in r = 2 to be moved to the end of\r",
							"      the row, the first 3 bytes in r = 3 to be moved to the end of\r",
							"      the row:\r",
							"\r",
							"      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]\r",
							"      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]\r",
							"      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]\r",
							"\r",
							"      We can make these substitutions inline with our column mixing to\r",
							"      generate an updated set of equations to produce each word in the\r",
							"      state (note the columns have changed positions):\r",
							"\r",
							"      c0 c1 c2 c3 => c0 c1 c2 c3\r",
							"      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)\r",
							"      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)\r",
							"      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)\r",
							"\r",
							"      Therefore:\r",
							"\r",
							"      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3\r",
							"      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3\r",
							"      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3\r",
							"      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3\r",
							"\r",
							"      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0\r",
							"      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0\r",
							"      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0\r",
							"      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0\r",
							"\r",
							"      ... and so forth for c'2 and c'3. The important distinction is\r",
							"      that the columns are cycling, with c0 being used with the m0\r",
							"      map when calculating c0, but c1 being used with the m0 map when\r",
							"      calculating c1 ... and so forth.\r",
							"\r",
							"      When performing the inverse we transform the mirror image and\r",
							"      skip the bottom row, instead of the top one, and move upwards:\r",
							"\r",
							"      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption\r",
							"      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)\r",
							"      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption\r",
							"      c3 c2 c1 c0    c3 c2 c1 c0\r",
							"\r",
							"      If you compare the resulting matrices for ShiftRows()+MixColumns()\r",
							"      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are\r",
							"      different (in encrypt mode vs. decrypt mode). So in order to use\r",
							"      the same code to handle both encryption and decryption, we will\r",
							"      need to do some mapping.\r",
							"\r",
							"      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be\r",
							"      a row number in the state, then the resulting matrix in encryption\r",
							"      mode for applying the above transformations would be:\r",
							"\r",
							"      r1: a b c d\r",
							"      r2: b c d a\r",
							"      r3: c d a b\r",
							"      r4: d a b c\r",
							"\r",
							"      If we did the same in decryption mode we would get:\r",
							"\r",
							"      r1: a d c b\r",
							"      r2: b a d c\r",
							"      r3: c b a d\r",
							"      r4: d c b a\r",
							"\r",
							"      If instead we swap d and b (set b=c3 and d=c1), then we get:\r",
							"\r",
							"      r1: a b c d\r",
							"      r2: d a b c\r",
							"      r3: c d a b\r",
							"      r4: b c d a\r",
							"\r",
							"      Now the 1st and 3rd rows are the same as the encryption matrix. All\r",
							"      we need to do then to make the mapping exactly the same is to swap\r",
							"      the 2nd and 4th rows when in decryption mode. To do this without\r",
							"      having to do it on each iteration, we swapped the 2nd and 4th rows\r",
							"      in the decryption key schedule. We also have to do the swap above\r",
							"      when we first pull in the input and when we set the final output. */\r",
							"    a2 =\r",
							"      m0[a >>> 24] ^\r",
							"      m1[b >>> 16 & 255] ^\r",
							"      m2[c >>> 8 & 255] ^\r",
							"      m3[d & 255] ^ w[++i];\r",
							"    b2 =\r",
							"      m0[b >>> 24] ^\r",
							"      m1[c >>> 16 & 255] ^\r",
							"      m2[d >>> 8 & 255] ^\r",
							"      m3[a & 255] ^ w[++i];\r",
							"    c2 =\r",
							"      m0[c >>> 24] ^\r",
							"      m1[d >>> 16 & 255] ^\r",
							"      m2[a >>> 8 & 255] ^\r",
							"      m3[b & 255] ^ w[++i];\r",
							"    d =\r",
							"      m0[d >>> 24] ^\r",
							"      m1[a >>> 16 & 255] ^\r",
							"      m2[b >>> 8 & 255] ^\r",
							"      m3[c & 255] ^ w[++i];\r",
							"    a = a2;\r",
							"    b = b2;\r",
							"    c = c2;\r",
							"  }\r",
							"\r",
							"  /*\r",
							"    Encrypt:\r",
							"    SubBytes(state)\r",
							"    ShiftRows(state)\r",
							"    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"\r",
							"    Decrypt:\r",
							"    InvShiftRows(state)\r",
							"    InvSubBytes(state)\r",
							"    AddRoundKey(state, w[0, Nb-1])\r",
							"   */\r",
							"   // Note: rows are shifted inline\r",
							"  output[0] =\r",
							"    (sub[a >>> 24] << 24) ^\r",
							"    (sub[b >>> 16 & 255] << 16) ^\r",
							"    (sub[c >>> 8 & 255] << 8) ^\r",
							"    (sub[d & 255]) ^ w[++i];\r",
							"  output[decrypt ? 3 : 1] =\r",
							"    (sub[b >>> 24] << 24) ^\r",
							"    (sub[c >>> 16 & 255] << 16) ^\r",
							"    (sub[d >>> 8 & 255] << 8) ^\r",
							"    (sub[a & 255]) ^ w[++i];\r",
							"  output[2] =\r",
							"    (sub[c >>> 24] << 24) ^\r",
							"    (sub[d >>> 16 & 255] << 16) ^\r",
							"    (sub[a >>> 8 & 255] << 8) ^\r",
							"    (sub[b & 255]) ^ w[++i];\r",
							"  output[decrypt ? 1 : 3] =\r",
							"    (sub[d >>> 24] << 24) ^\r",
							"    (sub[a >>> 16 & 255] << 16) ^\r",
							"    (sub[b >>> 8 & 255] << 8) ^\r",
							"    (sub[c & 255]) ^ w[++i];\r",
							"}\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * forge.cipher.createCipher('AES-<mode>', key);\r",
							" * forge.cipher.createDecipher('AES-<mode>', key);\r",
							" *\r",
							" * Creates a deprecated AES cipher object. This object's mode will default to\r",
							" * CBC (cipher-block-chaining).\r",
							" *\r",
							" * The key and iv may be given as a string of bytes, an array of bytes, a\r",
							" * byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the symmetric key to use.\r",
							" *          output the buffer to write to.\r",
							" *          decrypt true for decryption, false for encryption.\r",
							" *          mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"function _createCipher(options) {\r",
							"  options = options || {};\r",
							"  var mode = (options.mode || 'CBC').toUpperCase();\r",
							"  var algorithm = 'AES-' + mode;\r",
							"\r",
							"  var cipher;\r",
							"  if(options.decrypt) {\r",
							"    cipher = forge.cipher.createDecipher(algorithm, options.key);\r",
							"  } else {\r",
							"    cipher = forge.cipher.createCipher(algorithm, options.key);\r",
							"  }\r",
							"\r",
							"  // backwards compatible start API\r",
							"  var start = cipher.start;\r",
							"  cipher.start = function(iv, options) {\r",
							"    // backwards compatibility: support second arg as output buffer\r",
							"    var output = null;\r",
							"    if(options instanceof forge.util.ByteBuffer) {\r",
							"      output = options;\r",
							"      options = {};\r",
							"    }\r",
							"    options = options || {};\r",
							"    options.output = output;\r",
							"    options.iv = iv;\r",
							"    start.call(cipher, options);\r",
							"  };\r",
							"\r",
							"  return cipher;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 6 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Object IDs for ASN.1.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"forge.pki = forge.pki || {};\r",
							"var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};\r",
							"\r",
							"// set id to name mapping and name to id mapping\r",
							"function _IN(id, name) {\r",
							"  oids[id] = name;\r",
							"  oids[name] = id;\r",
							"}\r",
							"// set id to name mapping only\r",
							"function _I_(id, name) {\r",
							"  oids[id] = name;\r",
							"}\r",
							"\r",
							"// algorithm OIDs\r",
							"_IN('1.2.840.113549.1.1.1', 'rsaEncryption');\r",
							"// Note: md2 & md4 not implemented\r",
							"//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');\r",
							"//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.4', 'md5WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.7', 'RSAES-OAEP');\r",
							"_IN('1.2.840.113549.1.1.8', 'mgf1');\r",
							"_IN('1.2.840.113549.1.1.9', 'pSpecified');\r",
							"_IN('1.2.840.113549.1.1.10', 'RSASSA-PSS');\r",
							"_IN('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption');\r",
							"\r",
							"_IN('1.2.840.10040.4.3', 'dsa-with-sha1');\r",
							"\r",
							"_IN('1.3.14.3.2.7', 'desCBC');\r",
							"\r",
							"_IN('1.3.14.3.2.26', 'sha1');\r",
							"_IN('2.16.840.1.101.3.4.2.1', 'sha256');\r",
							"_IN('2.16.840.1.101.3.4.2.2', 'sha384');\r",
							"_IN('2.16.840.1.101.3.4.2.3', 'sha512');\r",
							"_IN('1.2.840.113549.2.5', 'md5');\r",
							"\r",
							"// pkcs#7 content types\r",
							"_IN('1.2.840.113549.1.7.1', 'data');\r",
							"_IN('1.2.840.113549.1.7.2', 'signedData');\r",
							"_IN('1.2.840.113549.1.7.3', 'envelopedData');\r",
							"_IN('1.2.840.113549.1.7.4', 'signedAndEnvelopedData');\r",
							"_IN('1.2.840.113549.1.7.5', 'digestedData');\r",
							"_IN('1.2.840.113549.1.7.6', 'encryptedData');\r",
							"\r",
							"// pkcs#9 oids\r",
							"_IN('1.2.840.113549.1.9.1', 'emailAddress');\r",
							"_IN('1.2.840.113549.1.9.2', 'unstructuredName');\r",
							"_IN('1.2.840.113549.1.9.3', 'contentType');\r",
							"_IN('1.2.840.113549.1.9.4', 'messageDigest');\r",
							"_IN('1.2.840.113549.1.9.5', 'signingTime');\r",
							"_IN('1.2.840.113549.1.9.6', 'counterSignature');\r",
							"_IN('1.2.840.113549.1.9.7', 'challengePassword');\r",
							"_IN('1.2.840.113549.1.9.8', 'unstructuredAddress');\r",
							"_IN('1.2.840.113549.1.9.14', 'extensionRequest');\r",
							"\r",
							"_IN('1.2.840.113549.1.9.20', 'friendlyName');\r",
							"_IN('1.2.840.113549.1.9.21', 'localKeyId');\r",
							"_IN('1.2.840.113549.1.9.22.1', 'x509Certificate');\r",
							"\r",
							"// pkcs#12 safe bags\r",
							"_IN('1.2.840.113549.1.12.10.1.1', 'keyBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.3', 'certBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.4', 'crlBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.5', 'secretBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.6', 'safeContentsBag');\r",
							"\r",
							"// password-based-encryption for pkcs#12\r",
							"_IN('1.2.840.113549.1.5.13', 'pkcs5PBES2');\r",
							"_IN('1.2.840.113549.1.5.12', 'pkcs5PBKDF2');\r",
							"\r",
							"_IN('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4');\r",
							"_IN('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4');\r",
							"_IN('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC');\r",
							"_IN('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC');\r",
							"_IN('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC');\r",
							"_IN('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC');\r",
							"\r",
							"// hmac OIDs\r",
							"_IN('1.2.840.113549.2.7', 'hmacWithSHA1');\r",
							"_IN('1.2.840.113549.2.8', 'hmacWithSHA224');\r",
							"_IN('1.2.840.113549.2.9', 'hmacWithSHA256');\r",
							"_IN('1.2.840.113549.2.10', 'hmacWithSHA384');\r",
							"_IN('1.2.840.113549.2.11', 'hmacWithSHA512');\r",
							"\r",
							"// symmetric key algorithm oids\r",
							"_IN('1.2.840.113549.3.7', 'des-EDE3-CBC');\r",
							"_IN('2.16.840.1.101.3.4.1.2', 'aes128-CBC');\r",
							"_IN('2.16.840.1.101.3.4.1.22', 'aes192-CBC');\r",
							"_IN('2.16.840.1.101.3.4.1.42', 'aes256-CBC');\r",
							"\r",
							"// certificate issuer/subject OIDs\r",
							"_IN('2.5.4.3', 'commonName');\r",
							"_IN('2.5.4.5', 'serialName');\r",
							"_IN('2.5.4.6', 'countryName');\r",
							"_IN('2.5.4.7', 'localityName');\r",
							"_IN('2.5.4.8', 'stateOrProvinceName');\r",
							"_IN('2.5.4.10', 'organizationName');\r",
							"_IN('2.5.4.11', 'organizationalUnitName');\r",
							"\r",
							"// X.509 extension OIDs\r",
							"_IN('2.16.840.1.113730.1.1', 'nsCertType');\r",
							"_I_('2.5.29.1', 'authorityKeyIdentifier'); // deprecated, use .35\r",
							"_I_('2.5.29.2', 'keyAttributes'); // obsolete use .37 or .15\r",
							"_I_('2.5.29.3', 'certificatePolicies'); // deprecated, use .32\r",
							"_I_('2.5.29.4', 'keyUsageRestriction'); // obsolete use .37 or .15\r",
							"_I_('2.5.29.5', 'policyMapping'); // deprecated use .33\r",
							"_I_('2.5.29.6', 'subtreesConstraint'); // obsolete use .30\r",
							"_I_('2.5.29.7', 'subjectAltName'); // deprecated use .17\r",
							"_I_('2.5.29.8', 'issuerAltName'); // deprecated use .18\r",
							"_I_('2.5.29.9', 'subjectDirectoryAttributes');\r",
							"_I_('2.5.29.10', 'basicConstraints'); // deprecated use .19\r",
							"_I_('2.5.29.11', 'nameConstraints'); // deprecated use .30\r",
							"_I_('2.5.29.12', 'policyConstraints'); // deprecated use .36\r",
							"_I_('2.5.29.13', 'basicConstraints'); // deprecated use .19\r",
							"_IN('2.5.29.14', 'subjectKeyIdentifier');\r",
							"_IN('2.5.29.15', 'keyUsage');\r",
							"_I_('2.5.29.16', 'privateKeyUsagePeriod');\r",
							"_IN('2.5.29.17', 'subjectAltName');\r",
							"_IN('2.5.29.18', 'issuerAltName');\r",
							"_IN('2.5.29.19', 'basicConstraints');\r",
							"_I_('2.5.29.20', 'cRLNumber');\r",
							"_I_('2.5.29.21', 'cRLReason');\r",
							"_I_('2.5.29.22', 'expirationDate');\r",
							"_I_('2.5.29.23', 'instructionCode');\r",
							"_I_('2.5.29.24', 'invalidityDate');\r",
							"_I_('2.5.29.25', 'cRLDistributionPoints'); // deprecated use .31\r",
							"_I_('2.5.29.26', 'issuingDistributionPoint'); // deprecated use .28\r",
							"_I_('2.5.29.27', 'deltaCRLIndicator');\r",
							"_I_('2.5.29.28', 'issuingDistributionPoint');\r",
							"_I_('2.5.29.29', 'certificateIssuer');\r",
							"_I_('2.5.29.30', 'nameConstraints');\r",
							"_IN('2.5.29.31', 'cRLDistributionPoints');\r",
							"_IN('2.5.29.32', 'certificatePolicies');\r",
							"_I_('2.5.29.33', 'policyMappings');\r",
							"_I_('2.5.29.34', 'policyConstraints'); // deprecated use .36\r",
							"_IN('2.5.29.35', 'authorityKeyIdentifier');\r",
							"_I_('2.5.29.36', 'policyConstraints');\r",
							"_IN('2.5.29.37', 'extKeyUsage');\r",
							"_I_('2.5.29.46', 'freshestCRL');\r",
							"_I_('2.5.29.54', 'inhibitAnyPolicy');\r",
							"\r",
							"// extKeyUsage purposes\r",
							"_IN('1.3.6.1.4.1.11129.2.4.2', 'timestampList');\r",
							"_IN('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess');\r",
							"_IN('1.3.6.1.5.5.7.3.1', 'serverAuth');\r",
							"_IN('1.3.6.1.5.5.7.3.2', 'clientAuth');\r",
							"_IN('1.3.6.1.5.5.7.3.3', 'codeSigning');\r",
							"_IN('1.3.6.1.5.5.7.3.4', 'emailProtection');\r",
							"_IN('1.3.6.1.5.5.7.3.8', 'timeStamping');\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 7 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\r",
							" *\r",
							" * See: RFC 1421.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2013-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * A Forge PEM object has the following fields:\r",
							" *\r",
							" * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\r",
							" *\r",
							" * procType: identifies the type of processing performed on the message,\r",
							" *   it has two subfields: version and type, eg: 4,ENCRYPTED.\r",
							" *\r",
							" * contentDomain: identifies the type of content in the message, typically\r",
							" *   only uses the value: \"RFC822\".\r",
							" *\r",
							" * dekInfo: identifies the message encryption algorithm and mode and includes\r",
							" *   any parameters for the algorithm, it has two subfields: algorithm and\r",
							" *   parameters, eg: DES-CBC,F8143EDE5960C597.\r",
							" *\r",
							" * headers: contains all other PEM encapsulated headers -- where order is\r",
							" *   significant (for pairing data like recipient ID + key info).\r",
							" *\r",
							" * body: the binary-encoded body.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for pem API\r",
							"var pem = module.exports = forge.pem = forge.pem || {};\r",
							"\r",
							"/**\r",
							" * Encodes (serializes) the given PEM object.\r",
							" *\r",
							" * @param msg the PEM message object to encode.\r",
							" * @param options the options to use:\r",
							" *          maxline the maximum characters per line for the body, (default: 64).\r",
							" *\r",
							" * @return the PEM-formatted string.\r",
							" */\r",
							"pem.encode = function(msg, options) {\r",
							"  options = options || {};\r",
							"  var rval = '-----BEGIN ' + msg.type + '-----\\r\\n';\r",
							"\r",
							"  // encode special headers\r",
							"  var header;\r",
							"  if(msg.procType) {\r",
							"    header = {\r",
							"      name: 'Proc-Type',\r",
							"      values: [String(msg.procType.version), msg.procType.type]\r",
							"    };\r",
							"    rval += foldHeader(header);\r",
							"  }\r",
							"  if(msg.contentDomain) {\r",
							"    header = {name: 'Content-Domain', values: [msg.contentDomain]};\r",
							"    rval += foldHeader(header);\r",
							"  }\r",
							"  if(msg.dekInfo) {\r",
							"    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};\r",
							"    if(msg.dekInfo.parameters) {\r",
							"      header.values.push(msg.dekInfo.parameters);\r",
							"    }\r",
							"    rval += foldHeader(header);\r",
							"  }\r",
							"\r",
							"  if(msg.headers) {\r",
							"    // encode all other headers\r",
							"    for(var i = 0; i < msg.headers.length; ++i) {\r",
							"      rval += foldHeader(msg.headers[i]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // terminate header\r",
							"  if(msg.procType) {\r",
							"    rval += '\\r\\n';\r",
							"  }\r",
							"\r",
							"  // add body\r",
							"  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\\r\\n';\r",
							"\r",
							"  rval += '-----END ' + msg.type + '-----\\r\\n';\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes (deserializes) all PEM messages found in the given string.\r",
							" *\r",
							" * @param str the PEM-formatted string to decode.\r",
							" *\r",
							" * @return the PEM message objects in an array.\r",
							" */\r",
							"pem.decode = function(str) {\r",
							"  var rval = [];\r",
							"\r",
							"  // split string into PEM messages (be lenient w/EOF on BEGIN line)\r",
							"  var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\r",
							"  var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\r",
							"  var rCRLF = /\\r?\\n/;\r",
							"  var match;\r",
							"  while(true) {\r",
							"    match = rMessage.exec(str);\r",
							"    if(!match) {\r",
							"      break;\r",
							"    }\r",
							"\r",
							"    var msg = {\r",
							"      type: match[1],\r",
							"      procType: null,\r",
							"      contentDomain: null,\r",
							"      dekInfo: null,\r",
							"      headers: [],\r",
							"      body: forge.util.decode64(match[3])\r",
							"    };\r",
							"    rval.push(msg);\r",
							"\r",
							"    // no headers\r",
							"    if(!match[2]) {\r",
							"      continue;\r",
							"    }\r",
							"\r",
							"    // parse headers\r",
							"    var lines = match[2].split(rCRLF);\r",
							"    var li = 0;\r",
							"    while(match && li < lines.length) {\r",
							"      // get line, trim any rhs whitespace\r",
							"      var line = lines[li].replace(/\\s+$/, '');\r",
							"\r",
							"      // RFC2822 unfold any following folded lines\r",
							"      for(var nl = li + 1; nl < lines.length; ++nl) {\r",
							"        var next = lines[nl];\r",
							"        if(!/\\s/.test(next[0])) {\r",
							"          break;\r",
							"        }\r",
							"        line += next;\r",
							"        li = nl;\r",
							"      }\r",
							"\r",
							"      // parse header\r",
							"      match = line.match(rHeader);\r",
							"      if(match) {\r",
							"        var header = {name: match[1], values: []};\r",
							"        var values = match[2].split(',');\r",
							"        for(var vi = 0; vi < values.length; ++vi) {\r",
							"          header.values.push(ltrim(values[vi]));\r",
							"        }\r",
							"\r",
							"        // Proc-Type must be the first header\r",
							"        if(!msg.procType) {\r",
							"          if(header.name !== 'Proc-Type') {\r",
							"            throw new Error('Invalid PEM formatted message. The first ' +\r",
							"              'encapsulated header must be \"Proc-Type\".');\r",
							"          } else if(header.values.length !== 2) {\r",
							"            throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' +\r",
							"              'header must have two subfields.');\r",
							"          }\r",
							"          msg.procType = {version: values[0], type: values[1]};\r",
							"        } else if(!msg.contentDomain && header.name === 'Content-Domain') {\r",
							"          // special-case Content-Domain\r",
							"          msg.contentDomain = values[0] || '';\r",
							"        } else if(!msg.dekInfo && header.name === 'DEK-Info') {\r",
							"          // special-case DEK-Info\r",
							"          if(header.values.length === 0) {\r",
							"            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\r",
							"              'header must have at least one subfield.');\r",
							"          }\r",
							"          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};\r",
							"        } else {\r",
							"          msg.headers.push(header);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      ++li;\r",
							"    }\r",
							"\r",
							"    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {\r",
							"      throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\r",
							"        'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(rval.length === 0) {\r",
							"    throw new Error('Invalid PEM formatted message.');\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"function foldHeader(header) {\r",
							"  var rval = header.name + ': ';\r",
							"\r",
							"  // ensure values with CRLF are folded\r",
							"  var values = [];\r",
							"  var insertSpace = function(match, $1) {\r",
							"    return ' ' + $1;\r",
							"  };\r",
							"  for(var i = 0; i < header.values.length; ++i) {\r",
							"    values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\r",
							"  }\r",
							"  rval += values.join(',') + '\\r\\n';\r",
							"\r",
							"  // do folding\r",
							"  var length = 0;\r",
							"  var candidate = -1;\r",
							"  for(var i = 0; i < rval.length; ++i, ++length) {\r",
							"    if(length > 65 && candidate !== -1) {\r",
							"      var insert = rval[candidate];\r",
							"      if(insert === ',') {\r",
							"        ++candidate;\r",
							"        rval = rval.substr(0, candidate) + '\\r\\n ' + rval.substr(candidate);\r",
							"      } else {\r",
							"        rval = rval.substr(0, candidate) +\r",
							"          '\\r\\n' + insert + rval.substr(candidate + 1);\r",
							"      }\r",
							"      length = (i - candidate - 1);\r",
							"      candidate = -1;\r",
							"      ++i;\r",
							"    } else if(rval[i] === ' ' || rval[i] === '\\t' || rval[i] === ',') {\r",
							"      candidate = i;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"function ltrim(str) {\r",
							"  return str.replace(/^\\s+/, '');\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 8 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Hash-based Message Authentication Code implementation. Requires a message\r",
							" * digest object that can be obtained, for example, from forge.md.sha1 or\r",
							" * forge.md.md5.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* HMAC API */\r",
							"var hmac = module.exports = forge.hmac = forge.hmac || {};\r",
							"\r",
							"/**\r",
							" * Creates an HMAC object that uses the given message digest object.\r",
							" *\r",
							" * @return an HMAC object.\r",
							" */\r",
							"hmac.create = function() {\r",
							"  // the hmac key to use\r",
							"  var _key = null;\r",
							"\r",
							"  // the message digest to use\r",
							"  var _md = null;\r",
							"\r",
							"  // the inner padding\r",
							"  var _ipadding = null;\r",
							"\r",
							"  // the outer padding\r",
							"  var _opadding = null;\r",
							"\r",
							"  // hmac context\r",
							"  var ctx = {};\r",
							"\r",
							"  /**\r",
							"   * Starts or restarts the HMAC with the given key and message digest.\r",
							"   *\r",
							"   * @param md the message digest to use, null to reuse the previous one,\r",
							"   *           a string to use builtin 'sha1', 'md5', 'sha256'.\r",
							"   * @param key the key to use as a string, array of bytes, byte buffer,\r",
							"   *           or null to reuse the previous key.\r",
							"   */\r",
							"  ctx.start = function(md, key) {\r",
							"    if(md !== null) {\r",
							"      if(typeof md === 'string') {\r",
							"        // create builtin message digest\r",
							"        md = md.toLowerCase();\r",
							"        if(md in forge.md.algorithms) {\r",
							"          _md = forge.md.algorithms[md].create();\r",
							"        } else {\r",
							"          throw new Error('Unknown hash algorithm \"' + md + '\"');\r",
							"        }\r",
							"      } else {\r",
							"        // store message digest\r",
							"        _md = md;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(key === null) {\r",
							"      // reuse previous key\r",
							"      key = _key;\r",
							"    } else {\r",
							"      if(typeof key === 'string') {\r",
							"        // convert string into byte buffer\r",
							"        key = forge.util.createBuffer(key);\r",
							"      } else if(forge.util.isArray(key)) {\r",
							"        // convert byte array into byte buffer\r",
							"        var tmp = key;\r",
							"        key = forge.util.createBuffer();\r",
							"        for(var i = 0; i < tmp.length; ++i) {\r",
							"          key.putByte(tmp[i]);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // if key is longer than blocksize, hash it\r",
							"      var keylen = key.length();\r",
							"      if(keylen > _md.blockLength) {\r",
							"        _md.start();\r",
							"        _md.update(key.bytes());\r",
							"        key = _md.digest();\r",
							"      }\r",
							"\r",
							"      // mix key into inner and outer padding\r",
							"      // ipadding = [0x36 * blocksize] ^ key\r",
							"      // opadding = [0x5C * blocksize] ^ key\r",
							"      _ipadding = forge.util.createBuffer();\r",
							"      _opadding = forge.util.createBuffer();\r",
							"      keylen = key.length();\r",
							"      for(var i = 0; i < keylen; ++i) {\r",
							"        var tmp = key.at(i);\r",
							"        _ipadding.putByte(0x36 ^ tmp);\r",
							"        _opadding.putByte(0x5C ^ tmp);\r",
							"      }\r",
							"\r",
							"      // if key is shorter than blocksize, add additional padding\r",
							"      if(keylen < _md.blockLength) {\r",
							"        var tmp = _md.blockLength - keylen;\r",
							"        for(var i = 0; i < tmp; ++i) {\r",
							"          _ipadding.putByte(0x36);\r",
							"          _opadding.putByte(0x5C);\r",
							"        }\r",
							"      }\r",
							"      _key = key;\r",
							"      _ipadding = _ipadding.bytes();\r",
							"      _opadding = _opadding.bytes();\r",
							"    }\r",
							"\r",
							"    // digest is done like so: hash(opadding | hash(ipadding | message))\r",
							"\r",
							"    // prepare to do inner hash\r",
							"    // hash(ipadding | message)\r",
							"    _md.start();\r",
							"    _md.update(_ipadding);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Updates the HMAC with the given message bytes.\r",
							"   *\r",
							"   * @param bytes the bytes to update with.\r",
							"   */\r",
							"  ctx.update = function(bytes) {\r",
							"    _md.update(bytes);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the Message Authentication Code (MAC).\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  ctx.getMac = function() {\r",
							"    // digest is done like so: hash(opadding | hash(ipadding | message))\r",
							"    // here we do the outer hashing\r",
							"    var inner = _md.digest().bytes();\r",
							"    _md.start();\r",
							"    _md.update(_opadding);\r",
							"    _md.update(inner);\r",
							"    return _md.digest();\r",
							"  };\r",
							"  // alias for getMac\r",
							"  ctx.digest = ctx.getMac;\r",
							"\r",
							"  return ctx;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 9 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2015 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var sha1 = module.exports = forge.sha1 = forge.sha1 || {};\r",
							"forge.md.sha1 = forge.md.algorithms.sha1 = sha1;\r",
							"\r",
							"/**\r",
							" * Creates a SHA-1 message digest object.\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"sha1.create = function() {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  // SHA-1 state contains five 32-bit integers\r",
							"  var _state = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for word storage\r",
							"  var _w = new Array(80);\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    algorithm: 'sha1',\r",
							"    blockLength: 64,\r",
							"    digestLength: 20,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 8\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength64 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength64 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _state = {\r",
							"      h0: 0x67452301,\r",
							"      h1: 0xEFCDAB89,\r",
							"      h2: 0x98BADCFE,\r",
							"      h3: 0x10325476,\r",
							"      h4: 0xC3D2E1F0\r",
							"    };\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = ((len[1] / 0x100000000) >>> 0);\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_state, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"   /**\r",
							"    * Produces the digest.\r",
							"    *\r",
							"    * @return a byte buffer containing the digest value.\r",
							"    */\r",
							"   md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate SHA-1 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 448 mod 512. In other words,\r",
							"    the data to be digested must be a multiple of 512 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 8 bytes (64\r",
							"    bits), that means that the last segment of the data must have 56 bytes\r",
							"    (448 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 448 mod 512 because\r",
							"    512 - 128 = 448.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 448 mod 512, then 512 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in big-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry from next int\r",
							"    var next, carry;\r",
							"    var bits = md.fullMessageLength[0] * 8;\r",
							"    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\r",
							"      next = md.fullMessageLength[i + 1] * 8;\r",
							"      carry = (next / 0x100000000) >>> 0;\r",
							"      bits += carry;\r",
							"      finalBlock.putInt32(bits >>> 0);\r",
							"      bits = next >>> 0;\r",
							"    }\r",
							"    finalBlock.putInt32(bits);\r",
							"\r",
							"    var s2 = {\r",
							"      h0: _state.h0,\r",
							"      h1: _state.h1,\r",
							"      h2: _state.h2,\r",
							"      h3: _state.h3,\r",
							"      h4: _state.h4\r",
							"    };\r",
							"    _update(s2, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    rval.putInt32(s2.h0);\r",
							"    rval.putInt32(s2.h1);\r",
							"    rval.putInt32(s2.h2);\r",
							"    rval.putInt32(s2.h3);\r",
							"    rval.putInt32(s2.h4);\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// sha-1 padding bytes not initialized yet\r",
							"var _padding = null;\r",
							"var _initialized = false;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a SHA-1 state with the given byte buffer.\r",
							" *\r",
							" * @param s the SHA-1 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (64 byte) chunks\r",
							"  var t, a, b, c, d, e, f, i;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 64) {\r",
							"    // the w array will be populated with sixteen 32-bit big-endian words\r",
							"    // and then extended into 80 32-bit words according to SHA-1 algorithm\r",
							"    // and for 32-79 using Max Locktyukhin's optimization\r",
							"\r",
							"    // initialize hash value for this chunk\r",
							"    a = s.h0;\r",
							"    b = s.h1;\r",
							"    c = s.h2;\r",
							"    d = s.h3;\r",
							"    e = s.h4;\r",
							"\r",
							"    // round 1\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      t = bytes.getInt32();\r",
							"      w[i] = t;\r",
							"      f = d ^ (b & (c ^ d));\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    for(; i < 20; ++i) {\r",
							"      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);\r",
							"      t = (t << 1) | (t >>> 31);\r",
							"      w[i] = t;\r",
							"      f = d ^ (b & (c ^ d));\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    // round 2\r",
							"    for(; i < 32; ++i) {\r",
							"      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);\r",
							"      t = (t << 1) | (t >>> 31);\r",
							"      w[i] = t;\r",
							"      f = b ^ c ^ d;\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    for(; i < 40; ++i) {\r",
							"      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\r",
							"      t = (t << 2) | (t >>> 30);\r",
							"      w[i] = t;\r",
							"      f = b ^ c ^ d;\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    // round 3\r",
							"    for(; i < 60; ++i) {\r",
							"      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\r",
							"      t = (t << 2) | (t >>> 30);\r",
							"      w[i] = t;\r",
							"      f = (b & c) | (d & (b ^ c));\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    // round 4\r",
							"    for(; i < 80; ++i) {\r",
							"      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\r",
							"      t = (t << 2) | (t >>> 30);\r",
							"      w[i] = t;\r",
							"      f = b ^ c ^ d;\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"\r",
							"    // update hash state\r",
							"    s.h0 = (s.h0 + a) | 0;\r",
							"    s.h1 = (s.h1 + b) | 0;\r",
							"    s.h2 = (s.h2 + c) | 0;\r",
							"    s.h3 = (s.h3 + d) | 0;\r",
							"    s.h4 = (s.h4 + e) | 0;\r",
							"\r",
							"    len -= 64;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 10 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * DES (Data Encryption Standard) implementation.\r",
							" *\r",
							" * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.\r",
							" * It is based on the BSD-licensed implementation by Paul Tero:\r",
							" *\r",
							" * Paul Tero, July 2001\r",
							" * http://www.tero.co.uk/des/\r",
							" *\r",
							" * Optimised for performance with large blocks by Michael Hayworth, November 2001\r",
							" * http://www.netdealing.com\r",
							" *\r",
							" * THIS SOFTWARE IS PROVIDED \"AS IS\" AND\r",
							" * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r",
							" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r",
							" * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\r",
							" * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r",
							" * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\r",
							" * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\r",
							" * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r",
							" * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r",
							" * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r",
							" * SUCH DAMAGE.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" * Copyright (c) 2012-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(13);\r",
							"__webpack_require__(18);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* DES API */\r",
							"module.exports = forge.des = forge.des || {};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('DES-<mode>', key);\r",
							" * cipher.start({iv: iv});\r",
							" *\r",
							" * Creates an DES cipher object to encrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as binary-encoded strings of bytes or\r",
							" * byte buffers.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC' if IV is\r",
							" *          given, 'ECB' if null).\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.startEncrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: false,\r",
							"    mode: mode || (iv === null ? 'ECB' : 'CBC')\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('DES-<mode>', key);\r",
							" *\r",
							" * Creates an DES cipher object to encrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a binary-encoded string of bytes or a byte buffer.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.createEncryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: false,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\r",
							" * decipher.start({iv: iv});\r",
							" *\r",
							" * Creates an DES cipher object to decrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as binary-encoded strings of bytes or\r",
							" * byte buffers.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC' if IV is\r",
							" *          given, 'ECB' if null).\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.startDecrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: true,\r",
							"    mode: mode || (iv === null ? 'ECB' : 'CBC')\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\r",
							" *\r",
							" * Creates an DES cipher object to decrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a binary-encoded string of bytes or a byte buffer.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.createDecryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: true,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new DES cipher algorithm object.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" * @param mode the mode factory function.\r",
							" *\r",
							" * @return the DES algorithm object.\r",
							" */\r",
							"forge.des.Algorithm = function(name, mode) {\r",
							"  var self = this;\r",
							"  self.name = name;\r",
							"  self.mode = new mode({\r",
							"    blockSize: 8,\r",
							"    cipher: {\r",
							"      encrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._keys, inBlock, outBlock, false);\r",
							"      },\r",
							"      decrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._keys, inBlock, outBlock, true);\r",
							"      }\r",
							"    }\r",
							"  });\r",
							"  self._init = false;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Initializes this DES algorithm by expanding its key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the key to use with this algorithm.\r",
							" *          decrypt true if the algorithm should be initialized for decryption,\r",
							" *            false for encryption.\r",
							" */\r",
							"forge.des.Algorithm.prototype.initialize = function(options) {\r",
							"  if(this._init) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  var key = forge.util.createBuffer(options.key);\r",
							"  if(this.name.indexOf('3DES') === 0) {\r",
							"    if(key.length() !== 24) {\r",
							"      throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // do key expansion to 16 or 48 subkeys (single or triple DES)\r",
							"  this._keys = _createKeys(key);\r",
							"  this._init = true;\r",
							"};\r",
							"\r",
							"/** Register DES algorithms **/\r",
							"\r",
							"registerAlgorithm('DES-ECB', forge.cipher.modes.ecb);\r",
							"registerAlgorithm('DES-CBC', forge.cipher.modes.cbc);\r",
							"registerAlgorithm('DES-CFB', forge.cipher.modes.cfb);\r",
							"registerAlgorithm('DES-OFB', forge.cipher.modes.ofb);\r",
							"registerAlgorithm('DES-CTR', forge.cipher.modes.ctr);\r",
							"\r",
							"registerAlgorithm('3DES-ECB', forge.cipher.modes.ecb);\r",
							"registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);\r",
							"registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);\r",
							"registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);\r",
							"registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);\r",
							"\r",
							"function registerAlgorithm(name, mode) {\r",
							"  var factory = function() {\r",
							"    return new forge.des.Algorithm(name, mode);\r",
							"  };\r",
							"  forge.cipher.registerAlgorithm(name, factory);\r",
							"}\r",
							"\r",
							"/** DES implementation **/\r",
							"\r",
							"var spfunction1 = [0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];\r",
							"var spfunction2 = [-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];\r",
							"var spfunction3 = [0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];\r",
							"var spfunction4 = [0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];\r",
							"var spfunction5 = [0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];\r",
							"var spfunction6 = [0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];\r",
							"var spfunction7 = [0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];\r",
							"var spfunction8 = [0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];\r",
							"\r",
							"/**\r",
							" * Create necessary sub keys.\r",
							" *\r",
							" * @param key the 64-bit or 192-bit key.\r",
							" *\r",
							" * @return the expanded keys.\r",
							" */\r",
							"function _createKeys(key) {\r",
							"  var pc2bytes0  = [0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],\r",
							"      pc2bytes1  = [0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],\r",
							"      pc2bytes2  = [0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],\r",
							"      pc2bytes3  = [0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],\r",
							"      pc2bytes4  = [0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],\r",
							"      pc2bytes5  = [0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],\r",
							"      pc2bytes6  = [0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],\r",
							"      pc2bytes7  = [0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],\r",
							"      pc2bytes8  = [0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],\r",
							"      pc2bytes9  = [0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],\r",
							"      pc2bytes10 = [0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],\r",
							"      pc2bytes11 = [0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],\r",
							"      pc2bytes12 = [0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],\r",
							"      pc2bytes13 = [0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];\r",
							"\r",
							"  // how many iterations (1 for des, 3 for triple des)\r",
							"  // changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys\r",
							"  var iterations = key.length() > 8 ? 3 : 1;\r",
							"\r",
							"  // stores the return keys\r",
							"  var keys = [];\r",
							"\r",
							"  // now define the left shifts which need to be done\r",
							"  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];\r",
							"\r",
							"  var n = 0, tmp;\r",
							"  for(var j = 0; j < iterations; j++) {\r",
							"    var left = key.getInt32();\r",
							"    var right = key.getInt32();\r",
							"\r",
							"    tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 4);\r",
							"\r",
							"    tmp = ((right >>> -16) ^ left) & 0x0000ffff;\r",
							"    left ^= tmp;\r",
							"    right ^= (tmp << -16);\r",
							"\r",
							"    tmp = ((left >>> 2) ^ right) & 0x33333333;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 2);\r",
							"\r",
							"    tmp = ((right >>> -16) ^ left) & 0x0000ffff;\r",
							"    left ^= tmp;\r",
							"    right ^= (tmp << -16);\r",
							"\r",
							"    tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 1);\r",
							"\r",
							"    tmp = ((right >>> 8) ^ left) & 0x00ff00ff;\r",
							"    left ^= tmp;\r",
							"    right ^= (tmp << 8);\r",
							"\r",
							"    tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 1);\r",
							"\r",
							"    // right needs to be shifted and OR'd with last four bits of left\r",
							"    tmp = (left << 8) | ((right >>> 20) & 0x000000f0);\r",
							"\r",
							"    // left needs to be put upside down\r",
							"    left = ((right << 24) | ((right << 8) & 0xff0000) |\r",
							"      ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0));\r",
							"    right = tmp;\r",
							"\r",
							"    // now go through and perform these shifts on the left and right keys\r",
							"    for(var i = 0; i < shifts.length; ++i) {\r",
							"      //shift the keys either one or two bits to the left\r",
							"      if(shifts[i]) {\r",
							"        left = (left << 2) | (left >>> 26);\r",
							"        right = (right << 2) | (right >>> 26);\r",
							"      } else {\r",
							"        left = (left << 1) | (left >>> 27);\r",
							"        right = (right << 1) | (right >>> 27);\r",
							"      }\r",
							"      left &= -0xf;\r",
							"      right &= -0xf;\r",
							"\r",
							"      // now apply PC-2, in such a way that E is easier when encrypting or\r",
							"      // decrypting this conversion will look like PC-2 except only the last 6\r",
							"      // bits of each byte are used rather than 48 consecutive bits and the\r",
							"      // order of lines will be according to how the S selection functions will\r",
							"      // be applied: S2, S4, S6, S8, S1, S3, S5, S7\r",
							"      var lefttmp = (\r",
							"        pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf] |\r",
							"        pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf] |\r",
							"        pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf] |\r",
							"        pc2bytes6[(left >>> 4) & 0xf]);\r",
							"      var righttmp = (\r",
							"        pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf] |\r",
							"        pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf] |\r",
							"        pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf] |\r",
							"        pc2bytes13[(right >>> 4) & 0xf]);\r",
							"      tmp = ((righttmp >>> 16) ^ lefttmp) & 0x0000ffff;\r",
							"      keys[n++] = lefttmp ^ tmp;\r",
							"      keys[n++] = righttmp ^ (tmp << 16);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return keys;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a single block (1 byte) using DES. The update will either\r",
							" * encrypt or decrypt the block.\r",
							" *\r",
							" * @param keys the expanded keys.\r",
							" * @param input the input block (an array of 32-bit words).\r",
							" * @param output the updated output block.\r",
							" * @param decrypt true to decrypt the block, false to encrypt it.\r",
							" */\r",
							"function _updateBlock(keys, input, output, decrypt) {\r",
							"  // set up loops for single or triple DES\r",
							"  var iterations = keys.length === 32 ? 3 : 9;\r",
							"  var looping;\r",
							"  if(iterations === 3) {\r",
							"    looping = decrypt ? [30, -2, -2] : [0, 32, 2];\r",
							"  } else {\r",
							"    looping = (decrypt ?\r",
							"      [94, 62, -2, 32, 64, 2, 30, -2, -2] :\r",
							"      [0, 32, 2, 62, 30, -2, 64, 96, 2]);\r",
							"  }\r",
							"\r",
							"  var tmp;\r",
							"\r",
							"  var left = input[0];\r",
							"  var right = input[1];\r",
							"\r",
							"  // first each 64 bit chunk of the message must be permuted according to IP\r",
							"  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 4);\r",
							"\r",
							"  tmp = ((left >>> 16) ^ right) & 0x0000ffff;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 16);\r",
							"\r",
							"  tmp = ((right >>> 2) ^ left) & 0x33333333;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 2);\r",
							"\r",
							"  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 8);\r",
							"\r",
							"  tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 1);\r",
							"\r",
							"  // rotate left 1 bit\r",
							"  left = ((left << 1) | (left >>> 31));\r",
							"  right = ((right << 1) | (right >>> 31));\r",
							"\r",
							"  for(var j = 0; j < iterations; j += 3) {\r",
							"    var endloop = looping[j + 1];\r",
							"    var loopinc = looping[j + 2];\r",
							"\r",
							"    // now go through and perform the encryption or decryption\r",
							"    for(var i = looping[j]; i != endloop; i += loopinc) {\r",
							"      var right1 = right ^ keys[i];\r",
							"      var right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];\r",
							"\r",
							"      // passing these bytes through the S selection functions\r",
							"      tmp = left;\r",
							"      left = right;\r",
							"      right = tmp ^ (\r",
							"        spfunction2[(right1 >>> 24) & 0x3f] |\r",
							"        spfunction4[(right1 >>> 16) & 0x3f] |\r",
							"        spfunction6[(right1 >>>  8) & 0x3f] |\r",
							"        spfunction8[right1 & 0x3f] |\r",
							"        spfunction1[(right2 >>> 24) & 0x3f] |\r",
							"        spfunction3[(right2 >>> 16) & 0x3f] |\r",
							"        spfunction5[(right2 >>>  8) & 0x3f] |\r",
							"        spfunction7[right2 & 0x3f]);\r",
							"    }\r",
							"    // unreverse left and right\r",
							"    tmp = left;\r",
							"    left = right;\r",
							"    right = tmp;\r",
							"  }\r",
							"\r",
							"  // rotate right 1 bit\r",
							"  left = ((left >>> 1) | (left << 31));\r",
							"  right = ((right >>> 1) | (right << 31));\r",
							"\r",
							"  // now perform IP-1, which is IP in the opposite direction\r",
							"  tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 1);\r",
							"\r",
							"  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 8);\r",
							"\r",
							"  tmp = ((right >>> 2) ^ left) & 0x33333333;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 2);\r",
							"\r",
							"  tmp = ((left >>> 16) ^ right) & 0x0000ffff;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 16);\r",
							"\r",
							"  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 4);\r",
							"\r",
							"  output[0] = left;\r",
							"  output[1] = right;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * forge.cipher.createCipher('DES-<mode>', key);\r",
							" * forge.cipher.createDecipher('DES-<mode>', key);\r",
							" *\r",
							" * Creates a deprecated DES cipher object. This object's mode will default to\r",
							" * CBC (cipher-block-chaining).\r",
							" *\r",
							" * The key may be given as a binary-encoded string of bytes or a byte buffer.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the symmetric key to use (64 or 192 bits).\r",
							" *          output the buffer to write to.\r",
							" *          decrypt true for decryption, false for encryption.\r",
							" *          mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"function _createCipher(options) {\r",
							"  options = options || {};\r",
							"  var mode = (options.mode || 'CBC').toUpperCase();\r",
							"  var algorithm = 'DES-' + mode;\r",
							"\r",
							"  var cipher;\r",
							"  if(options.decrypt) {\r",
							"    cipher = forge.cipher.createDecipher(algorithm, options.key);\r",
							"  } else {\r",
							"    cipher = forge.cipher.createCipher(algorithm, options.key);\r",
							"  }\r",
							"\r",
							"  // backwards compatible start API\r",
							"  var start = cipher.start;\r",
							"  cipher.start = function(iv, options) {\r",
							"    // backwards compatibility: support second arg as output buffer\r",
							"    var output = null;\r",
							"    if(options instanceof forge.util.ByteBuffer) {\r",
							"      output = options;\r",
							"      options = {};\r",
							"    }\r",
							"    options = options || {};\r",
							"    options.output = output;\r",
							"    options.iv = iv;\r",
							"    start.call(cipher, options);\r",
							"  };\r",
							"\r",
							"  return cipher;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 11 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of basic RSA algorithms.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * The only algorithm currently supported for PKI is RSA.\r",
							" *\r",
							" * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo\r",
							" * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier\r",
							" * and a subjectPublicKey of type bit string.\r",
							" *\r",
							" * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r",
							" * for the algorithm, if any. In the case of RSA, there aren't any.\r",
							" *\r",
							" * SubjectPublicKeyInfo ::= SEQUENCE {\r",
							" *   algorithm AlgorithmIdentifier,\r",
							" *   subjectPublicKey BIT STRING\r",
							" * }\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *   algorithm OBJECT IDENTIFIER,\r",
							" *   parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * For an RSA public key, the subjectPublicKey is:\r",
							" *\r",
							" * RSAPublicKey ::= SEQUENCE {\r",
							" *   modulus            INTEGER,    -- n\r",
							" *   publicExponent     INTEGER     -- e\r",
							" * }\r",
							" *\r",
							" * PrivateKeyInfo ::= SEQUENCE {\r",
							" *   version                   Version,\r",
							" *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,\r",
							" *   privateKey                PrivateKey,\r",
							" *   attributes           [0]  IMPLICIT Attributes OPTIONAL\r",
							" * }\r",
							" *\r",
							" * Version ::= INTEGER\r",
							" * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" * PrivateKey ::= OCTET STRING\r",
							" * Attributes ::= SET OF Attribute\r",
							" *\r",
							" * An RSA private key as the following structure:\r",
							" *\r",
							" * RSAPrivateKey ::= SEQUENCE {\r",
							" *   version Version,\r",
							" *   modulus INTEGER, -- n\r",
							" *   publicExponent INTEGER, -- e\r",
							" *   privateExponent INTEGER, -- d\r",
							" *   prime1 INTEGER, -- p\r",
							" *   prime2 INTEGER, -- q\r",
							" *   exponent1 INTEGER, -- d mod (p-1)\r",
							" *   exponent2 INTEGER, -- d mod (q-1)\r",
							" *   coefficient INTEGER -- (inverse of q) mod p\r",
							" * }\r",
							" *\r",
							" * Version ::= INTEGER\r",
							" *\r",
							" * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(12);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(26);\r",
							"__webpack_require__(27);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(1);\r",
							"\r",
							"if(typeof BigInteger === 'undefined') {\r",
							"  var BigInteger = forge.jsbn.BigInteger;\r",
							"}\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/*\r",
							" * RSA encryption and decryption, see RFC 2313.\r",
							" */\r",
							"forge.pki = forge.pki || {};\r",
							"module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};\r",
							"var pki = forge.pki;\r",
							"\r",
							"// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\r",
							"var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\r",
							"\r",
							"// validator for a PrivateKeyInfo structure\r",
							"var privateKeyValidator = {\r",
							"  // PrivateKeyInfo\r",
							"  name: 'PrivateKeyInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    // Version (INTEGER)\r",
							"    name: 'PrivateKeyInfo.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyVersion'\r",
							"  }, {\r",
							"    // privateKeyAlgorithm\r",
							"    name: 'PrivateKeyInfo.privateKeyAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'AlgorithmIdentifier.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'privateKeyOid'\r",
							"    }]\r",
							"  }, {\r",
							"    // PrivateKey\r",
							"    name: 'PrivateKeyInfo',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'privateKey'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for an RSA private key\r",
							"var rsaPrivateKeyValidator = {\r",
							"  // RSAPrivateKey\r",
							"  name: 'RSAPrivateKey',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    // Version (INTEGER)\r",
							"    name: 'RSAPrivateKey.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyVersion'\r",
							"  }, {\r",
							"    // modulus (n)\r",
							"    name: 'RSAPrivateKey.modulus',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyModulus'\r",
							"  }, {\r",
							"    // publicExponent (e)\r",
							"    name: 'RSAPrivateKey.publicExponent',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPublicExponent'\r",
							"  }, {\r",
							"    // privateExponent (d)\r",
							"    name: 'RSAPrivateKey.privateExponent',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPrivateExponent'\r",
							"  }, {\r",
							"    // prime1 (p)\r",
							"    name: 'RSAPrivateKey.prime1',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPrime1'\r",
							"  }, {\r",
							"    // prime2 (q)\r",
							"    name: 'RSAPrivateKey.prime2',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPrime2'\r",
							"  }, {\r",
							"    // exponent1 (d mod (p-1))\r",
							"    name: 'RSAPrivateKey.exponent1',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyExponent1'\r",
							"  }, {\r",
							"    // exponent2 (d mod (q-1))\r",
							"    name: 'RSAPrivateKey.exponent2',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyExponent2'\r",
							"  }, {\r",
							"    // coefficient ((inverse of q) mod p)\r",
							"    name: 'RSAPrivateKey.coefficient',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyCoefficient'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for an RSA public key\r",
							"var rsaPublicKeyValidator = {\r",
							"  // RSAPublicKey\r",
							"  name: 'RSAPublicKey',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    // modulus (n)\r",
							"    name: 'RSAPublicKey.modulus',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'publicKeyModulus'\r",
							"  }, {\r",
							"    // publicExponent (e)\r",
							"    name: 'RSAPublicKey.exponent',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'publicKeyExponent'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for an SubjectPublicKeyInfo structure\r",
							"// Note: Currently only works with an RSA public key\r",
							"var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {\r",
							"  name: 'SubjectPublicKeyInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  captureAsn1: 'subjectPublicKeyInfo',\r",
							"  value: [{\r",
							"    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'AlgorithmIdentifier.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'publicKeyOid'\r",
							"    }]\r",
							"  }, {\r",
							"    // subjectPublicKey\r",
							"    name: 'SubjectPublicKeyInfo.subjectPublicKey',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.BITSTRING,\r",
							"    constructed: false,\r",
							"    value: [{\r",
							"      // RSAPublicKey\r",
							"      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      captureAsn1: 'rsaPublicKey'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Wrap digest in DigestInfo object.\r",
							" *\r",
							" * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.\r",
							" *\r",
							" * DigestInfo ::= SEQUENCE {\r",
							" *   digestAlgorithm DigestAlgorithmIdentifier,\r",
							" *   digest Digest\r",
							" * }\r",
							" *\r",
							" * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" * Digest ::= OCTET STRING\r",
							" *\r",
							" * @param md the message digest object with the hash to sign.\r",
							" *\r",
							" * @return the encoded message (ready for RSA encrytion)\r",
							" */\r",
							"var emsaPkcs1v15encode = function(md) {\r",
							"  // get the oid for the algorithm\r",
							"  var oid;\r",
							"  if(md.algorithm in pki.oids) {\r",
							"    oid = pki.oids[md.algorithm];\r",
							"  } else {\r",
							"    var error = new Error('Unknown message digest algorithm.');\r",
							"    error.algorithm = md.algorithm;\r",
							"    throw error;\r",
							"  }\r",
							"  var oidBytes = asn1.oidToDer(oid).getBytes();\r",
							"\r",
							"  // create the digest info\r",
							"  var digestInfo = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"  var digestAlgorithm = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"  digestAlgorithm.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));\r",
							"  digestAlgorithm.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));\r",
							"  var digest = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\r",
							"    false, md.digest().getBytes());\r",
							"  digestInfo.value.push(digestAlgorithm);\r",
							"  digestInfo.value.push(digest);\r",
							"\r",
							"  // encode digest info\r",
							"  return asn1.toDer(digestInfo).getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Performs x^c mod n (RSA encryption or decryption operation).\r",
							" *\r",
							" * @param x the number to raise and mod.\r",
							" * @param key the key to use.\r",
							" * @param pub true if the key is public, false if private.\r",
							" *\r",
							" * @return the result of x^c mod n.\r",
							" */\r",
							"var _modPow = function(x, key, pub) {\r",
							"  if(pub) {\r",
							"    return x.modPow(key.e, key.n);\r",
							"  }\r",
							"\r",
							"  if(!key.p || !key.q) {\r",
							"    // allow calculation without CRT params (slow)\r",
							"    return x.modPow(key.d, key.n);\r",
							"  }\r",
							"\r",
							"  // pre-compute dP, dQ, and qInv if necessary\r",
							"  if(!key.dP) {\r",
							"    key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));\r",
							"  }\r",
							"  if(!key.dQ) {\r",
							"    key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));\r",
							"  }\r",
							"  if(!key.qInv) {\r",
							"    key.qInv = key.q.modInverse(key.p);\r",
							"  }\r",
							"\r",
							"  /* Chinese remainder theorem (CRT) states:\r",
							"\r",
							"    Suppose n1, n2, ..., nk are positive integers which are pairwise\r",
							"    coprime (n1 and n2 have no common factors other than 1). For any\r",
							"    integers x1, x2, ..., xk there exists an integer x solving the\r",
							"    system of simultaneous congruences (where ~= means modularly\r",
							"    congruent so a ~= b mod n means a mod n = b mod n):\r",
							"\r",
							"    x ~= x1 mod n1\r",
							"    x ~= x2 mod n2\r",
							"    ...\r",
							"    x ~= xk mod nk\r",
							"\r",
							"    This system of congruences has a single simultaneous solution x\r",
							"    between 0 and n - 1. Furthermore, each xk solution and x itself\r",
							"    is congruent modulo the product n = n1*n2*...*nk.\r",
							"    So x1 mod n = x2 mod n = xk mod n = x mod n.\r",
							"\r",
							"    The single simultaneous solution x can be solved with the following\r",
							"    equation:\r",
							"\r",
							"    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\r",
							"\r",
							"    Where x is less than n, xi = x mod ni.\r",
							"\r",
							"    For RSA we are only concerned with k = 2. The modulus n = pq, where\r",
							"    p and q are coprime. The RSA decryption algorithm is:\r",
							"\r",
							"    y = x^d mod n\r",
							"\r",
							"    Given the above:\r",
							"\r",
							"    x1 = x^d mod p\r",
							"    r1 = n/p = q\r",
							"    s1 = q^-1 mod p\r",
							"    x2 = x^d mod q\r",
							"    r2 = n/q = p\r",
							"    s2 = p^-1 mod q\r",
							"\r",
							"    So y = (x1r1s1 + x2r2s2) mod n\r",
							"         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\r",
							"\r",
							"    According to Fermat's Little Theorem, if the modulus P is prime,\r",
							"    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\r",
							"    Since A is not divisible by P it follows that if:\r",
							"    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\r",
							"\r",
							"    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\r",
							"    to calculate). In order to calculate x^d mod p more quickly the\r",
							"    exponent d mod (p - 1) is stored in the RSA private key (the same\r",
							"    is done for x^d mod q). These values are referred to as dP and dQ\r",
							"    respectively. Therefore we now have:\r",
							"\r",
							"    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\r",
							"\r",
							"    Since we'll be reducing x^dP by modulo p (same for q) we can also\r",
							"    reduce x by p (and q respectively) before hand. Therefore, let\r",
							"\r",
							"    xp = ((x mod p)^dP mod p), and\r",
							"    xq = ((x mod q)^dQ mod q), yielding:\r",
							"\r",
							"    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\r",
							"\r",
							"    This can be further reduced to a simple algorithm that only\r",
							"    requires 1 inverse (the q inverse is used) to be used and stored.\r",
							"    The algorithm is called Garner's algorithm. If qInv is the\r",
							"    inverse of q, we simply calculate:\r",
							"\r",
							"    y = (qInv*(xp - xq) mod p) * q + xq\r",
							"\r",
							"    However, there are two further complications. First, we need to\r",
							"    ensure that xp > xq to prevent signed BigIntegers from being used\r",
							"    so we add p until this is true (since we will be mod'ing with\r",
							"    p anyway). Then, there is a known timing attack on algorithms\r",
							"    using the CRT. To mitigate this risk, \"cryptographic blinding\"\r",
							"    should be used. This requires simply generating a random number r\r",
							"    between 0 and n-1 and its inverse and multiplying x by r^e before\r",
							"    calculating y and then multiplying y by r^-1 afterwards. Note that\r",
							"    r must be coprime with n (gcd(r, n) === 1) in order to have an\r",
							"    inverse.\r",
							"  */\r",
							"\r",
							"  // cryptographic blinding\r",
							"  var r;\r",
							"  do {\r",
							"    r = new BigInteger(\r",
							"      forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),\r",
							"      16);\r",
							"  } while(r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));\r",
							"  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);\r",
							"\r",
							"  // calculate xp and xq\r",
							"  var xp = x.mod(key.p).modPow(key.dP, key.p);\r",
							"  var xq = x.mod(key.q).modPow(key.dQ, key.q);\r",
							"\r",
							"  // xp must be larger than xq to avoid signed bit usage\r",
							"  while(xp.compareTo(xq) < 0) {\r",
							"    xp = xp.add(key.p);\r",
							"  }\r",
							"\r",
							"  // do last step\r",
							"  var y = xp.subtract(xq)\r",
							"    .multiply(key.qInv).mod(key.p)\r",
							"    .multiply(key.q).add(xq);\r",
							"\r",
							"  // remove effect of random for cryptographic blinding\r",
							"  y = y.multiply(r.modInverse(key.n)).mod(key.n);\r",
							"\r",
							"  return y;\r",
							"};\r",
							"\r",
							"/**\r",
							" * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or\r",
							" * 'encrypt' on a public key object instead.\r",
							" *\r",
							" * Performs RSA encryption.\r",
							" *\r",
							" * The parameter bt controls whether to put padding bytes before the\r",
							" * message passed in. Set bt to either true or false to disable padding\r",
							" * completely (in order to handle e.g. EMSA-PSS encoding seperately before),\r",
							" * signaling whether the encryption operation is a public key operation\r",
							" * (i.e. encrypting data) or not, i.e. private key operation (data signing).\r",
							" *\r",
							" * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01\r",
							" * (for signing) or 0x02 (for encryption). The key operation mode (private\r",
							" * or public) is derived from this flag in that case).\r",
							" *\r",
							" * @param m the message to encrypt as a byte string.\r",
							" * @param key the RSA key to use.\r",
							" * @param bt for PKCS#1 v1.5 padding, the block type to use\r",
							" *   (0x01 for private key, 0x02 for public),\r",
							" *   to disable padding: true = public key, false = private key.\r",
							" *\r",
							" * @return the encrypted bytes as a string.\r",
							" */\r",
							"pki.rsa.encrypt = function(m, key, bt) {\r",
							"  var pub = bt;\r",
							"  var eb;\r",
							"\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  if(bt !== false && bt !== true) {\r",
							"    // legacy, default to PKCS#1 v1.5 padding\r",
							"    pub = (bt === 0x02);\r",
							"    eb = _encodePkcs1_v1_5(m, key, bt);\r",
							"  } else {\r",
							"    eb = forge.util.createBuffer();\r",
							"    eb.putBytes(m);\r",
							"  }\r",
							"\r",
							"  // load encryption block as big integer 'x'\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var x = new BigInteger(eb.toHex(), 16);\r",
							"\r",
							"  // do RSA encryption\r",
							"  var y = _modPow(x, key, pub);\r",
							"\r",
							"  // convert y into the encrypted data byte string, if y is shorter in\r",
							"  // bytes than k, then prepend zero bytes to fill up ed\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var yhex = y.toString(16);\r",
							"  var ed = forge.util.createBuffer();\r",
							"  var zeros = k - Math.ceil(yhex.length / 2);\r",
							"  while(zeros > 0) {\r",
							"    ed.putByte(0x00);\r",
							"    --zeros;\r",
							"  }\r",
							"  ed.putBytes(forge.util.hexToBytes(yhex));\r",
							"  return ed.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or\r",
							" * 'verify' on a public key object instead.\r",
							" *\r",
							" * Performs RSA decryption.\r",
							" *\r",
							" * The parameter ml controls whether to apply PKCS#1 v1.5 padding\r",
							" * or not.  Set ml = false to disable padding removal completely\r",
							" * (in order to handle e.g. EMSA-PSS later on) and simply pass back\r",
							" * the RSA encryption block.\r",
							" *\r",
							" * @param ed the encrypted data to decrypt in as a byte string.\r",
							" * @param key the RSA key to use.\r",
							" * @param pub true for a public key operation, false for private.\r",
							" * @param ml the message length, if known, false to disable padding.\r",
							" *\r",
							" * @return the decrypted message as a byte string.\r",
							" */\r",
							"pki.rsa.decrypt = function(ed, key, pub, ml) {\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  // error if the length of the encrypted data ED is not k\r",
							"  if(ed.length !== k) {\r",
							"    var error = new Error('Encrypted message length is invalid.');\r",
							"    error.length = ed.length;\r",
							"    error.expected = k;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // convert encrypted data into a big integer\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);\r",
							"\r",
							"  // y must be less than the modulus or it wasn't the result of\r",
							"  // a previous mod operation (encryption) using that modulus\r",
							"  if(y.compareTo(key.n) >= 0) {\r",
							"    throw new Error('Encrypted message is invalid.');\r",
							"  }\r",
							"\r",
							"  // do RSA decryption\r",
							"  var x = _modPow(y, key, pub);\r",
							"\r",
							"  // create the encryption block, if x is shorter in bytes than k, then\r",
							"  // prepend zero bytes to fill up eb\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var xhex = x.toString(16);\r",
							"  var eb = forge.util.createBuffer();\r",
							"  var zeros = k - Math.ceil(xhex.length / 2);\r",
							"  while(zeros > 0) {\r",
							"    eb.putByte(0x00);\r",
							"    --zeros;\r",
							"  }\r",
							"  eb.putBytes(forge.util.hexToBytes(xhex));\r",
							"\r",
							"  if(ml !== false) {\r",
							"    // legacy, default to PKCS#1 v1.5 padding\r",
							"    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);\r",
							"  }\r",
							"\r",
							"  // return message\r",
							"  return eb.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RSA key-pair generation state object. It is used to allow\r",
							" * key-generation to be performed in steps. It also allows for a UI to\r",
							" * display progress updates.\r",
							" *\r",
							" * @param bits the size for the private key in bits, defaults to 2048.\r",
							" * @param e the public exponent to use, defaults to 65537 (0x10001).\r",
							" * @param [options] the options to use.\r",
							" *          prng a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" *          algorithm the algorithm to use (default: 'PRIMEINC').\r",
							" *\r",
							" * @return the state object to use to generate the key-pair.\r",
							" */\r",
							"pki.rsa.createKeyPairGenerationState = function(bits, e, options) {\r",
							"  // TODO: migrate step-based prime generation code to forge.prime\r",
							"\r",
							"  // set default bits\r",
							"  if(typeof(bits) === 'string') {\r",
							"    bits = parseInt(bits, 10);\r",
							"  }\r",
							"  bits = bits || 2048;\r",
							"\r",
							"  // create prng with api that matches BigInteger secure random\r",
							"  options = options || {};\r",
							"  var prng = options.prng || forge.random;\r",
							"  var rng = {\r",
							"    // x is an array to fill with bytes\r",
							"    nextBytes: function(x) {\r",
							"      var b = prng.getBytesSync(x.length);\r",
							"      for(var i = 0; i < x.length; ++i) {\r",
							"        x[i] = b.charCodeAt(i);\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  var algorithm = options.algorithm || 'PRIMEINC';\r",
							"\r",
							"  // create PRIMEINC algorithm state\r",
							"  var rval;\r",
							"  if(algorithm === 'PRIMEINC') {\r",
							"    rval = {\r",
							"      algorithm: algorithm,\r",
							"      state: 0,\r",
							"      bits: bits,\r",
							"      rng: rng,\r",
							"      eInt: e || 65537,\r",
							"      e: new BigInteger(null),\r",
							"      p: null,\r",
							"      q: null,\r",
							"      qBits: bits >> 1,\r",
							"      pBits: bits - (bits >> 1),\r",
							"      pqState: 0,\r",
							"      num: null,\r",
							"      keys: null\r",
							"    };\r",
							"    rval.e.fromInt(rval.eInt);\r",
							"  } else {\r",
							"    throw new Error('Invalid key generation algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Attempts to runs the key-generation algorithm for at most n seconds\r",
							" * (approximately) using the given state. When key-generation has completed,\r",
							" * the keys will be stored in state.keys.\r",
							" *\r",
							" * To use this function to update a UI while generating a key or to prevent\r",
							" * causing browser lockups/warnings, set \"n\" to a value other than 0. A\r",
							" * simple pattern for generating a key and showing a progress indicator is:\r",
							" *\r",
							" * var state = pki.rsa.createKeyPairGenerationState(2048);\r",
							" * var step = function() {\r",
							" *   // step key-generation, run algorithm for 100 ms, repeat\r",
							" *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {\r",
							" *     setTimeout(step, 1);\r",
							" *   } else {\r",
							" *     // key-generation complete\r",
							" *     // TODO: turn off progress indicator here\r",
							" *     // TODO: use the generated key-pair in \"state.keys\"\r",
							" *   }\r",
							" * };\r",
							" * // TODO: turn on progress indicator here\r",
							" * setTimeout(step, 0);\r",
							" *\r",
							" * @param state the state to use.\r",
							" * @param n the maximum number of milliseconds to run the algorithm for, 0\r",
							" *          to run the algorithm to completion.\r",
							" *\r",
							" * @return true if the key-generation completed, false if not.\r",
							" */\r",
							"pki.rsa.stepKeyPairGenerationState = function(state, n) {\r",
							"  // set default algorithm if not set\r",
							"  if(!('algorithm' in state)) {\r",
							"    state.algorithm = 'PRIMEINC';\r",
							"  }\r",
							"\r",
							"  // TODO: migrate step-based prime generation code to forge.prime\r",
							"  // TODO: abstract as PRIMEINC algorithm\r",
							"\r",
							"  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)\r",
							"  // with some minor optimizations and designed to run in steps\r",
							"\r",
							"  // local state vars\r",
							"  var THIRTY = new BigInteger(null);\r",
							"  THIRTY.fromInt(30);\r",
							"  var deltaIdx = 0;\r",
							"  var op_or = function(x, y) { return x|y; };\r",
							"\r",
							"  // keep stepping until time limit is reached or done\r",
							"  var t1 = +new Date();\r",
							"  var t2;\r",
							"  var total = 0;\r",
							"  while(state.keys === null && (n <= 0 || total < n)) {\r",
							"    // generate p or q\r",
							"    if(state.state === 0) {\r",
							"      /* Note: All primes are of the form:\r",
							"\r",
							"        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i\r",
							"\r",
							"        When we generate a random number, we always align it at 30k + 1. Each\r",
							"        time the number is determined not to be prime we add to get to the\r",
							"        next 'i', eg: if the number was at 30k + 1 we add 6. */\r",
							"      var bits = (state.p === null) ? state.pBits : state.qBits;\r",
							"      var bits1 = bits - 1;\r",
							"\r",
							"      // get a random number\r",
							"      if(state.pqState === 0) {\r",
							"        state.num = new BigInteger(bits, state.rng);\r",
							"        // force MSB set\r",
							"        if(!state.num.testBit(bits1)) {\r",
							"          state.num.bitwiseTo(\r",
							"            BigInteger.ONE.shiftLeft(bits1), op_or, state.num);\r",
							"        }\r",
							"        // align number on 30k+1 boundary\r",
							"        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);\r",
							"        deltaIdx = 0;\r",
							"\r",
							"        ++state.pqState;\r",
							"      } else if(state.pqState === 1) {\r",
							"        // try to make the number a prime\r",
							"        if(state.num.bitLength() > bits) {\r",
							"          // overflow, try again\r",
							"          state.pqState = 0;\r",
							"          // do primality test\r",
							"        } else if(state.num.isProbablePrime(\r",
							"          _getMillerRabinTests(state.num.bitLength()))) {\r",
							"          ++state.pqState;\r",
							"        } else {\r",
							"          // get next potential prime\r",
							"          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\r",
							"        }\r",
							"      } else if(state.pqState === 2) {\r",
							"        // ensure number is coprime with e\r",
							"        state.pqState =\r",
							"          (state.num.subtract(BigInteger.ONE).gcd(state.e)\r",
							"          .compareTo(BigInteger.ONE) === 0) ? 3 : 0;\r",
							"      } else if(state.pqState === 3) {\r",
							"        // store p or q\r",
							"        state.pqState = 0;\r",
							"        if(state.p === null) {\r",
							"          state.p = state.num;\r",
							"        } else {\r",
							"          state.q = state.num;\r",
							"        }\r",
							"\r",
							"        // advance state if both p and q are ready\r",
							"        if(state.p !== null && state.q !== null) {\r",
							"          ++state.state;\r",
							"        }\r",
							"        state.num = null;\r",
							"      }\r",
							"    } else if(state.state === 1) {\r",
							"      // ensure p is larger than q (swap them if not)\r",
							"      if(state.p.compareTo(state.q) < 0) {\r",
							"        state.num = state.p;\r",
							"        state.p = state.q;\r",
							"        state.q = state.num;\r",
							"      }\r",
							"      ++state.state;\r",
							"    } else if(state.state === 2) {\r",
							"      // compute phi: (p - 1)(q - 1) (Euler's totient function)\r",
							"      state.p1 = state.p.subtract(BigInteger.ONE);\r",
							"      state.q1 = state.q.subtract(BigInteger.ONE);\r",
							"      state.phi = state.p1.multiply(state.q1);\r",
							"      ++state.state;\r",
							"    } else if(state.state === 3) {\r",
							"      // ensure e and phi are coprime\r",
							"      if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {\r",
							"        // phi and e are coprime, advance\r",
							"        ++state.state;\r",
							"      } else {\r",
							"        // phi and e aren't coprime, so generate a new p and q\r",
							"        state.p = null;\r",
							"        state.q = null;\r",
							"        state.state = 0;\r",
							"      }\r",
							"    } else if(state.state === 4) {\r",
							"      // create n, ensure n is has the right number of bits\r",
							"      state.n = state.p.multiply(state.q);\r",
							"\r",
							"      // ensure n is right number of bits\r",
							"      if(state.n.bitLength() === state.bits) {\r",
							"        // success, advance\r",
							"        ++state.state;\r",
							"      } else {\r",
							"        // failed, get new q\r",
							"        state.q = null;\r",
							"        state.state = 0;\r",
							"      }\r",
							"    } else if(state.state === 5) {\r",
							"      // set keys\r",
							"      var d = state.e.modInverse(state.phi);\r",
							"      state.keys = {\r",
							"        privateKey: pki.rsa.setPrivateKey(\r",
							"          state.n, state.e, d, state.p, state.q,\r",
							"          d.mod(state.p1), d.mod(state.q1),\r",
							"          state.q.modInverse(state.p)),\r",
							"        publicKey: pki.rsa.setPublicKey(state.n, state.e)\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // update timing\r",
							"    t2 = +new Date();\r",
							"    total += t2 - t1;\r",
							"    t1 = t2;\r",
							"  }\r",
							"\r",
							"  return state.keys !== null;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Generates an RSA public-private key pair in a single call.\r",
							" *\r",
							" * To generate a key-pair in steps (to allow for progress updates and to\r",
							" * prevent blocking or warnings in slow browsers) then use the key-pair\r",
							" * generation state functions.\r",
							" *\r",
							" * To generate a key-pair asynchronously (either through web-workers, if\r",
							" * available, or by breaking up the work on the main thread), pass a\r",
							" * callback function.\r",
							" *\r",
							" * @param [bits] the size for the private key in bits, defaults to 2048.\r",
							" * @param [e] the public exponent to use, defaults to 65537.\r",
							" * @param [options] options for key-pair generation, if given then 'bits'\r",
							" *          and 'e' must *not* be given:\r",
							" *          bits the size for the private key in bits, (default: 2048).\r",
							" *          e the public exponent to use, (default: 65537 (0x10001)).\r",
							" *          workerScript the worker script URL.\r",
							" *          workers the number of web workers (if supported) to use,\r",
							" *            (default: 2).\r",
							" *          workLoad the size of the work load, ie: number of possible prime\r",
							" *            numbers for each web worker to check per work assignment,\r",
							" *            (default: 100).\r",
							" *          prng a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" *          algorithm the algorithm to use (default: 'PRIMEINC').\r",
							" * @param [callback(err, keypair)] called once the operation completes.\r",
							" *\r",
							" * @return an object with privateKey and publicKey properties.\r",
							" */\r",
							"pki.rsa.generateKeyPair = function(bits, e, options, callback) {\r",
							"  // (bits), (options), (callback)\r",
							"  if(arguments.length === 1) {\r",
							"    if(typeof bits === 'object') {\r",
							"      options = bits;\r",
							"      bits = undefined;\r",
							"    } else if(typeof bits === 'function') {\r",
							"      callback = bits;\r",
							"      bits = undefined;\r",
							"    }\r",
							"  } else if(arguments.length === 2) {\r",
							"    // (bits, e), (bits, options), (bits, callback), (options, callback)\r",
							"    if(typeof bits === 'number') {\r",
							"      if(typeof e === 'function') {\r",
							"        callback = e;\r",
							"        e = undefined;\r",
							"      } else if(typeof e !== 'number') {\r",
							"        options = e;\r",
							"        e = undefined;\r",
							"      }\r",
							"    } else {\r",
							"      options = bits;\r",
							"      callback = e;\r",
							"      bits = undefined;\r",
							"      e = undefined;\r",
							"    }\r",
							"  } else if(arguments.length === 3) {\r",
							"    // (bits, e, options), (bits, e, callback), (bits, options, callback)\r",
							"    if(typeof e === 'number') {\r",
							"      if(typeof options === 'function') {\r",
							"        callback = options;\r",
							"        options = undefined;\r",
							"      }\r",
							"    } else {\r",
							"      callback = options;\r",
							"      options = e;\r",
							"      e = undefined;\r",
							"    }\r",
							"  }\r",
							"  options = options || {};\r",
							"  if(bits === undefined) {\r",
							"    bits = options.bits || 2048;\r",
							"  }\r",
							"  if(e === undefined) {\r",
							"    e = options.e || 0x10001;\r",
							"  }\r",
							"\r",
							"  // if native code is permitted and a callback is given, use native\r",
							"  // key generation code if available and if parameters are acceptable\r",
							"  if(!forge.options.usePureJavaScript && callback &&\r",
							"    bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {\r",
							"    if(_detectSubtleCrypto('generateKey') && _detectSubtleCrypto('exportKey')) {\r",
							"      // use standard native generateKey\r",
							"      return window.crypto.subtle.generateKey({\r",
							"        name: 'RSASSA-PKCS1-v1_5',\r",
							"        modulusLength: bits,\r",
							"        publicExponent: _intToUint8Array(e),\r",
							"        hash: {name: 'SHA-256'}\r",
							"      }, true /* key can be exported*/, ['sign', 'verify'])\r",
							"      .then(function(pair) {\r",
							"        return window.crypto.subtle.exportKey('pkcs8', pair.privateKey);\r",
							"      // avoiding catch(function(err) {...}) to support IE <= 8\r",
							"      }).then(undefined, function(err) {\r",
							"        callback(err);\r",
							"      }).then(function(pkcs8) {\r",
							"        if(pkcs8) {\r",
							"          var privateKey = pki.privateKeyFromAsn1(\r",
							"            asn1.fromDer(forge.util.createBuffer(pkcs8)));\r",
							"          callback(null, {\r",
							"            privateKey: privateKey,\r",
							"            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\r",
							"          });\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"    if(_detectSubtleMsCrypto('generateKey') &&\r",
							"      _detectSubtleMsCrypto('exportKey')) {\r",
							"      var genOp = window.msCrypto.subtle.generateKey({\r",
							"        name: 'RSASSA-PKCS1-v1_5',\r",
							"        modulusLength: bits,\r",
							"        publicExponent: _intToUint8Array(e),\r",
							"        hash: {name: 'SHA-256'}\r",
							"      }, true /* key can be exported*/, ['sign', 'verify']);\r",
							"      genOp.oncomplete = function(e) {\r",
							"        var pair = e.target.result;\r",
							"        var exportOp = window.msCrypto.subtle.exportKey(\r",
							"          'pkcs8', pair.privateKey);\r",
							"        exportOp.oncomplete = function(e) {\r",
							"          var pkcs8 = e.target.result;\r",
							"          var privateKey = pki.privateKeyFromAsn1(\r",
							"            asn1.fromDer(forge.util.createBuffer(pkcs8)));\r",
							"          callback(null, {\r",
							"            privateKey: privateKey,\r",
							"            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\r",
							"          });\r",
							"        };\r",
							"        exportOp.onerror = function(err) {\r",
							"          callback(err);\r",
							"        };\r",
							"      };\r",
							"      genOp.onerror = function(err) {\r",
							"        callback(err);\r",
							"      };\r",
							"      return;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // use JavaScript implementation\r",
							"  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);\r",
							"  if(!callback) {\r",
							"    pki.rsa.stepKeyPairGenerationState(state, 0);\r",
							"    return state.keys;\r",
							"  }\r",
							"  _generateKeyPair(state, options, callback);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets an RSA public key from BigIntegers modulus and exponent.\r",
							" *\r",
							" * @param n the modulus.\r",
							" * @param e the exponent.\r",
							" *\r",
							" * @return the public key.\r",
							" */\r",
							"pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {\r",
							"  var key = {\r",
							"    n: n,\r",
							"    e: e\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Encrypts the given data with this public key. Newer applications\r",
							"   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for\r",
							"   * legacy applications.\r",
							"   *\r",
							"   * @param data the byte string to encrypt.\r",
							"   * @param scheme the encryption scheme to use:\r",
							"   *          'RSAES-PKCS1-V1_5' (default),\r",
							"   *          'RSA-OAEP',\r",
							"   *          'RAW', 'NONE', or null to perform raw RSA encryption,\r",
							"   *          an object with an 'encode' property set to a function\r",
							"   *          with the signature 'function(data, key)' that returns\r",
							"   *          a binary-encoded string representing the encoded data.\r",
							"   * @param schemeOptions any scheme-specific options.\r",
							"   *\r",
							"   * @return the encrypted byte string.\r",
							"   */\r",
							"  key.encrypt = function(data, scheme, schemeOptions) {\r",
							"    if(typeof scheme === 'string') {\r",
							"      scheme = scheme.toUpperCase();\r",
							"    } else if(scheme === undefined) {\r",
							"      scheme = 'RSAES-PKCS1-V1_5';\r",
							"    }\r",
							"\r",
							"    if(scheme === 'RSAES-PKCS1-V1_5') {\r",
							"      scheme = {\r",
							"        encode: function(m, key, pub) {\r",
							"          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();\r",
							"        }\r",
							"      };\r",
							"    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\r",
							"      scheme = {\r",
							"        encode: function(m, key) {\r",
							"          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);\r",
							"        }\r",
							"      };\r",
							"    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\r",
							"      scheme = { encode: function(e) { return e; } };\r",
							"    } else if(typeof scheme === 'string') {\r",
							"      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\r",
							"    }\r",
							"\r",
							"    // do scheme-based encoding then rsa encryption\r",
							"    var e = scheme.encode(data, key, true);\r",
							"    return pki.rsa.encrypt(e, key, true);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Verifies the given signature against the given digest.\r",
							"   *\r",
							"   * PKCS#1 supports multiple (currently two) signature schemes:\r",
							"   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\r",
							"   *\r",
							"   * By default this implementation uses the \"old scheme\", i.e.\r",
							"   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the\r",
							"   * signature is an OCTET STRING that holds a DigestInfo.\r",
							"   *\r",
							"   * DigestInfo ::= SEQUENCE {\r",
							"   *   digestAlgorithm DigestAlgorithmIdentifier,\r",
							"   *   digest Digest\r",
							"   * }\r",
							"   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							"   * Digest ::= OCTET STRING\r",
							"   *\r",
							"   * To perform PSS signature verification, provide an instance\r",
							"   * of Forge PSS object as the scheme parameter.\r",
							"   *\r",
							"   * @param digest the message digest hash to compare against the signature,\r",
							"   *          as a binary-encoded string.\r",
							"   * @param signature the signature to verify, as a binary-encoded string.\r",
							"   * @param scheme signature verification scheme to use:\r",
							"   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\r",
							"   *          a Forge PSS object for RSASSA-PSS,\r",
							"   *          'NONE' or null for none, DigestInfo will not be expected, but\r",
							"   *            PKCS#1 v1.5 padding will still be used.\r",
							"   *\r",
							"   * @return true if the signature was verified, false if not.\r",
							"   */\r",
							"   key.verify = function(digest, signature, scheme) {\r",
							"     if(typeof scheme === 'string') {\r",
							"       scheme = scheme.toUpperCase();\r",
							"     } else if(scheme === undefined) {\r",
							"       scheme = 'RSASSA-PKCS1-V1_5';\r",
							"     }\r",
							"\r",
							"     if(scheme === 'RSASSA-PKCS1-V1_5') {\r",
							"       scheme = {\r",
							"         verify: function(digest, d) {\r",
							"           // remove padding\r",
							"           d = _decodePkcs1_v1_5(d, key, true);\r",
							"           // d is ASN.1 BER-encoded DigestInfo\r",
							"           var obj = asn1.fromDer(d);\r",
							"           // compare the given digest to the decrypted one\r",
							"           return digest === obj.value[1].value;\r",
							"         }\r",
							"       };\r",
							"     } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\r",
							"       scheme = {\r",
							"         verify: function(digest, d) {\r",
							"           // remove padding\r",
							"           d = _decodePkcs1_v1_5(d, key, true);\r",
							"           return digest === d;\r",
							"         }\r",
							"       };\r",
							"     }\r",
							"\r",
							"     // do rsa decryption w/o any decoding, then verify -- which does decoding\r",
							"     var d = pki.rsa.decrypt(signature, key, true, false);\r",
							"     return scheme.verify(digest, d, key.n.bitLength());\r",
							"  };\r",
							"\r",
							"  return key;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets an RSA private key from BigIntegers modulus, exponent, primes,\r",
							" * prime exponents, and modular multiplicative inverse.\r",
							" *\r",
							" * @param n the modulus.\r",
							" * @param e the public exponent.\r",
							" * @param d the private exponent ((inverse of e) mod n).\r",
							" * @param p the first prime.\r",
							" * @param q the second prime.\r",
							" * @param dP exponent1 (d mod (p-1)).\r",
							" * @param dQ exponent2 (d mod (q-1)).\r",
							" * @param qInv ((inverse of q) mod p)\r",
							" *\r",
							" * @return the private key.\r",
							" */\r",
							"pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(\r",
							"  n, e, d, p, q, dP, dQ, qInv) {\r",
							"  var key = {\r",
							"    n: n,\r",
							"    e: e,\r",
							"    d: d,\r",
							"    p: p,\r",
							"    q: q,\r",
							"    dP: dP,\r",
							"    dQ: dQ,\r",
							"    qInv: qInv\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Decrypts the given data with this private key. The decryption scheme\r",
							"   * must match the one used to encrypt the data.\r",
							"   *\r",
							"   * @param data the byte string to decrypt.\r",
							"   * @param scheme the decryption scheme to use:\r",
							"   *          'RSAES-PKCS1-V1_5' (default),\r",
							"   *          'RSA-OAEP',\r",
							"   *          'RAW', 'NONE', or null to perform raw RSA decryption.\r",
							"   * @param schemeOptions any scheme-specific options.\r",
							"   *\r",
							"   * @return the decrypted byte string.\r",
							"   */\r",
							"  key.decrypt = function(data, scheme, schemeOptions) {\r",
							"    if(typeof scheme === 'string') {\r",
							"      scheme = scheme.toUpperCase();\r",
							"    } else if(scheme === undefined) {\r",
							"      scheme = 'RSAES-PKCS1-V1_5';\r",
							"    }\r",
							"\r",
							"    // do rsa decryption w/o any decoding\r",
							"    var d = pki.rsa.decrypt(data, key, false, false);\r",
							"\r",
							"    if(scheme === 'RSAES-PKCS1-V1_5') {\r",
							"      scheme = { decode: _decodePkcs1_v1_5 };\r",
							"    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\r",
							"      scheme = {\r",
							"        decode: function(d, key) {\r",
							"          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);\r",
							"        }\r",
							"      };\r",
							"    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\r",
							"      scheme = { decode: function(d) { return d; } };\r",
							"    } else {\r",
							"      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\r",
							"    }\r",
							"\r",
							"    // decode according to scheme\r",
							"    return scheme.decode(d, key, false);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Signs the given digest, producing a signature.\r",
							"   *\r",
							"   * PKCS#1 supports multiple (currently two) signature schemes:\r",
							"   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\r",
							"   *\r",
							"   * By default this implementation uses the \"old scheme\", i.e.\r",
							"   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide\r",
							"   * an instance of Forge PSS object as the scheme parameter.\r",
							"   *\r",
							"   * @param md the message digest object with the hash to sign.\r",
							"   * @param scheme the signature scheme to use:\r",
							"   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\r",
							"   *          a Forge PSS object for RSASSA-PSS,\r",
							"   *          'NONE' or null for none, DigestInfo will not be used but\r",
							"   *            PKCS#1 v1.5 padding will still be used.\r",
							"   *\r",
							"   * @return the signature as a byte string.\r",
							"   */\r",
							"  key.sign = function(md, scheme) {\r",
							"    /* Note: The internal implementation of RSA operations is being\r",
							"      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy\r",
							"      code like the use of an encoding block identifier 'bt' will eventually\r",
							"      be removed. */\r",
							"\r",
							"    // private key operation\r",
							"    var bt = false;\r",
							"\r",
							"    if(typeof scheme === 'string') {\r",
							"      scheme = scheme.toUpperCase();\r",
							"    }\r",
							"\r",
							"    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {\r",
							"      scheme = { encode: emsaPkcs1v15encode };\r",
							"      bt = 0x01;\r",
							"    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\r",
							"      scheme = { encode: function() { return md; } };\r",
							"      bt = 0x01;\r",
							"    }\r",
							"\r",
							"    // encode and then encrypt\r",
							"    var d = scheme.encode(md, key.n.bitLength());\r",
							"    return pki.rsa.encrypt(d, key, bt);\r",
							"  };\r",
							"\r",
							"  return key;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.\r",
							" *\r",
							" * @param rsaKey the ASN.1 RSAPrivateKey.\r",
							" *\r",
							" * @return the ASN.1 PrivateKeyInfo.\r",
							" */\r",
							"pki.wrapRsaPrivateKey = function(rsaKey) {\r",
							"  // PrivateKeyInfo\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version (0)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(0).getBytes()),\r",
							"    // privateKeyAlgorithm\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ]),\r",
							"    // PrivateKey\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"      asn1.toDer(rsaKey).getBytes())\r",
							"    ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a private key from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 representation of a PrivateKeyInfo containing an\r",
							" *          RSAPrivateKey or an RSAPrivateKey.\r",
							" *\r",
							" * @return the private key.\r",
							" */\r",
							"pki.privateKeyFromAsn1 = function(obj) {\r",
							"  // get PrivateKeyInfo\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(asn1.validate(obj, privateKeyValidator, capture, errors)) {\r",
							"    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));\r",
							"  }\r",
							"\r",
							"  // get RSAPrivateKey\r",
							"  capture = {};\r",
							"  errors = [];\r",
							"  if(!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read private key. ' +\r",
							"      'ASN.1 object does not contain an RSAPrivateKey.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // Note: Version is currently ignored.\r",
							"  // capture.privateKeyVersion\r",
							"  // FIXME: inefficient, get a BigInteger that uses byte strings\r",
							"  var n, e, d, p, q, dP, dQ, qInv;\r",
							"  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();\r",
							"  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();\r",
							"  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();\r",
							"  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();\r",
							"  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();\r",
							"  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();\r",
							"  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();\r",
							"  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();\r",
							"\r",
							"  // set private key\r",
							"  return pki.setRsaPrivateKey(\r",
							"    new BigInteger(n, 16),\r",
							"    new BigInteger(e, 16),\r",
							"    new BigInteger(d, 16),\r",
							"    new BigInteger(p, 16),\r",
							"    new BigInteger(q, 16),\r",
							"    new BigInteger(dP, 16),\r",
							"    new BigInteger(dQ, 16),\r",
							"    new BigInteger(qInv, 16));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a private key to an ASN.1 RSAPrivateKey.\r",
							" *\r",
							" * @param key the private key.\r",
							" *\r",
							" * @return the ASN.1 representation of an RSAPrivateKey.\r",
							" */\r",
							"pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {\r",
							"  // RSAPrivateKey\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version (0 = only 2 primes, 1 multiple primes)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(0).getBytes()),\r",
							"    // modulus (n)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.n)),\r",
							"    // publicExponent (e)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.e)),\r",
							"    // privateExponent (d)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.d)),\r",
							"    // privateKeyPrime1 (p)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.p)),\r",
							"    // privateKeyPrime2 (q)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.q)),\r",
							"    // privateKeyExponent1 (dP)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.dP)),\r",
							"    // privateKeyExponent2 (dQ)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.dQ)),\r",
							"    // coefficient (qInv)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.qInv))\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.\r",
							" *\r",
							" * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.\r",
							" *\r",
							" * @return the public key.\r",
							" */\r",
							"pki.publicKeyFromAsn1 = function(obj) {\r",
							"  // get SubjectPublicKeyInfo\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(asn1.validate(obj, publicKeyValidator, capture, errors)) {\r",
							"    // get oid\r",
							"    var oid = asn1.derToOid(capture.publicKeyOid);\r",
							"    if(oid !== pki.oids.rsaEncryption) {\r",
							"      var error = new Error('Cannot read public key. Unknown OID.');\r",
							"      error.oid = oid;\r",
							"      throw error;\r",
							"    }\r",
							"    obj = capture.rsaPublicKey;\r",
							"  }\r",
							"\r",
							"  // get RSA params\r",
							"  errors = [];\r",
							"  if(!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read public key. ' +\r",
							"      'ASN.1 object does not contain an RSAPublicKey.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // FIXME: inefficient, get a BigInteger that uses byte strings\r",
							"  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();\r",
							"  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();\r",
							"\r",
							"  // set public key\r",
							"  return pki.setRsaPublicKey(\r",
							"    new BigInteger(n, 16),\r",
							"    new BigInteger(e, 16));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a public key to an ASN.1 SubjectPublicKeyInfo.\r",
							" *\r",
							" * @param key the public key.\r",
							" *\r",
							" * @return the asn1 representation of a SubjectPublicKeyInfo.\r",
							" */\r",
							"pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {\r",
							"  // SubjectPublicKeyInfo\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // AlgorithmIdentifier\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\r",
							"      // parameters (null)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ]),\r",
							"    // subjectPublicKey\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\r",
							"      pki.publicKeyToRSAPublicKey(key)\r",
							"    ])\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a public key to an ASN.1 RSAPublicKey.\r",
							" *\r",
							" * @param key the public key.\r",
							" *\r",
							" * @return the asn1 representation of a RSAPublicKey.\r",
							" */\r",
							"pki.publicKeyToRSAPublicKey = function(key) {\r",
							"  // RSAPublicKey\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // modulus (n)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.n)),\r",
							"    // publicExponent (e)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.e))\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a message using PKCS#1 v1.5 padding.\r",
							" *\r",
							" * @param m the message to encode.\r",
							" * @param key the RSA key to use.\r",
							" * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02\r",
							" *          (for encryption).\r",
							" *\r",
							" * @return the padded byte buffer.\r",
							" */\r",
							"function _encodePkcs1_v1_5(m, key, bt) {\r",
							"  var eb = forge.util.createBuffer();\r",
							"\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  /* use PKCS#1 v1.5 padding */\r",
							"  if(m.length > (k - 11)) {\r",
							"    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');\r",
							"    error.length = m.length;\r",
							"    error.max = k - 11;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  /* A block type BT, a padding string PS, and the data D shall be\r",
							"    formatted into an octet string EB, the encryption block:\r",
							"\r",
							"    EB = 00 || BT || PS || 00 || D\r",
							"\r",
							"    The block type BT shall be a single octet indicating the structure of\r",
							"    the encryption block. For this version of the document it shall have\r",
							"    value 00, 01, or 02. For a private-key operation, the block type\r",
							"    shall be 00 or 01. For a public-key operation, it shall be 02.\r",
							"\r",
							"    The padding string PS shall consist of k-3-||D|| octets. For block\r",
							"    type 00, the octets shall have value 00; for block type 01, they\r",
							"    shall have value FF; and for block type 02, they shall be\r",
							"    pseudorandomly generated and nonzero. This makes the length of the\r",
							"    encryption block EB equal to k. */\r",
							"\r",
							"  // build the encryption block\r",
							"  eb.putByte(0x00);\r",
							"  eb.putByte(bt);\r",
							"\r",
							"  // create the padding\r",
							"  var padNum = k - 3 - m.length;\r",
							"  var padByte;\r",
							"  // private key op\r",
							"  if(bt === 0x00 || bt === 0x01) {\r",
							"    padByte = (bt === 0x00) ? 0x00 : 0xFF;\r",
							"    for(var i = 0; i < padNum; ++i) {\r",
							"      eb.putByte(padByte);\r",
							"    }\r",
							"  } else {\r",
							"    // public key op\r",
							"    // pad with random non-zero values\r",
							"    while(padNum > 0) {\r",
							"      var numZeros = 0;\r",
							"      var padBytes = forge.random.getBytes(padNum);\r",
							"      for(var i = 0; i < padNum; ++i) {\r",
							"        padByte = padBytes.charCodeAt(i);\r",
							"        if(padByte === 0) {\r",
							"          ++numZeros;\r",
							"        } else {\r",
							"          eb.putByte(padByte);\r",
							"        }\r",
							"      }\r",
							"      padNum = numZeros;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // zero followed by message\r",
							"  eb.putByte(0x00);\r",
							"  eb.putBytes(m);\r",
							"\r",
							"  return eb;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decodes a message using PKCS#1 v1.5 padding.\r",
							" *\r",
							" * @param em the message to decode.\r",
							" * @param key the RSA key to use.\r",
							" * @param pub true if the key is a public key, false if it is private.\r",
							" * @param ml the message length, if specified.\r",
							" *\r",
							" * @return the decoded bytes.\r",
							" */\r",
							"function _decodePkcs1_v1_5(em, key, pub, ml) {\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  /* It is an error if any of the following conditions occurs:\r",
							"\r",
							"    1. The encryption block EB cannot be parsed unambiguously.\r",
							"    2. The padding string PS consists of fewer than eight octets\r",
							"      or is inconsisent with the block type BT.\r",
							"    3. The decryption process is a public-key operation and the block\r",
							"      type BT is not 00 or 01, or the decryption process is a\r",
							"      private-key operation and the block type is not 02.\r",
							"   */\r",
							"\r",
							"  // parse the encryption block\r",
							"  var eb = forge.util.createBuffer(em);\r",
							"  var first = eb.getByte();\r",
							"  var bt = eb.getByte();\r",
							"  if(first !== 0x00 ||\r",
							"    (pub && bt !== 0x00 && bt !== 0x01) ||\r",
							"    (!pub && bt != 0x02) ||\r",
							"    (pub && bt === 0x00 && typeof(ml) === 'undefined')) {\r",
							"    throw new Error('Encryption block is invalid.');\r",
							"  }\r",
							"\r",
							"  var padNum = 0;\r",
							"  if(bt === 0x00) {\r",
							"    // check all padding bytes for 0x00\r",
							"    padNum = k - 3 - ml;\r",
							"    for(var i = 0; i < padNum; ++i) {\r",
							"      if(eb.getByte() !== 0x00) {\r",
							"        throw new Error('Encryption block is invalid.');\r",
							"      }\r",
							"    }\r",
							"  } else if(bt === 0x01) {\r",
							"    // find the first byte that isn't 0xFF, should be after all padding\r",
							"    padNum = 0;\r",
							"    while(eb.length() > 1) {\r",
							"      if(eb.getByte() !== 0xFF) {\r",
							"        --eb.read;\r",
							"        break;\r",
							"      }\r",
							"      ++padNum;\r",
							"    }\r",
							"  } else if(bt === 0x02) {\r",
							"    // look for 0x00 byte\r",
							"    padNum = 0;\r",
							"    while(eb.length() > 1) {\r",
							"      if(eb.getByte() === 0x00) {\r",
							"        --eb.read;\r",
							"        break;\r",
							"      }\r",
							"      ++padNum;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // zero must be 0x00 and padNum must be (k - 3 - message length)\r",
							"  var zero = eb.getByte();\r",
							"  if(zero !== 0x00 || padNum !== (k - 3 - eb.length())) {\r",
							"    throw new Error('Encryption block is invalid.');\r",
							"  }\r",
							"\r",
							"  return eb.getBytes();\r",
							"}\r",
							"\r",
							"/**\r",
							" * Runs the key-generation algorithm asynchronously, either in the background\r",
							" * via Web Workers, or using the main thread and setImmediate.\r",
							" *\r",
							" * @param state the key-pair generation state.\r",
							" * @param [options] options for key-pair generation:\r",
							" *          workerScript the worker script URL.\r",
							" *          workers the number of web workers (if supported) to use,\r",
							" *            (default: 2, -1 to use estimated cores minus one).\r",
							" *          workLoad the size of the work load, ie: number of possible prime\r",
							" *            numbers for each web worker to check per work assignment,\r",
							" *            (default: 100).\r",
							" * @param callback(err, keypair) called once the operation completes.\r",
							" */\r",
							"function _generateKeyPair(state, options, callback) {\r",
							"  if(typeof options === 'function') {\r",
							"    callback = options;\r",
							"    options = {};\r",
							"  }\r",
							"  options = options || {};\r",
							"\r",
							"  var opts = {\r",
							"    algorithm: {\r",
							"      name: options.algorithm || 'PRIMEINC',\r",
							"      options: {\r",
							"        workers: options.workers || 2,\r",
							"        workLoad: options.workLoad || 100,\r",
							"        workerScript: options.workerScript\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"  if('prng' in options) {\r",
							"    opts.prng = options.prng;\r",
							"  }\r",
							"\r",
							"  generate();\r",
							"\r",
							"  function generate() {\r",
							"    // find p and then q (done in series to simplify)\r",
							"    getPrime(state.pBits, function(err, num) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"      state.p = num;\r",
							"      if(state.q !== null) {\r",
							"        return finish(err, state.q);\r",
							"      }\r",
							"      getPrime(state.qBits, finish);\r",
							"    });\r",
							"  }\r",
							"\r",
							"  function getPrime(bits, callback) {\r",
							"    forge.prime.generateProbablePrime(bits, opts, callback);\r",
							"  }\r",
							"\r",
							"  function finish(err, num) {\r",
							"    if(err) {\r",
							"      return callback(err);\r",
							"    }\r",
							"\r",
							"    // set q\r",
							"    state.q = num;\r",
							"\r",
							"    // ensure p is larger than q (swap them if not)\r",
							"    if(state.p.compareTo(state.q) < 0) {\r",
							"      var tmp = state.p;\r",
							"      state.p = state.q;\r",
							"      state.q = tmp;\r",
							"    }\r",
							"\r",
							"    // ensure p is coprime with e\r",
							"    if(state.p.subtract(BigInteger.ONE).gcd(state.e)\r",
							"      .compareTo(BigInteger.ONE) !== 0) {\r",
							"      state.p = null;\r",
							"      generate();\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // ensure q is coprime with e\r",
							"    if(state.q.subtract(BigInteger.ONE).gcd(state.e)\r",
							"      .compareTo(BigInteger.ONE) !== 0) {\r",
							"      state.q = null;\r",
							"      getPrime(state.qBits, finish);\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // compute phi: (p - 1)(q - 1) (Euler's totient function)\r",
							"    state.p1 = state.p.subtract(BigInteger.ONE);\r",
							"    state.q1 = state.q.subtract(BigInteger.ONE);\r",
							"    state.phi = state.p1.multiply(state.q1);\r",
							"\r",
							"    // ensure e and phi are coprime\r",
							"    if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\r",
							"      // phi and e aren't coprime, so generate a new p and q\r",
							"      state.p = state.q = null;\r",
							"      generate();\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // create n, ensure n is has the right number of bits\r",
							"    state.n = state.p.multiply(state.q);\r",
							"    if(state.n.bitLength() !== state.bits) {\r",
							"      // failed, get new q\r",
							"      state.q = null;\r",
							"      getPrime(state.qBits, finish);\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // set keys\r",
							"    var d = state.e.modInverse(state.phi);\r",
							"    state.keys = {\r",
							"      privateKey: pki.rsa.setPrivateKey(\r",
							"        state.n, state.e, d, state.p, state.q,\r",
							"        d.mod(state.p1), d.mod(state.q1),\r",
							"        state.q.modInverse(state.p)),\r",
							"      publicKey: pki.rsa.setPublicKey(state.n, state.e)\r",
							"    };\r",
							"\r",
							"    callback(null, state.keys);\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a positive BigInteger into 2's-complement big-endian bytes.\r",
							" *\r",
							" * @param b the big integer to convert.\r",
							" *\r",
							" * @return the bytes.\r",
							" */\r",
							"function _bnToBytes(b) {\r",
							"  // prepend 0x00 if first byte >= 0x80\r",
							"  var hex = b.toString(16);\r",
							"  if(hex[0] >= '8') {\r",
							"    hex = '00' + hex;\r",
							"  }\r",
							"  var bytes = forge.util.hexToBytes(hex);\r",
							"\r",
							"  // ensure integer is minimally-encoded\r",
							"  if(bytes.length > 1 &&\r",
							"    // leading 0x00 for positive integer\r",
							"    ((bytes.charCodeAt(0) === 0 &&\r",
							"    (bytes.charCodeAt(1) & 0x80) === 0) ||\r",
							"    // leading 0xFF for negative integer\r",
							"    (bytes.charCodeAt(0) === 0xFF &&\r",
							"    (bytes.charCodeAt(1) & 0x80) === 0x80))) {\r",
							"    return bytes.substr(1);\r",
							"  }\r",
							"  return bytes;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Returns the required number of Miller-Rabin tests to generate a\r",
							" * prime with an error probability of (1/2)^80.\r",
							" *\r",
							" * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\r",
							" *\r",
							" * @param bits the bit size.\r",
							" *\r",
							" * @return the required number of iterations.\r",
							" */\r",
							"function _getMillerRabinTests(bits) {\r",
							"  if(bits <= 100) return 27;\r",
							"  if(bits <= 150) return 18;\r",
							"  if(bits <= 200) return 15;\r",
							"  if(bits <= 250) return 12;\r",
							"  if(bits <= 300) return 9;\r",
							"  if(bits <= 350) return 8;\r",
							"  if(bits <= 400) return 7;\r",
							"  if(bits <= 500) return 6;\r",
							"  if(bits <= 600) return 5;\r",
							"  if(bits <= 800) return 4;\r",
							"  if(bits <= 1250) return 3;\r",
							"  return 2;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Performs feature detection on the SubtleCrypto interface.\r",
							" *\r",
							" * @param fn the feature (function) to detect.\r",
							" *\r",
							" * @return true if detected, false if not.\r",
							" */\r",
							"function _detectSubtleCrypto(fn) {\r",
							"  return (typeof window !== 'undefined' &&\r",
							"    typeof window.crypto === 'object' &&\r",
							"    typeof window.crypto.subtle === 'object' &&\r",
							"    typeof window.crypto.subtle[fn] === 'function');\r",
							"}\r",
							"\r",
							"/**\r",
							" * Performs feature detection on the deprecated Microsoft Internet Explorer\r",
							" * outdated SubtleCrypto interface. This function should only be used after\r",
							" * checking for the modern, standard SubtleCrypto interface.\r",
							" *\r",
							" * @param fn the feature (function) to detect.\r",
							" *\r",
							" * @return true if detected, false if not.\r",
							" */\r",
							"function _detectSubtleMsCrypto(fn) {\r",
							"  return (typeof window !== 'undefined' &&\r",
							"    typeof window.msCrypto === 'object' &&\r",
							"    typeof window.msCrypto.subtle === 'object' &&\r",
							"    typeof window.msCrypto.subtle[fn] === 'function');\r",
							"}\r",
							"\r",
							"function _intToUint8Array(x) {\r",
							"  var bytes = forge.util.hexToBytes(x.toString(16));\r",
							"  var buffer = new Uint8Array(bytes.length);\r",
							"  for(var i = 0; i < bytes.length; ++i) {\r",
							"    buffer[i] = bytes.charCodeAt(i);\r",
							"  }\r",
							"  return buffer;\r",
							"}\r",
							"\r",
							"function _privateKeyFromJwk(jwk) {\r",
							"  if(jwk.kty !== 'RSA') {\r",
							"    throw new Error(\r",
							"      'Unsupported key algorithm \"' + jwk.kty + '\"; algorithm must be \"RSA\".');\r",
							"  }\r",
							"  return pki.setRsaPrivateKey(\r",
							"    _base64ToBigInt(jwk.n),\r",
							"    _base64ToBigInt(jwk.e),\r",
							"    _base64ToBigInt(jwk.d),\r",
							"    _base64ToBigInt(jwk.p),\r",
							"    _base64ToBigInt(jwk.q),\r",
							"    _base64ToBigInt(jwk.dp),\r",
							"    _base64ToBigInt(jwk.dq),\r",
							"    _base64ToBigInt(jwk.qi));\r",
							"}\r",
							"\r",
							"function _publicKeyFromJwk(jwk) {\r",
							"  if(jwk.kty !== 'RSA') {\r",
							"    throw new Error('Key algorithm must be \"RSA\".');\r",
							"  }\r",
							"  return pki.setRsaPublicKey(\r",
							"    _base64ToBigInt(jwk.n),\r",
							"    _base64ToBigInt(jwk.e));\r",
							"}\r",
							"\r",
							"function _base64ToBigInt(b64) {\r",
							"  return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 12 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"// Copyright (c) 2005  Tom Wu\r",
							"// All Rights Reserved.\r",
							"// See \"LICENSE\" for details.\r",
							"\r",
							"// Basic JavaScript BN library - subset useful for RSA encryption.\r",
							"\r",
							"/*\r",
							"Licensing (LICENSE)\r",
							"-------------------\r",
							"\r",
							"This software is covered under the following copyright:\r",
							"*/\r",
							"/*\r",
							" * Copyright (c) 2003-2005  Tom Wu\r",
							" * All Rights Reserved.\r",
							" *\r",
							" * Permission is hereby granted, free of charge, to any person obtaining\r",
							" * a copy of this software and associated documentation files (the\r",
							" * \"Software\"), to deal in the Software without restriction, including\r",
							" * without limitation the rights to use, copy, modify, merge, publish,\r",
							" * distribute, sublicense, and/or sell copies of the Software, and to\r",
							" * permit persons to whom the Software is furnished to do so, subject to\r",
							" * the following conditions:\r",
							" *\r",
							" * The above copyright notice and this permission notice shall be\r",
							" * included in all copies or substantial portions of the Software.\r",
							" *\r",
							" * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\r",
							" * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\r",
							" * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\r",
							" *\r",
							" * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\r",
							" * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\r",
							" * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\r",
							" * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\r",
							" * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r",
							" *\r",
							" * In addition, the following condition applies:\r",
							" *\r",
							" * All redistributions must retain an intact copy of this copyright notice\r",
							" * and disclaimer.\r",
							" */\r",
							"/*\r",
							"Address all questions regarding this license to:\r",
							"\r",
							"  Tom Wu\r",
							"  tjw@cs.Stanford.EDU\r",
							"*/\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"module.exports = forge.jsbn = forge.jsbn || {};\r",
							"\r",
							"// Bits per digit\r",
							"var dbits;\r",
							"\r",
							"// JavaScript engine analysis\r",
							"var canary = 0xdeadbeefcafe;\r",
							"var j_lm = ((canary&0xffffff)==0xefcafe);\r",
							"\r",
							"// (public) Constructor\r",
							"function BigInteger(a,b,c) {\r",
							"  this.data = [];\r",
							"  if(a != null)\r",
							"    if(\"number\" == typeof a) this.fromNumber(a,b,c);\r",
							"    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\r",
							"    else this.fromString(a,b);\r",
							"}\r",
							"forge.jsbn.BigInteger = BigInteger;\r",
							"\r",
							"// return new, unset BigInteger\r",
							"function nbi() { return new BigInteger(null); }\r",
							"\r",
							"// am: Compute w_j += (x*this_i), propagate carries,\r",
							"// c is initial carry, returns final carry.\r",
							"// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\r",
							"// We need to select the fastest one that works in this environment.\r",
							"\r",
							"// am1: use a single mult and divide to get the high bits,\r",
							"// max digit bits should be 26 because\r",
							"// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\r",
							"function am1(i,x,w,j,c,n) {\r",
							"  while(--n >= 0) {\r",
							"    var v = x*this.data[i++]+w.data[j]+c;\r",
							"    c = Math.floor(v/0x4000000);\r",
							"    w.data[j++] = v&0x3ffffff;\r",
							"  }\r",
							"  return c;\r",
							"}\r",
							"// am2 avoids a big mult-and-extract completely.\r",
							"// Max digit bits should be <= 30 because we do bitwise ops\r",
							"// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\r",
							"function am2(i,x,w,j,c,n) {\r",
							"  var xl = x&0x7fff, xh = x>>15;\r",
							"  while(--n >= 0) {\r",
							"    var l = this.data[i]&0x7fff;\r",
							"    var h = this.data[i++]>>15;\r",
							"    var m = xh*l+h*xl;\r",
							"    l = xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);\r",
							"    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\r",
							"    w.data[j++] = l&0x3fffffff;\r",
							"  }\r",
							"  return c;\r",
							"}\r",
							"// Alternately, set max digit bits to 28 since some\r",
							"// browsers slow down when dealing with 32-bit numbers.\r",
							"function am3(i,x,w,j,c,n) {\r",
							"  var xl = x&0x3fff, xh = x>>14;\r",
							"  while(--n >= 0) {\r",
							"    var l = this.data[i]&0x3fff;\r",
							"    var h = this.data[i++]>>14;\r",
							"    var m = xh*l+h*xl;\r",
							"    l = xl*l+((m&0x3fff)<<14)+w.data[j]+c;\r",
							"    c = (l>>28)+(m>>14)+xh*h;\r",
							"    w.data[j++] = l&0xfffffff;\r",
							"  }\r",
							"  return c;\r",
							"}\r",
							"\r",
							"// node.js (no browser)\r",
							"if(typeof(navigator) === 'undefined')\r",
							"{\r",
							"   BigInteger.prototype.am = am3;\r",
							"   dbits = 28;\r",
							"} else if(j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\r",
							"  BigInteger.prototype.am = am2;\r",
							"  dbits = 30;\r",
							"} else if(j_lm && (navigator.appName != \"Netscape\")) {\r",
							"  BigInteger.prototype.am = am1;\r",
							"  dbits = 26;\r",
							"} else { // Mozilla/Netscape seems to prefer am3\r",
							"  BigInteger.prototype.am = am3;\r",
							"  dbits = 28;\r",
							"}\r",
							"\r",
							"BigInteger.prototype.DB = dbits;\r",
							"BigInteger.prototype.DM = ((1<<dbits)-1);\r",
							"BigInteger.prototype.DV = (1<<dbits);\r",
							"\r",
							"var BI_FP = 52;\r",
							"BigInteger.prototype.FV = Math.pow(2,BI_FP);\r",
							"BigInteger.prototype.F1 = BI_FP-dbits;\r",
							"BigInteger.prototype.F2 = 2*dbits-BI_FP;\r",
							"\r",
							"// Digit conversions\r",
							"var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r",
							"var BI_RC = new Array();\r",
							"var rr,vv;\r",
							"rr = \"0\".charCodeAt(0);\r",
							"for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\r",
							"rr = \"a\".charCodeAt(0);\r",
							"for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r",
							"rr = \"A\".charCodeAt(0);\r",
							"for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r",
							"\r",
							"function int2char(n) { return BI_RM.charAt(n); }\r",
							"function intAt(s,i) {\r",
							"  var c = BI_RC[s.charCodeAt(i)];\r",
							"  return (c==null)?-1:c;\r",
							"}\r",
							"\r",
							"// (protected) copy this to r\r",
							"function bnpCopyTo(r) {\r",
							"  for(var i = this.t-1; i >= 0; --i) r.data[i] = this.data[i];\r",
							"  r.t = this.t;\r",
							"  r.s = this.s;\r",
							"}\r",
							"\r",
							"// (protected) set from integer value x, -DV <= x < DV\r",
							"function bnpFromInt(x) {\r",
							"  this.t = 1;\r",
							"  this.s = (x<0)?-1:0;\r",
							"  if(x > 0) this.data[0] = x;\r",
							"  else if(x < -1) this.data[0] = x+this.DV;\r",
							"  else this.t = 0;\r",
							"}\r",
							"\r",
							"// return bigint initialized to value\r",
							"function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\r",
							"\r",
							"// (protected) set from string and radix\r",
							"function bnpFromString(s,b) {\r",
							"  var k;\r",
							"  if(b == 16) k = 4;\r",
							"  else if(b == 8) k = 3;\r",
							"  else if(b == 256) k = 8; // byte array\r",
							"  else if(b == 2) k = 1;\r",
							"  else if(b == 32) k = 5;\r",
							"  else if(b == 4) k = 2;\r",
							"  else { this.fromRadix(s,b); return; }\r",
							"  this.t = 0;\r",
							"  this.s = 0;\r",
							"  var i = s.length, mi = false, sh = 0;\r",
							"  while(--i >= 0) {\r",
							"    var x = (k==8)?s[i]&0xff:intAt(s,i);\r",
							"    if(x < 0) {\r",
							"      if(s.charAt(i) == \"-\") mi = true;\r",
							"      continue;\r",
							"    }\r",
							"    mi = false;\r",
							"    if(sh == 0)\r",
							"      this.data[this.t++] = x;\r",
							"    else if(sh+k > this.DB) {\r",
							"      this.data[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\r",
							"      this.data[this.t++] = (x>>(this.DB-sh));\r",
							"    } else\r",
							"      this.data[this.t-1] |= x<<sh;\r",
							"    sh += k;\r",
							"    if(sh >= this.DB) sh -= this.DB;\r",
							"  }\r",
							"  if(k == 8 && (s[0]&0x80) != 0) {\r",
							"    this.s = -1;\r",
							"    if(sh > 0) this.data[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\r",
							"  }\r",
							"  this.clamp();\r",
							"  if(mi) BigInteger.ZERO.subTo(this,this);\r",
							"}\r",
							"\r",
							"// (protected) clamp off excess high words\r",
							"function bnpClamp() {\r",
							"  var c = this.s&this.DM;\r",
							"  while(this.t > 0 && this.data[this.t-1] == c) --this.t;\r",
							"}\r",
							"\r",
							"// (public) return string representation in given radix\r",
							"function bnToString(b) {\r",
							"  if(this.s < 0) return \"-\"+this.negate().toString(b);\r",
							"  var k;\r",
							"  if(b == 16) k = 4;\r",
							"  else if(b == 8) k = 3;\r",
							"  else if(b == 2) k = 1;\r",
							"  else if(b == 32) k = 5;\r",
							"  else if(b == 4) k = 2;\r",
							"  else return this.toRadix(b);\r",
							"  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\r",
							"  var p = this.DB-(i*this.DB)%k;\r",
							"  if(i-- > 0) {\r",
							"    if(p < this.DB && (d = this.data[i]>>p) > 0) { m = true; r = int2char(d); }\r",
							"    while(i >= 0) {\r",
							"      if(p < k) {\r",
							"        d = (this.data[i]&((1<<p)-1))<<(k-p);\r",
							"        d |= this.data[--i]>>(p+=this.DB-k);\r",
							"      } else {\r",
							"        d = (this.data[i]>>(p-=k))&km;\r",
							"        if(p <= 0) { p += this.DB; --i; }\r",
							"      }\r",
							"      if(d > 0) m = true;\r",
							"      if(m) r += int2char(d);\r",
							"    }\r",
							"  }\r",
							"  return m?r:\"0\";\r",
							"}\r",
							"\r",
							"// (public) -this\r",
							"function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\r",
							"\r",
							"// (public) |this|\r",
							"function bnAbs() { return (this.s<0)?this.negate():this; }\r",
							"\r",
							"// (public) return + if this > a, - if this < a, 0 if equal\r",
							"function bnCompareTo(a) {\r",
							"  var r = this.s-a.s;\r",
							"  if(r != 0) return r;\r",
							"  var i = this.t;\r",
							"  r = i-a.t;\r",
							"  if(r != 0) return (this.s<0)?-r:r;\r",
							"  while(--i >= 0) if((r=this.data[i]-a.data[i]) != 0) return r;\r",
							"  return 0;\r",
							"}\r",
							"\r",
							"// returns bit length of the integer x\r",
							"function nbits(x) {\r",
							"  var r = 1, t;\r",
							"  if((t=x>>>16) != 0) { x = t; r += 16; }\r",
							"  if((t=x>>8) != 0) { x = t; r += 8; }\r",
							"  if((t=x>>4) != 0) { x = t; r += 4; }\r",
							"  if((t=x>>2) != 0) { x = t; r += 2; }\r",
							"  if((t=x>>1) != 0) { x = t; r += 1; }\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// (public) return the number of bits in \"this\"\r",
							"function bnBitLength() {\r",
							"  if(this.t <= 0) return 0;\r",
							"  return this.DB*(this.t-1)+nbits(this.data[this.t-1]^(this.s&this.DM));\r",
							"}\r",
							"\r",
							"// (protected) r = this << n*DB\r",
							"function bnpDLShiftTo(n,r) {\r",
							"  var i;\r",
							"  for(i = this.t-1; i >= 0; --i) r.data[i+n] = this.data[i];\r",
							"  for(i = n-1; i >= 0; --i) r.data[i] = 0;\r",
							"  r.t = this.t+n;\r",
							"  r.s = this.s;\r",
							"}\r",
							"\r",
							"// (protected) r = this >> n*DB\r",
							"function bnpDRShiftTo(n,r) {\r",
							"  for(var i = n; i < this.t; ++i) r.data[i-n] = this.data[i];\r",
							"  r.t = Math.max(this.t-n,0);\r",
							"  r.s = this.s;\r",
							"}\r",
							"\r",
							"// (protected) r = this << n\r",
							"function bnpLShiftTo(n,r) {\r",
							"  var bs = n%this.DB;\r",
							"  var cbs = this.DB-bs;\r",
							"  var bm = (1<<cbs)-1;\r",
							"  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\r",
							"  for(i = this.t-1; i >= 0; --i) {\r",
							"    r.data[i+ds+1] = (this.data[i]>>cbs)|c;\r",
							"    c = (this.data[i]&bm)<<bs;\r",
							"  }\r",
							"  for(i = ds-1; i >= 0; --i) r.data[i] = 0;\r",
							"  r.data[ds] = c;\r",
							"  r.t = this.t+ds+1;\r",
							"  r.s = this.s;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) r = this >> n\r",
							"function bnpRShiftTo(n,r) {\r",
							"  r.s = this.s;\r",
							"  var ds = Math.floor(n/this.DB);\r",
							"  if(ds >= this.t) { r.t = 0; return; }\r",
							"  var bs = n%this.DB;\r",
							"  var cbs = this.DB-bs;\r",
							"  var bm = (1<<bs)-1;\r",
							"  r.data[0] = this.data[ds]>>bs;\r",
							"  for(var i = ds+1; i < this.t; ++i) {\r",
							"    r.data[i-ds-1] |= (this.data[i]&bm)<<cbs;\r",
							"    r.data[i-ds] = this.data[i]>>bs;\r",
							"  }\r",
							"  if(bs > 0) r.data[this.t-ds-1] |= (this.s&bm)<<cbs;\r",
							"  r.t = this.t-ds;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) r = this - a\r",
							"function bnpSubTo(a,r) {\r",
							"  var i = 0, c = 0, m = Math.min(a.t,this.t);\r",
							"  while(i < m) {\r",
							"    c += this.data[i]-a.data[i];\r",
							"    r.data[i++] = c&this.DM;\r",
							"    c >>= this.DB;\r",
							"  }\r",
							"  if(a.t < this.t) {\r",
							"    c -= a.s;\r",
							"    while(i < this.t) {\r",
							"      c += this.data[i];\r",
							"      r.data[i++] = c&this.DM;\r",
							"      c >>= this.DB;\r",
							"    }\r",
							"    c += this.s;\r",
							"  } else {\r",
							"    c += this.s;\r",
							"    while(i < a.t) {\r",
							"      c -= a.data[i];\r",
							"      r.data[i++] = c&this.DM;\r",
							"      c >>= this.DB;\r",
							"    }\r",
							"    c -= a.s;\r",
							"  }\r",
							"  r.s = (c<0)?-1:0;\r",
							"  if(c < -1) r.data[i++] = this.DV+c;\r",
							"  else if(c > 0) r.data[i++] = c;\r",
							"  r.t = i;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) r = this * a, r != this,a (HAC 14.12)\r",
							"// \"this\" should be the larger one if appropriate.\r",
							"function bnpMultiplyTo(a,r) {\r",
							"  var x = this.abs(), y = a.abs();\r",
							"  var i = x.t;\r",
							"  r.t = i+y.t;\r",
							"  while(--i >= 0) r.data[i] = 0;\r",
							"  for(i = 0; i < y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);\r",
							"  r.s = 0;\r",
							"  r.clamp();\r",
							"  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\r",
							"}\r",
							"\r",
							"// (protected) r = this^2, r != this (HAC 14.16)\r",
							"function bnpSquareTo(r) {\r",
							"  var x = this.abs();\r",
							"  var i = r.t = 2*x.t;\r",
							"  while(--i >= 0) r.data[i] = 0;\r",
							"  for(i = 0; i < x.t-1; ++i) {\r",
							"    var c = x.am(i,x.data[i],r,2*i,0,1);\r",
							"    if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\r",
							"      r.data[i+x.t] -= x.DV;\r",
							"      r.data[i+x.t+1] = 1;\r",
							"    }\r",
							"  }\r",
							"  if(r.t > 0) r.data[r.t-1] += x.am(i,x.data[i],r,2*i,0,1);\r",
							"  r.s = 0;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\r",
							"// r != q, this != m.  q or r may be null.\r",
							"function bnpDivRemTo(m,q,r) {\r",
							"  var pm = m.abs();\r",
							"  if(pm.t <= 0) return;\r",
							"  var pt = this.abs();\r",
							"  if(pt.t < pm.t) {\r",
							"    if(q != null) q.fromInt(0);\r",
							"    if(r != null) this.copyTo(r);\r",
							"    return;\r",
							"  }\r",
							"  if(r == null) r = nbi();\r",
							"  var y = nbi(), ts = this.s, ms = m.s;\r",
							"  var nsh = this.DB-nbits(pm.data[pm.t-1]);\t// normalize modulus\r",
							"  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }\r",
							"  var ys = y.t;\r",
							"  var y0 = y.data[ys-1];\r",
							"  if(y0 == 0) return;\r",
							"  var yt = y0*(1<<this.F1)+((ys>1)?y.data[ys-2]>>this.F2:0);\r",
							"  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\r",
							"  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\r",
							"  y.dlShiftTo(j,t);\r",
							"  if(r.compareTo(t) >= 0) {\r",
							"    r.data[r.t++] = 1;\r",
							"    r.subTo(t,r);\r",
							"  }\r",
							"  BigInteger.ONE.dlShiftTo(ys,t);\r",
							"  t.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\r",
							"  while(y.t < ys) y.data[y.t++] = 0;\r",
							"  while(--j >= 0) {\r",
							"    // Estimate quotient digit\r",
							"    var qd = (r.data[--i]==y0)?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);\r",
							"    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\r",
							"      y.dlShiftTo(j,t);\r",
							"      r.subTo(t,r);\r",
							"      while(r.data[i] < --qd) r.subTo(t,r);\r",
							"    }\r",
							"  }\r",
							"  if(q != null) {\r",
							"    r.drShiftTo(ys,q);\r",
							"    if(ts != ms) BigInteger.ZERO.subTo(q,q);\r",
							"  }\r",
							"  r.t = ys;\r",
							"  r.clamp();\r",
							"  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\r",
							"  if(ts < 0) BigInteger.ZERO.subTo(r,r);\r",
							"}\r",
							"\r",
							"// (public) this mod a\r",
							"function bnMod(a) {\r",
							"  var r = nbi();\r",
							"  this.abs().divRemTo(a,null,r);\r",
							"  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// Modular reduction using \"classic\" algorithm\r",
							"function Classic(m) { this.m = m; }\r",
							"function cConvert(x) {\r",
							"  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\r",
							"  else return x;\r",
							"}\r",
							"function cRevert(x) { return x; }\r",
							"function cReduce(x) { x.divRemTo(this.m,null,x); }\r",
							"function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r",
							"function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r",
							"\r",
							"Classic.prototype.convert = cConvert;\r",
							"Classic.prototype.revert = cRevert;\r",
							"Classic.prototype.reduce = cReduce;\r",
							"Classic.prototype.mulTo = cMulTo;\r",
							"Classic.prototype.sqrTo = cSqrTo;\r",
							"\r",
							"// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\r",
							"// justification:\r",
							"//         xy == 1 (mod m)\r",
							"//         xy =  1+km\r",
							"//   xy(2-xy) = (1+km)(1-km)\r",
							"// x[y(2-xy)] = 1-k^2m^2\r",
							"// x[y(2-xy)] == 1 (mod m^2)\r",
							"// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\r",
							"// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\r",
							"// JS multiply \"overflows\" differently from C/C++, so care is needed here.\r",
							"function bnpInvDigit() {\r",
							"  if(this.t < 1) return 0;\r",
							"  var x = this.data[0];\r",
							"  if((x&1) == 0) return 0;\r",
							"  var y = x&3;\t\t// y == 1/x mod 2^2\r",
							"  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\r",
							"  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\r",
							"  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\r",
							"  // last step - calculate inverse mod DV directly;\r",
							"  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\r",
							"  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\r",
							"  // we really want the negative inverse, and -DV < y < DV\r",
							"  return (y>0)?this.DV-y:-y;\r",
							"}\r",
							"\r",
							"// Montgomery reduction\r",
							"function Montgomery(m) {\r",
							"  this.m = m;\r",
							"  this.mp = m.invDigit();\r",
							"  this.mpl = this.mp&0x7fff;\r",
							"  this.mph = this.mp>>15;\r",
							"  this.um = (1<<(m.DB-15))-1;\r",
							"  this.mt2 = 2*m.t;\r",
							"}\r",
							"\r",
							"// xR mod m\r",
							"function montConvert(x) {\r",
							"  var r = nbi();\r",
							"  x.abs().dlShiftTo(this.m.t,r);\r",
							"  r.divRemTo(this.m,null,r);\r",
							"  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// x/R mod m\r",
							"function montRevert(x) {\r",
							"  var r = nbi();\r",
							"  x.copyTo(r);\r",
							"  this.reduce(r);\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// x = x/R mod m (HAC 14.32)\r",
							"function montReduce(x) {\r",
							"  while(x.t <= this.mt2)\t// pad x so am has enough room later\r",
							"    x.data[x.t++] = 0;\r",
							"  for(var i = 0; i < this.m.t; ++i) {\r",
							"    // faster way of calculating u0 = x.data[i]*mp mod DV\r",
							"    var j = x.data[i]&0x7fff;\r",
							"    var u0 = (j*this.mpl+(((j*this.mph+(x.data[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\r",
							"    // use am to combine the multiply-shift-add into one call\r",
							"    j = i+this.m.t;\r",
							"    x.data[j] += this.m.am(0,u0,x,i,0,this.m.t);\r",
							"    // propagate carry\r",
							"    while(x.data[j] >= x.DV) { x.data[j] -= x.DV; x.data[++j]++; }\r",
							"  }\r",
							"  x.clamp();\r",
							"  x.drShiftTo(this.m.t,x);\r",
							"  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r",
							"}\r",
							"\r",
							"// r = \"x^2/R mod m\"; x != r\r",
							"function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r",
							"\r",
							"// r = \"xy/R mod m\"; x,y != r\r",
							"function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r",
							"\r",
							"Montgomery.prototype.convert = montConvert;\r",
							"Montgomery.prototype.revert = montRevert;\r",
							"Montgomery.prototype.reduce = montReduce;\r",
							"Montgomery.prototype.mulTo = montMulTo;\r",
							"Montgomery.prototype.sqrTo = montSqrTo;\r",
							"\r",
							"// (protected) true iff this is even\r",
							"function bnpIsEven() { return ((this.t>0)?(this.data[0]&1):this.s) == 0; }\r",
							"\r",
							"// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\r",
							"function bnpExp(e,z) {\r",
							"  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\r",
							"  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\r",
							"  g.copyTo(r);\r",
							"  while(--i >= 0) {\r",
							"    z.sqrTo(r,r2);\r",
							"    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\r",
							"    else { var t = r; r = r2; r2 = t; }\r",
							"  }\r",
							"  return z.revert(r);\r",
							"}\r",
							"\r",
							"// (public) this^e % m, 0 <= e < 2^32\r",
							"function bnModPowInt(e,m) {\r",
							"  var z;\r",
							"  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\r",
							"  return this.exp(e,z);\r",
							"}\r",
							"\r",
							"// protected\r",
							"BigInteger.prototype.copyTo = bnpCopyTo;\r",
							"BigInteger.prototype.fromInt = bnpFromInt;\r",
							"BigInteger.prototype.fromString = bnpFromString;\r",
							"BigInteger.prototype.clamp = bnpClamp;\r",
							"BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\r",
							"BigInteger.prototype.drShiftTo = bnpDRShiftTo;\r",
							"BigInteger.prototype.lShiftTo = bnpLShiftTo;\r",
							"BigInteger.prototype.rShiftTo = bnpRShiftTo;\r",
							"BigInteger.prototype.subTo = bnpSubTo;\r",
							"BigInteger.prototype.multiplyTo = bnpMultiplyTo;\r",
							"BigInteger.prototype.squareTo = bnpSquareTo;\r",
							"BigInteger.prototype.divRemTo = bnpDivRemTo;\r",
							"BigInteger.prototype.invDigit = bnpInvDigit;\r",
							"BigInteger.prototype.isEven = bnpIsEven;\r",
							"BigInteger.prototype.exp = bnpExp;\r",
							"\r",
							"// public\r",
							"BigInteger.prototype.toString = bnToString;\r",
							"BigInteger.prototype.negate = bnNegate;\r",
							"BigInteger.prototype.abs = bnAbs;\r",
							"BigInteger.prototype.compareTo = bnCompareTo;\r",
							"BigInteger.prototype.bitLength = bnBitLength;\r",
							"BigInteger.prototype.mod = bnMod;\r",
							"BigInteger.prototype.modPowInt = bnModPowInt;\r",
							"\r",
							"// \"constants\"\r",
							"BigInteger.ZERO = nbv(0);\r",
							"BigInteger.ONE = nbv(1);\r",
							"\r",
							"// jsbn2 lib\r",
							"\r",
							"//Copyright (c) 2005-2009  Tom Wu\r",
							"//All Rights Reserved.\r",
							"//See \"LICENSE\" for details (See jsbn.js for LICENSE).\r",
							"\r",
							"//Extended JavaScript BN functions, required for RSA private ops.\r",
							"\r",
							"//Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\r",
							"\r",
							"//(public)\r",
							"function bnClone() { var r = nbi(); this.copyTo(r); return r; }\r",
							"\r",
							"//(public) return value as integer\r",
							"function bnIntValue() {\r",
							"if(this.s < 0) {\r",
							" if(this.t == 1) return this.data[0]-this.DV;\r",
							" else if(this.t == 0) return -1;\r",
							"} else if(this.t == 1) return this.data[0];\r",
							"else if(this.t == 0) return 0;\r",
							"// assumes 16 < DB < 32\r",
							"return ((this.data[1]&((1<<(32-this.DB))-1))<<this.DB)|this.data[0];\r",
							"}\r",
							"\r",
							"//(public) return value as byte\r",
							"function bnByteValue() { return (this.t==0)?this.s:(this.data[0]<<24)>>24; }\r",
							"\r",
							"//(public) return value as short (assumes DB>=16)\r",
							"function bnShortValue() { return (this.t==0)?this.s:(this.data[0]<<16)>>16; }\r",
							"\r",
							"//(protected) return x s.t. r^x < DV\r",
							"function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\r",
							"\r",
							"//(public) 0 if this == 0, 1 if this > 0\r",
							"function bnSigNum() {\r",
							"if(this.s < 0) return -1;\r",
							"else if(this.t <= 0 || (this.t == 1 && this.data[0] <= 0)) return 0;\r",
							"else return 1;\r",
							"}\r",
							"\r",
							"//(protected) convert to radix string\r",
							"function bnpToRadix(b) {\r",
							"if(b == null) b = 10;\r",
							"if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\r",
							"var cs = this.chunkSize(b);\r",
							"var a = Math.pow(b,cs);\r",
							"var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\r",
							"this.divRemTo(d,y,z);\r",
							"while(y.signum() > 0) {\r",
							" r = (a+z.intValue()).toString(b).substr(1) + r;\r",
							" y.divRemTo(d,y,z);\r",
							"}\r",
							"return z.intValue().toString(b) + r;\r",
							"}\r",
							"\r",
							"//(protected) convert from radix string\r",
							"function bnpFromRadix(s,b) {\r",
							"this.fromInt(0);\r",
							"if(b == null) b = 10;\r",
							"var cs = this.chunkSize(b);\r",
							"var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\r",
							"for(var i = 0; i < s.length; ++i) {\r",
							" var x = intAt(s,i);\r",
							" if(x < 0) {\r",
							"   if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\r",
							"   continue;\r",
							" }\r",
							" w = b*w+x;\r",
							" if(++j >= cs) {\r",
							"   this.dMultiply(d);\r",
							"   this.dAddOffset(w,0);\r",
							"   j = 0;\r",
							"   w = 0;\r",
							" }\r",
							"}\r",
							"if(j > 0) {\r",
							" this.dMultiply(Math.pow(b,j));\r",
							" this.dAddOffset(w,0);\r",
							"}\r",
							"if(mi) BigInteger.ZERO.subTo(this,this);\r",
							"}\r",
							"\r",
							"//(protected) alternate constructor\r",
							"function bnpFromNumber(a,b,c) {\r",
							"if(\"number\" == typeof b) {\r",
							" // new BigInteger(int,int,RNG)\r",
							" if(a < 2) this.fromInt(1);\r",
							" else {\r",
							"   this.fromNumber(a,c);\r",
							"   if(!this.testBit(a-1))  // force MSB set\r",
							"     this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\r",
							"   if(this.isEven()) this.dAddOffset(1,0); // force odd\r",
							"   while(!this.isProbablePrime(b)) {\r",
							"     this.dAddOffset(2,0);\r",
							"     if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\r",
							"   }\r",
							" }\r",
							"} else {\r",
							" // new BigInteger(int,RNG)\r",
							" var x = new Array(), t = a&7;\r",
							" x.length = (a>>3)+1;\r",
							" b.nextBytes(x);\r",
							" if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\r",
							" this.fromString(x,256);\r",
							"}\r",
							"}\r",
							"\r",
							"//(public) convert to bigendian byte array\r",
							"function bnToByteArray() {\r",
							"var i = this.t, r = new Array();\r",
							"r[0] = this.s;\r",
							"var p = this.DB-(i*this.DB)%8, d, k = 0;\r",
							"if(i-- > 0) {\r",
							" if(p < this.DB && (d = this.data[i]>>p) != (this.s&this.DM)>>p)\r",
							"   r[k++] = d|(this.s<<(this.DB-p));\r",
							" while(i >= 0) {\r",
							"   if(p < 8) {\r",
							"     d = (this.data[i]&((1<<p)-1))<<(8-p);\r",
							"     d |= this.data[--i]>>(p+=this.DB-8);\r",
							"   } else {\r",
							"     d = (this.data[i]>>(p-=8))&0xff;\r",
							"     if(p <= 0) { p += this.DB; --i; }\r",
							"   }\r",
							"   if((d&0x80) != 0) d |= -256;\r",
							"   if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\r",
							"   if(k > 0 || d != this.s) r[k++] = d;\r",
							" }\r",
							"}\r",
							"return r;\r",
							"}\r",
							"\r",
							"function bnEquals(a) { return(this.compareTo(a)==0); }\r",
							"function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\r",
							"function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\r",
							"\r",
							"//(protected) r = this op a (bitwise)\r",
							"function bnpBitwiseTo(a,op,r) {\r",
							"var i, f, m = Math.min(a.t,this.t);\r",
							"for(i = 0; i < m; ++i) r.data[i] = op(this.data[i],a.data[i]);\r",
							"if(a.t < this.t) {\r",
							" f = a.s&this.DM;\r",
							" for(i = m; i < this.t; ++i) r.data[i] = op(this.data[i],f);\r",
							" r.t = this.t;\r",
							"} else {\r",
							" f = this.s&this.DM;\r",
							" for(i = m; i < a.t; ++i) r.data[i] = op(f,a.data[i]);\r",
							" r.t = a.t;\r",
							"}\r",
							"r.s = op(this.s,a.s);\r",
							"r.clamp();\r",
							"}\r",
							"\r",
							"//(public) this & a\r",
							"function op_and(x,y) { return x&y; }\r",
							"function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\r",
							"\r",
							"//(public) this | a\r",
							"function op_or(x,y) { return x|y; }\r",
							"function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\r",
							"\r",
							"//(public) this ^ a\r",
							"function op_xor(x,y) { return x^y; }\r",
							"function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\r",
							"\r",
							"//(public) this & ~a\r",
							"function op_andnot(x,y) { return x&~y; }\r",
							"function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\r",
							"\r",
							"//(public) ~this\r",
							"function bnNot() {\r",
							"var r = nbi();\r",
							"for(var i = 0; i < this.t; ++i) r.data[i] = this.DM&~this.data[i];\r",
							"r.t = this.t;\r",
							"r.s = ~this.s;\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) this << n\r",
							"function bnShiftLeft(n) {\r",
							"var r = nbi();\r",
							"if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) this >> n\r",
							"function bnShiftRight(n) {\r",
							"var r = nbi();\r",
							"if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//return index of lowest 1-bit in x, x < 2^31\r",
							"function lbit(x) {\r",
							"if(x == 0) return -1;\r",
							"var r = 0;\r",
							"if((x&0xffff) == 0) { x >>= 16; r += 16; }\r",
							"if((x&0xff) == 0) { x >>= 8; r += 8; }\r",
							"if((x&0xf) == 0) { x >>= 4; r += 4; }\r",
							"if((x&3) == 0) { x >>= 2; r += 2; }\r",
							"if((x&1) == 0) ++r;\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) returns index of lowest 1-bit (or -1 if none)\r",
							"function bnGetLowestSetBit() {\r",
							"for(var i = 0; i < this.t; ++i)\r",
							" if(this.data[i] != 0) return i*this.DB+lbit(this.data[i]);\r",
							"if(this.s < 0) return this.t*this.DB;\r",
							"return -1;\r",
							"}\r",
							"\r",
							"//return number of 1 bits in x\r",
							"function cbit(x) {\r",
							"var r = 0;\r",
							"while(x != 0) { x &= x-1; ++r; }\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) return number of set bits\r",
							"function bnBitCount() {\r",
							"var r = 0, x = this.s&this.DM;\r",
							"for(var i = 0; i < this.t; ++i) r += cbit(this.data[i]^x);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) true iff nth bit is set\r",
							"function bnTestBit(n) {\r",
							"var j = Math.floor(n/this.DB);\r",
							"if(j >= this.t) return(this.s!=0);\r",
							"return((this.data[j]&(1<<(n%this.DB)))!=0);\r",
							"}\r",
							"\r",
							"//(protected) this op (1<<n)\r",
							"function bnpChangeBit(n,op) {\r",
							"var r = BigInteger.ONE.shiftLeft(n);\r",
							"this.bitwiseTo(r,op,r);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) this | (1<<n)\r",
							"function bnSetBit(n) { return this.changeBit(n,op_or); }\r",
							"\r",
							"//(public) this & ~(1<<n)\r",
							"function bnClearBit(n) { return this.changeBit(n,op_andnot); }\r",
							"\r",
							"//(public) this ^ (1<<n)\r",
							"function bnFlipBit(n) { return this.changeBit(n,op_xor); }\r",
							"\r",
							"//(protected) r = this + a\r",
							"function bnpAddTo(a,r) {\r",
							"var i = 0, c = 0, m = Math.min(a.t,this.t);\r",
							"while(i < m) {\r",
							" c += this.data[i]+a.data[i];\r",
							" r.data[i++] = c&this.DM;\r",
							" c >>= this.DB;\r",
							"}\r",
							"if(a.t < this.t) {\r",
							" c += a.s;\r",
							" while(i < this.t) {\r",
							"   c += this.data[i];\r",
							"   r.data[i++] = c&this.DM;\r",
							"   c >>= this.DB;\r",
							" }\r",
							" c += this.s;\r",
							"} else {\r",
							" c += this.s;\r",
							" while(i < a.t) {\r",
							"   c += a.data[i];\r",
							"   r.data[i++] = c&this.DM;\r",
							"   c >>= this.DB;\r",
							" }\r",
							" c += a.s;\r",
							"}\r",
							"r.s = (c<0)?-1:0;\r",
							"if(c > 0) r.data[i++] = c;\r",
							"else if(c < -1) r.data[i++] = this.DV+c;\r",
							"r.t = i;\r",
							"r.clamp();\r",
							"}\r",
							"\r",
							"//(public) this + a\r",
							"function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\r",
							"\r",
							"//(public) this - a\r",
							"function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\r",
							"\r",
							"//(public) this * a\r",
							"function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\r",
							"\r",
							"//(public) this / a\r",
							"function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\r",
							"\r",
							"//(public) this % a\r",
							"function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\r",
							"\r",
							"//(public) [this/a,this%a]\r",
							"function bnDivideAndRemainder(a) {\r",
							"var q = nbi(), r = nbi();\r",
							"this.divRemTo(a,q,r);\r",
							"return new Array(q,r);\r",
							"}\r",
							"\r",
							"//(protected) this *= n, this >= 0, 1 < n < DV\r",
							"function bnpDMultiply(n) {\r",
							"this.data[this.t] = this.am(0,n-1,this,0,0,this.t);\r",
							"++this.t;\r",
							"this.clamp();\r",
							"}\r",
							"\r",
							"//(protected) this += n << w words, this >= 0\r",
							"function bnpDAddOffset(n,w) {\r",
							"if(n == 0) return;\r",
							"while(this.t <= w) this.data[this.t++] = 0;\r",
							"this.data[w] += n;\r",
							"while(this.data[w] >= this.DV) {\r",
							" this.data[w] -= this.DV;\r",
							" if(++w >= this.t) this.data[this.t++] = 0;\r",
							" ++this.data[w];\r",
							"}\r",
							"}\r",
							"\r",
							"//A \"null\" reducer\r",
							"function NullExp() {}\r",
							"function nNop(x) { return x; }\r",
							"function nMulTo(x,y,r) { x.multiplyTo(y,r); }\r",
							"function nSqrTo(x,r) { x.squareTo(r); }\r",
							"\r",
							"NullExp.prototype.convert = nNop;\r",
							"NullExp.prototype.revert = nNop;\r",
							"NullExp.prototype.mulTo = nMulTo;\r",
							"NullExp.prototype.sqrTo = nSqrTo;\r",
							"\r",
							"//(public) this^e\r",
							"function bnPow(e) { return this.exp(e,new NullExp()); }\r",
							"\r",
							"//(protected) r = lower n words of \"this * a\", a.t <= n\r",
							"//\"this\" should be the larger one if appropriate.\r",
							"function bnpMultiplyLowerTo(a,n,r) {\r",
							"var i = Math.min(this.t+a.t,n);\r",
							"r.s = 0; // assumes a,this >= 0\r",
							"r.t = i;\r",
							"while(i > 0) r.data[--i] = 0;\r",
							"var j;\r",
							"for(j = r.t-this.t; i < j; ++i) r.data[i+this.t] = this.am(0,a.data[i],r,i,0,this.t);\r",
							"for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a.data[i],r,i,0,n-i);\r",
							"r.clamp();\r",
							"}\r",
							"\r",
							"//(protected) r = \"this * a\" without lower n words, n > 0\r",
							"//\"this\" should be the larger one if appropriate.\r",
							"function bnpMultiplyUpperTo(a,n,r) {\r",
							"--n;\r",
							"var i = r.t = this.t+a.t-n;\r",
							"r.s = 0; // assumes a,this >= 0\r",
							"while(--i >= 0) r.data[i] = 0;\r",
							"for(i = Math.max(n-this.t,0); i < a.t; ++i)\r",
							" r.data[this.t+i-n] = this.am(n-i,a.data[i],r,0,0,this.t+i-n);\r",
							"r.clamp();\r",
							"r.drShiftTo(1,r);\r",
							"}\r",
							"\r",
							"//Barrett modular reduction\r",
							"function Barrett(m) {\r",
							"// setup Barrett\r",
							"this.r2 = nbi();\r",
							"this.q3 = nbi();\r",
							"BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\r",
							"this.mu = this.r2.divide(m);\r",
							"this.m = m;\r",
							"}\r",
							"\r",
							"function barrettConvert(x) {\r",
							"if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\r",
							"else if(x.compareTo(this.m) < 0) return x;\r",
							"else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\r",
							"}\r",
							"\r",
							"function barrettRevert(x) { return x; }\r",
							"\r",
							"//x = x mod m (HAC 14.42)\r",
							"function barrettReduce(x) {\r",
							"x.drShiftTo(this.m.t-1,this.r2);\r",
							"if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\r",
							"this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\r",
							"this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\r",
							"while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\r",
							"x.subTo(this.r2,x);\r",
							"while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r",
							"}\r",
							"\r",
							"//r = x^2 mod m; x != r\r",
							"function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r",
							"\r",
							"//r = x*y mod m; x,y != r\r",
							"function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r",
							"\r",
							"Barrett.prototype.convert = barrettConvert;\r",
							"Barrett.prototype.revert = barrettRevert;\r",
							"Barrett.prototype.reduce = barrettReduce;\r",
							"Barrett.prototype.mulTo = barrettMulTo;\r",
							"Barrett.prototype.sqrTo = barrettSqrTo;\r",
							"\r",
							"//(public) this^e % m (HAC 14.85)\r",
							"function bnModPow(e,m) {\r",
							"var i = e.bitLength(), k, r = nbv(1), z;\r",
							"if(i <= 0) return r;\r",
							"else if(i < 18) k = 1;\r",
							"else if(i < 48) k = 3;\r",
							"else if(i < 144) k = 4;\r",
							"else if(i < 768) k = 5;\r",
							"else k = 6;\r",
							"if(i < 8)\r",
							" z = new Classic(m);\r",
							"else if(m.isEven())\r",
							" z = new Barrett(m);\r",
							"else\r",
							" z = new Montgomery(m);\r",
							"\r",
							"// precomputation\r",
							"var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\r",
							"g[1] = z.convert(this);\r",
							"if(k > 1) {\r",
							" var g2 = nbi();\r",
							" z.sqrTo(g[1],g2);\r",
							" while(n <= km) {\r",
							"   g[n] = nbi();\r",
							"   z.mulTo(g2,g[n-2],g[n]);\r",
							"   n += 2;\r",
							" }\r",
							"}\r",
							"\r",
							"var j = e.t-1, w, is1 = true, r2 = nbi(), t;\r",
							"i = nbits(e.data[j])-1;\r",
							"while(j >= 0) {\r",
							" if(i >= k1) w = (e.data[j]>>(i-k1))&km;\r",
							" else {\r",
							"   w = (e.data[j]&((1<<(i+1))-1))<<(k1-i);\r",
							"   if(j > 0) w |= e.data[j-1]>>(this.DB+i-k1);\r",
							" }\r",
							"\r",
							" n = k;\r",
							" while((w&1) == 0) { w >>= 1; --n; }\r",
							" if((i -= n) < 0) { i += this.DB; --j; }\r",
							" if(is1) {  // ret == 1, don't bother squaring or multiplying it\r",
							"   g[w].copyTo(r);\r",
							"   is1 = false;\r",
							" } else {\r",
							"   while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\r",
							"   if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\r",
							"   z.mulTo(r2,g[w],r);\r",
							" }\r",
							"\r",
							" while(j >= 0 && (e.data[j]&(1<<i)) == 0) {\r",
							"   z.sqrTo(r,r2); t = r; r = r2; r2 = t;\r",
							"   if(--i < 0) { i = this.DB-1; --j; }\r",
							" }\r",
							"}\r",
							"return z.revert(r);\r",
							"}\r",
							"\r",
							"//(public) gcd(this,a) (HAC 14.54)\r",
							"function bnGCD(a) {\r",
							"var x = (this.s<0)?this.negate():this.clone();\r",
							"var y = (a.s<0)?a.negate():a.clone();\r",
							"if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\r",
							"var i = x.getLowestSetBit(), g = y.getLowestSetBit();\r",
							"if(g < 0) return x;\r",
							"if(i < g) g = i;\r",
							"if(g > 0) {\r",
							" x.rShiftTo(g,x);\r",
							" y.rShiftTo(g,y);\r",
							"}\r",
							"while(x.signum() > 0) {\r",
							" if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\r",
							" if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\r",
							" if(x.compareTo(y) >= 0) {\r",
							"   x.subTo(y,x);\r",
							"   x.rShiftTo(1,x);\r",
							" } else {\r",
							"   y.subTo(x,y);\r",
							"   y.rShiftTo(1,y);\r",
							" }\r",
							"}\r",
							"if(g > 0) y.lShiftTo(g,y);\r",
							"return y;\r",
							"}\r",
							"\r",
							"//(protected) this % n, n < 2^26\r",
							"function bnpModInt(n) {\r",
							"if(n <= 0) return 0;\r",
							"var d = this.DV%n, r = (this.s<0)?n-1:0;\r",
							"if(this.t > 0)\r",
							" if(d == 0) r = this.data[0]%n;\r",
							" else for(var i = this.t-1; i >= 0; --i) r = (d*r+this.data[i])%n;\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) 1/this % m (HAC 14.61)\r",
							"function bnModInverse(m) {\r",
							"var ac = m.isEven();\r",
							"if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\r",
							"var u = m.clone(), v = this.clone();\r",
							"var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\r",
							"while(u.signum() != 0) {\r",
							" while(u.isEven()) {\r",
							"   u.rShiftTo(1,u);\r",
							"   if(ac) {\r",
							"     if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\r",
							"     a.rShiftTo(1,a);\r",
							"   } else if(!b.isEven()) b.subTo(m,b);\r",
							"   b.rShiftTo(1,b);\r",
							" }\r",
							" while(v.isEven()) {\r",
							"   v.rShiftTo(1,v);\r",
							"   if(ac) {\r",
							"     if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\r",
							"     c.rShiftTo(1,c);\r",
							"   } else if(!d.isEven()) d.subTo(m,d);\r",
							"   d.rShiftTo(1,d);\r",
							" }\r",
							" if(u.compareTo(v) >= 0) {\r",
							"   u.subTo(v,u);\r",
							"   if(ac) a.subTo(c,a);\r",
							"   b.subTo(d,b);\r",
							" } else {\r",
							"   v.subTo(u,v);\r",
							"   if(ac) c.subTo(a,c);\r",
							"   d.subTo(b,d);\r",
							" }\r",
							"}\r",
							"if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\r",
							"if(d.compareTo(m) >= 0) return d.subtract(m);\r",
							"if(d.signum() < 0) d.addTo(m,d); else return d;\r",
							"if(d.signum() < 0) return d.add(m); else return d;\r",
							"}\r",
							"\r",
							"var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];\r",
							"var lplim = (1<<26)/lowprimes[lowprimes.length-1];\r",
							"\r",
							"//(public) test primality with certainty >= 1-.5^t\r",
							"function bnIsProbablePrime(t) {\r",
							"var i, x = this.abs();\r",
							"if(x.t == 1 && x.data[0] <= lowprimes[lowprimes.length-1]) {\r",
							" for(i = 0; i < lowprimes.length; ++i)\r",
							"   if(x.data[0] == lowprimes[i]) return true;\r",
							" return false;\r",
							"}\r",
							"if(x.isEven()) return false;\r",
							"i = 1;\r",
							"while(i < lowprimes.length) {\r",
							" var m = lowprimes[i], j = i+1;\r",
							" while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\r",
							" m = x.modInt(m);\r",
							" while(i < j) if(m%lowprimes[i++] == 0) return false;\r",
							"}\r",
							"return x.millerRabin(t);\r",
							"}\r",
							"\r",
							"//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\r",
							"function bnpMillerRabin(t) {\r",
							"var n1 = this.subtract(BigInteger.ONE);\r",
							"var k = n1.getLowestSetBit();\r",
							"if(k <= 0) return false;\r",
							"var r = n1.shiftRight(k);\r",
							"var prng = bnGetPrng();\r",
							"var a;\r",
							"for(var i = 0; i < t; ++i) {\r",
							" // select witness 'a' at random from between 1 and n1\r",
							" do {\r",
							"   a = new BigInteger(this.bitLength(), prng);\r",
							" }\r",
							" while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\r",
							" var y = a.modPow(r,this);\r",
							" if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\r",
							"   var j = 1;\r",
							"   while(j++ < k && y.compareTo(n1) != 0) {\r",
							"     y = y.modPowInt(2,this);\r",
							"     if(y.compareTo(BigInteger.ONE) == 0) return false;\r",
							"   }\r",
							"   if(y.compareTo(n1) != 0) return false;\r",
							" }\r",
							"}\r",
							"return true;\r",
							"}\r",
							"\r",
							"// get pseudo random number generator\r",
							"function bnGetPrng() {\r",
							"  // create prng with api that matches BigInteger secure random\r",
							"  return {\r",
							"    // x is an array to fill with bytes\r",
							"    nextBytes: function(x) {\r",
							"      for(var i = 0; i < x.length; ++i) {\r",
							"        x[i] = Math.floor(Math.random() * 0x0100);\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"}\r",
							"\r",
							"//protected\r",
							"BigInteger.prototype.chunkSize = bnpChunkSize;\r",
							"BigInteger.prototype.toRadix = bnpToRadix;\r",
							"BigInteger.prototype.fromRadix = bnpFromRadix;\r",
							"BigInteger.prototype.fromNumber = bnpFromNumber;\r",
							"BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\r",
							"BigInteger.prototype.changeBit = bnpChangeBit;\r",
							"BigInteger.prototype.addTo = bnpAddTo;\r",
							"BigInteger.prototype.dMultiply = bnpDMultiply;\r",
							"BigInteger.prototype.dAddOffset = bnpDAddOffset;\r",
							"BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\r",
							"BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\r",
							"BigInteger.prototype.modInt = bnpModInt;\r",
							"BigInteger.prototype.millerRabin = bnpMillerRabin;\r",
							"\r",
							"//public\r",
							"BigInteger.prototype.clone = bnClone;\r",
							"BigInteger.prototype.intValue = bnIntValue;\r",
							"BigInteger.prototype.byteValue = bnByteValue;\r",
							"BigInteger.prototype.shortValue = bnShortValue;\r",
							"BigInteger.prototype.signum = bnSigNum;\r",
							"BigInteger.prototype.toByteArray = bnToByteArray;\r",
							"BigInteger.prototype.equals = bnEquals;\r",
							"BigInteger.prototype.min = bnMin;\r",
							"BigInteger.prototype.max = bnMax;\r",
							"BigInteger.prototype.and = bnAnd;\r",
							"BigInteger.prototype.or = bnOr;\r",
							"BigInteger.prototype.xor = bnXor;\r",
							"BigInteger.prototype.andNot = bnAndNot;\r",
							"BigInteger.prototype.not = bnNot;\r",
							"BigInteger.prototype.shiftLeft = bnShiftLeft;\r",
							"BigInteger.prototype.shiftRight = bnShiftRight;\r",
							"BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\r",
							"BigInteger.prototype.bitCount = bnBitCount;\r",
							"BigInteger.prototype.testBit = bnTestBit;\r",
							"BigInteger.prototype.setBit = bnSetBit;\r",
							"BigInteger.prototype.clearBit = bnClearBit;\r",
							"BigInteger.prototype.flipBit = bnFlipBit;\r",
							"BigInteger.prototype.add = bnAdd;\r",
							"BigInteger.prototype.subtract = bnSubtract;\r",
							"BigInteger.prototype.multiply = bnMultiply;\r",
							"BigInteger.prototype.divide = bnDivide;\r",
							"BigInteger.prototype.remainder = bnRemainder;\r",
							"BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\r",
							"BigInteger.prototype.modPow = bnModPow;\r",
							"BigInteger.prototype.modInverse = bnModInverse;\r",
							"BigInteger.prototype.pow = bnPow;\r",
							"BigInteger.prototype.gcd = bnGCD;\r",
							"BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\r",
							"\r",
							"//BigInteger interfaces not implemented in jsbn:\r",
							"\r",
							"//BigInteger(int signum, byte[] magnitude)\r",
							"//double doubleValue()\r",
							"//float floatValue()\r",
							"//int hashCode()\r",
							"//long longValue()\r",
							"//static BigInteger valueOf(long val)\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 13 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Cipher base API.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"module.exports = forge.cipher = forge.cipher || {};\r",
							"\r",
							"// registered algorithms\r",
							"forge.cipher.algorithms = forge.cipher.algorithms || {};\r",
							"\r",
							"/**\r",
							" * Creates a cipher object that can be used to encrypt data using the given\r",
							" * algorithm and key. The algorithm may be provided as a string value for a\r",
							" * previously registered algorithm or it may be given as a cipher algorithm\r",
							" * API object.\r",
							" *\r",
							" * @param algorithm the algorithm to use, either a string or an algorithm API\r",
							" *          object.\r",
							" * @param key the key to use, as a binary-encoded string of bytes or a\r",
							" *          byte buffer.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.cipher.createCipher = function(algorithm, key) {\r",
							"  var api = algorithm;\r",
							"  if(typeof api === 'string') {\r",
							"    api = forge.cipher.getAlgorithm(api);\r",
							"    if(api) {\r",
							"      api = api();\r",
							"    }\r",
							"  }\r",
							"  if(!api) {\r",
							"    throw new Error('Unsupported algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  // assume block cipher\r",
							"  return new forge.cipher.BlockCipher({\r",
							"    algorithm: api,\r",
							"    key: key,\r",
							"    decrypt: false\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a decipher object that can be used to decrypt data using the given\r",
							" * algorithm and key. The algorithm may be provided as a string value for a\r",
							" * previously registered algorithm or it may be given as a cipher algorithm\r",
							" * API object.\r",
							" *\r",
							" * @param algorithm the algorithm to use, either a string or an algorithm API\r",
							" *          object.\r",
							" * @param key the key to use, as a binary-encoded string of bytes or a\r",
							" *          byte buffer.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.cipher.createDecipher = function(algorithm, key) {\r",
							"  var api = algorithm;\r",
							"  if(typeof api === 'string') {\r",
							"    api = forge.cipher.getAlgorithm(api);\r",
							"    if(api) {\r",
							"      api = api();\r",
							"    }\r",
							"  }\r",
							"  if(!api) {\r",
							"    throw new Error('Unsupported algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  // assume block cipher\r",
							"  return new forge.cipher.BlockCipher({\r",
							"    algorithm: api,\r",
							"    key: key,\r",
							"    decrypt: true\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Registers an algorithm by name. If the name was already registered, the\r",
							" * algorithm API object will be overwritten.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" * @param algorithm the algorithm API object.\r",
							" */\r",
							"forge.cipher.registerAlgorithm = function(name, algorithm) {\r",
							"  name = name.toUpperCase();\r",
							"  forge.cipher.algorithms[name] = algorithm;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a registered algorithm by name.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" *\r",
							" * @return the algorithm, if found, null if not.\r",
							" */\r",
							"forge.cipher.getAlgorithm = function(name) {\r",
							"  name = name.toUpperCase();\r",
							"  if(name in forge.cipher.algorithms) {\r",
							"    return forge.cipher.algorithms[name];\r",
							"  }\r",
							"  return null;\r",
							"};\r",
							"\r",
							"var BlockCipher = forge.cipher.BlockCipher = function(options) {\r",
							"  this.algorithm = options.algorithm;\r",
							"  this.mode = this.algorithm.mode;\r",
							"  this.blockSize = this.mode.blockSize;\r",
							"  this._finish = false;\r",
							"  this._input = null;\r",
							"  this.output = null;\r",
							"  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\r",
							"  this._decrypt = options.decrypt;\r",
							"  this.algorithm.initialize(options);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Starts or restarts the encryption or decryption process, whichever\r",
							" * was previously configured.\r",
							" *\r",
							" * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\r",
							" * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\r",
							" * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\r",
							" * 32-bit integers, then it must be 4 integers long.\r",
							" *\r",
							" * Note: an IV is not required or used in ECB mode.\r",
							" *\r",
							" * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\r",
							" * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\r",
							" * by NIST SP-800-38D but another length may be given.\r",
							" *\r",
							" * @param options the options to use:\r",
							" *          iv the initialization vector to use as a binary-encoded string of\r",
							" *            bytes, null to reuse the last ciphered block from a previous\r",
							" *            update() (this \"residue\" method is for legacy support only).\r",
							" *          additionalData additional authentication data as a binary-encoded\r",
							" *            string of bytes, for 'GCM' mode, (default: none).\r",
							" *          tagLength desired length of authentication tag, in bits, for\r",
							" *            'GCM' mode (0-128, default: 128).\r",
							" *          tag the authentication tag to check if decrypting, as a\r",
							" *             binary-encoded string of bytes.\r",
							" *          output the output the buffer to write to, null to create one.\r",
							" */\r",
							"BlockCipher.prototype.start = function(options) {\r",
							"  options = options || {};\r",
							"  var opts = {};\r",
							"  for(var key in options) {\r",
							"    opts[key] = options[key];\r",
							"  }\r",
							"  opts.decrypt = this._decrypt;\r",
							"  this._finish = false;\r",
							"  this._input = forge.util.createBuffer();\r",
							"  this.output = options.output || forge.util.createBuffer();\r",
							"  this.mode.start(opts);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Updates the next block according to the cipher mode.\r",
							" *\r",
							" * @param input the buffer to read from.\r",
							" */\r",
							"BlockCipher.prototype.update = function(input) {\r",
							"  if(input) {\r",
							"    // input given, so empty it into the input buffer\r",
							"    this._input.putBuffer(input);\r",
							"  }\r",
							"\r",
							"  // do cipher operation until it needs more input and not finished\r",
							"  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&\r",
							"    !this._finish) {}\r",
							"\r",
							"  // free consumed memory from input buffer\r",
							"  this._input.compact();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Finishes encrypting or decrypting.\r",
							" *\r",
							" * @param pad a padding function to use in CBC mode, null for default,\r",
							" *          signature(blockSize, buffer, decrypt).\r",
							" *\r",
							" * @return true if successful, false on error.\r",
							" */\r",
							"BlockCipher.prototype.finish = function(pad) {\r",
							"  // backwards-compatibility w/deprecated padding API\r",
							"  // Note: will overwrite padding functions even after another start() call\r",
							"  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\r",
							"    this.mode.pad = function(input) {\r",
							"      return pad(this.blockSize, input, false);\r",
							"    };\r",
							"    this.mode.unpad = function(output) {\r",
							"      return pad(this.blockSize, output, true);\r",
							"    };\r",
							"  }\r",
							"\r",
							"  // build options for padding and afterFinish functions\r",
							"  var options = {};\r",
							"  options.decrypt = this._decrypt;\r",
							"\r",
							"  // get # of bytes that won't fill a block\r",
							"  options.overflow = this._input.length() % this.blockSize;\r",
							"\r",
							"  if(!this._decrypt && this.mode.pad) {\r",
							"    if(!this.mode.pad(this._input, options)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // do final update\r",
							"  this._finish = true;\r",
							"  this.update();\r",
							"\r",
							"  if(this._decrypt && this.mode.unpad) {\r",
							"    if(!this.mode.unpad(this.output, options)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(this.mode.afterFinish) {\r",
							"    if(!this.mode.afterFinish(this.output, options)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return true;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 14 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Message Digest Algorithm 5 with 128-bit digest (MD5) implementation.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var md5 = module.exports = forge.md5 = forge.md5 || {};\r",
							"forge.md.md5 = forge.md.algorithms.md5 = md5;\r",
							"\r",
							"/**\r",
							" * Creates an MD5 message digest object.\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"md5.create = function() {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  // MD5 state contains four 32-bit integers\r",
							"  var _state = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for word storage\r",
							"  var _w = new Array(16);\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    algorithm: 'md5',\r",
							"    blockLength: 64,\r",
							"    digestLength: 16,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 8\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength64 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength64 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _state = {\r",
							"      h0: 0x67452301,\r",
							"      h1: 0xEFCDAB89,\r",
							"      h2: 0x98BADCFE,\r",
							"      h3: 0x10325476\r",
							"    };\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = (len[1] / 0x100000000) >>> 0;\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_state, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the digest.\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate MD5 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 448 mod 512. In other words,\r",
							"    the data to be digested must be a multiple of 512 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 8 bytes (64\r",
							"    bits), that means that the last segment of the data must have 56 bytes\r",
							"    (448 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 448 mod 512 because\r",
							"    512 - 128 = 448.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 448 mod 512, then 512 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in little-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry\r",
							"    var bits, carry = 0;\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      bits = md.fullMessageLength[i] * 8 + carry;\r",
							"      carry = (bits / 0x100000000) >>> 0;\r",
							"      finalBlock.putInt32Le(bits >>> 0);\r",
							"    }\r",
							"\r",
							"    var s2 = {\r",
							"      h0: _state.h0,\r",
							"      h1: _state.h1,\r",
							"      h2: _state.h2,\r",
							"      h3: _state.h3\r",
							"    };\r",
							"    _update(s2, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    rval.putInt32Le(s2.h0);\r",
							"    rval.putInt32Le(s2.h1);\r",
							"    rval.putInt32Le(s2.h2);\r",
							"    rval.putInt32Le(s2.h3);\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// padding, constant tables for calculating md5\r",
							"var _padding = null;\r",
							"var _g = null;\r",
							"var _r = null;\r",
							"var _k = null;\r",
							"var _initialized = false;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\r",
							"\r",
							"  // g values\r",
							"  _g = [\r",
							"    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r",
							"    1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,\r",
							"    5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,\r",
							"    0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];\r",
							"\r",
							"  // rounds table\r",
							"  _r = [\r",
							"    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\r",
							"    5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\r",
							"    4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\r",
							"    6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21];\r",
							"\r",
							"  // get the result of abs(sin(i + 1)) as a 32-bit integer\r",
							"  _k = new Array(64);\r",
							"  for(var i = 0; i < 64; ++i) {\r",
							"    _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);\r",
							"  }\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates an MD5 state with the given byte buffer.\r",
							" *\r",
							" * @param s the MD5 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (64 byte) chunks\r",
							"  var t, a, b, c, d, f, r, i;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 64) {\r",
							"    // initialize hash value for this chunk\r",
							"    a = s.h0;\r",
							"    b = s.h1;\r",
							"    c = s.h2;\r",
							"    d = s.h3;\r",
							"\r",
							"    // round 1\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      w[i] = bytes.getInt32Le();\r",
							"      f = d ^ (b & (c ^ d));\r",
							"      t = (a + f + _k[i] + w[i]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"    // round 2\r",
							"    for(; i < 32; ++i) {\r",
							"      f = c ^ (d & (b ^ c));\r",
							"      t = (a + f + _k[i] + w[_g[i]]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"    // round 3\r",
							"    for(; i < 48; ++i) {\r",
							"      f = b ^ c ^ d;\r",
							"      t = (a + f + _k[i] + w[_g[i]]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"    // round 4\r",
							"    for(; i < 64; ++i) {\r",
							"      f = c ^ (b | ~d);\r",
							"      t = (a + f + _k[i] + w[_g[i]]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"\r",
							"    // update hash state\r",
							"    s.h0 = (s.h0 + a) | 0;\r",
							"    s.h1 = (s.h1 + b) | 0;\r",
							"    s.h2 = (s.h2 + c) | 0;\r",
							"    s.h3 = (s.h3 + d) | 0;\r",
							"\r",
							"    len -= 64;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 15 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Password-Based Key-Derivation Function #2 implementation.\r",
							" *\r",
							" * See RFC 2898 for details.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\r",
							"\r",
							"var crypto;\r",
							"if(forge.util.isNodejs && !forge.options.usePureJavaScript) {\r",
							"  crypto = __webpack_require__(22);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Derives a key from a password.\r",
							" *\r",
							" * @param p the password as a binary-encoded string of bytes.\r",
							" * @param s the salt as a binary-encoded string of bytes.\r",
							" * @param c the iteration count, a positive integer.\r",
							" * @param dkLen the intended length, in bytes, of the derived key,\r",
							" *          (max: 2^32 - 1) * hash length of the PRF.\r",
							" * @param [md] the message digest (or algorithm identifier as a string) to use\r",
							" *          in the PRF, defaults to SHA-1.\r",
							" * @param [callback(err, key)] presence triggers asynchronous version, called\r",
							" *          once the operation completes.\r",
							" *\r",
							" * @return the derived key, as a binary-encoded string of bytes, for the\r",
							" *           synchronous version (if no callback is specified).\r",
							" */\r",
							"module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(\r",
							"  p, s, c, dkLen, md, callback) {\r",
							"  if(typeof md === 'function') {\r",
							"    callback = md;\r",
							"    md = null;\r",
							"  }\r",
							"\r",
							"  // use native implementation if possible and not disabled, note that\r",
							"  // some node versions only support SHA-1, others allow digest to be changed\r",
							"  if(forge.util.isNodejs && !forge.options.usePureJavaScript &&\r",
							"    crypto.pbkdf2 && (md === null || typeof md !== 'object') &&\r",
							"    (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {\r",
							"    if(typeof md !== 'string') {\r",
							"      // default prf to SHA-1\r",
							"      md = 'sha1';\r",
							"    }\r",
							"    p = new Buffer(p, 'binary');\r",
							"    s = new Buffer(s, 'binary');\r",
							"    if(!callback) {\r",
							"      if(crypto.pbkdf2Sync.length === 4) {\r",
							"        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');\r",
							"      }\r",
							"      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');\r",
							"    }\r",
							"    if(crypto.pbkdf2Sync.length === 4) {\r",
							"      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {\r",
							"        if(err) {\r",
							"          return callback(err);\r",
							"        }\r",
							"        callback(null, key.toString('binary'));\r",
							"      });\r",
							"    }\r",
							"    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"      callback(null, key.toString('binary'));\r",
							"    });\r",
							"  }\r",
							"\r",
							"  if(typeof md === 'undefined' || md === null) {\r",
							"    // default prf to SHA-1\r",
							"    md = 'sha1';\r",
							"  }\r",
							"  if(typeof md === 'string') {\r",
							"    if(!(md in forge.md.algorithms)) {\r",
							"      throw new Error('Unknown hash algorithm: ' + md);\r",
							"    }\r",
							"    md = forge.md[md].create();\r",
							"  }\r",
							"\r",
							"  var hLen = md.digestLength;\r",
							"\r",
							"  /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\r",
							"    stop. */\r",
							"  if(dkLen > (0xFFFFFFFF * hLen)) {\r",
							"    var err = new Error('Derived key is too long.');\r",
							"    if(callback) {\r",
							"      return callback(err);\r",
							"    }\r",
							"    throw err;\r",
							"  }\r",
							"\r",
							"  /* 2. Let len be the number of hLen-octet blocks in the derived key,\r",
							"    rounding up, and let r be the number of octets in the last\r",
							"    block:\r",
							"\r",
							"    len = CEIL(dkLen / hLen),\r",
							"    r = dkLen - (len - 1) * hLen. */\r",
							"  var len = Math.ceil(dkLen / hLen);\r",
							"  var r = dkLen - (len - 1) * hLen;\r",
							"\r",
							"  /* 3. For each block of the derived key apply the function F defined\r",
							"    below to the password P, the salt S, the iteration count c, and\r",
							"    the block index to compute the block:\r",
							"\r",
							"    T_1 = F(P, S, c, 1),\r",
							"    T_2 = F(P, S, c, 2),\r",
							"    ...\r",
							"    T_len = F(P, S, c, len),\r",
							"\r",
							"    where the function F is defined as the exclusive-or sum of the\r",
							"    first c iterates of the underlying pseudorandom function PRF\r",
							"    applied to the password P and the concatenation of the salt S\r",
							"    and the block index i:\r",
							"\r",
							"    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\r",
							"\r",
							"    where\r",
							"\r",
							"    u_1 = PRF(P, S || INT(i)),\r",
							"    u_2 = PRF(P, u_1),\r",
							"    ...\r",
							"    u_c = PRF(P, u_{c-1}).\r",
							"\r",
							"    Here, INT(i) is a four-octet encoding of the integer i, most\r",
							"    significant octet first. */\r",
							"  var prf = forge.hmac.create();\r",
							"  prf.start(md, p);\r",
							"  var dk = '';\r",
							"  var xor, u_c, u_c1;\r",
							"\r",
							"  // sync version\r",
							"  if(!callback) {\r",
							"    for(var i = 1; i <= len; ++i) {\r",
							"      // PRF(P, S || INT(i)) (first iteration)\r",
							"      prf.start(null, null);\r",
							"      prf.update(s);\r",
							"      prf.update(forge.util.int32ToBytes(i));\r",
							"      xor = u_c1 = prf.digest().getBytes();\r",
							"\r",
							"      // PRF(P, u_{c-1}) (other iterations)\r",
							"      for(var j = 2; j <= c; ++j) {\r",
							"        prf.start(null, null);\r",
							"        prf.update(u_c1);\r",
							"        u_c = prf.digest().getBytes();\r",
							"        // F(p, s, c, i)\r",
							"        xor = forge.util.xorBytes(xor, u_c, hLen);\r",
							"        u_c1 = u_c;\r",
							"      }\r",
							"\r",
							"      /* 4. Concatenate the blocks and extract the first dkLen octets to\r",
							"        produce a derived key DK:\r",
							"\r",
							"        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\r",
							"      dk += (i < len) ? xor : xor.substr(0, r);\r",
							"    }\r",
							"    /* 5. Output the derived key DK. */\r",
							"    return dk;\r",
							"  }\r",
							"\r",
							"  // async version\r",
							"  var i = 1, j;\r",
							"  function outer() {\r",
							"    if(i > len) {\r",
							"      // done\r",
							"      return callback(null, dk);\r",
							"    }\r",
							"\r",
							"    // PRF(P, S || INT(i)) (first iteration)\r",
							"    prf.start(null, null);\r",
							"    prf.update(s);\r",
							"    prf.update(forge.util.int32ToBytes(i));\r",
							"    xor = u_c1 = prf.digest().getBytes();\r",
							"\r",
							"    // PRF(P, u_{c-1}) (other iterations)\r",
							"    j = 2;\r",
							"    inner();\r",
							"  }\r",
							"\r",
							"  function inner() {\r",
							"    if(j <= c) {\r",
							"      prf.start(null, null);\r",
							"      prf.update(u_c1);\r",
							"      u_c = prf.digest().getBytes();\r",
							"      // F(p, s, c, i)\r",
							"      xor = forge.util.xorBytes(xor, u_c, hLen);\r",
							"      u_c1 = u_c;\r",
							"      ++j;\r",
							"      return forge.util.setImmediate(inner);\r",
							"    }\r",
							"\r",
							"    /* 4. Concatenate the blocks and extract the first dkLen octets to\r",
							"      produce a derived key DK:\r",
							"\r",
							"      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\r",
							"    dk += (i < len) ? xor : xor.substr(0, r);\r",
							"\r",
							"    ++i;\r",
							"    outer();\r",
							"  }\r",
							"\r",
							"  outer();\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 16 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of X.509 and related components (such as\r",
							" * Certification Signing Requests) of a Public Key Infrastructure.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * The ASN.1 representation of an X.509v3 certificate is as follows\r",
							" * (see RFC 2459):\r",
							" *\r",
							" * Certificate ::= SEQUENCE {\r",
							" *   tbsCertificate       TBSCertificate,\r",
							" *   signatureAlgorithm   AlgorithmIdentifier,\r",
							" *   signatureValue       BIT STRING\r",
							" * }\r",
							" *\r",
							" * TBSCertificate ::= SEQUENCE {\r",
							" *   version         [0]  EXPLICIT Version DEFAULT v1,\r",
							" *   serialNumber         CertificateSerialNumber,\r",
							" *   signature            AlgorithmIdentifier,\r",
							" *   issuer               Name,\r",
							" *   validity             Validity,\r",
							" *   subject              Name,\r",
							" *   subjectPublicKeyInfo SubjectPublicKeyInfo,\r",
							" *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\r",
							" *                        -- If present, version shall be v2 or v3\r",
							" *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\r",
							" *                        -- If present, version shall be v2 or v3\r",
							" *   extensions      [3]  EXPLICIT Extensions OPTIONAL\r",
							" *                        -- If present, version shall be v3\r",
							" * }\r",
							" *\r",
							" * Version ::= INTEGER  { v1(0), v2(1), v3(2) }\r",
							" *\r",
							" * CertificateSerialNumber ::= INTEGER\r",
							" *\r",
							" * Name ::= CHOICE {\r",
							" *   // only one possible choice for now\r",
							" *   RDNSequence\r",
							" * }\r",
							" *\r",
							" * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\r",
							" *\r",
							" * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue\r",
							" *\r",
							" * AttributeTypeAndValue ::= SEQUENCE {\r",
							" *   type     AttributeType,\r",
							" *   value    AttributeValue\r",
							" * }\r",
							" * AttributeType ::= OBJECT IDENTIFIER\r",
							" * AttributeValue ::= ANY DEFINED BY AttributeType\r",
							" *\r",
							" * Validity ::= SEQUENCE {\r",
							" *   notBefore      Time,\r",
							" *   notAfter       Time\r",
							" * }\r",
							" *\r",
							" * Time ::= CHOICE {\r",
							" *   utcTime        UTCTime,\r",
							" *   generalTime    GeneralizedTime\r",
							" * }\r",
							" *\r",
							" * UniqueIdentifier ::= BIT STRING\r",
							" *\r",
							" * SubjectPublicKeyInfo ::= SEQUENCE {\r",
							" *   algorithm            AlgorithmIdentifier,\r",
							" *   subjectPublicKey     BIT STRING\r",
							" * }\r",
							" *\r",
							" * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension\r",
							" *\r",
							" * Extension ::= SEQUENCE {\r",
							" *   extnID      OBJECT IDENTIFIER,\r",
							" *   critical    BOOLEAN DEFAULT FALSE,\r",
							" *   extnValue   OCTET STRING\r",
							" * }\r",
							" *\r",
							" * The only key algorithm currently supported for PKI is RSA.\r",
							" *\r",
							" * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.\r",
							" *\r",
							" * PKCS#10 v1.7 describes certificate signing requests:\r",
							" *\r",
							" * CertificationRequestInfo:\r",
							" *\r",
							" * CertificationRequestInfo ::= SEQUENCE {\r",
							" *   version       INTEGER { v1(0) } (v1,...),\r",
							" *   subject       Name,\r",
							" *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},\r",
							" *   attributes    [0] Attributes{{ CRIAttributes }}\r",
							" * }\r",
							" *\r",
							" * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}\r",
							" *\r",
							" * CRIAttributes  ATTRIBUTE  ::= {\r",
							" *   ... -- add any locally defined attributes here -- }\r",
							" *\r",
							" * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {\r",
							" *   type   ATTRIBUTE.&id({IOSet}),\r",
							" *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})\r",
							" * }\r",
							" *\r",
							" * CertificationRequest ::= SEQUENCE {\r",
							" *   certificationRequestInfo CertificationRequestInfo,\r",
							" *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},\r",
							" *   signature          BIT STRING\r",
							" * }\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(38);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(17);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/* Public Key Infrastructure (PKI) implementation. */\r",
							"var pki = module.exports = forge.pki = forge.pki || {};\r",
							"var oids = pki.oids;\r",
							"\r",
							"// short name OID mappings\r",
							"var _shortNames = {};\r",
							"_shortNames['CN'] = oids['commonName'];\r",
							"_shortNames['commonName'] = 'CN';\r",
							"_shortNames['C'] = oids['countryName'];\r",
							"_shortNames['countryName'] = 'C';\r",
							"_shortNames['L'] = oids['localityName'];\r",
							"_shortNames['localityName'] = 'L';\r",
							"_shortNames['ST'] = oids['stateOrProvinceName'];\r",
							"_shortNames['stateOrProvinceName'] = 'ST';\r",
							"_shortNames['O'] = oids['organizationName'];\r",
							"_shortNames['organizationName'] = 'O';\r",
							"_shortNames['OU'] = oids['organizationalUnitName'];\r",
							"_shortNames['organizationalUnitName'] = 'OU';\r",
							"_shortNames['E'] = oids['emailAddress'];\r",
							"_shortNames['emailAddress'] = 'E';\r",
							"\r",
							"// validator for an SubjectPublicKeyInfo structure\r",
							"// Note: Currently only works with an RSA public key\r",
							"var publicKeyValidator = forge.pki.rsa.publicKeyValidator;\r",
							"\r",
							"// validator for an X.509v3 certificate\r",
							"var x509CertificateValidator = {\r",
							"  name: 'Certificate',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'Certificate.TBSCertificate',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'tbsCertificate',\r",
							"    value: [{\r",
							"      name: 'Certificate.TBSCertificate.version',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 0,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.version.integer',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.INTEGER,\r",
							"        constructed: false,\r",
							"        capture: 'certVersion'\r",
							"      }]\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.serialNumber',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'certSerialNumber'\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.signature',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.signature.algorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false,\r",
							"        capture: 'certinfoSignatureOid'\r",
							"      }, {\r",
							"        name: 'Certificate.TBSCertificate.signature.parameters',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        optional: true,\r",
							"        captureAsn1: 'certinfoSignatureParams'\r",
							"      }]\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.issuer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'certIssuer'\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.validity',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      // Note: UTC and generalized times may both appear so the capture\r",
							"      // names are based on their detected order, the names used below\r",
							"      // are only for the common case, which validity time really means\r",
							"      // \"notBefore\" and which means \"notAfter\" will be determined by order\r",
							"      value: [{\r",
							"        // notBefore (Time) (UTC time case)\r",
							"        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.UTCTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity1UTCTime'\r",
							"      }, {\r",
							"        // notBefore (Time) (generalized time case)\r",
							"        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.GENERALIZEDTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity2GeneralizedTime'\r",
							"      }, {\r",
							"        // notAfter (Time) (only UTC time is supported)\r",
							"        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.UTCTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity3UTCTime'\r",
							"      }, {\r",
							"        // notAfter (Time) (only UTC time is supported)\r",
							"        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.GENERALIZEDTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity4GeneralizedTime'\r",
							"      }]\r",
							"    }, {\r",
							"      // Name (subject) (RDNSequence)\r",
							"      name: 'Certificate.TBSCertificate.subject',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'certSubject'\r",
							"    },\r",
							"      // SubjectPublicKeyInfo\r",
							"      publicKeyValidator,\r",
							"    {\r",
							"      // issuerUniqueID (optional)\r",
							"      name: 'Certificate.TBSCertificate.issuerUniqueID',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 1,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.issuerUniqueID.id',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.BITSTRING,\r",
							"        constructed: false,\r",
							"        // TODO: support arbitrary bit length ids\r",
							"        captureBitStringValue: 'certIssuerUniqueId'\r",
							"      }]\r",
							"    }, {\r",
							"      // subjectUniqueID (optional)\r",
							"      name: 'Certificate.TBSCertificate.subjectUniqueID',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 2,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.subjectUniqueID.id',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.BITSTRING,\r",
							"        constructed: false,\r",
							"        // TODO: support arbitrary bit length ids\r",
							"        captureBitStringValue: 'certSubjectUniqueId'\r",
							"      }]\r",
							"    }, {\r",
							"      // Extensions (optional)\r",
							"      name: 'Certificate.TBSCertificate.extensions',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 3,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'certExtensions',\r",
							"      optional: true\r",
							"    }]\r",
							"  }, {\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    name: 'Certificate.signatureAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      // algorithm\r",
							"      name: 'Certificate.signatureAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'certSignatureOid'\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.signature.parameters',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      optional: true,\r",
							"      captureAsn1: 'certSignatureParams'\r",
							"    }]\r",
							"  }, {\r",
							"    // SignatureValue\r",
							"    name: 'Certificate.signatureValue',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.BITSTRING,\r",
							"    constructed: false,\r",
							"    captureBitStringValue: 'certSignature'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var rsassaPssParameterValidator = {\r",
							"  name: 'rsapss',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'rsapss.hashAlgorithm',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.SEQUENCE,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false,\r",
							"        capture: 'hashOid'\r",
							"        /* parameter block omitted, for SHA1 NULL anyhow. */\r",
							"      }]\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'rsapss.maskGenAlgorithm',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 1,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.SEQUENCE,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false,\r",
							"        capture: 'maskGenOid'\r",
							"      }, {\r",
							"        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SEQUENCE,\r",
							"        constructed: true,\r",
							"        value: [{\r",
							"          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          type: asn1.Type.OID,\r",
							"          constructed: false,\r",
							"          capture: 'maskGenHashOid'\r",
							"          /* parameter block omitted, for SHA1 NULL anyhow. */\r",
							"        }]\r",
							"      }]\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'rsapss.saltLength',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 2,\r",
							"    optional: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.saltLength.saltLength',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'saltLength'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'rsapss.trailerField',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 3,\r",
							"    optional: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.trailer.trailer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'trailer'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for a CertificationRequestInfo structure\r",
							"var certificationRequestInfoValidator = {\r",
							"  name: 'CertificationRequestInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  captureAsn1: 'certificationRequestInfo',\r",
							"  value: [{\r",
							"    name: 'CertificationRequestInfo.integer',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'certificationRequestInfoVersion'\r",
							"  }, {\r",
							"    // Name (subject) (RDNSequence)\r",
							"    name: 'CertificationRequestInfo.subject',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'certificationRequestInfoSubject'\r",
							"  },\r",
							"  // SubjectPublicKeyInfo\r",
							"  publicKeyValidator,\r",
							"  {\r",
							"    name: 'CertificationRequestInfo.attributes',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'certificationRequestInfoAttributes',\r",
							"    value: [{\r",
							"      name: 'CertificationRequestInfo.attributes',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'CertificationRequestInfo.attributes.type',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false\r",
							"      }, {\r",
							"        name: 'CertificationRequestInfo.attributes.value',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SET,\r",
							"        constructed: true\r",
							"      }]\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for a CertificationRequest structure\r",
							"var certificationRequestValidator = {\r",
							"  name: 'CertificationRequest',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  captureAsn1: 'csr',\r",
							"  value: [\r",
							"    certificationRequestInfoValidator, {\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    name: 'CertificationRequest.signatureAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      // algorithm\r",
							"      name: 'CertificationRequest.signatureAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'csrSignatureOid'\r",
							"    }, {\r",
							"      name: 'CertificationRequest.signatureAlgorithm.parameters',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      optional: true,\r",
							"      captureAsn1: 'csrSignatureParams'\r",
							"    }]\r",
							"  }, {\r",
							"    // signature\r",
							"    name: 'CertificationRequest.signature',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.BITSTRING,\r",
							"    constructed: false,\r",
							"    captureBitStringValue: 'csrSignature'\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName\r",
							" * sets into an array with objects that have type and value properties.\r",
							" *\r",
							" * @param rdn the RDNSequence to convert.\r",
							" * @param md a message digest to append type and value to if provided.\r",
							" */\r",
							"pki.RDNAttributesAsArray = function(rdn, md) {\r",
							"  var rval = [];\r",
							"\r",
							"  // each value in 'rdn' in is a SET of RelativeDistinguishedName\r",
							"  var set, attr, obj;\r",
							"  for(var si = 0; si < rdn.value.length; ++si) {\r",
							"    // get the RelativeDistinguishedName set\r",
							"    set = rdn.value[si];\r",
							"\r",
							"    // each value in the SET is an AttributeTypeAndValue sequence\r",
							"    // containing first a type (an OID) and second a value (defined by\r",
							"    // the OID)\r",
							"    for(var i = 0; i < set.value.length; ++i) {\r",
							"      obj = {};\r",
							"      attr = set.value[i];\r",
							"      obj.type = asn1.derToOid(attr.value[0].value);\r",
							"      obj.value = attr.value[1].value;\r",
							"      obj.valueTagClass = attr.value[1].type;\r",
							"      // if the OID is known, get its name and short name\r",
							"      if(obj.type in oids) {\r",
							"        obj.name = oids[obj.type];\r",
							"        if(obj.name in _shortNames) {\r",
							"          obj.shortName = _shortNames[obj.name];\r",
							"        }\r",
							"      }\r",
							"      if(md) {\r",
							"        md.update(obj.type);\r",
							"        md.update(obj.value);\r",
							"      }\r",
							"      rval.push(obj);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts ASN.1 CRIAttributes into an array with objects that have type and\r",
							" * value properties.\r",
							" *\r",
							" * @param attributes the CRIAttributes to convert.\r",
							" */\r",
							"pki.CRIAttributesAsArray = function(attributes) {\r",
							"  var rval = [];\r",
							"\r",
							"  // each value in 'attributes' in is a SEQUENCE with an OID and a SET\r",
							"  for(var si = 0; si < attributes.length; ++si) {\r",
							"    // get the attribute sequence\r",
							"    var seq = attributes[si];\r",
							"\r",
							"    // each value in the SEQUENCE containing first a type (an OID) and\r",
							"    // second a set of values (defined by the OID)\r",
							"    var type = asn1.derToOid(seq.value[0].value);\r",
							"    var values = seq.value[1].value;\r",
							"    for(var vi = 0; vi < values.length; ++vi) {\r",
							"      var obj = {};\r",
							"      obj.type = type;\r",
							"      obj.value = values[vi].value;\r",
							"      obj.valueTagClass = values[vi].type;\r",
							"      // if the OID is known, get its name and short name\r",
							"      if(obj.type in oids) {\r",
							"        obj.name = oids[obj.type];\r",
							"        if(obj.name in _shortNames) {\r",
							"          obj.shortName = _shortNames[obj.name];\r",
							"        }\r",
							"      }\r",
							"      // parse extensions\r",
							"      if(obj.type === oids.extensionRequest) {\r",
							"        obj.extensions = [];\r",
							"        for(var ei = 0; ei < obj.value.length; ++ei) {\r",
							"          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));\r",
							"        }\r",
							"      }\r",
							"      rval.push(obj);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an issuer or subject attribute from its name, type, or short name.\r",
							" *\r",
							" * @param obj the issuer or subject object.\r",
							" * @param options a short name string or an object with:\r",
							" *          shortName the short name for the attribute.\r",
							" *          name the name for the attribute.\r",
							" *          type the type for the attribute.\r",
							" *\r",
							" * @return the attribute.\r",
							" */\r",
							"function _getAttribute(obj, options) {\r",
							"  if(typeof options === 'string') {\r",
							"    options = {shortName: options};\r",
							"  }\r",
							"\r",
							"  var rval = null;\r",
							"  var attr;\r",
							"  for(var i = 0; rval === null && i < obj.attributes.length; ++i) {\r",
							"    attr = obj.attributes[i];\r",
							"    if(options.type && options.type === attr.type) {\r",
							"      rval = attr;\r",
							"    } else if(options.name && options.name === attr.name) {\r",
							"      rval = attr;\r",
							"    } else if(options.shortName && options.shortName === attr.shortName) {\r",
							"      rval = attr;\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts signature parameters from ASN.1 structure.\r",
							" *\r",
							" * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had\r",
							" * no parameters.\r",
							" *\r",
							" * RSASSA-PSS-params  ::=  SEQUENCE  {\r",
							" *   hashAlgorithm      [0] HashAlgorithm DEFAULT\r",
							" *                             sha1Identifier,\r",
							" *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT\r",
							" *                             mgf1SHA1Identifier,\r",
							" *   saltLength         [2] INTEGER DEFAULT 20,\r",
							" *   trailerField       [3] INTEGER DEFAULT 1\r",
							" * }\r",
							" *\r",
							" * HashAlgorithm  ::=  AlgorithmIdentifier\r",
							" *\r",
							" * MaskGenAlgorithm  ::=  AlgorithmIdentifier\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *   algorithm OBJECT IDENTIFIER,\r",
							" *   parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * @param oid The OID specifying the signature algorithm\r",
							" * @param obj The ASN.1 structure holding the parameters\r",
							" * @param fillDefaults Whether to use return default values where omitted\r",
							" * @return signature parameter object\r",
							" */\r",
							"var _readSignatureParameters = function(oid, obj, fillDefaults) {\r",
							"  var params = {};\r",
							"\r",
							"  if(oid !== oids['RSASSA-PSS']) {\r",
							"    return params;\r",
							"  }\r",
							"\r",
							"  if(fillDefaults) {\r",
							"    params = {\r",
							"      hash: {\r",
							"        algorithmOid: oids['sha1']\r",
							"      },\r",
							"      mgf: {\r",
							"        algorithmOid: oids['mgf1'],\r",
							"        hash: {\r",
							"          algorithmOid: oids['sha1']\r",
							"        }\r",
							"      },\r",
							"      saltLength: 20\r",
							"    };\r",
							"  }\r",
							"\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read RSASSA-PSS parameter block.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(capture.hashOid !== undefined) {\r",
							"    params.hash = params.hash || {};\r",
							"    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);\r",
							"  }\r",
							"\r",
							"  if(capture.maskGenOid !== undefined) {\r",
							"    params.mgf = params.mgf || {};\r",
							"    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);\r",
							"    params.mgf.hash = params.mgf.hash || {};\r",
							"    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);\r",
							"  }\r",
							"\r",
							"  if(capture.saltLength !== undefined) {\r",
							"    params.saltLength = capture.saltLength.charCodeAt(0);\r",
							"  }\r",
							"\r",
							"  return params;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509 certificate from PEM format.\r",
							" *\r",
							" * Note: If the certificate is to be verified then compute hash should\r",
							" * be set to true. This will scan the TBSCertificate part of the ASN.1\r",
							" * object while it is converted so it doesn't need to be converted back\r",
							" * to ASN.1-DER-encoding later.\r",
							" *\r",
							" * @param pem the PEM-formatted certificate.\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" * @param strict true to be strict when checking ASN.1 value lengths, false to\r",
							" *          allow truncated values (default: true).\r",
							" *\r",
							" * @return the certificate.\r",
							" */\r",
							"pki.certificateFromPem = function(pem, computeHash, strict) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'CERTIFICATE' &&\r",
							"    msg.type !== 'X509 CERTIFICATE' &&\r",
							"    msg.type !== 'TRUSTED CERTIFICATE') {\r",
							"    var error = new Error('Could not convert certificate from PEM; PEM header type ' +\r",
							"      'is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert certificate from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body, strict);\r",
							"\r",
							"  return pki.certificateFromAsn1(obj, computeHash);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509 certificate to PEM format.\r",
							" *\r",
							" * @param cert the certificate.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted certificate.\r",
							" */\r",
							"pki.certificateToPem = function(cert, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'CERTIFICATE',\r",
							"    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA public key from PEM format.\r",
							" *\r",
							" * @param pem the PEM-formatted public key.\r",
							" *\r",
							" * @return the public key.\r",
							" */\r",
							"pki.publicKeyFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {\r",
							"    var error = new Error('Could not convert public key from PEM; PEM header ' +\r",
							"      'type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert public key from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body);\r",
							"\r",
							"  return pki.publicKeyFromAsn1(obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).\r",
							" *\r",
							" * @param key the public key.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted public key.\r",
							" */\r",
							"pki.publicKeyToPem = function(key, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'PUBLIC KEY',\r",
							"    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA public key to PEM format (using an RSAPublicKey).\r",
							" *\r",
							" * @param key the public key.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted public key.\r",
							" */\r",
							"pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'RSA PUBLIC KEY',\r",
							"    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a fingerprint for the given public key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          [md] the message digest object to use (defaults to forge.md.sha1).\r",
							" *          [type] the type of fingerprint, such as 'RSAPublicKey',\r",
							" *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').\r",
							" *          [encoding] an alternative output encoding, such as 'hex'\r",
							" *            (defaults to none, outputs a byte buffer).\r",
							" *          [delimiter] the delimiter to use between bytes for 'hex' encoded\r",
							" *            output, eg: ':' (defaults to none).\r",
							" *\r",
							" * @return the fingerprint as a byte buffer or other encoding based on options.\r",
							" */\r",
							"pki.getPublicKeyFingerprint = function(key, options) {\r",
							"  options = options || {};\r",
							"  var md = options.md || forge.md.sha1.create();\r",
							"  var type = options.type || 'RSAPublicKey';\r",
							"\r",
							"  var bytes;\r",
							"  switch(type) {\r",
							"  case 'RSAPublicKey':\r",
							"    bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();\r",
							"    break;\r",
							"  case 'SubjectPublicKeyInfo':\r",
							"    bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();\r",
							"    break;\r",
							"  default:\r",
							"    throw new Error('Unknown fingerprint type \"' + options.type + '\".');\r",
							"  }\r",
							"\r",
							"  // hash public key bytes\r",
							"  md.start();\r",
							"  md.update(bytes);\r",
							"  var digest = md.digest();\r",
							"  if(options.encoding === 'hex') {\r",
							"    var hex = digest.toHex();\r",
							"    if(options.delimiter) {\r",
							"      return hex.match(/.{2}/g).join(options.delimiter);\r",
							"    }\r",
							"    return hex;\r",
							"  } else if(options.encoding === 'binary') {\r",
							"    return digest.getBytes();\r",
							"  } else if(options.encoding) {\r",
							"    throw new Error('Unknown encoding \"' + options.encoding + '\".');\r",
							"  }\r",
							"  return digest;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request (CSR) from PEM format.\r",
							" *\r",
							" * Note: If the certification request is to be verified then compute hash\r",
							" * should be set to true. This will scan the CertificationRequestInfo part of\r",
							" * the ASN.1 object while it is converted so it doesn't need to be converted\r",
							" * back to ASN.1-DER-encoding later.\r",
							" *\r",
							" * @param pem the PEM-formatted certificate.\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" * @param strict true to be strict when checking ASN.1 value lengths, false to\r",
							" *          allow truncated values (default: true).\r",
							" *\r",
							" * @return the certification request (CSR).\r",
							" */\r",
							"pki.certificationRequestFromPem = function(pem, computeHash, strict) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'CERTIFICATE REQUEST') {\r",
							"    var error = new Error('Could not convert certification request from PEM; ' +\r",
							"      'PEM header type is not \"CERTIFICATE REQUEST\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert certification request from PEM; ' +\r",
							"      'PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body, strict);\r",
							"\r",
							"  return pki.certificationRequestFromAsn1(obj, computeHash);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request (CSR) to PEM format.\r",
							" *\r",
							" * @param csr the certification request.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted certification request.\r",
							" */\r",
							"pki.certificationRequestToPem = function(csr, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'CERTIFICATE REQUEST',\r",
							"    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty X.509v3 RSA certificate.\r",
							" *\r",
							" * @return the certificate.\r",
							" */\r",
							"pki.createCertificate = function() {\r",
							"  var cert = {};\r",
							"  cert.version = 0x02;\r",
							"  cert.serialNumber = '00';\r",
							"  cert.signatureOid = null;\r",
							"  cert.signature = null;\r",
							"  cert.siginfo = {};\r",
							"  cert.siginfo.algorithmOid = null;\r",
							"  cert.validity = {};\r",
							"  cert.validity.notBefore = new Date();\r",
							"  cert.validity.notAfter = new Date();\r",
							"\r",
							"  cert.issuer = {};\r",
							"  cert.issuer.getField = function(sn) {\r",
							"    return _getAttribute(cert.issuer, sn);\r",
							"  };\r",
							"  cert.issuer.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.issuer.attributes.push(attr);\r",
							"  };\r",
							"  cert.issuer.attributes = [];\r",
							"  cert.issuer.hash = null;\r",
							"\r",
							"  cert.subject = {};\r",
							"  cert.subject.getField = function(sn) {\r",
							"    return _getAttribute(cert.subject, sn);\r",
							"  };\r",
							"  cert.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.subject.attributes.push(attr);\r",
							"  };\r",
							"  cert.subject.attributes = [];\r",
							"  cert.subject.hash = null;\r",
							"\r",
							"  cert.extensions = [];\r",
							"  cert.publicKey = null;\r",
							"  cert.md = null;\r",
							"\r",
							"  /**\r",
							"   * Sets the subject of this certificate.\r",
							"   *\r",
							"   * @param attrs the array of subject attributes to use.\r",
							"   * @param uniqueId an optional a unique ID to use.\r",
							"   */\r",
							"  cert.setSubject = function(attrs, uniqueId) {\r",
							"    // set new attributes, clear hash\r",
							"    _fillMissingFields(attrs);\r",
							"    cert.subject.attributes = attrs;\r",
							"    delete cert.subject.uniqueId;\r",
							"    if(uniqueId) {\r",
							"      // TODO: support arbitrary bit length ids\r",
							"      cert.subject.uniqueId = uniqueId;\r",
							"    }\r",
							"    cert.subject.hash = null;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Sets the issuer of this certificate.\r",
							"   *\r",
							"   * @param attrs the array of issuer attributes to use.\r",
							"   * @param uniqueId an optional a unique ID to use.\r",
							"   */\r",
							"  cert.setIssuer = function(attrs, uniqueId) {\r",
							"    // set new attributes, clear hash\r",
							"    _fillMissingFields(attrs);\r",
							"    cert.issuer.attributes = attrs;\r",
							"    delete cert.issuer.uniqueId;\r",
							"    if(uniqueId) {\r",
							"      // TODO: support arbitrary bit length ids\r",
							"      cert.issuer.uniqueId = uniqueId;\r",
							"    }\r",
							"    cert.issuer.hash = null;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Sets the extensions of this certificate.\r",
							"   *\r",
							"   * @param exts the array of extensions to use.\r",
							"   */\r",
							"  cert.setExtensions = function(exts) {\r",
							"    for(var i = 0; i < exts.length; ++i) {\r",
							"      _fillMissingExtensionFields(exts[i], {cert: cert});\r",
							"    }\r",
							"    // set new extensions\r",
							"    cert.extensions = exts;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Gets an extension by its name or id.\r",
							"   *\r",
							"   * @param options the name to use or an object with:\r",
							"   *          name the name to use.\r",
							"   *          id the id to use.\r",
							"   *\r",
							"   * @return the extension or null if not found.\r",
							"   */\r",
							"  cert.getExtension = function(options) {\r",
							"    if(typeof options === 'string') {\r",
							"      options = {name: options};\r",
							"    }\r",
							"\r",
							"    var rval = null;\r",
							"    var ext;\r",
							"    for(var i = 0; rval === null && i < cert.extensions.length; ++i) {\r",
							"      ext = cert.extensions[i];\r",
							"      if(options.id && ext.id === options.id) {\r",
							"        rval = ext;\r",
							"      } else if(options.name && ext.name === options.name) {\r",
							"        rval = ext;\r",
							"      }\r",
							"    }\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Signs this certificate using the given private key.\r",
							"   *\r",
							"   * @param key the private key to sign with.\r",
							"   * @param md the message digest object to use (defaults to forge.md.sha1).\r",
							"   */\r",
							"  cert.sign = function(key, md) {\r",
							"    // TODO: get signature OID from private key\r",
							"    cert.md = md || forge.md.sha1.create();\r",
							"    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];\r",
							"    if(!algorithmOid) {\r",
							"      var error = new Error('Could not compute certificate digest. ' +\r",
							"        'Unknown message digest algorithm OID.');\r",
							"      error.algorithm = cert.md.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;\r",
							"\r",
							"    // get TBSCertificate, convert to DER\r",
							"    cert.tbsCertificate = pki.getTBSCertificate(cert);\r",
							"    var bytes = asn1.toDer(cert.tbsCertificate);\r",
							"\r",
							"    // digest and sign\r",
							"    cert.md.update(bytes.getBytes());\r",
							"    cert.signature = key.sign(cert.md);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Attempts verify the signature on the passed certificate using this\r",
							"   * certificate's public key.\r",
							"   *\r",
							"   * @param child the certificate to verify.\r",
							"   *\r",
							"   * @return true if verified, false if not.\r",
							"   */\r",
							"  cert.verify = function(child) {\r",
							"    var rval = false;\r",
							"\r",
							"    if(!cert.issued(child)) {\r",
							"      var issuer = child.issuer;\r",
							"      var subject = cert.subject;\r",
							"      var error = new Error('The parent certificate did not issue the given child ' +\r",
							"        'certificate; the child certificate\\'s issuer does not match the ' +\r",
							"        'parent\\'s subject.');\r",
							"      error.expectedIssuer = issuer.attributes;\r",
							"      error.actualIssuer = subject.attributes;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    var md = child.md;\r",
							"    if(md === null) {\r",
							"      // check signature OID for supported signature types\r",
							"      if(child.signatureOid in oids) {\r",
							"        var oid = oids[child.signatureOid];\r",
							"        switch(oid) {\r",
							"        case 'sha1WithRSAEncryption':\r",
							"          md = forge.md.sha1.create();\r",
							"          break;\r",
							"        case 'md5WithRSAEncryption':\r",
							"          md = forge.md.md5.create();\r",
							"          break;\r",
							"        case 'sha256WithRSAEncryption':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        case 'sha384WithRSAEncryption':\r",
							"          md = forge.md.sha384.create();\r",
							"          break;\r",
							"        case 'sha512WithRSAEncryption':\r",
							"          md = forge.md.sha512.create();\r",
							"          break;\r",
							"        case 'RSASSA-PSS':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        }\r",
							"      }\r",
							"      if(md === null) {\r",
							"        var error = new Error('Could not compute certificate digest. ' +\r",
							"          'Unknown signature OID.');\r",
							"        error.signatureOid = child.signatureOid;\r",
							"        throw error;\r",
							"      }\r",
							"\r",
							"      // produce DER formatted TBSCertificate and digest it\r",
							"      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);\r",
							"      var bytes = asn1.toDer(tbsCertificate);\r",
							"      md.update(bytes.getBytes());\r",
							"    }\r",
							"\r",
							"    if(md !== null) {\r",
							"      var scheme;\r",
							"\r",
							"      switch(child.signatureOid) {\r",
							"      case oids.sha1WithRSAEncryption:\r",
							"        scheme = undefined;  /* use PKCS#1 v1.5 padding scheme */\r",
							"        break;\r",
							"      case oids['RSASSA-PSS']:\r",
							"        var hash, mgf;\r",
							"\r",
							"        /* initialize mgf */\r",
							"        hash = oids[child.signatureParameters.mgf.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          var error = new Error('Unsupported MGF hash function.');\r",
							"          error.oid = child.signatureParameters.mgf.hash.algorithmOid;\r",
							"          error.name = hash;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = oids[child.signatureParameters.mgf.algorithmOid];\r",
							"        if(mgf === undefined || forge.mgf[mgf] === undefined) {\r",
							"          var error = new Error('Unsupported MGF function.');\r",
							"          error.oid = child.signatureParameters.mgf.algorithmOid;\r",
							"          error.name = mgf;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = forge.mgf[mgf].create(forge.md[hash].create());\r",
							"\r",
							"        /* initialize hash function */\r",
							"        hash = oids[child.signatureParameters.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          throw {\r",
							"            message: 'Unsupported RSASSA-PSS hash function.',\r",
							"            oid: child.signatureParameters.hash.algorithmOid,\r",
							"            name: hash\r",
							"          };\r",
							"        }\r",
							"\r",
							"        scheme = forge.pss.create(forge.md[hash].create(), mgf,\r",
							"          child.signatureParameters.saltLength);\r",
							"        break;\r",
							"      }\r",
							"\r",
							"      // verify signature on cert using public key\r",
							"      rval = cert.publicKey.verify(\r",
							"        md.digest().getBytes(), child.signature, scheme);\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Returns true if this certificate's issuer matches the passed\r",
							"   * certificate's subject. Note that no signature check is performed.\r",
							"   *\r",
							"   * @param parent the certificate to check.\r",
							"   *\r",
							"   * @return true if this certificate's issuer matches the passed certificate's\r",
							"   *         subject.\r",
							"   */\r",
							"  cert.isIssuer = function(parent) {\r",
							"    var rval = false;\r",
							"\r",
							"    var i = cert.issuer;\r",
							"    var s = parent.subject;\r",
							"\r",
							"    // compare hashes if present\r",
							"    if(i.hash && s.hash) {\r",
							"      rval = (i.hash === s.hash);\r",
							"    } else if(i.attributes.length === s.attributes.length) {\r",
							"      // all attributes are the same so issuer matches subject\r",
							"      rval = true;\r",
							"      var iattr, sattr;\r",
							"      for(var n = 0; rval && n < i.attributes.length; ++n) {\r",
							"        iattr = i.attributes[n];\r",
							"        sattr = s.attributes[n];\r",
							"        if(iattr.type !== sattr.type || iattr.value !== sattr.value) {\r",
							"          // attribute mismatch\r",
							"          rval = false;\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Returns true if this certificate's subject matches the issuer of the\r",
							"   * given certificate). Note that not signature check is performed.\r",
							"   *\r",
							"   * @param child the certificate to check.\r",
							"   *\r",
							"   * @return true if this certificate's subject matches the passed\r",
							"   *         certificate's issuer.\r",
							"   */\r",
							"  cert.issued = function(child) {\r",
							"    return child.isIssuer(cert);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Generates the subjectKeyIdentifier for this certificate as byte buffer.\r",
							"   *\r",
							"   * @return the subjectKeyIdentifier for this certificate as byte buffer.\r",
							"   */\r",
							"  cert.generateSubjectKeyIdentifier = function() {\r",
							"    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:\r",
							"\r",
							"      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the\r",
							"        value of the BIT STRING subjectPublicKey (excluding the tag,\r",
							"        length, and number of unused bits).\r",
							"\r",
							"      (2) The keyIdentifier is composed of a four bit type field with\r",
							"        the value 0100 followed by the least significant 60 bits of the\r",
							"        SHA-1 hash of the value of the BIT STRING subjectPublicKey\r",
							"        (excluding the tag, length, and number of unused bit string bits).\r",
							"    */\r",
							"\r",
							"    // skipping the tag, length, and number of unused bits is the same\r",
							"    // as just using the RSAPublicKey (for RSA keys, which are the\r",
							"    // only ones supported)\r",
							"    return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Verifies the subjectKeyIdentifier extension value for this certificate\r",
							"   * against its public key. If no extension is found, false will be\r",
							"   * returned.\r",
							"   *\r",
							"   * @return true if verified, false if not.\r",
							"   */\r",
							"  cert.verifySubjectKeyIdentifier = function() {\r",
							"    var oid = oids['subjectKeyIdentifier'];\r",
							"    for(var i = 0; i < cert.extensions.length; ++i) {\r",
							"      var ext = cert.extensions[i];\r",
							"      if(ext.id === oid) {\r",
							"        var ski = cert.generateSubjectKeyIdentifier().getBytes();\r",
							"        return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);\r",
							"      }\r",
							"    }\r",
							"    return false;\r",
							"  };\r",
							"\r",
							"  return cert;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509v3 RSA certificate from an ASN.1 object.\r",
							" *\r",
							" * Note: If the certificate is to be verified then compute hash should\r",
							" * be set to true. There is currently no implementation for converting\r",
							" * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1\r",
							" * object needs to be scanned before the cert object is created.\r",
							" *\r",
							" * @param obj the asn1 representation of an X.509v3 RSA certificate.\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" *\r",
							" * @return the certificate.\r",
							" */\r",
							"pki.certificateFromAsn1 = function(obj, computeHash) {\r",
							"  // validate certificate and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, x509CertificateValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read X.509 certificate. ' +\r",
							"      'ASN.1 object is not an X509v3 Certificate.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get oid\r",
							"  var oid = asn1.derToOid(capture.publicKeyOid);\r",
							"  if(oid !== pki.oids.rsaEncryption) {\r",
							"    throw new Error('Cannot read public key. OID is not RSA.');\r",
							"  }\r",
							"\r",
							"  // create certificate\r",
							"  var cert = pki.createCertificate();\r",
							"  cert.version = capture.certVersion ?\r",
							"    capture.certVersion.charCodeAt(0) : 0;\r",
							"  var serial = forge.util.createBuffer(capture.certSerialNumber);\r",
							"  cert.serialNumber = serial.toHex();\r",
							"  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);\r",
							"  cert.signatureParameters = _readSignatureParameters(\r",
							"    cert.signatureOid, capture.certSignatureParams, true);\r",
							"  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);\r",
							"  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid,\r",
							"    capture.certinfoSignatureParams, false);\r",
							"  cert.signature = capture.certSignature;\r",
							"\r",
							"  var validity = [];\r",
							"  if(capture.certValidity1UTCTime !== undefined) {\r",
							"    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));\r",
							"  }\r",
							"  if(capture.certValidity2GeneralizedTime !== undefined) {\r",
							"    validity.push(asn1.generalizedTimeToDate(\r",
							"      capture.certValidity2GeneralizedTime));\r",
							"  }\r",
							"  if(capture.certValidity3UTCTime !== undefined) {\r",
							"    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));\r",
							"  }\r",
							"  if(capture.certValidity4GeneralizedTime !== undefined) {\r",
							"    validity.push(asn1.generalizedTimeToDate(\r",
							"      capture.certValidity4GeneralizedTime));\r",
							"  }\r",
							"  if(validity.length > 2) {\r",
							"    throw new Error('Cannot read notBefore/notAfter validity times; more ' +\r",
							"      'than two times were provided in the certificate.');\r",
							"  }\r",
							"  if(validity.length < 2) {\r",
							"    throw new Error('Cannot read notBefore/notAfter validity times; they ' +\r",
							"      'were not provided as either UTCTime or GeneralizedTime.');\r",
							"  }\r",
							"  cert.validity.notBefore = validity[0];\r",
							"  cert.validity.notAfter = validity[1];\r",
							"\r",
							"  // keep TBSCertificate to preserve signature when exporting\r",
							"  cert.tbsCertificate = capture.tbsCertificate;\r",
							"\r",
							"  if(computeHash) {\r",
							"    // check signature OID for supported signature types\r",
							"    cert.md = null;\r",
							"    if(cert.signatureOid in oids) {\r",
							"      var oid = oids[cert.signatureOid];\r",
							"      switch(oid) {\r",
							"      case 'sha1WithRSAEncryption':\r",
							"        cert.md = forge.md.sha1.create();\r",
							"        break;\r",
							"      case 'md5WithRSAEncryption':\r",
							"        cert.md = forge.md.md5.create();\r",
							"        break;\r",
							"      case 'sha256WithRSAEncryption':\r",
							"        cert.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      case 'sha384WithRSAEncryption':\r",
							"        cert.md = forge.md.sha384.create();\r",
							"        break;\r",
							"      case 'sha512WithRSAEncryption':\r",
							"        cert.md = forge.md.sha512.create();\r",
							"        break;\r",
							"      case 'RSASSA-PSS':\r",
							"        cert.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"    if(cert.md === null) {\r",
							"      var error = new Error('Could not compute certificate digest. ' +\r",
							"        'Unknown signature OID.');\r",
							"      error.signatureOid = cert.signatureOid;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // produce DER formatted TBSCertificate and digest it\r",
							"    var bytes = asn1.toDer(cert.tbsCertificate);\r",
							"    cert.md.update(bytes.getBytes());\r",
							"  }\r",
							"\r",
							"  // handle issuer, build issuer message digest\r",
							"  var imd = forge.md.sha1.create();\r",
							"  cert.issuer.getField = function(sn) {\r",
							"    return _getAttribute(cert.issuer, sn);\r",
							"  };\r",
							"  cert.issuer.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.issuer.attributes.push(attr);\r",
							"  };\r",
							"  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);\r",
							"  if(capture.certIssuerUniqueId) {\r",
							"    cert.issuer.uniqueId = capture.certIssuerUniqueId;\r",
							"  }\r",
							"  cert.issuer.hash = imd.digest().toHex();\r",
							"\r",
							"  // handle subject, build subject message digest\r",
							"  var smd = forge.md.sha1.create();\r",
							"  cert.subject.getField = function(sn) {\r",
							"    return _getAttribute(cert.subject, sn);\r",
							"  };\r",
							"  cert.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.subject.attributes.push(attr);\r",
							"  };\r",
							"  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);\r",
							"  if(capture.certSubjectUniqueId) {\r",
							"    cert.subject.uniqueId = capture.certSubjectUniqueId;\r",
							"  }\r",
							"  cert.subject.hash = smd.digest().toHex();\r",
							"\r",
							"  // handle extensions\r",
							"  if(capture.certExtensions) {\r",
							"    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);\r",
							"  } else {\r",
							"    cert.extensions = [];\r",
							"  }\r",
							"\r",
							"  // convert RSA public key from ASN.1\r",
							"  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\r",
							"\r",
							"  return cert;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an ASN.1 extensions object (with extension sequences as its\r",
							" * values) into an array of extension objects with types and values.\r",
							" *\r",
							" * Supported extensions:\r",
							" *\r",
							" * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }\r",
							" * KeyUsage ::= BIT STRING {\r",
							" *   digitalSignature        (0),\r",
							" *   nonRepudiation          (1),\r",
							" *   keyEncipherment         (2),\r",
							" *   dataEncipherment        (3),\r",
							" *   keyAgreement            (4),\r",
							" *   keyCertSign             (5),\r",
							" *   cRLSign                 (6),\r",
							" *   encipherOnly            (7),\r",
							" *   decipherOnly            (8)\r",
							" * }\r",
							" *\r",
							" * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }\r",
							" * BasicConstraints ::= SEQUENCE {\r",
							" *   cA                      BOOLEAN DEFAULT FALSE,\r",
							" *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL\r",
							" * }\r",
							" *\r",
							" * subjectAltName EXTENSION ::= {\r",
							" *   SYNTAX GeneralNames\r",
							" *   IDENTIFIED BY id-ce-subjectAltName\r",
							" * }\r",
							" *\r",
							" * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\r",
							" *\r",
							" * GeneralName ::= CHOICE {\r",
							" *   otherName      [0] INSTANCE OF OTHER-NAME,\r",
							" *   rfc822Name     [1] IA5String,\r",
							" *   dNSName        [2] IA5String,\r",
							" *   x400Address    [3] ORAddress,\r",
							" *   directoryName  [4] Name,\r",
							" *   ediPartyName   [5] EDIPartyName,\r",
							" *   uniformResourceIdentifier [6] IA5String,\r",
							" *   IPAddress      [7] OCTET STRING,\r",
							" *   registeredID   [8] OBJECT IDENTIFIER\r",
							" * }\r",
							" *\r",
							" * OTHER-NAME ::= TYPE-IDENTIFIER\r",
							" *\r",
							" * EDIPartyName ::= SEQUENCE {\r",
							" *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,\r",
							" *   partyName    [1] DirectoryString {ub-name}\r",
							" * }\r",
							" *\r",
							" * @param exts the extensions ASN.1 with extension sequences to parse.\r",
							" *\r",
							" * @return the array.\r",
							" */\r",
							"pki.certificateExtensionsFromAsn1 = function(exts) {\r",
							"  var rval = [];\r",
							"  for(var i = 0; i < exts.value.length; ++i) {\r",
							"    // get extension sequence\r",
							"    var extseq = exts.value[i];\r",
							"    for(var ei = 0; ei < extseq.value.length; ++ei) {\r",
							"      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses a single certificate extension from ASN.1.\r",
							" *\r",
							" * @param ext the extension in ASN.1 format.\r",
							" *\r",
							" * @return the parsed extension as an object.\r",
							" */\r",
							"pki.certificateExtensionFromAsn1 = function(ext) {\r",
							"  // an extension has:\r",
							"  // [0] extnID      OBJECT IDENTIFIER\r",
							"  // [1] critical    BOOLEAN DEFAULT FALSE\r",
							"  // [2] extnValue   OCTET STRING\r",
							"  var e = {};\r",
							"  e.id = asn1.derToOid(ext.value[0].value);\r",
							"  e.critical = false;\r",
							"  if(ext.value[1].type === asn1.Type.BOOLEAN) {\r",
							"    e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);\r",
							"    e.value = ext.value[2].value;\r",
							"  } else {\r",
							"    e.value = ext.value[1].value;\r",
							"  }\r",
							"  // if the oid is known, get its name\r",
							"  if(e.id in oids) {\r",
							"    e.name = oids[e.id];\r",
							"\r",
							"    // handle key usage\r",
							"    if(e.name === 'keyUsage') {\r",
							"      // get value as BIT STRING\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      var b2 = 0x00;\r",
							"      var b3 = 0x00;\r",
							"      if(ev.value.length > 1) {\r",
							"        // skip first byte, just indicates unused bits which\r",
							"        // will be padded with 0s anyway\r",
							"        // get bytes with flag bits\r",
							"        b2 = ev.value.charCodeAt(1);\r",
							"        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;\r",
							"      }\r",
							"      // set flags\r",
							"      e.digitalSignature = (b2 & 0x80) === 0x80;\r",
							"      e.nonRepudiation = (b2 & 0x40) === 0x40;\r",
							"      e.keyEncipherment = (b2 & 0x20) === 0x20;\r",
							"      e.dataEncipherment = (b2 & 0x10) === 0x10;\r",
							"      e.keyAgreement = (b2 & 0x08) === 0x08;\r",
							"      e.keyCertSign = (b2 & 0x04) === 0x04;\r",
							"      e.cRLSign = (b2 & 0x02) === 0x02;\r",
							"      e.encipherOnly = (b2 & 0x01) === 0x01;\r",
							"      e.decipherOnly = (b3 & 0x80) === 0x80;\r",
							"    } else if(e.name === 'basicConstraints') {\r",
							"      // handle basic constraints\r",
							"      // get value as SEQUENCE\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      // get cA BOOLEAN flag (defaults to false)\r",
							"      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {\r",
							"        e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);\r",
							"      } else {\r",
							"        e.cA = false;\r",
							"      }\r",
							"      // get path length constraint\r",
							"      var value = null;\r",
							"      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {\r",
							"        value = ev.value[0].value;\r",
							"      } else if(ev.value.length > 1) {\r",
							"        value = ev.value[1].value;\r",
							"      }\r",
							"      if(value !== null) {\r",
							"        e.pathLenConstraint = asn1.derToInteger(value);\r",
							"      }\r",
							"    } else if(e.name === 'extKeyUsage') {\r",
							"      // handle extKeyUsage\r",
							"      // value is a SEQUENCE of OIDs\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      for(var vi = 0; vi < ev.value.length; ++vi) {\r",
							"        var oid = asn1.derToOid(ev.value[vi].value);\r",
							"        if(oid in oids) {\r",
							"          e[oids[oid]] = true;\r",
							"        } else {\r",
							"          e[oid] = true;\r",
							"        }\r",
							"      }\r",
							"    } else if(e.name === 'nsCertType') {\r",
							"      // handle nsCertType\r",
							"      // get value as BIT STRING\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      var b2 = 0x00;\r",
							"      if(ev.value.length > 1) {\r",
							"        // skip first byte, just indicates unused bits which\r",
							"        // will be padded with 0s anyway\r",
							"        // get bytes with flag bits\r",
							"        b2 = ev.value.charCodeAt(1);\r",
							"      }\r",
							"      // set flags\r",
							"      e.client = (b2 & 0x80) === 0x80;\r",
							"      e.server = (b2 & 0x40) === 0x40;\r",
							"      e.email = (b2 & 0x20) === 0x20;\r",
							"      e.objsign = (b2 & 0x10) === 0x10;\r",
							"      e.reserved = (b2 & 0x08) === 0x08;\r",
							"      e.sslCA = (b2 & 0x04) === 0x04;\r",
							"      e.emailCA = (b2 & 0x02) === 0x02;\r",
							"      e.objCA = (b2 & 0x01) === 0x01;\r",
							"    } else if(\r",
							"      e.name === 'subjectAltName' ||\r",
							"      e.name === 'issuerAltName') {\r",
							"      // handle subjectAltName/issuerAltName\r",
							"      e.altNames = [];\r",
							"\r",
							"      // ev is a SYNTAX SEQUENCE\r",
							"      var gn;\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      for(var n = 0; n < ev.value.length; ++n) {\r",
							"        // get GeneralName\r",
							"        gn = ev.value[n];\r",
							"\r",
							"        var altName = {\r",
							"          type: gn.type,\r",
							"          value: gn.value\r",
							"        };\r",
							"        e.altNames.push(altName);\r",
							"\r",
							"        // Note: Support for types 1,2,6,7,8\r",
							"        switch(gn.type) {\r",
							"        // rfc822Name\r",
							"        case 1:\r",
							"        // dNSName\r",
							"        case 2:\r",
							"        // uniformResourceIdentifier (URI)\r",
							"        case 6:\r",
							"          break;\r",
							"        // IPAddress\r",
							"        case 7:\r",
							"          // convert to IPv4/IPv6 string representation\r",
							"          altName.ip = forge.util.bytesToIP(gn.value);\r",
							"          break;\r",
							"        // registeredID\r",
							"        case 8:\r",
							"          altName.oid = asn1.derToOid(gn.value);\r",
							"          break;\r",
							"        default:\r",
							"          // unsupported\r",
							"        }\r",
							"      }\r",
							"    } else if(e.name === 'subjectKeyIdentifier') {\r",
							"      // value is an OCTETSTRING w/the hash of the key-type specific\r",
							"      // public key structure (eg: RSAPublicKey)\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);\r",
							"    }\r",
							"  }\r",
							"  return e;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.\r",
							" *\r",
							" * Note: If the certification request is to be verified then compute hash\r",
							" * should be set to true. There is currently no implementation for converting\r",
							" * a certificate back to ASN.1 so the CertificationRequestInfo part of the\r",
							" * ASN.1 object needs to be scanned before the csr object is created.\r",
							" *\r",
							" * @param obj the asn1 representation of a PKCS#10 certification request (CSR).\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" *\r",
							" * @return the certification request (CSR).\r",
							" */\r",
							"pki.certificationRequestFromAsn1 = function(obj, computeHash) {\r",
							"  // validate certification request and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, certificationRequestValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#10 certificate request. ' +\r",
							"      'ASN.1 object is not a PKCS#10 CertificationRequest.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get oid\r",
							"  var oid = asn1.derToOid(capture.publicKeyOid);\r",
							"  if(oid !== pki.oids.rsaEncryption) {\r",
							"    throw new Error('Cannot read public key. OID is not RSA.');\r",
							"  }\r",
							"\r",
							"  // create certification request\r",
							"  var csr = pki.createCertificationRequest();\r",
							"  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;\r",
							"  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);\r",
							"  csr.signatureParameters = _readSignatureParameters(\r",
							"    csr.signatureOid, capture.csrSignatureParams, true);\r",
							"  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);\r",
							"  csr.siginfo.parameters = _readSignatureParameters(\r",
							"    csr.siginfo.algorithmOid, capture.csrSignatureParams, false);\r",
							"  csr.signature = capture.csrSignature;\r",
							"\r",
							"  // keep CertificationRequestInfo to preserve signature when exporting\r",
							"  csr.certificationRequestInfo = capture.certificationRequestInfo;\r",
							"\r",
							"  if(computeHash) {\r",
							"    // check signature OID for supported signature types\r",
							"    csr.md = null;\r",
							"    if(csr.signatureOid in oids) {\r",
							"      var oid = oids[csr.signatureOid];\r",
							"      switch(oid) {\r",
							"      case 'sha1WithRSAEncryption':\r",
							"        csr.md = forge.md.sha1.create();\r",
							"        break;\r",
							"      case 'md5WithRSAEncryption':\r",
							"        csr.md = forge.md.md5.create();\r",
							"        break;\r",
							"      case 'sha256WithRSAEncryption':\r",
							"        csr.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      case 'sha384WithRSAEncryption':\r",
							"        csr.md = forge.md.sha384.create();\r",
							"        break;\r",
							"      case 'sha512WithRSAEncryption':\r",
							"        csr.md = forge.md.sha512.create();\r",
							"        break;\r",
							"      case 'RSASSA-PSS':\r",
							"        csr.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"    if(csr.md === null) {\r",
							"      var error = new Error('Could not compute certification request digest. ' +\r",
							"        'Unknown signature OID.');\r",
							"      error.signatureOid = csr.signatureOid;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // produce DER formatted CertificationRequestInfo and digest it\r",
							"    var bytes = asn1.toDer(csr.certificationRequestInfo);\r",
							"    csr.md.update(bytes.getBytes());\r",
							"  }\r",
							"\r",
							"  // handle subject, build subject message digest\r",
							"  var smd = forge.md.sha1.create();\r",
							"  csr.subject.getField = function(sn) {\r",
							"    return _getAttribute(csr.subject, sn);\r",
							"  };\r",
							"  csr.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.subject.attributes.push(attr);\r",
							"  };\r",
							"  csr.subject.attributes = pki.RDNAttributesAsArray(\r",
							"    capture.certificationRequestInfoSubject, smd);\r",
							"  csr.subject.hash = smd.digest().toHex();\r",
							"\r",
							"  // convert RSA public key from ASN.1\r",
							"  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\r",
							"\r",
							"  // convert attributes from ASN.1\r",
							"  csr.getAttribute = function(sn) {\r",
							"    return _getAttribute(csr, sn);\r",
							"  };\r",
							"  csr.addAttribute = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.attributes.push(attr);\r",
							"  };\r",
							"  csr.attributes = pki.CRIAttributesAsArray(\r",
							"    capture.certificationRequestInfoAttributes || []);\r",
							"\r",
							"  return csr;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty certification request (a CSR or certificate signing\r",
							" * request). Once created, its public key and attributes can be set and then\r",
							" * it can be signed.\r",
							" *\r",
							" * @return the empty certification request.\r",
							" */\r",
							"pki.createCertificationRequest = function() {\r",
							"  var csr = {};\r",
							"  csr.version = 0x00;\r",
							"  csr.signatureOid = null;\r",
							"  csr.signature = null;\r",
							"  csr.siginfo = {};\r",
							"  csr.siginfo.algorithmOid = null;\r",
							"\r",
							"  csr.subject = {};\r",
							"  csr.subject.getField = function(sn) {\r",
							"    return _getAttribute(csr.subject, sn);\r",
							"  };\r",
							"  csr.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.subject.attributes.push(attr);\r",
							"  };\r",
							"  csr.subject.attributes = [];\r",
							"  csr.subject.hash = null;\r",
							"\r",
							"  csr.publicKey = null;\r",
							"  csr.attributes = [];\r",
							"  csr.getAttribute = function(sn) {\r",
							"    return _getAttribute(csr, sn);\r",
							"  };\r",
							"  csr.addAttribute = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.attributes.push(attr);\r",
							"  };\r",
							"  csr.md = null;\r",
							"\r",
							"  /**\r",
							"   * Sets the subject of this certification request.\r",
							"   *\r",
							"   * @param attrs the array of subject attributes to use.\r",
							"   */\r",
							"  csr.setSubject = function(attrs) {\r",
							"    // set new attributes\r",
							"    _fillMissingFields(attrs);\r",
							"    csr.subject.attributes = attrs;\r",
							"    csr.subject.hash = null;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Sets the attributes of this certification request.\r",
							"   *\r",
							"   * @param attrs the array of attributes to use.\r",
							"   */\r",
							"  csr.setAttributes = function(attrs) {\r",
							"    // set new attributes\r",
							"    _fillMissingFields(attrs);\r",
							"    csr.attributes = attrs;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Signs this certification request using the given private key.\r",
							"   *\r",
							"   * @param key the private key to sign with.\r",
							"   * @param md the message digest object to use (defaults to forge.md.sha1).\r",
							"   */\r",
							"  csr.sign = function(key, md) {\r",
							"    // TODO: get signature OID from private key\r",
							"    csr.md = md || forge.md.sha1.create();\r",
							"    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];\r",
							"    if(!algorithmOid) {\r",
							"      var error = new Error('Could not compute certification request digest. ' +\r",
							"        'Unknown message digest algorithm OID.');\r",
							"      error.algorithm = csr.md.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;\r",
							"\r",
							"    // get CertificationRequestInfo, convert to DER\r",
							"    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);\r",
							"    var bytes = asn1.toDer(csr.certificationRequestInfo);\r",
							"\r",
							"    // digest and sign\r",
							"    csr.md.update(bytes.getBytes());\r",
							"    csr.signature = key.sign(csr.md);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Attempts verify the signature on the passed certification request using\r",
							"   * its public key.\r",
							"   *\r",
							"   * A CSR that has been exported to a file in PEM format can be verified using\r",
							"   * OpenSSL using this command:\r",
							"   *\r",
							"   * openssl req -in <the-csr-pem-file> -verify -noout -text\r",
							"   *\r",
							"   * @return true if verified, false if not.\r",
							"   */\r",
							"  csr.verify = function() {\r",
							"    var rval = false;\r",
							"\r",
							"    var md = csr.md;\r",
							"    if(md === null) {\r",
							"      // check signature OID for supported signature types\r",
							"      if(csr.signatureOid in oids) {\r",
							"        // TODO: create DRY `OID to md` function\r",
							"        var oid = oids[csr.signatureOid];\r",
							"        switch(oid) {\r",
							"        case 'sha1WithRSAEncryption':\r",
							"          md = forge.md.sha1.create();\r",
							"          break;\r",
							"        case 'md5WithRSAEncryption':\r",
							"          md = forge.md.md5.create();\r",
							"          break;\r",
							"        case 'sha256WithRSAEncryption':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        case 'sha384WithRSAEncryption':\r",
							"          md = forge.md.sha384.create();\r",
							"          break;\r",
							"        case 'sha512WithRSAEncryption':\r",
							"          md = forge.md.sha512.create();\r",
							"          break;\r",
							"        case 'RSASSA-PSS':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        }\r",
							"      }\r",
							"      if(md === null) {\r",
							"        var error = new Error('Could not compute certification request digest. ' +\r",
							"          'Unknown signature OID.');\r",
							"        error.signatureOid = csr.signatureOid;\r",
							"        throw error;\r",
							"      }\r",
							"\r",
							"      // produce DER formatted CertificationRequestInfo and digest it\r",
							"      var cri = csr.certificationRequestInfo ||\r",
							"        pki.getCertificationRequestInfo(csr);\r",
							"      var bytes = asn1.toDer(cri);\r",
							"      md.update(bytes.getBytes());\r",
							"    }\r",
							"\r",
							"    if(md !== null) {\r",
							"      var scheme;\r",
							"\r",
							"      switch(csr.signatureOid) {\r",
							"      case oids.sha1WithRSAEncryption:\r",
							"        /* use PKCS#1 v1.5 padding scheme */\r",
							"        break;\r",
							"      case oids['RSASSA-PSS']:\r",
							"        var hash, mgf;\r",
							"\r",
							"        /* initialize mgf */\r",
							"        hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          var error = new Error('Unsupported MGF hash function.');\r",
							"          error.oid = csr.signatureParameters.mgf.hash.algorithmOid;\r",
							"          error.name = hash;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = oids[csr.signatureParameters.mgf.algorithmOid];\r",
							"        if(mgf === undefined || forge.mgf[mgf] === undefined) {\r",
							"          var error = new Error('Unsupported MGF function.');\r",
							"          error.oid = csr.signatureParameters.mgf.algorithmOid;\r",
							"          error.name = mgf;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = forge.mgf[mgf].create(forge.md[hash].create());\r",
							"\r",
							"        /* initialize hash function */\r",
							"        hash = oids[csr.signatureParameters.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          var error = new Error('Unsupported RSASSA-PSS hash function.');\r",
							"          error.oid = csr.signatureParameters.hash.algorithmOid;\r",
							"          error.name = hash;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        scheme = forge.pss.create(forge.md[hash].create(), mgf,\r",
							"          csr.signatureParameters.saltLength);\r",
							"        break;\r",
							"      }\r",
							"\r",
							"      // verify signature on csr using its public key\r",
							"      rval = csr.publicKey.verify(\r",
							"        md.digest().getBytes(), csr.signature, scheme);\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return csr;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.\r",
							" *\r",
							" * @param obj the subject or issuer (distinguished name).\r",
							" *\r",
							" * @return the ASN.1 RDNSequence.\r",
							" */\r",
							"function _dnToAsn1(obj) {\r",
							"  // create an empty RDNSequence\r",
							"  var rval = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"  // iterate over attributes\r",
							"  var attr, set;\r",
							"  var attrs = obj.attributes;\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    attr = attrs[i];\r",
							"    var value = attr.value;\r",
							"\r",
							"    // reuse tag class for attribute value if available\r",
							"    var valueTagClass = asn1.Type.PRINTABLESTRING;\r",
							"    if('valueTagClass' in attr) {\r",
							"      valueTagClass = attr.valueTagClass;\r",
							"\r",
							"      if(valueTagClass === asn1.Type.UTF8) {\r",
							"        value = forge.util.encodeUtf8(value);\r",
							"      }\r",
							"      // FIXME: handle more encodings\r",
							"    }\r",
							"\r",
							"    // create a RelativeDistinguishedName set\r",
							"    // each value in the set is an AttributeTypeAndValue first\r",
							"    // containing the type (an OID) and second the value\r",
							"    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // AttributeType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(attr.type).getBytes()),\r",
							"        // AttributeValue\r",
							"        asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)\r",
							"      ])\r",
							"    ]);\r",
							"    rval.value.push(set);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Gets all printable attributes (typically of an issuer or subject) in a\r",
							" * simplified JSON format for display.\r",
							" *\r",
							" * @param attrs the attributes.\r",
							" *\r",
							" * @return the JSON for display.\r",
							" */\r",
							"function _getAttributesAsJson(attrs) {\r",
							"  var rval = {};\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    var attr = attrs[i];\r",
							"    if(attr.shortName && (\r",
							"      attr.valueTagClass === asn1.Type.UTF8 ||\r",
							"      attr.valueTagClass === asn1.Type.PRINTABLESTRING ||\r",
							"      attr.valueTagClass === asn1.Type.IA5STRING)) {\r",
							"      var value = attr.value;\r",
							"      if(attr.valueTagClass === asn1.Type.UTF8) {\r",
							"        value = forge.util.encodeUtf8(attr.value);\r",
							"      }\r",
							"      if(!(attr.shortName in rval)) {\r",
							"        rval[attr.shortName] = value;\r",
							"      } else if(forge.util.isArray(rval[attr.shortName])) {\r",
							"        rval[attr.shortName].push(value);\r",
							"      } else {\r",
							"        rval[attr.shortName] = [rval[attr.shortName], value];\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Fills in missing fields in attributes.\r",
							" *\r",
							" * @param attrs the attributes to fill missing fields in.\r",
							" */\r",
							"function _fillMissingFields(attrs) {\r",
							"  var attr;\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    attr = attrs[i];\r",
							"\r",
							"    // populate missing name\r",
							"    if(typeof attr.name === 'undefined') {\r",
							"      if(attr.type && attr.type in pki.oids) {\r",
							"        attr.name = pki.oids[attr.type];\r",
							"      } else if(attr.shortName && attr.shortName in _shortNames) {\r",
							"        attr.name = pki.oids[_shortNames[attr.shortName]];\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // populate missing type (OID)\r",
							"    if(typeof attr.type === 'undefined') {\r",
							"      if(attr.name && attr.name in pki.oids) {\r",
							"        attr.type = pki.oids[attr.name];\r",
							"      } else {\r",
							"        var error = new Error('Attribute type not specified.');\r",
							"        error.attribute = attr;\r",
							"        throw error;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // populate missing shortname\r",
							"    if(typeof attr.shortName === 'undefined') {\r",
							"      if(attr.name && attr.name in _shortNames) {\r",
							"        attr.shortName = _shortNames[attr.name];\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // convert extensions to value\r",
							"    if(attr.type === oids.extensionRequest) {\r",
							"      attr.valueConstructed = true;\r",
							"      attr.valueTagClass = asn1.Type.SEQUENCE;\r",
							"      if(!attr.value && attr.extensions) {\r",
							"        attr.value = [];\r",
							"        for(var ei = 0; ei < attr.extensions.length; ++ei) {\r",
							"          attr.value.push(pki.certificateExtensionToAsn1(\r",
							"            _fillMissingExtensionFields(attr.extensions[ei])));\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(typeof attr.value === 'undefined') {\r",
							"      var error = new Error('Attribute value not specified.');\r",
							"      error.attribute = attr;\r",
							"      throw error;\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Fills in missing fields in certificate extensions.\r",
							" *\r",
							" * @param e the extension.\r",
							" * @param [options] the options to use.\r",
							" *          [cert] the certificate the extensions are for.\r",
							" *\r",
							" * @return the extension.\r",
							" */\r",
							"function _fillMissingExtensionFields(e, options) {\r",
							"  options = options || {};\r",
							"\r",
							"  // populate missing name\r",
							"  if(typeof e.name === 'undefined') {\r",
							"    if(e.id && e.id in pki.oids) {\r",
							"      e.name = pki.oids[e.id];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // populate missing id\r",
							"  if(typeof e.id === 'undefined') {\r",
							"    if(e.name && e.name in pki.oids) {\r",
							"      e.id = pki.oids[e.name];\r",
							"    } else {\r",
							"      var error = new Error('Extension ID not specified.');\r",
							"      error.extension = e;\r",
							"      throw error;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(typeof e.value !== 'undefined') {\r",
							"    return e;\r",
							"  }\r",
							"\r",
							"  // handle missing value:\r",
							"\r",
							"  // value is a BIT STRING\r",
							"  if(e.name === 'keyUsage') {\r",
							"    // build flags\r",
							"    var unused = 0;\r",
							"    var b2 = 0x00;\r",
							"    var b3 = 0x00;\r",
							"    if(e.digitalSignature) {\r",
							"      b2 |= 0x80;\r",
							"      unused = 7;\r",
							"    }\r",
							"    if(e.nonRepudiation) {\r",
							"      b2 |= 0x40;\r",
							"      unused = 6;\r",
							"    }\r",
							"    if(e.keyEncipherment) {\r",
							"      b2 |= 0x20;\r",
							"      unused = 5;\r",
							"    }\r",
							"    if(e.dataEncipherment) {\r",
							"      b2 |= 0x10;\r",
							"      unused = 4;\r",
							"    }\r",
							"    if(e.keyAgreement) {\r",
							"      b2 |= 0x08;\r",
							"      unused = 3;\r",
							"    }\r",
							"    if(e.keyCertSign) {\r",
							"      b2 |= 0x04;\r",
							"      unused = 2;\r",
							"    }\r",
							"    if(e.cRLSign) {\r",
							"      b2 |= 0x02;\r",
							"      unused = 1;\r",
							"    }\r",
							"    if(e.encipherOnly) {\r",
							"      b2 |= 0x01;\r",
							"      unused = 0;\r",
							"    }\r",
							"    if(e.decipherOnly) {\r",
							"      b3 |= 0x80;\r",
							"      unused = 7;\r",
							"    }\r",
							"\r",
							"    // create bit string\r",
							"    var value = String.fromCharCode(unused);\r",
							"    if(b3 !== 0) {\r",
							"      value += String.fromCharCode(b2) + String.fromCharCode(b3);\r",
							"    } else if(b2 !== 0) {\r",
							"      value += String.fromCharCode(b2);\r",
							"    }\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\r",
							"  } else if(e.name === 'basicConstraints') {\r",
							"    // basicConstraints is a SEQUENCE\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    // cA BOOLEAN flag defaults to false\r",
							"    if(e.cA) {\r",
							"      e.value.value.push(asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,\r",
							"        String.fromCharCode(0xFF)));\r",
							"    }\r",
							"    if('pathLenConstraint' in e) {\r",
							"      e.value.value.push(asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        asn1.integerToDer(e.pathLenConstraint).getBytes()));\r",
							"    }\r",
							"  } else if(e.name === 'extKeyUsage') {\r",
							"    // extKeyUsage is a SEQUENCE of OIDs\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    var seq = e.value.value;\r",
							"    for(var key in e) {\r",
							"      if(e[key] !== true) {\r",
							"        continue;\r",
							"      }\r",
							"      // key is name in OID map\r",
							"      if(key in oids) {\r",
							"        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,\r",
							"          false, asn1.oidToDer(oids[key]).getBytes()));\r",
							"      } else if(key.indexOf('.') !== -1) {\r",
							"        // assume key is an OID\r",
							"        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,\r",
							"          false, asn1.oidToDer(key).getBytes()));\r",
							"      }\r",
							"    }\r",
							"  } else if(e.name === 'nsCertType') {\r",
							"    // nsCertType is a BIT STRING\r",
							"    // build flags\r",
							"    var unused = 0;\r",
							"    var b2 = 0x00;\r",
							"\r",
							"    if(e.client) {\r",
							"      b2 |= 0x80;\r",
							"      unused = 7;\r",
							"    }\r",
							"    if(e.server) {\r",
							"      b2 |= 0x40;\r",
							"      unused = 6;\r",
							"    }\r",
							"    if(e.email) {\r",
							"      b2 |= 0x20;\r",
							"      unused = 5;\r",
							"    }\r",
							"    if(e.objsign) {\r",
							"      b2 |= 0x10;\r",
							"      unused = 4;\r",
							"    }\r",
							"    if(e.reserved) {\r",
							"      b2 |= 0x08;\r",
							"      unused = 3;\r",
							"    }\r",
							"    if(e.sslCA) {\r",
							"      b2 |= 0x04;\r",
							"      unused = 2;\r",
							"    }\r",
							"    if(e.emailCA) {\r",
							"      b2 |= 0x02;\r",
							"      unused = 1;\r",
							"    }\r",
							"    if(e.objCA) {\r",
							"      b2 |= 0x01;\r",
							"      unused = 0;\r",
							"    }\r",
							"\r",
							"    // create bit string\r",
							"    var value = String.fromCharCode(unused);\r",
							"    if(b2 !== 0) {\r",
							"      value += String.fromCharCode(b2);\r",
							"    }\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\r",
							"  } else if(e.name === 'subjectAltName' || e.name === 'issuerAltName') {\r",
							"    // SYNTAX SEQUENCE\r",
							"    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"    var altName;\r",
							"    for(var n = 0; n < e.altNames.length; ++n) {\r",
							"      altName = e.altNames[n];\r",
							"      var value = altName.value;\r",
							"      // handle IP\r",
							"      if(altName.type === 7 && altName.ip) {\r",
							"        value = forge.util.bytesFromIP(altName.ip);\r",
							"        if(value === null) {\r",
							"          var error = new Error(\r",
							"            'Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\r",
							"          error.extension = e;\r",
							"          throw error;\r",
							"        }\r",
							"      } else if(altName.type === 8) {\r",
							"        // handle OID\r",
							"        if(altName.oid) {\r",
							"          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\r",
							"        } else {\r",
							"          // deprecated ... convert value to OID\r",
							"          value = asn1.oidToDer(value);\r",
							"        }\r",
							"      }\r",
							"      e.value.value.push(asn1.create(\r",
							"        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,\r",
							"        value));\r",
							"    }\r",
							"  } else if(e.name === 'subjectKeyIdentifier' && options.cert) {\r",
							"    var ski = options.cert.generateSubjectKeyIdentifier();\r",
							"    e.subjectKeyIdentifier = ski.toHex();\r",
							"    // OCTETSTRING w/digest\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());\r",
							"  } else if(e.name === 'authorityKeyIdentifier' && options.cert) {\r",
							"    // SYNTAX SEQUENCE\r",
							"    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    var seq = e.value.value;\r",
							"\r",
							"    if(e.keyIdentifier) {\r",
							"      var keyIdentifier = (e.keyIdentifier === true ?\r",
							"        options.cert.generateSubjectKeyIdentifier().getBytes() :\r",
							"        e.keyIdentifier);\r",
							"      seq.push(\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));\r",
							"    }\r",
							"\r",
							"    if(e.authorityCertIssuer) {\r",
							"      var authorityCertIssuer = [\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [\r",
							"          _dnToAsn1(e.authorityCertIssuer === true ?\r",
							"            options.cert.issuer : e.authorityCertIssuer)\r",
							"        ])\r",
							"      ];\r",
							"      seq.push(\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));\r",
							"    }\r",
							"\r",
							"    if(e.serialNumber) {\r",
							"      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ?\r",
							"        options.cert.serialNumber : e.serialNumber);\r",
							"      seq.push(\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));\r",
							"    }\r",
							"  } else if (e.name === 'cRLDistributionPoints') {\r",
							"    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    var seq = e.value.value;\r",
							"\r",
							"    // Create sub SEQUENCE of DistributionPointName\r",
							"    var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"    // Create fullName CHOICE\r",
							"    var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\r",
							"    var altName;\r",
							"    for(var n = 0; n < e.altNames.length; ++n) {\r",
							"      altName = e.altNames[n];\r",
							"      var value = altName.value;\r",
							"      // handle IP\r",
							"      if(altName.type === 7 && altName.ip) {\r",
							"        value = forge.util.bytesFromIP(altName.ip);\r",
							"        if(value === null) {\r",
							"          var error = new Error(\r",
							"            'Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\r",
							"          error.extension = e;\r",
							"          throw error;\r",
							"        }\r",
							"      } else if(altName.type === 8) {\r",
							"        // handle OID\r",
							"        if(altName.oid) {\r",
							"          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\r",
							"        } else {\r",
							"          // deprecated ... convert value to OID\r",
							"          value = asn1.oidToDer(value);\r",
							"        }\r",
							"      }\r",
							"      fullNameGeneralNames.value.push(asn1.create(\r",
							"        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,\r",
							"        value));\r",
							"    }\r",
							"\r",
							"    // Add to the parent SEQUENCE\r",
							"    subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));\r",
							"    seq.push(subSeq);\r",
							"  }\r",
							"\r",
							"  // ensure value has been defined by now\r",
							"  if(typeof e.value === 'undefined') {\r",
							"    var error = new Error('Extension value not specified.');\r",
							"    error.extension = e;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  return e;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Convert signature parameters object to ASN.1\r",
							" *\r",
							" * @param {String} oid Signature algorithm OID\r",
							" * @param params The signature parametrs object\r",
							" * @return ASN.1 object representing signature parameters\r",
							" */\r",
							"function _signatureParametersToAsn1(oid, params) {\r",
							"  switch(oid) {\r",
							"  case oids['RSASSA-PSS']:\r",
							"    var parts = [];\r",
							"\r",
							"    if(params.hash.algorithmOid !== undefined) {\r",
							"      parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(params.hash.algorithmOid).getBytes()),\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"        ])\r",
							"      ]));\r",
							"    }\r",
							"\r",
							"    if(params.mgf.algorithmOid !== undefined) {\r",
							"      parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(params.mgf.algorithmOid).getBytes()),\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"              asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"          ])\r",
							"        ])\r",
							"      ]));\r",
							"    }\r",
							"\r",
							"    if(params.saltLength !== undefined) {\r",
							"      parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"          asn1.integerToDer(params.saltLength).getBytes())\r",
							"      ]));\r",
							"    }\r",
							"\r",
							"    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);\r",
							"\r",
							"  default:\r",
							"    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a certification request's attributes to an ASN.1 set of\r",
							" * CRIAttributes.\r",
							" *\r",
							" * @param csr certification request.\r",
							" *\r",
							" * @return the ASN.1 set of CRIAttributes.\r",
							" */\r",
							"function _CRIAttributesToAsn1(csr) {\r",
							"  // create an empty context-specific container\r",
							"  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\r",
							"\r",
							"  // no attributes, return empty container\r",
							"  if(csr.attributes.length === 0) {\r",
							"    return rval;\r",
							"  }\r",
							"\r",
							"  // each attribute has a sequence with a type and a set of values\r",
							"  var attrs = csr.attributes;\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    var attr = attrs[i];\r",
							"    var value = attr.value;\r",
							"\r",
							"    // reuse tag class for attribute value if available\r",
							"    var valueTagClass = asn1.Type.UTF8;\r",
							"    if('valueTagClass' in attr) {\r",
							"      valueTagClass = attr.valueTagClass;\r",
							"    }\r",
							"    if(valueTagClass === asn1.Type.UTF8) {\r",
							"      value = forge.util.encodeUtf8(value);\r",
							"    }\r",
							"    var valueConstructed = false;\r",
							"    if('valueConstructed' in attr) {\r",
							"      valueConstructed = attr.valueConstructed;\r",
							"    }\r",
							"    // FIXME: handle more encodings\r",
							"\r",
							"    // create a RelativeDistinguishedName set\r",
							"    // each value in the set is an AttributeTypeAndValue first\r",
							"    // containing the type (an OID) and second the value\r",
							"    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // AttributeType\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(attr.type).getBytes()),\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"        // AttributeValue\r",
							"        asn1.create(\r",
							"          asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)\r",
							"      ])\r",
							"    ]);\r",
							"    rval.value.push(seq);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.\r",
							" *\r",
							" * @param cert the certificate.\r",
							" *\r",
							" * @return the asn1 TBSCertificate.\r",
							" */\r",
							"pki.getTBSCertificate = function(cert) {\r",
							"  // TBSCertificate\r",
							"  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version\r",
							"    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"      // integer\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        asn1.integerToDer(cert.version).getBytes())\r",
							"    ]),\r",
							"    // serialNumber\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      forge.util.hexToBytes(cert.serialNumber)),\r",
							"    // signature\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),\r",
							"      // parameters\r",
							"      _signatureParametersToAsn1(\r",
							"        cert.siginfo.algorithmOid, cert.siginfo.parameters)\r",
							"    ]),\r",
							"    // issuer\r",
							"    _dnToAsn1(cert.issuer),\r",
							"    // validity\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // notBefore\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\r",
							"        asn1.dateToUtcTime(cert.validity.notBefore)),\r",
							"      // notAfter\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\r",
							"        asn1.dateToUtcTime(cert.validity.notAfter))\r",
							"    ]),\r",
							"    // subject\r",
							"    _dnToAsn1(cert.subject),\r",
							"    // SubjectPublicKeyInfo\r",
							"    pki.publicKeyToAsn1(cert.publicKey)\r",
							"  ]);\r",
							"\r",
							"  if(cert.issuer.uniqueId) {\r",
							"    // issuerUniqueID (optional)\r",
							"    tbs.value.push(\r",
							"      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"          // TODO: support arbitrary bit length ids\r",
							"          String.fromCharCode(0x00) +\r",
							"          cert.issuer.uniqueId\r",
							"        )\r",
							"      ])\r",
							"    );\r",
							"  }\r",
							"  if(cert.subject.uniqueId) {\r",
							"    // subjectUniqueID (optional)\r",
							"    tbs.value.push(\r",
							"      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"          // TODO: support arbitrary bit length ids\r",
							"          String.fromCharCode(0x00) +\r",
							"          cert.subject.uniqueId\r",
							"        )\r",
							"      ])\r",
							"    );\r",
							"  }\r",
							"\r",
							"  if(cert.extensions.length > 0) {\r",
							"    // extensions (optional)\r",
							"    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));\r",
							"  }\r",
							"\r",
							"  return tbs;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the ASN.1 CertificationRequestInfo part of a\r",
							" * PKCS#10 CertificationRequest.\r",
							" *\r",
							" * @param csr the certification request.\r",
							" *\r",
							" * @return the asn1 CertificationRequestInfo.\r",
							" */\r",
							"pki.getCertificationRequestInfo = function(csr) {\r",
							"  // CertificationRequestInfo\r",
							"  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(csr.version).getBytes()),\r",
							"    // subject\r",
							"    _dnToAsn1(csr.subject),\r",
							"    // SubjectPublicKeyInfo\r",
							"    pki.publicKeyToAsn1(csr.publicKey),\r",
							"    // attributes\r",
							"    _CRIAttributesToAsn1(csr)\r",
							"  ]);\r",
							"\r",
							"  return cri;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.\r",
							" *\r",
							" * @param dn the DistinguishedName.\r",
							" *\r",
							" * @return the asn1 representation of a DistinguishedName.\r",
							" */\r",
							"pki.distinguishedNameToAsn1 = function(dn) {\r",
							"  return _dnToAsn1(dn);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509v3 RSA certificate to an ASN.1 object.\r",
							" *\r",
							" * @param cert the certificate.\r",
							" *\r",
							" * @return the asn1 representation of an X.509v3 RSA certificate.\r",
							" */\r",
							"pki.certificateToAsn1 = function(cert) {\r",
							"  // prefer cached TBSCertificate over generating one\r",
							"  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);\r",
							"\r",
							"  // Certificate\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // TBSCertificate\r",
							"    tbsCertificate,\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(cert.signatureOid).getBytes()),\r",
							"      // parameters\r",
							"      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)\r",
							"    ]),\r",
							"    // SignatureValue\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"      String.fromCharCode(0x00) + cert.signature)\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts X.509v3 certificate extensions to ASN.1.\r",
							" *\r",
							" * @param exts the extensions to convert.\r",
							" *\r",
							" * @return the extensions in ASN.1 format.\r",
							" */\r",
							"pki.certificateExtensionsToAsn1 = function(exts) {\r",
							"  // create top-level extension container\r",
							"  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);\r",
							"\r",
							"  // create extension sequence (stores a sequence for each extension)\r",
							"  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"  rval.value.push(seq);\r",
							"\r",
							"  for(var i = 0; i < exts.length; ++i) {\r",
							"    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a single certificate extension to ASN.1.\r",
							" *\r",
							" * @param ext the extension to convert.\r",
							" *\r",
							" * @return the extension in ASN.1 format.\r",
							" */\r",
							"pki.certificateExtensionToAsn1 = function(ext) {\r",
							"  // create a sequence for each extension\r",
							"  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"  // extnID (OID)\r",
							"  extseq.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"    asn1.oidToDer(ext.id).getBytes()));\r",
							"\r",
							"  // critical defaults to false\r",
							"  if(ext.critical) {\r",
							"    // critical BOOLEAN DEFAULT FALSE\r",
							"    extseq.value.push(asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,\r",
							"      String.fromCharCode(0xFF)));\r",
							"  }\r",
							"\r",
							"  var value = ext.value;\r",
							"  if(typeof ext.value !== 'string') {\r",
							"    // value is asn.1\r",
							"    value = asn1.toDer(value).getBytes();\r",
							"  }\r",
							"\r",
							"  // extnValue (OCTET STRING)\r",
							"  extseq.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));\r",
							"\r",
							"  return extseq;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request to an ASN.1 object.\r",
							" *\r",
							" * @param csr the certification request.\r",
							" *\r",
							" * @return the asn1 representation of a certification request.\r",
							" */\r",
							"pki.certificationRequestToAsn1 = function(csr) {\r",
							"  // prefer cached CertificationRequestInfo over generating one\r",
							"  var cri = csr.certificationRequestInfo ||\r",
							"    pki.getCertificationRequestInfo(csr);\r",
							"\r",
							"  // Certificate\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // CertificationRequestInfo\r",
							"    cri,\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(csr.signatureOid).getBytes()),\r",
							"      // parameters\r",
							"      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)\r",
							"    ]),\r",
							"    // signature\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"      String.fromCharCode(0x00) + csr.signature)\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a CA store.\r",
							" *\r",
							" * @param certs an optional array of certificate objects or PEM-formatted\r",
							" *          certificate strings to add to the CA store.\r",
							" *\r",
							" * @return the CA store.\r",
							" */\r",
							"pki.createCaStore = function(certs) {\r",
							"  // create CA store\r",
							"  var caStore = {\r",
							"    // stored certificates\r",
							"    certs: {}\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Gets the certificate that issued the passed certificate or its\r",
							"   * 'parent'.\r",
							"   *\r",
							"   * @param cert the certificate to get the parent for.\r",
							"   *\r",
							"   * @return the parent certificate or null if none was found.\r",
							"   */\r",
							"  caStore.getIssuer = function(cert) {\r",
							"    var rval = getBySubject(cert.issuer);\r",
							"\r",
							"    // see if there are multiple matches\r",
							"    /*if(forge.util.isArray(rval)) {\r",
							"      // TODO: resolve multiple matches by checking\r",
							"      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.\r",
							"      // FIXME: or alternatively do authority key mapping\r",
							"      // if possible (X.509v1 certs can't work?)\r",
							"      throw new Error('Resolving multiple issuer matches not implemented yet.');\r",
							"    }*/\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Adds a trusted certificate to the store.\r",
							"   *\r",
							"   * @param cert the certificate to add as a trusted certificate (either a\r",
							"   *          pki.certificate object or a PEM-formatted certificate).\r",
							"   */\r",
							"  caStore.addCertificate = function(cert) {\r",
							"    // convert from pem if necessary\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = forge.pki.certificateFromPem(cert);\r",
							"    }\r",
							"\r",
							"    ensureSubjectHasHash(cert.subject);\r",
							"\r",
							"    if(!caStore.hasCertificate(cert)) {  // avoid duplicate certificates in store\r",
							"      if(cert.subject.hash in caStore.certs) {\r",
							"        // subject hash already exists, append to array\r",
							"        var tmp = caStore.certs[cert.subject.hash];\r",
							"        if(!forge.util.isArray(tmp)) {\r",
							"          tmp = [tmp];\r",
							"        }\r",
							"        tmp.push(cert);\r",
							"        caStore.certs[cert.subject.hash] = tmp;\r",
							"      } else {\r",
							"        caStore.certs[cert.subject.hash] = cert;\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Checks to see if the given certificate is in the store.\r",
							"   *\r",
							"   * @param cert the certificate to check (either a pki.certificate or a\r",
							"   *          PEM-formatted certificate).\r",
							"   *\r",
							"   * @return true if the certificate is in the store, false if not.\r",
							"   */\r",
							"  caStore.hasCertificate = function(cert) {\r",
							"    // convert from pem if necessary\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = forge.pki.certificateFromPem(cert);\r",
							"    }\r",
							"\r",
							"    var match = getBySubject(cert.subject);\r",
							"    if(!match) {\r",
							"      return false;\r",
							"    }\r",
							"    if(!forge.util.isArray(match)) {\r",
							"      match = [match];\r",
							"    }\r",
							"    // compare DER-encoding of certificates\r",
							"    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\r",
							"    for(var i = 0; i < match.length; ++i) {\r",
							"      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\r",
							"      if(der1 === der2) {\r",
							"        return true;\r",
							"      }\r",
							"    }\r",
							"    return false;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Lists all of the certificates kept in the store.\r",
							"   *\r",
							"   * @return an array of all of the pki.certificate objects in the store.\r",
							"   */\r",
							"  caStore.listAllCertificates = function() {\r",
							"    var certList = [];\r",
							"\r",
							"    for(var hash in caStore.certs) {\r",
							"      if(caStore.certs.hasOwnProperty(hash)) {\r",
							"        var value = caStore.certs[hash];\r",
							"        if(!forge.util.isArray(value)) {\r",
							"          certList.push(value);\r",
							"        } else {\r",
							"          for(var i = 0; i < value.length; ++i) {\r",
							"            certList.push(value[i]);\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return certList;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Removes a certificate from the store.\r",
							"   *\r",
							"   * @param cert the certificate to remove (either a pki.certificate or a\r",
							"   *          PEM-formatted certificate).\r",
							"   *\r",
							"   * @return the certificate that was removed or null if the certificate\r",
							"   *           wasn't in store.\r",
							"   */\r",
							"  caStore.removeCertificate = function(cert) {\r",
							"    var result;\r",
							"\r",
							"    // convert from pem if necessary\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = forge.pki.certificateFromPem(cert);\r",
							"    }\r",
							"    ensureSubjectHasHash(cert.subject);\r",
							"    if(!caStore.hasCertificate(cert)) {\r",
							"      return null;\r",
							"    }\r",
							"\r",
							"    var match = getBySubject(cert.subject);\r",
							"\r",
							"    if(!forge.util.isArray(match)) {\r",
							"      result = caStore.certs[cert.subject.hash];\r",
							"      delete caStore.certs[cert.subject.hash];\r",
							"      return result;\r",
							"    }\r",
							"\r",
							"    // compare DER-encoding of certificates\r",
							"    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\r",
							"    for(var i = 0; i < match.length; ++i) {\r",
							"      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\r",
							"      if(der1 === der2) {\r",
							"        result = match[i];\r",
							"        match.splice(i, 1);\r",
							"      }\r",
							"    }\r",
							"    if(match.length === 0) {\r",
							"      delete caStore.certs[cert.subject.hash];\r",
							"    }\r",
							"\r",
							"    return result;\r",
							"  };\r",
							"\r",
							"  function getBySubject(subject) {\r",
							"    ensureSubjectHasHash(subject);\r",
							"    return caStore.certs[subject.hash] || null;\r",
							"  }\r",
							"\r",
							"  function ensureSubjectHasHash(subject) {\r",
							"    // produce subject hash if it doesn't exist\r",
							"    if(!subject.hash) {\r",
							"      var md = forge.md.sha1.create();\r",
							"      subject.attributes =  pki.RDNAttributesAsArray(_dnToAsn1(subject), md);\r",
							"      subject.hash = md.digest().toHex();\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // auto-add passed in certs\r",
							"  if(certs) {\r",
							"    // parse PEM-formatted certificates as necessary\r",
							"    for(var i = 0; i < certs.length; ++i) {\r",
							"      var cert = certs[i];\r",
							"      caStore.addCertificate(cert);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return caStore;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Certificate verification errors, based on TLS.\r",
							" */\r",
							"pki.certificateError = {\r",
							"  bad_certificate: 'forge.pki.BadCertificate',\r",
							"  unsupported_certificate: 'forge.pki.UnsupportedCertificate',\r",
							"  certificate_revoked: 'forge.pki.CertificateRevoked',\r",
							"  certificate_expired: 'forge.pki.CertificateExpired',\r",
							"  certificate_unknown: 'forge.pki.CertificateUnknown',\r",
							"  unknown_ca: 'forge.pki.UnknownCertificateAuthority'\r",
							"};\r",
							"\r",
							"/**\r",
							" * Verifies a certificate chain against the given Certificate Authority store\r",
							" * with an optional custom verify callback.\r",
							" *\r",
							" * @param caStore a certificate store to verify against.\r",
							" * @param chain the certificate chain to verify, with the root or highest\r",
							" *          authority at the end (an array of certificates).\r",
							" * @param verify called for every certificate in the chain.\r",
							" *\r",
							" * The verify callback has the following signature:\r",
							" *\r",
							" * verified - Set to true if certificate was verified, otherwise the\r",
							" *   pki.certificateError for why the certificate failed.\r",
							" * depth - The current index in the chain, where 0 is the end point's cert.\r",
							" * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous\r",
							" *   end point.\r",
							" *\r",
							" * The function returns true on success and on failure either the appropriate\r",
							" * pki.certificateError or an object with 'error' set to the appropriate\r",
							" * pki.certificateError and 'message' set to a custom error message.\r",
							" *\r",
							" * @return true if successful, error thrown if not.\r",
							" */\r",
							"pki.verifyCertificateChain = function(caStore, chain, verify) {\r",
							"  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate\r",
							"    Section 6: Certification Path Validation\r",
							"    See inline parentheticals related to this particular implementation.\r",
							"\r",
							"    The primary goal of path validation is to verify the binding between\r",
							"    a subject distinguished name or a subject alternative name and subject\r",
							"    public key, as represented in the end entity certificate, based on the\r",
							"    public key of the trust anchor. This requires obtaining a sequence of\r",
							"    certificates that support that binding. That sequence should be provided\r",
							"    in the passed 'chain'. The trust anchor should be in the given CA\r",
							"    store. The 'end entity' certificate is the certificate provided by the\r",
							"    end point (typically a server) and is the first in the chain.\r",
							"\r",
							"    To meet this goal, the path validation process verifies, among other\r",
							"    things, that a prospective certification path (a sequence of n\r",
							"    certificates or a 'chain') satisfies the following conditions:\r",
							"\r",
							"    (a) for all x in {1, ..., n-1}, the subject of certificate x is\r",
							"          the issuer of certificate x+1;\r",
							"\r",
							"    (b) certificate 1 is issued by the trust anchor;\r",
							"\r",
							"    (c) certificate n is the certificate to be validated; and\r",
							"\r",
							"    (d) for all x in {1, ..., n}, the certificate was valid at the\r",
							"          time in question.\r",
							"\r",
							"    Note that here 'n' is index 0 in the chain and 1 is the last certificate\r",
							"    in the chain and it must be signed by a certificate in the connection's\r",
							"    CA store.\r",
							"\r",
							"    The path validation process also determines the set of certificate\r",
							"    policies that are valid for this path, based on the certificate policies\r",
							"    extension, policy mapping extension, policy constraints extension, and\r",
							"    inhibit any-policy extension.\r",
							"\r",
							"    Note: Policy mapping extension not supported (Not Required).\r",
							"\r",
							"    Note: If the certificate has an unsupported critical extension, then it\r",
							"    must be rejected.\r",
							"\r",
							"    Note: A certificate is self-issued if the DNs that appear in the subject\r",
							"    and issuer fields are identical and are not empty.\r",
							"\r",
							"    The path validation algorithm assumes the following seven inputs are\r",
							"    provided to the path processing logic. What this specific implementation\r",
							"    will use is provided parenthetically:\r",
							"\r",
							"    (a) a prospective certification path of length n (the 'chain')\r",
							"    (b) the current date/time: ('now').\r",
							"    (c) user-initial-policy-set: A set of certificate policy identifiers\r",
							"          naming the policies that are acceptable to the certificate user.\r",
							"          The user-initial-policy-set contains the special value any-policy\r",
							"          if the user is not concerned about certificate policy\r",
							"          (Not implemented. Any policy is accepted).\r",
							"    (d) trust anchor information, describing a CA that serves as a trust\r",
							"          anchor for the certification path. The trust anchor information\r",
							"          includes:\r",
							"\r",
							"      (1)  the trusted issuer name,\r",
							"      (2)  the trusted public key algorithm,\r",
							"      (3)  the trusted public key, and\r",
							"      (4)  optionally, the trusted public key parameters associated\r",
							"             with the public key.\r",
							"\r",
							"      (Trust anchors are provided via certificates in the CA store).\r",
							"\r",
							"      The trust anchor information may be provided to the path processing\r",
							"      procedure in the form of a self-signed certificate. The trusted anchor\r",
							"      information is trusted because it was delivered to the path processing\r",
							"      procedure by some trustworthy out-of-band procedure. If the trusted\r",
							"      public key algorithm requires parameters, then the parameters are\r",
							"      provided along with the trusted public key (No parameters used in this\r",
							"      implementation).\r",
							"\r",
							"    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is\r",
							"          allowed in the certification path.\r",
							"          (Not implemented, no policy checking)\r",
							"\r",
							"    (f) initial-explicit-policy, which indicates if the path must be valid\r",
							"          for at least one of the certificate policies in the user-initial-\r",
							"          policy-set.\r",
							"          (Not implemented, no policy checking)\r",
							"\r",
							"    (g) initial-any-policy-inhibit, which indicates whether the\r",
							"          anyPolicy OID should be processed if it is included in a\r",
							"          certificate.\r",
							"          (Not implemented, so any policy is valid provided that it is\r",
							"          not marked as critical) */\r",
							"\r",
							"  /* Basic Path Processing:\r",
							"\r",
							"    For each certificate in the 'chain', the following is checked:\r",
							"\r",
							"    1. The certificate validity period includes the current time.\r",
							"    2. The certificate was signed by its parent (where the parent is either\r",
							"       the next in the chain or from the CA store). Allow processing to\r",
							"       continue to the next step if no parent is found but the certificate is\r",
							"       in the CA store.\r",
							"    3. TODO: The certificate has not been revoked.\r",
							"    4. The certificate issuer name matches the parent's subject name.\r",
							"    5. TODO: If the certificate is self-issued and not the final certificate\r",
							"       in the chain, skip this step, otherwise verify that the subject name\r",
							"       is within one of the permitted subtrees of X.500 distinguished names\r",
							"       and that each of the alternative names in the subjectAltName extension\r",
							"       (critical or non-critical) is within one of the permitted subtrees for\r",
							"       that name type.\r",
							"    6. TODO: If the certificate is self-issued and not the final certificate\r",
							"       in the chain, skip this step, otherwise verify that the subject name\r",
							"       is not within one of the excluded subtrees for X.500 distinguished\r",
							"       names and none of the subjectAltName extension names are excluded for\r",
							"       that name type.\r",
							"    7. The other steps in the algorithm for basic path processing involve\r",
							"       handling the policy extension which is not presently supported in this\r",
							"       implementation. Instead, if a critical policy extension is found, the\r",
							"       certificate is rejected as not supported.\r",
							"    8. If the certificate is not the first or if its the only certificate in\r",
							"       the chain (having no parent from the CA store or is self-signed) and it\r",
							"       has a critical key usage extension, verify that the keyCertSign bit is\r",
							"       set. If the key usage extension exists, verify that the basic\r",
							"       constraints extension exists. If the basic constraints extension exists,\r",
							"       verify that the cA flag is set. If pathLenConstraint is set, ensure that\r",
							"       the number of certificates that precede in the chain (come earlier\r",
							"       in the chain as implemented below), excluding the very first in the\r",
							"       chain (typically the end-entity one), isn't greater than the\r",
							"       pathLenConstraint. This constraint limits the number of intermediate\r",
							"       CAs that may appear below a CA before only end-entity certificates\r",
							"       may be issued. */\r",
							"\r",
							"  // copy cert chain references to another array to protect against changes\r",
							"  // in verify callback\r",
							"  chain = chain.slice(0);\r",
							"  var certs = chain.slice(0);\r",
							"\r",
							"  // get current date\r",
							"  var now = new Date();\r",
							"\r",
							"  // verify each cert in the chain using its parent, where the parent\r",
							"  // is either the next in the chain or from the CA store\r",
							"  var first = true;\r",
							"  var error = null;\r",
							"  var depth = 0;\r",
							"  do {\r",
							"    var cert = chain.shift();\r",
							"    var parent = null;\r",
							"    var selfSigned = false;\r",
							"\r",
							"    // 1. check valid time\r",
							"    if(now < cert.validity.notBefore || now > cert.validity.notAfter) {\r",
							"      error = {\r",
							"        message: 'Certificate is not valid yet or has expired.',\r",
							"        error: pki.certificateError.certificate_expired,\r",
							"        notBefore: cert.validity.notBefore,\r",
							"        notAfter: cert.validity.notAfter,\r",
							"        now: now\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // 2. verify with parent from chain or CA store\r",
							"    if(error === null) {\r",
							"      parent = chain[0] || caStore.getIssuer(cert);\r",
							"      if(parent === null) {\r",
							"        // check for self-signed cert\r",
							"        if(cert.isIssuer(cert)) {\r",
							"          selfSigned = true;\r",
							"          parent = cert;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(parent) {\r",
							"        // FIXME: current CA store implementation might have multiple\r",
							"        // certificates where the issuer can't be determined from the\r",
							"        // certificate (happens rarely with, eg: old certificates) so normalize\r",
							"        // by always putting parents into an array\r",
							"        // TODO: there's may be an extreme degenerate case currently uncovered\r",
							"        // where an old intermediate certificate seems to have a matching parent\r",
							"        // but none of the parents actually verify ... but the intermediate\r",
							"        // is in the CA and it should pass this check; needs investigation\r",
							"        var parents = parent;\r",
							"        if(!forge.util.isArray(parents)) {\r",
							"          parents = [parents];\r",
							"        }\r",
							"\r",
							"        // try to verify with each possible parent (typically only one)\r",
							"        var verified = false;\r",
							"        while(!verified && parents.length > 0) {\r",
							"          parent = parents.shift();\r",
							"          try {\r",
							"            verified = parent.verify(cert);\r",
							"          } catch(ex) {\r",
							"            // failure to verify, don't care why, try next one\r",
							"          }\r",
							"        }\r",
							"\r",
							"        if(!verified) {\r",
							"          error = {\r",
							"            message: 'Certificate signature is invalid.',\r",
							"            error: pki.certificateError.bad_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(error === null && (!parent || selfSigned) &&\r",
							"        !caStore.hasCertificate(cert)) {\r",
							"        // no parent issuer and certificate itself is not trusted\r",
							"        error = {\r",
							"          message: 'Certificate is not trusted.',\r",
							"          error: pki.certificateError.unknown_ca\r",
							"        };\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // TODO: 3. check revoked\r",
							"\r",
							"    // 4. check for matching issuer/subject\r",
							"    if(error === null && parent && !cert.isIssuer(parent)) {\r",
							"      // parent is not issuer\r",
							"      error = {\r",
							"        message: 'Certificate issuer is invalid.',\r",
							"        error: pki.certificateError.bad_certificate\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // 5. TODO: check names with permitted names tree\r",
							"\r",
							"    // 6. TODO: check names against excluded names tree\r",
							"\r",
							"    // 7. check for unsupported critical extensions\r",
							"    if(error === null) {\r",
							"      // supported extensions\r",
							"      var se = {\r",
							"        keyUsage: true,\r",
							"        basicConstraints: true\r",
							"      };\r",
							"      for(var i = 0; error === null && i < cert.extensions.length; ++i) {\r",
							"        var ext = cert.extensions[i];\r",
							"        if(ext.critical && !(ext.name in se)) {\r",
							"          error = {\r",
							"            message:\r",
							"              'Certificate has an unsupported critical extension.',\r",
							"            error: pki.certificateError.unsupported_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // 8. check for CA if cert is not first or is the only certificate\r",
							"    // remaining in chain with no parent or is self-signed\r",
							"    if(error === null &&\r",
							"      (!first || (chain.length === 0 && (!parent || selfSigned)))) {\r",
							"      // first check keyUsage extension and then basic constraints\r",
							"      var bcExt = cert.getExtension('basicConstraints');\r",
							"      var keyUsageExt = cert.getExtension('keyUsage');\r",
							"      if(keyUsageExt !== null) {\r",
							"        // keyCertSign must be true and there must be a basic\r",
							"        // constraints extension\r",
							"        if(!keyUsageExt.keyCertSign || bcExt === null) {\r",
							"          // bad certificate\r",
							"          error = {\r",
							"            message:\r",
							"              'Certificate keyUsage or basicConstraints conflict ' +\r",
							"              'or indicate that the certificate is not a CA. ' +\r",
							"              'If the certificate is the only one in the chain or ' +\r",
							"              'isn\\'t the first then the certificate must be a ' +\r",
							"              'valid CA.',\r",
							"            error: pki.certificateError.bad_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"      // basic constraints cA flag must be set\r",
							"      if(error === null && bcExt !== null && !bcExt.cA) {\r",
							"        // bad certificate\r",
							"        error = {\r",
							"          message:\r",
							"            'Certificate basicConstraints indicates the certificate ' +\r",
							"            'is not a CA.',\r",
							"          error: pki.certificateError.bad_certificate\r",
							"        };\r",
							"      }\r",
							"      // if error is not null and keyUsage is available, then we know it\r",
							"      // has keyCertSign and there is a basic constraints extension too,\r",
							"      // which means we can check pathLenConstraint (if it exists)\r",
							"      if(error === null && keyUsageExt !== null &&\r",
							"        'pathLenConstraint' in bcExt) {\r",
							"        // pathLen is the maximum # of intermediate CA certs that can be\r",
							"        // found between the current certificate and the end-entity (depth 0)\r",
							"        // certificate; this number does not include the end-entity (depth 0,\r",
							"        // last in the chain) even if it happens to be a CA certificate itself\r",
							"        var pathLen = depth - 1;\r",
							"        if(pathLen > bcExt.pathLenConstraint) {\r",
							"          // pathLenConstraint violated, bad certificate\r",
							"          error = {\r",
							"            message:\r",
							"              'Certificate basicConstraints pathLenConstraint violated.',\r",
							"            error: pki.certificateError.bad_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // call application callback\r",
							"    var vfd = (error === null) ? true : error.error;\r",
							"    var ret = verify ? verify(vfd, depth, certs) : vfd;\r",
							"    if(ret === true) {\r",
							"      // clear any set error\r",
							"      error = null;\r",
							"    } else {\r",
							"      // if passed basic tests, set default message and alert\r",
							"      if(vfd === true) {\r",
							"        error = {\r",
							"          message: 'The application rejected the certificate.',\r",
							"          error: pki.certificateError.bad_certificate\r",
							"        };\r",
							"      }\r",
							"\r",
							"      // check for custom error info\r",
							"      if(ret || ret === 0) {\r",
							"        // set custom message and error\r",
							"        if(typeof ret === 'object' && !forge.util.isArray(ret)) {\r",
							"          if(ret.message) {\r",
							"             error.message = ret.message;\r",
							"          }\r",
							"          if(ret.error) {\r",
							"            error.error = ret.error;\r",
							"          }\r",
							"        } else if(typeof ret === 'string') {\r",
							"          // set custom error\r",
							"          error.error = ret;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // throw error\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // no longer first cert in chain\r",
							"    first = false;\r",
							"    ++depth;\r",
							"  } while(chain.length > 0);\r",
							"\r",
							"  return true;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 17 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of PKCS#1 PSS signature padding.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for PSS API\r",
							"var pss = module.exports = forge.pss = forge.pss || {};\r",
							"\r",
							"/**\r",
							" * Creates a PSS signature scheme object.\r",
							" *\r",
							" * There are several ways to provide a salt for encoding:\r",
							" *\r",
							" * 1. Specify the saltLength only and the built-in PRNG will generate it.\r",
							" * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\r",
							" *   will be used.\r",
							" * 3. Specify the salt itself as a forge.util.ByteBuffer.\r",
							" *\r",
							" * @param options the options to use:\r",
							" *          md the message digest object to use, a forge md instance.\r",
							" *          mgf the mask generation function to use, a forge mgf instance.\r",
							" *          [saltLength] the length of the salt in octets.\r",
							" *          [prng] the pseudo-random number generator to use to produce a salt.\r",
							" *          [salt] the salt to use when encoding.\r",
							" *\r",
							" * @return a signature scheme object.\r",
							" */\r",
							"pss.create = function(options) {\r",
							"  // backwards compatibility w/legacy args: hash, mgf, sLen\r",
							"  if(arguments.length === 3) {\r",
							"    options = {\r",
							"      md: arguments[0],\r",
							"      mgf: arguments[1],\r",
							"      saltLength: arguments[2]\r",
							"    };\r",
							"  }\r",
							"\r",
							"  var hash = options.md;\r",
							"  var mgf = options.mgf;\r",
							"  var hLen = hash.digestLength;\r",
							"\r",
							"  var salt_ = options.salt || null;\r",
							"  if(typeof salt_ === 'string') {\r",
							"    // assume binary-encoded string\r",
							"    salt_ = forge.util.createBuffer(salt_);\r",
							"  }\r",
							"\r",
							"  var sLen;\r",
							"  if('saltLength' in options) {\r",
							"    sLen = options.saltLength;\r",
							"  } else if(salt_ !== null) {\r",
							"    sLen = salt_.length();\r",
							"  } else {\r",
							"    throw new Error('Salt length not specified or specific salt not given.');\r",
							"  }\r",
							"\r",
							"  if(salt_ !== null && salt_.length() !== sLen) {\r",
							"    throw new Error('Given salt length does not match length of given salt.');\r",
							"  }\r",
							"\r",
							"  var prng = options.prng || forge.random;\r",
							"\r",
							"  var pssobj = {};\r",
							"\r",
							"  /**\r",
							"   * Encodes a PSS signature.\r",
							"   *\r",
							"   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\r",
							"   *\r",
							"   * @param md the message digest object with the hash to sign.\r",
							"   * @param modsBits the length of the RSA modulus in bits.\r",
							"   *\r",
							"   * @return the encoded message as a binary-encoded string of length\r",
							"   *           ceil((modBits - 1) / 8).\r",
							"   */\r",
							"  pssobj.encode = function(md, modBits) {\r",
							"    var i;\r",
							"    var emBits = modBits - 1;\r",
							"    var emLen = Math.ceil(emBits / 8);\r",
							"\r",
							"    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\r",
							"    var mHash = md.digest().getBytes();\r",
							"\r",
							"    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\r",
							"    if(emLen < hLen + sLen + 2) {\r",
							"      throw new Error('Message is too long to encrypt.');\r",
							"    }\r",
							"\r",
							"    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\r",
							"     *    then salt is the empty string. */\r",
							"    var salt;\r",
							"    if(salt_ === null) {\r",
							"      salt = prng.getBytesSync(sLen);\r",
							"    } else {\r",
							"      salt = salt_.bytes();\r",
							"    }\r",
							"\r",
							"    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\r",
							"    var m_ = new forge.util.ByteBuffer();\r",
							"    m_.fillWithByte(0, 8);\r",
							"    m_.putBytes(mHash);\r",
							"    m_.putBytes(salt);\r",
							"\r",
							"    /* 6. Let H = Hash(M'), an octet string of length hLen. */\r",
							"    hash.start();\r",
							"    hash.update(m_.getBytes());\r",
							"    var h = hash.digest().getBytes();\r",
							"\r",
							"    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\r",
							"     *    zero octets.  The length of PS may be 0. */\r",
							"    var ps = new forge.util.ByteBuffer();\r",
							"    ps.fillWithByte(0, emLen - sLen - hLen - 2);\r",
							"\r",
							"    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\r",
							"     *    emLen - hLen - 1. */\r",
							"    ps.putByte(0x01);\r",
							"    ps.putBytes(salt);\r",
							"    var db = ps.getBytes();\r",
							"\r",
							"    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\r",
							"    var maskLen = emLen - hLen - 1;\r",
							"    var dbMask = mgf.generate(h, maskLen);\r",
							"\r",
							"    /* 10. Let maskedDB = DB \\xor dbMask. */\r",
							"    var maskedDB = '';\r",
							"    for(i = 0; i < maskLen; i++) {\r",
							"      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\r",
							"    }\r",
							"\r",
							"    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\r",
							"     *     maskedDB to zero. */\r",
							"    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\r",
							"    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +\r",
							"      maskedDB.substr(1);\r",
							"\r",
							"    /* 12. Let EM = maskedDB || H || 0xbc.\r",
							"     * 13. Output EM. */\r",
							"    return maskedDB + h + String.fromCharCode(0xbc);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Verifies a PSS signature.\r",
							"   *\r",
							"   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\r",
							"   *\r",
							"   * @param mHash the message digest hash, as a binary-encoded string, to\r",
							"   *         compare against the signature.\r",
							"   * @param em the encoded message, as a binary-encoded string\r",
							"   *          (RSA decryption result).\r",
							"   * @param modsBits the length of the RSA modulus in bits.\r",
							"   *\r",
							"   * @return true if the signature was verified, false if not.\r",
							"   */\r",
							"  pssobj.verify = function(mHash, em, modBits) {\r",
							"    var i;\r",
							"    var emBits = modBits - 1;\r",
							"    var emLen = Math.ceil(emBits / 8);\r",
							"\r",
							"    /* c. Convert the message representative m to an encoded message EM\r",
							"     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\r",
							"     *    is the length in bits of the RSA modulus n */\r",
							"    em = em.substr(-emLen);\r",
							"\r",
							"    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\r",
							"    if(emLen < hLen + sLen + 2) {\r",
							"      throw new Error('Inconsistent parameters to PSS signature verification.');\r",
							"    }\r",
							"\r",
							"    /* 4. If the rightmost octet of EM does not have hexadecimal value\r",
							"     *    0xbc, output \"inconsistent\" and stop. */\r",
							"    if(em.charCodeAt(emLen - 1) !== 0xbc) {\r",
							"      throw new Error('Encoded message does not end in 0xBC.');\r",
							"    }\r",
							"\r",
							"    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\r",
							"     *    let H be the next hLen octets. */\r",
							"    var maskLen = emLen - hLen - 1;\r",
							"    var maskedDB = em.substr(0, maskLen);\r",
							"    var h = em.substr(maskLen, hLen);\r",
							"\r",
							"    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\r",
							"     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\r",
							"    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\r",
							"    if((maskedDB.charCodeAt(0) & mask) !== 0) {\r",
							"      throw new Error('Bits beyond keysize not zero as expected.');\r",
							"    }\r",
							"\r",
							"    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\r",
							"    var dbMask = mgf.generate(h, maskLen);\r",
							"\r",
							"    /* 8. Let DB = maskedDB \\xor dbMask. */\r",
							"    var db = '';\r",
							"    for(i = 0; i < maskLen; i++) {\r",
							"      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\r",
							"    }\r",
							"\r",
							"    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\r",
							"     * in DB to zero. */\r",
							"    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\r",
							"\r",
							"    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\r",
							"     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\r",
							"     * position is \"position 1\") does not have hexadecimal value 0x01,\r",
							"     * output \"inconsistent\" and stop. */\r",
							"    var checkLen = emLen - hLen - sLen - 2;\r",
							"    for(i = 0; i < checkLen; i++) {\r",
							"      if(db.charCodeAt(i) !== 0x00) {\r",
							"        throw new Error('Leftmost octets not zero as expected');\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(db.charCodeAt(checkLen) !== 0x01) {\r",
							"      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\r",
							"    }\r",
							"\r",
							"    /* 11. Let salt be the last sLen octets of DB. */\r",
							"    var salt = db.substr(-sLen);\r",
							"\r",
							"    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\r",
							"    var m_ = new forge.util.ByteBuffer();\r",
							"    m_.fillWithByte(0, 8);\r",
							"    m_.putBytes(mHash);\r",
							"    m_.putBytes(salt);\r",
							"\r",
							"    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\r",
							"    hash.start();\r",
							"    hash.update(m_.getBytes());\r",
							"    var h_ = hash.digest().getBytes();\r",
							"\r",
							"    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\r",
							"    return h === h_;\r",
							"  };\r",
							"\r",
							"  return pssobj;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 18 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Supported cipher modes.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"forge.cipher = forge.cipher || {};\r",
							"\r",
							"// supported cipher modes\r",
							"var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\r",
							"\r",
							"/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\r",
							"\r",
							"modes.ecb = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'ECB';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = new Array(this._ints);\r",
							"  this._outBlock = new Array(this._ints);\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.start = function(options) {};\r",
							"\r",
							"modes.ecb.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = input.getInt32();\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i]);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = input.getInt32();\r",
							"  }\r",
							"\r",
							"  // decrypt block\r",
							"  this.cipher.decrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i]);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.pad = function(input, options) {\r",
							"  // add PKCS#7 padding to block (each pad byte is the\r",
							"  // value of the number of pad bytes)\r",
							"  var padding = (input.length() === this.blockSize ?\r",
							"    this.blockSize : (this.blockSize - input.length()));\r",
							"  input.fillWithByte(padding, padding);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.unpad = function(output, options) {\r",
							"  // check for error: input data not a multiple of blockSize\r",
							"  if(options.overflow > 0) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // ensure padding byte count is valid\r",
							"  var len = output.length();\r",
							"  var count = output.at(len - 1);\r",
							"  if(count > (this.blockSize << 2)) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // trim off padding bytes\r",
							"  output.truncate(count);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"/** Cipher-block Chaining (CBC) **/\r",
							"\r",
							"modes.cbc = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'CBC';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = new Array(this._ints);\r",
							"  this._outBlock = new Array(this._ints);\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.start = function(options) {\r",
							"  // Note: legacy support for using IV residue (has security flaws)\r",
							"  // if IV is null, reuse block from previous processing\r",
							"  if(options.iv === null) {\r",
							"    // must have a previous block\r",
							"    if(!this._prev) {\r",
							"      throw new Error('Invalid IV parameter.');\r",
							"    }\r",
							"    this._iv = this._prev.slice(0);\r",
							"  } else if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  } else {\r",
							"    // save IV as \"previous\" block\r",
							"    this._iv = transformIV(options.iv);\r",
							"    this._prev = this._iv.slice(0);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  // CBC XOR's IV (or previous block) with plaintext\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = this._prev[i] ^ input.getInt32();\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output, save previous block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i]);\r",
							"  }\r",
							"  this._prev = this._outBlock;\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = input.getInt32();\r",
							"  }\r",
							"\r",
							"  // decrypt block\r",
							"  this.cipher.decrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output, save previous ciphered block\r",
							"  // CBC XOR's IV (or previous block) with ciphertext\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._prev[i] ^ this._outBlock[i]);\r",
							"  }\r",
							"  this._prev = this._inBlock.slice(0);\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.pad = function(input, options) {\r",
							"  // add PKCS#7 padding to block (each pad byte is the\r",
							"  // value of the number of pad bytes)\r",
							"  var padding = (input.length() === this.blockSize ?\r",
							"    this.blockSize : (this.blockSize - input.length()));\r",
							"  input.fillWithByte(padding, padding);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.unpad = function(output, options) {\r",
							"  // check for error: input data not a multiple of blockSize\r",
							"  if(options.overflow > 0) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // ensure padding byte count is valid\r",
							"  var len = output.length();\r",
							"  var count = output.at(len - 1);\r",
							"  if(count > (this.blockSize << 2)) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // trim off padding bytes\r",
							"  output.truncate(count);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"/** Cipher feedback (CFB) **/\r",
							"\r",
							"modes.cfb = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'CFB';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = null;\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.cfb.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // use IV as first input\r",
							"  this._iv = transformIV(options.iv);\r",
							"  this._inBlock = this._iv.slice(0);\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.cfb.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output, write input as output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\r",
							"      output.putInt32(this._inBlock[i]);\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // handle partial block\r",
							"  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"  if(partialBytes > 0) {\r",
							"    partialBytes = this.blockSize - partialBytes;\r",
							"  }\r",
							"\r",
							"  // XOR input with output, write input as partial output\r",
							"  this._partialOutput.clear();\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\r",
							"    this._partialOutput.putInt32(this._partialBlock[i]);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0) {\r",
							"    // block still incomplete, restore input buffer\r",
							"    input.read -= this.blockSize;\r",
							"  } else {\r",
							"    // block complete, update input block\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = this._partialBlock[i];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // skip any previous partial bytes\r",
							"  if(this._partialBytes > 0) {\r",
							"    this._partialOutput.getBytes(this._partialBytes);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0 && !finish) {\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      partialBytes - this._partialBytes));\r",
							"    this._partialBytes = partialBytes;\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  output.putBytes(this._partialOutput.getBytes(\r",
							"    inputLength - this._partialBytes));\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.cfb.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (CFB always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output, write input as output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = input.getInt32();\r",
							"      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // handle partial block\r",
							"  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"  if(partialBytes > 0) {\r",
							"    partialBytes = this.blockSize - partialBytes;\r",
							"  }\r",
							"\r",
							"  // XOR input with output, write input as partial output\r",
							"  this._partialOutput.clear();\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._partialBlock[i] = input.getInt32();\r",
							"    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0) {\r",
							"    // block still incomplete, restore input buffer\r",
							"    input.read -= this.blockSize;\r",
							"  } else {\r",
							"    // block complete, update input block\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = this._partialBlock[i];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // skip any previous partial bytes\r",
							"  if(this._partialBytes > 0) {\r",
							"    this._partialOutput.getBytes(this._partialBytes);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0 && !finish) {\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      partialBytes - this._partialBytes));\r",
							"    this._partialBytes = partialBytes;\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  output.putBytes(this._partialOutput.getBytes(\r",
							"    inputLength - this._partialBytes));\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"/** Output feedback (OFB) **/\r",
							"\r",
							"modes.ofb = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'OFB';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = null;\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ofb.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // use IV as first input\r",
							"  this._iv = transformIV(options.iv);\r",
							"  this._inBlock = this._iv.slice(0);\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ofb.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(input.length() === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (OFB always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output and update next input\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      output.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"      this._inBlock[i] = this._outBlock[i];\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // handle partial block\r",
							"  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"  if(partialBytes > 0) {\r",
							"    partialBytes = this.blockSize - partialBytes;\r",
							"  }\r",
							"\r",
							"  // XOR input with output\r",
							"  this._partialOutput.clear();\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0) {\r",
							"    // block still incomplete, restore input buffer\r",
							"    input.read -= this.blockSize;\r",
							"  } else {\r",
							"    // block complete, update input block\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = this._outBlock[i];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // skip any previous partial bytes\r",
							"  if(this._partialBytes > 0) {\r",
							"    this._partialOutput.getBytes(this._partialBytes);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0 && !finish) {\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      partialBytes - this._partialBytes));\r",
							"    this._partialBytes = partialBytes;\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  output.putBytes(this._partialOutput.getBytes(\r",
							"    inputLength - this._partialBytes));\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\r",
							"\r",
							"/** Counter (CTR) **/\r",
							"\r",
							"modes.ctr = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'CTR';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = null;\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ctr.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // use IV as first input\r",
							"  this._iv = transformIV(options.iv);\r",
							"  this._inBlock = this._iv.slice(0);\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ctr.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (CTR always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      output.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"    }\r",
							"  } else {\r",
							"    // handle partial block\r",
							"    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"    if(partialBytes > 0) {\r",
							"      partialBytes = this.blockSize - partialBytes;\r",
							"    }\r",
							"\r",
							"    // XOR input with output\r",
							"    this._partialOutput.clear();\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"    }\r",
							"\r",
							"    if(partialBytes > 0) {\r",
							"      // block still incomplete, restore input buffer\r",
							"      input.read -= this.blockSize;\r",
							"    }\r",
							"\r",
							"    // skip any previous partial bytes\r",
							"    if(this._partialBytes > 0) {\r",
							"      this._partialOutput.getBytes(this._partialBytes);\r",
							"    }\r",
							"\r",
							"    if(partialBytes > 0 && !finish) {\r",
							"      output.putBytes(this._partialOutput.getBytes(\r",
							"        partialBytes - this._partialBytes));\r",
							"      this._partialBytes = partialBytes;\r",
							"      return true;\r",
							"    }\r",
							"\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      inputLength - this._partialBytes));\r",
							"    this._partialBytes = 0;\r",
							"  }\r",
							"\r",
							"  // block complete, increment counter (input block)\r",
							"  inc32(this._inBlock);\r",
							"};\r",
							"\r",
							"modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\r",
							"\r",
							"/** Galois/Counter Mode (GCM) **/\r",
							"\r",
							"modes.gcm = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'GCM';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = new Array(this._ints);\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"\r",
							"  // R is actually this value concatenated with 120 more zero bits, but\r",
							"  // we only XOR against R so the other zeros have no effect -- we just\r",
							"  // apply this value to the first integer in a block\r",
							"  this._R = 0xE1000000;\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // ensure IV is a byte buffer\r",
							"  var iv = forge.util.createBuffer(options.iv);\r",
							"\r",
							"  // no ciphered data processed yet\r",
							"  this._cipherLength = 0;\r",
							"\r",
							"  // default additional data is none\r",
							"  var additionalData;\r",
							"  if('additionalData' in options) {\r",
							"    additionalData = forge.util.createBuffer(options.additionalData);\r",
							"  } else {\r",
							"    additionalData = forge.util.createBuffer();\r",
							"  }\r",
							"\r",
							"  // default tag length is 128 bits\r",
							"  if('tagLength' in options) {\r",
							"    this._tagLength = options.tagLength;\r",
							"  } else {\r",
							"    this._tagLength = 128;\r",
							"  }\r",
							"\r",
							"  // if tag is given, ensure tag matches tag length\r",
							"  this._tag = null;\r",
							"  if(options.decrypt) {\r",
							"    // save tag to check later\r",
							"    this._tag = forge.util.createBuffer(options.tag).getBytes();\r",
							"    if(this._tag.length !== (this._tagLength / 8)) {\r",
							"      throw new Error('Authentication tag does not match tag length.');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // create tmp storage for hash calculation\r",
							"  this._hashBlock = new Array(this._ints);\r",
							"\r",
							"  // no tag generated yet\r",
							"  this.tag = null;\r",
							"\r",
							"  // generate hash subkey\r",
							"  // (apply block cipher to \"zero\" block)\r",
							"  this._hashSubkey = new Array(this._ints);\r",
							"  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\r",
							"\r",
							"  // generate table M\r",
							"  // use 4-bit tables (32 component decomposition of a 16 byte value)\r",
							"  // 8-bit tables take more space and are known to have security\r",
							"  // vulnerabilities (in native implementations)\r",
							"  this.componentBits = 4;\r",
							"  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\r",
							"\r",
							"  // Note: support IV length different from 96 bits? (only supporting\r",
							"  // 96 bits is recommended by NIST SP-800-38D)\r",
							"  // generate J_0\r",
							"  var ivLength = iv.length();\r",
							"  if(ivLength === 12) {\r",
							"    // 96-bit IV\r",
							"    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\r",
							"  } else {\r",
							"    // IV is NOT 96-bits\r",
							"    this._j0 = [0, 0, 0, 0];\r",
							"    while(iv.length() > 0) {\r",
							"      this._j0 = this.ghash(\r",
							"        this._hashSubkey, this._j0,\r",
							"        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\r",
							"    }\r",
							"    this._j0 = this.ghash(\r",
							"      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\r",
							"  }\r",
							"\r",
							"  // generate ICB (initial counter block)\r",
							"  this._inBlock = this._j0.slice(0);\r",
							"  inc32(this._inBlock);\r",
							"  this._partialBytes = 0;\r",
							"\r",
							"  // consume authentication data\r",
							"  additionalData = forge.util.createBuffer(additionalData);\r",
							"  // save additional data length as a BE 64-bit number\r",
							"  this._aDataLength = from64To32(additionalData.length() * 8);\r",
							"  // pad additional data to 128 bit (16 byte) block size\r",
							"  var overflow = additionalData.length() % this.blockSize;\r",
							"  if(overflow) {\r",
							"    additionalData.fillWithByte(0, this.blockSize - overflow);\r",
							"  }\r",
							"  this._s = [0, 0, 0, 0];\r",
							"  while(additionalData.length() > 0) {\r",
							"    this._s = this.ghash(this._hashSubkey, this._s, [\r",
							"      additionalData.getInt32(),\r",
							"      additionalData.getInt32(),\r",
							"      additionalData.getInt32(),\r",
							"      additionalData.getInt32()\r",
							"    ]);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      output.putInt32(this._outBlock[i] ^= input.getInt32());\r",
							"    }\r",
							"    this._cipherLength += this.blockSize;\r",
							"  } else {\r",
							"    // handle partial block\r",
							"    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"    if(partialBytes > 0) {\r",
							"      partialBytes = this.blockSize - partialBytes;\r",
							"    }\r",
							"\r",
							"    // XOR input with output\r",
							"    this._partialOutput.clear();\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"    }\r",
							"\r",
							"    if(partialBytes === 0 || finish) {\r",
							"      // handle overflow prior to hashing\r",
							"      if(finish) {\r",
							"        // get block overflow\r",
							"        var overflow = inputLength % this.blockSize;\r",
							"        this._cipherLength += overflow;\r",
							"        // truncate for hash function\r",
							"        this._partialOutput.truncate(this.blockSize - overflow);\r",
							"      } else {\r",
							"        this._cipherLength += this.blockSize;\r",
							"      }\r",
							"\r",
							"      // get output block for hashing\r",
							"      for(var i = 0; i < this._ints; ++i) {\r",
							"        this._outBlock[i] = this._partialOutput.getInt32();\r",
							"      }\r",
							"      this._partialOutput.read -= this.blockSize;\r",
							"    }\r",
							"\r",
							"    // skip any previous partial bytes\r",
							"    if(this._partialBytes > 0) {\r",
							"      this._partialOutput.getBytes(this._partialBytes);\r",
							"    }\r",
							"\r",
							"    if(partialBytes > 0 && !finish) {\r",
							"      // block still incomplete, restore input buffer, get partial output,\r",
							"      // and return early\r",
							"      input.read -= this.blockSize;\r",
							"      output.putBytes(this._partialOutput.getBytes(\r",
							"        partialBytes - this._partialBytes));\r",
							"      this._partialBytes = partialBytes;\r",
							"      return true;\r",
							"    }\r",
							"\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      inputLength - this._partialBytes));\r",
							"    this._partialBytes = 0;\r",
							"  }\r",
							"\r",
							"  // update hash block S\r",
							"  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\r",
							"\r",
							"  // increment counter (input block)\r",
							"  inc32(this._inBlock);\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (GCM always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // increment counter (input block)\r",
							"  inc32(this._inBlock);\r",
							"\r",
							"  // update hash block S\r",
							"  this._hashBlock[0] = input.getInt32();\r",
							"  this._hashBlock[1] = input.getInt32();\r",
							"  this._hashBlock[2] = input.getInt32();\r",
							"  this._hashBlock[3] = input.getInt32();\r",
							"  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\r",
							"\r",
							"  // XOR hash input with output\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\r",
							"  }\r",
							"\r",
							"  // increment cipher data length\r",
							"  if(inputLength < this.blockSize) {\r",
							"    this._cipherLength += inputLength % this.blockSize;\r",
							"  } else {\r",
							"    this._cipherLength += this.blockSize;\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.afterFinish = function(output, options) {\r",
							"  var rval = true;\r",
							"\r",
							"  // handle overflow\r",
							"  if(options.decrypt && options.overflow) {\r",
							"    output.truncate(this.blockSize - options.overflow);\r",
							"  }\r",
							"\r",
							"  // handle authentication tag\r",
							"  this.tag = forge.util.createBuffer();\r",
							"\r",
							"  // concatenate additional data length with cipher length\r",
							"  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\r",
							"\r",
							"  // include lengths in hash\r",
							"  this._s = this.ghash(this._hashSubkey, this._s, lengths);\r",
							"\r",
							"  // do GCTR(J_0, S)\r",
							"  var tag = [];\r",
							"  this.cipher.encrypt(this._j0, tag);\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this.tag.putInt32(this._s[i] ^ tag[i]);\r",
							"  }\r",
							"\r",
							"  // trim tag to length\r",
							"  this.tag.truncate(this.tag.length() % (this._tagLength / 8));\r",
							"\r",
							"  // check authentication tag\r",
							"  if(options.decrypt && this.tag.bytes() !== this._tag) {\r",
							"    rval = false;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\r",
							" * field multiplication. The field, GF(2^128), is defined by the polynomial:\r",
							" *\r",
							" * x^128 + x^7 + x^2 + x + 1\r",
							" *\r",
							" * Which is represented in little-endian binary form as: 11100001 (0xe1). When\r",
							" * the value of a coefficient is 1, a bit is set. The value R, is the\r",
							" * concatenation of this value and 120 zero bits, yielding a 128-bit value\r",
							" * which matches the block size.\r",
							" *\r",
							" * This function will multiply two elements (vectors of bytes), X and Y, in\r",
							" * the field GF(2^128). The result is initialized to zero. For each bit of\r",
							" * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\r",
							" * by the current value of Y. For each bit, the value of Y will be raised by\r",
							" * a power of x (multiplied by the polynomial x). This can be achieved by\r",
							" * shifting Y once to the right. If the current value of Y, prior to being\r",
							" * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\r",
							" * Otherwise, we must divide by R after shifting to find the remainder.\r",
							" *\r",
							" * @param x the first block to multiply by the second.\r",
							" * @param y the second block to multiply by the first.\r",
							" *\r",
							" * @return the block result of the multiplication.\r",
							" */\r",
							"modes.gcm.prototype.multiply = function(x, y) {\r",
							"  var z_i = [0, 0, 0, 0];\r",
							"  var v_i = y.slice(0);\r",
							"\r",
							"  // calculate Z_128 (block has 128 bits)\r",
							"  for(var i = 0; i < 128; ++i) {\r",
							"    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\r",
							"    // else Z_{i+1} = Z_i ^ V_i\r",
							"    // get x_i by finding 32-bit int position, then left shift 1 by remainder\r",
							"    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));\r",
							"    if(x_i) {\r",
							"      z_i[0] ^= v_i[0];\r",
							"      z_i[1] ^= v_i[1];\r",
							"      z_i[2] ^= v_i[2];\r",
							"      z_i[3] ^= v_i[3];\r",
							"    }\r",
							"\r",
							"    // if LSB(V_i) is 1, V_i = V_i >> 1\r",
							"    // else V_i = (V_i >> 1) ^ R\r",
							"    this.pow(v_i, v_i);\r",
							"  }\r",
							"\r",
							"  return z_i;\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.pow = function(x, out) {\r",
							"  // if LSB(x) is 1, x = x >>> 1\r",
							"  // else x = (x >>> 1) ^ R\r",
							"  var lsb = x[3] & 1;\r",
							"\r",
							"  // always do x >>> 1:\r",
							"  // starting with the rightmost integer, shift each integer to the right\r",
							"  // one bit, pulling in the bit from the integer to the left as its top\r",
							"  // most bit (do this for the last 3 integers)\r",
							"  for(var i = 3; i > 0; --i) {\r",
							"    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);\r",
							"  }\r",
							"  // shift the first integer normally\r",
							"  out[0] = x[0] >>> 1;\r",
							"\r",
							"  // if lsb was not set, then polynomial had a degree of 127 and doesn't\r",
							"  // need to divided; otherwise, XOR with R to find the remainder; we only\r",
							"  // need to XOR the first integer since R technically ends w/120 zero bits\r",
							"  if(lsb) {\r",
							"    out[0] ^= this._R;\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.tableMultiply = function(x) {\r",
							"  // assumes 4-bit tables are used\r",
							"  var z = [0, 0, 0, 0];\r",
							"  for(var i = 0; i < 32; ++i) {\r",
							"    var idx = (i / 8) | 0;\r",
							"    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;\r",
							"    var ah = this._m[i][x_i];\r",
							"    z[0] ^= ah[0];\r",
							"    z[1] ^= ah[1];\r",
							"    z[2] ^= ah[2];\r",
							"    z[3] ^= ah[3];\r",
							"  }\r",
							"  return z;\r",
							"};\r",
							"\r",
							"/**\r",
							" * A continuing version of the GHASH algorithm that operates on a single\r",
							" * block. The hash block, last hash value (Ym) and the new block to hash\r",
							" * are given.\r",
							" *\r",
							" * @param h the hash block.\r",
							" * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\r",
							" * @param x the block to hash.\r",
							" *\r",
							" * @return the hashed value (Ym).\r",
							" */\r",
							"modes.gcm.prototype.ghash = function(h, y, x) {\r",
							"  y[0] ^= x[0];\r",
							"  y[1] ^= x[1];\r",
							"  y[2] ^= x[2];\r",
							"  y[3] ^= x[3];\r",
							"  return this.tableMultiply(y);\r",
							"  //return this.multiply(y, h);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Precomputes a table for multiplying against the hash subkey. This\r",
							" * mechanism provides a substantial speed increase over multiplication\r",
							" * performed without a table. The table-based multiplication this table is\r",
							" * for solves X * H by multiplying each component of X by H and then\r",
							" * composing the results together using XOR.\r",
							" *\r",
							" * This function can be used to generate tables with different bit sizes\r",
							" * for the components, however, this implementation assumes there are\r",
							" * 32 components of X (which is a 16 byte vector), therefore each component\r",
							" * takes 4-bits (so the table is constructed with bits=4).\r",
							" *\r",
							" * @param h the hash subkey.\r",
							" * @param bits the bit size for a component.\r",
							" */\r",
							"modes.gcm.prototype.generateHashTable = function(h, bits) {\r",
							"  // TODO: There are further optimizations that would use only the\r",
							"  // first table M_0 (or some variant) along with a remainder table;\r",
							"  // this can be explored in the future\r",
							"  var multiplier = 8 / bits;\r",
							"  var perInt = 4 * multiplier;\r",
							"  var size = 16 * multiplier;\r",
							"  var m = new Array(size);\r",
							"  for(var i = 0; i < size; ++i) {\r",
							"    var tmp = [0, 0, 0, 0];\r",
							"    var idx = (i / perInt) | 0;\r",
							"    var shft = ((perInt - 1 - (i % perInt)) * bits);\r",
							"    tmp[idx] = (1 << (bits - 1)) << shft;\r",
							"    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\r",
							"  }\r",
							"  return m;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Generates a table for multiplying against the hash subkey for one\r",
							" * particular component (out of all possible component values).\r",
							" *\r",
							" * @param mid the pre-multiplied value for the middle key of the table.\r",
							" * @param bits the bit size for a component.\r",
							" */\r",
							"modes.gcm.prototype.generateSubHashTable = function(mid, bits) {\r",
							"  // compute the table quickly by minimizing the number of\r",
							"  // POW operations -- they only need to be performed for powers of 2,\r",
							"  // all other entries can be composed from those powers using XOR\r",
							"  var size = 1 << bits;\r",
							"  var half = size >>> 1;\r",
							"  var m = new Array(size);\r",
							"  m[half] = mid.slice(0);\r",
							"  var i = half >>> 1;\r",
							"  while(i > 0) {\r",
							"    // raise m0[2 * i] and store in m0[i]\r",
							"    this.pow(m[2 * i], m[i] = []);\r",
							"    i >>= 1;\r",
							"  }\r",
							"  i = 2;\r",
							"  while(i < half) {\r",
							"    for(var j = 1; j < i; ++j) {\r",
							"      var m_i = m[i];\r",
							"      var m_j = m[j];\r",
							"      m[i + j] = [\r",
							"        m_i[0] ^ m_j[0],\r",
							"        m_i[1] ^ m_j[1],\r",
							"        m_i[2] ^ m_j[2],\r",
							"        m_i[3] ^ m_j[3]\r",
							"      ];\r",
							"    }\r",
							"    i *= 2;\r",
							"  }\r",
							"  m[0] = [0, 0, 0, 0];\r",
							"  /* Note: We could avoid storing these by doing composition during multiply\r",
							"  calculate top half using composition by speed is preferred. */\r",
							"  for(i = half + 1; i < size; ++i) {\r",
							"    var c = m[i ^ half];\r",
							"    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\r",
							"  }\r",
							"  return m;\r",
							"};\r",
							"\r",
							"/** Utility functions */\r",
							"\r",
							"function transformIV(iv) {\r",
							"  if(typeof iv === 'string') {\r",
							"    // convert iv string into byte buffer\r",
							"    iv = forge.util.createBuffer(iv);\r",
							"  }\r",
							"\r",
							"  if(forge.util.isArray(iv) && iv.length > 4) {\r",
							"    // convert iv byte array into byte buffer\r",
							"    var tmp = iv;\r",
							"    iv = forge.util.createBuffer();\r",
							"    for(var i = 0; i < tmp.length; ++i) {\r",
							"      iv.putByte(tmp[i]);\r",
							"    }\r",
							"  }\r",
							"  if(!forge.util.isArray(iv)) {\r",
							"    // convert iv byte buffer into 32-bit integer array\r",
							"    iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];\r",
							"  }\r",
							"\r",
							"  return iv;\r",
							"}\r",
							"\r",
							"function inc32(block) {\r",
							"  // increment last 32 bits of block only\r",
							"  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;\r",
							"}\r",
							"\r",
							"function from64To32(num) {\r",
							"  // convert 64-bit number to two BE Int32s\r",
							"  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 19 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * A Javascript implementation of Transport Layer Security (TLS).\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2009-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * The TLS Handshake Protocol involves the following steps:\r",
							" *\r",
							" * - Exchange hello messages to agree on algorithms, exchange random values,\r",
							" * and check for session resumption.\r",
							" *\r",
							" * - Exchange the necessary cryptographic parameters to allow the client and\r",
							" * server to agree on a premaster secret.\r",
							" *\r",
							" * - Exchange certificates and cryptographic information to allow the client\r",
							" * and server to authenticate themselves.\r",
							" *\r",
							" * - Generate a master secret from the premaster secret and exchanged random\r",
							" * values.\r",
							" *\r",
							" * - Provide security parameters to the record layer.\r",
							" *\r",
							" * - Allow the client and server to verify that their peer has calculated the\r",
							" * same security parameters and that the handshake occurred without tampering\r",
							" * by an attacker.\r",
							" *\r",
							" * Up to 4 different messages may be sent during a key exchange. The server\r",
							" * certificate, the server key exchange, the client certificate, and the\r",
							" * client key exchange.\r",
							" *\r",
							" * A typical handshake (from the client's perspective).\r",
							" *\r",
							" * 1. Client sends ClientHello.\r",
							" * 2. Client receives ServerHello.\r",
							" * 3. Client receives optional Certificate.\r",
							" * 4. Client receives optional ServerKeyExchange.\r",
							" * 5. Client receives ServerHelloDone.\r",
							" * 6. Client sends optional Certificate.\r",
							" * 7. Client sends ClientKeyExchange.\r",
							" * 8. Client sends optional CertificateVerify.\r",
							" * 9. Client sends ChangeCipherSpec.\r",
							" * 10. Client sends Finished.\r",
							" * 11. Client receives ChangeCipherSpec.\r",
							" * 12. Client receives Finished.\r",
							" * 13. Client sends/receives application data.\r",
							" *\r",
							" * To reuse an existing session:\r",
							" *\r",
							" * 1. Client sends ClientHello with session ID for reuse.\r",
							" * 2. Client receives ServerHello with same session ID if reusing.\r",
							" * 3. Client receives ChangeCipherSpec message if reusing.\r",
							" * 4. Client receives Finished.\r",
							" * 5. Client sends ChangeCipherSpec.\r",
							" * 6. Client sends Finished.\r",
							" *\r",
							" * Note: Client ignores HelloRequest if in the middle of a handshake.\r",
							" *\r",
							" * Record Layer:\r",
							" *\r",
							" * The record layer fragments information blocks into TLSPlaintext records\r",
							" * carrying data in chunks of 2^14 bytes or less. Client message boundaries are\r",
							" * not preserved in the record layer (i.e., multiple client messages of the\r",
							" * same ContentType MAY be coalesced into a single TLSPlaintext record, or a\r",
							" * single message MAY be fragmented across several records).\r",
							" *\r",
							" * struct {\r",
							" *   uint8 major;\r",
							" *   uint8 minor;\r",
							" * } ProtocolVersion;\r",
							" *\r",
							" * struct {\r",
							" *   ContentType type;\r",
							" *   ProtocolVersion version;\r",
							" *   uint16 length;\r",
							" *   opaque fragment[TLSPlaintext.length];\r",
							" * } TLSPlaintext;\r",
							" *\r",
							" * type:\r",
							" *   The higher-level protocol used to process the enclosed fragment.\r",
							" *\r",
							" * version:\r",
							" *   The version of the protocol being employed. TLS Version 1.2 uses version\r",
							" *   {3, 3}. TLS Version 1.0 uses version {3, 1}. Note that a client that\r",
							" *   supports multiple versions of TLS may not know what version will be\r",
							" *   employed before it receives the ServerHello.\r",
							" *\r",
							" * length:\r",
							" *   The length (in bytes) of the following TLSPlaintext.fragment. The length\r",
							" *   MUST NOT exceed 2^14 = 16384 bytes.\r",
							" *\r",
							" * fragment:\r",
							" *   The application data. This data is transparent and treated as an\r",
							" *   independent block to be dealt with by the higher-level protocol specified\r",
							" *   by the type field.\r",
							" *\r",
							" * Implementations MUST NOT send zero-length fragments of Handshake, Alert, or\r",
							" * ChangeCipherSpec content types. Zero-length fragments of Application data\r",
							" * MAY be sent as they are potentially useful as a traffic analysis\r",
							" * countermeasure.\r",
							" *\r",
							" * Note: Data of different TLS record layer content types MAY be interleaved.\r",
							" * Application data is generally of lower precedence for transmission than\r",
							" * other content types. However, records MUST be delivered to the network in\r",
							" * the same order as they are protected by the record layer. Recipients MUST\r",
							" * receive and process interleaved application layer traffic during handshakes\r",
							" * subsequent to the first one on a connection.\r",
							" *\r",
							" * struct {\r",
							" *   ContentType type;       // same as TLSPlaintext.type\r",
							" *   ProtocolVersion version;// same as TLSPlaintext.version\r",
							" *   uint16 length;\r",
							" *   opaque fragment[TLSCompressed.length];\r",
							" * } TLSCompressed;\r",
							" *\r",
							" * length:\r",
							" *   The length (in bytes) of the following TLSCompressed.fragment.\r",
							" *   The length MUST NOT exceed 2^14 + 1024.\r",
							" *\r",
							" * fragment:\r",
							" *   The compressed form of TLSPlaintext.fragment.\r",
							" *\r",
							" * Note: A CompressionMethod.null operation is an identity operation; no fields\r",
							" * are altered. In this implementation, since no compression is supported,\r",
							" * uncompressed records are always the same as compressed records.\r",
							" *\r",
							" * Encryption Information:\r",
							" *\r",
							" * The encryption and MAC functions translate a TLSCompressed structure into a\r",
							" * TLSCiphertext. The decryption functions reverse the process. The MAC of the\r",
							" * record also includes a sequence number so that missing, extra, or repeated\r",
							" * messages are detectable.\r",
							" *\r",
							" * struct {\r",
							" *   ContentType type;\r",
							" *   ProtocolVersion version;\r",
							" *   uint16 length;\r",
							" *   select (SecurityParameters.cipher_type) {\r",
							" *     case stream: GenericStreamCipher;\r",
							" *     case block:  GenericBlockCipher;\r",
							" *     case aead:   GenericAEADCipher;\r",
							" *   } fragment;\r",
							" * } TLSCiphertext;\r",
							" *\r",
							" * type:\r",
							" *   The type field is identical to TLSCompressed.type.\r",
							" *\r",
							" * version:\r",
							" *   The version field is identical to TLSCompressed.version.\r",
							" *\r",
							" * length:\r",
							" *   The length (in bytes) of the following TLSCiphertext.fragment.\r",
							" *   The length MUST NOT exceed 2^14 + 2048.\r",
							" *\r",
							" * fragment:\r",
							" *   The encrypted form of TLSCompressed.fragment, with the MAC.\r",
							" *\r",
							" * Note: Only CBC Block Ciphers are supported by this implementation.\r",
							" *\r",
							" * The TLSCompressed.fragment structures are converted to/from block\r",
							" * TLSCiphertext.fragment structures.\r",
							" *\r",
							" * struct {\r",
							" *   opaque IV[SecurityParameters.record_iv_length];\r",
							" *   block-ciphered struct {\r",
							" *     opaque content[TLSCompressed.length];\r",
							" *     opaque MAC[SecurityParameters.mac_length];\r",
							" *     uint8 padding[GenericBlockCipher.padding_length];\r",
							" *     uint8 padding_length;\r",
							" *   };\r",
							" * } GenericBlockCipher;\r",
							" *\r",
							" * The MAC is generated as described in Section 6.2.3.1.\r",
							" *\r",
							" * IV:\r",
							" *   The Initialization Vector (IV) SHOULD be chosen at random, and MUST be\r",
							" *   unpredictable. Note that in versions of TLS prior to 1.1, there was no\r",
							" *   IV field, and the last ciphertext block of the previous record (the \"CBC\r",
							" *   residue\") was used as the IV. This was changed to prevent the attacks\r",
							" *   described in [CBCATT]. For block ciphers, the IV length is of length\r",
							" *   SecurityParameters.record_iv_length, which is equal to the\r",
							" *   SecurityParameters.block_size.\r",
							" *\r",
							" * padding:\r",
							" *   Padding that is added to force the length of the plaintext to be an\r",
							" *   integral multiple of the block cipher's block length. The padding MAY be\r",
							" *   any length up to 255 bytes, as long as it results in the\r",
							" *   TLSCiphertext.length being an integral multiple of the block length.\r",
							" *   Lengths longer than necessary might be desirable to frustrate attacks on\r",
							" *   a protocol that are based on analysis of the lengths of exchanged\r",
							" *   messages. Each uint8 in the padding data vector MUST be filled with the\r",
							" *   padding length value. The receiver MUST check this padding and MUST use\r",
							" *   the bad_record_mac alert to indicate padding errors.\r",
							" *\r",
							" * padding_length:\r",
							" *   The padding length MUST be such that the total size of the\r",
							" *   GenericBlockCipher structure is a multiple of the cipher's block length.\r",
							" *   Legal values range from zero to 255, inclusive. This length specifies the\r",
							" *   length of the padding field exclusive of the padding_length field itself.\r",
							" *\r",
							" * The encrypted data length (TLSCiphertext.length) is one more than the sum of\r",
							" * SecurityParameters.block_length, TLSCompressed.length,\r",
							" * SecurityParameters.mac_length, and padding_length.\r",
							" *\r",
							" * Example: If the block length is 8 bytes, the content length\r",
							" * (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the\r",
							" * length before padding is 82 bytes (this does not include the IV. Thus, the\r",
							" * padding length modulo 8 must be equal to 6 in order to make the total length\r",
							" * an even multiple of 8 bytes (the block length). The padding length can be\r",
							" * 6, 14, 22, and so on, through 254. If the padding length were the minimum\r",
							" * necessary, 6, the padding would be 6 bytes, each containing the value 6.\r",
							" * Thus, the last 8 octets of the GenericBlockCipher before block encryption\r",
							" * would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.\r",
							" *\r",
							" * Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical\r",
							" * that the entire plaintext of the record be known before any ciphertext is\r",
							" * transmitted. Otherwise, it is possible for the attacker to mount the attack\r",
							" * described in [CBCATT].\r",
							" *\r",
							" * Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing\r",
							" * attack on CBC padding based on the time required to compute the MAC. In\r",
							" * order to defend against this attack, implementations MUST ensure that\r",
							" * record processing time is essentially the same whether or not the padding\r",
							" * is correct. In general, the best way to do this is to compute the MAC even\r",
							" * if the padding is incorrect, and only then reject the packet. For instance,\r",
							" * if the pad appears to be incorrect, the implementation might assume a\r",
							" * zero-length pad and then compute the MAC. This leaves a small timing\r",
							" * channel, since MAC performance depends, to some extent, on the size of the\r",
							" * data fragment, but it is not believed to be large enough to be exploitable,\r",
							" * due to the large block size of existing MACs and the small size of the\r",
							" * timing signal.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(14);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(20);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/**\r",
							" * Generates pseudo random bytes by mixing the result of two hash functions,\r",
							" * MD5 and SHA-1.\r",
							" *\r",
							" * prf_TLS1(secret, label, seed) =\r",
							" *   P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed);\r",
							" *\r",
							" * Each P_hash function functions as follows:\r",
							" *\r",
							" * P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +\r",
							" *                        HMAC_hash(secret, A(2) + seed) +\r",
							" *                        HMAC_hash(secret, A(3) + seed) + ...\r",
							" * A() is defined as:\r",
							" *   A(0) = seed\r",
							" *   A(i) = HMAC_hash(secret, A(i-1))\r",
							" *\r",
							" * The '+' operator denotes concatenation.\r",
							" *\r",
							" * As many iterations A(N) as are needed are performed to generate enough\r",
							" * pseudo random byte output. If an iteration creates more data than is\r",
							" * necessary, then it is truncated.\r",
							" *\r",
							" * Therefore:\r",
							" * A(1) = HMAC_hash(secret, A(0))\r",
							" *      = HMAC_hash(secret, seed)\r",
							" * A(2) = HMAC_hash(secret, A(1))\r",
							" *      = HMAC_hash(secret, HMAC_hash(secret, seed))\r",
							" *\r",
							" * Therefore:\r",
							" * P_hash(secret, seed) =\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, A(0)) + seed) +\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, A(1)) + seed) +\r",
							" *   ...\r",
							" *\r",
							" * Therefore:\r",
							" * P_hash(secret, seed) =\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, seed) + seed) +\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, HMAC_hash(secret, seed)) + seed) +\r",
							" *   ...\r",
							" *\r",
							" * @param secret the secret to use.\r",
							" * @param label the label to use.\r",
							" * @param seed the seed value to use.\r",
							" * @param length the number of bytes to generate.\r",
							" *\r",
							" * @return the pseudo random bytes in a byte buffer.\r",
							" */\r",
							"var prf_TLS1 = function(secret, label, seed, length) {\r",
							"  var rval = forge.util.createBuffer();\r",
							"\r",
							"  /* For TLS 1.0, the secret is split in half, into two secrets of equal\r",
							"    length. If the secret has an odd length then the last byte of the first\r",
							"    half will be the same as the first byte of the second. The length of the\r",
							"    two secrets is half of the secret rounded up. */\r",
							"  var idx = (secret.length >> 1);\r",
							"  var slen = idx + (secret.length & 1);\r",
							"  var s1 = secret.substr(0, slen);\r",
							"  var s2 = secret.substr(idx, slen);\r",
							"  var ai = forge.util.createBuffer();\r",
							"  var hmac = forge.hmac.create();\r",
							"  seed = label + seed;\r",
							"\r",
							"  // determine the number of iterations that must be performed to generate\r",
							"  // enough output bytes, md5 creates 16 byte hashes, sha1 creates 20\r",
							"  var md5itr = Math.ceil(length / 16);\r",
							"  var sha1itr = Math.ceil(length / 20);\r",
							"\r",
							"  // do md5 iterations\r",
							"  hmac.start('MD5', s1);\r",
							"  var md5bytes = forge.util.createBuffer();\r",
							"  ai.putBytes(seed);\r",
							"  for(var i = 0; i < md5itr; ++i) {\r",
							"    // HMAC_hash(secret, A(i-1))\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.getBytes());\r",
							"    ai.putBuffer(hmac.digest());\r",
							"\r",
							"    // HMAC_hash(secret, A(i) + seed)\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.bytes() + seed);\r",
							"    md5bytes.putBuffer(hmac.digest());\r",
							"  }\r",
							"\r",
							"  // do sha1 iterations\r",
							"  hmac.start('SHA1', s2);\r",
							"  var sha1bytes = forge.util.createBuffer();\r",
							"  ai.clear();\r",
							"  ai.putBytes(seed);\r",
							"  for(var i = 0; i < sha1itr; ++i) {\r",
							"    // HMAC_hash(secret, A(i-1))\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.getBytes());\r",
							"    ai.putBuffer(hmac.digest());\r",
							"\r",
							"    // HMAC_hash(secret, A(i) + seed)\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.bytes() + seed);\r",
							"    sha1bytes.putBuffer(hmac.digest());\r",
							"  }\r",
							"\r",
							"  // XOR the md5 bytes with the sha1 bytes\r",
							"  rval.putBytes(forge.util.xorBytes(\r",
							"    md5bytes.getBytes(), sha1bytes.getBytes(), length));\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Generates pseudo random bytes using a SHA256 algorithm. For TLS 1.2.\r",
							" *\r",
							" * @param secret the secret to use.\r",
							" * @param label the label to use.\r",
							" * @param seed the seed value to use.\r",
							" * @param length the number of bytes to generate.\r",
							" *\r",
							" * @return the pseudo random bytes in a byte buffer.\r",
							" */\r",
							"var prf_sha256 = function(secret, label, seed, length) {\r",
							"   // FIXME: implement me for TLS 1.2\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a MAC for a record using the SHA-1 hash algorithm.\r",
							" *\r",
							" * @param key the mac key.\r",
							" * @param state the sequence number (array of two 32-bit integers).\r",
							" * @param record the record.\r",
							" *\r",
							" * @return the sha-1 hash (20 bytes) for the given record.\r",
							" */\r",
							"var hmac_sha1 = function(key, seqNum, record) {\r",
							"  /* MAC is computed like so:\r",
							"  HMAC_hash(\r",
							"    key, seqNum +\r",
							"      TLSCompressed.type +\r",
							"      TLSCompressed.version +\r",
							"      TLSCompressed.length +\r",
							"      TLSCompressed.fragment)\r",
							"  */\r",
							"  var hmac = forge.hmac.create();\r",
							"  hmac.start('SHA1', key);\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putInt32(seqNum[0]);\r",
							"  b.putInt32(seqNum[1]);\r",
							"  b.putByte(record.type);\r",
							"  b.putByte(record.version.major);\r",
							"  b.putByte(record.version.minor);\r",
							"  b.putInt16(record.length);\r",
							"  b.putBytes(record.fragment.bytes());\r",
							"  hmac.update(b.getBytes());\r",
							"  return hmac.digest().getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compresses the TLSPlaintext record into a TLSCompressed record using the\r",
							" * deflate algorithm.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param record the TLSPlaintext record to compress.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"var deflate = function(c, record, s) {\r",
							"  var rval = false;\r",
							"\r",
							"  try {\r",
							"    var bytes = c.deflate(record.fragment.getBytes());\r",
							"    record.fragment = forge.util.createBuffer(bytes);\r",
							"    record.length = bytes.length;\r",
							"    rval = true;\r",
							"  } catch(ex) {\r",
							"    // deflate error, fail out\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decompresses the TLSCompressed record into a TLSPlaintext record using the\r",
							" * deflate algorithm.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param record the TLSCompressed record to decompress.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"var inflate = function(c, record, s) {\r",
							"  var rval = false;\r",
							"\r",
							"  try {\r",
							"    var bytes = c.inflate(record.fragment.getBytes());\r",
							"    record.fragment = forge.util.createBuffer(bytes);\r",
							"    record.length = bytes.length;\r",
							"    rval = true;\r",
							"  } catch(ex) {\r",
							"    // inflate error, fail out\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Reads a TLS variable-length vector from a byte buffer.\r",
							" *\r",
							" * Variable-length vectors are defined by specifying a subrange of legal\r",
							" * lengths, inclusively, using the notation <floor..ceiling>. When these are\r",
							" * encoded, the actual length precedes the vector's contents in the byte\r",
							" * stream. The length will be in the form of a number consuming as many bytes\r",
							" * as required to hold the vector's specified maximum (ceiling) length. A\r",
							" * variable-length vector with an actual length field of zero is referred to\r",
							" * as an empty vector.\r",
							" *\r",
							" * @param b the byte buffer.\r",
							" * @param lenBytes the number of bytes required to store the length.\r",
							" *\r",
							" * @return the resulting byte buffer.\r",
							" */\r",
							"var readVector = function(b, lenBytes) {\r",
							"  var len = 0;\r",
							"  switch(lenBytes) {\r",
							"  case 1:\r",
							"    len = b.getByte();\r",
							"    break;\r",
							"  case 2:\r",
							"    len = b.getInt16();\r",
							"    break;\r",
							"  case 3:\r",
							"    len = b.getInt24();\r",
							"    break;\r",
							"  case 4:\r",
							"    len = b.getInt32();\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  // read vector bytes into a new buffer\r",
							"  return forge.util.createBuffer(b.getBytes(len));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Writes a TLS variable-length vector to a byte buffer.\r",
							" *\r",
							" * @param b the byte buffer.\r",
							" * @param lenBytes the number of bytes required to store the length.\r",
							" * @param v the byte buffer vector.\r",
							" */\r",
							"var writeVector = function(b, lenBytes, v) {\r",
							"  // encode length at the start of the vector, where the number of bytes for\r",
							"  // the length is the maximum number of bytes it would take to encode the\r",
							"  // vector's ceiling\r",
							"  b.putInt(v.length(), lenBytes << 3);\r",
							"  b.putBuffer(v);\r",
							"};\r",
							"\r",
							"/**\r",
							" * The tls implementation.\r",
							" */\r",
							"var tls = {};\r",
							"\r",
							"/**\r",
							" * Version: TLS 1.2 = 3.3, TLS 1.1 = 3.2, TLS 1.0 = 3.1. Both TLS 1.1 and\r",
							" * TLS 1.2 were still too new (ie: openSSL didn't implement them) at the time\r",
							" * of this implementation so TLS 1.0 was implemented instead.\r",
							" */\r",
							"tls.Versions = {\r",
							"  TLS_1_0: {major: 3, minor: 1},\r",
							"  TLS_1_1: {major: 3, minor: 2},\r",
							"  TLS_1_2: {major: 3, minor: 3}\r",
							"};\r",
							"tls.SupportedVersions = [\r",
							"  tls.Versions.TLS_1_1,\r",
							"  tls.Versions.TLS_1_0\r",
							"];\r",
							"tls.Version = tls.SupportedVersions[0];\r",
							"\r",
							"/**\r",
							" * Maximum fragment size. True maximum is 16384, but we fragment before that\r",
							" * to allow for unusual small increases during compression.\r",
							" */\r",
							"tls.MaxFragment = 16384 - 1024;\r",
							"\r",
							"/**\r",
							" * Whether this entity is considered the \"client\" or \"server\".\r",
							" * enum { server, client } ConnectionEnd;\r",
							" */\r",
							"tls.ConnectionEnd = {\r",
							"  server: 0,\r",
							"  client: 1\r",
							"};\r",
							"\r",
							"/**\r",
							" * Pseudo-random function algorithm used to generate keys from the master\r",
							" * secret.\r",
							" * enum { tls_prf_sha256 } PRFAlgorithm;\r",
							" */\r",
							"tls.PRFAlgorithm = {\r",
							"  tls_prf_sha256: 0\r",
							"};\r",
							"\r",
							"/**\r",
							" * Bulk encryption algorithms.\r",
							" * enum { null, rc4, des3, aes } BulkCipherAlgorithm;\r",
							" */\r",
							"tls.BulkCipherAlgorithm = {\r",
							"  none: null,\r",
							"  rc4: 0,\r",
							"  des3: 1,\r",
							"  aes: 2\r",
							"};\r",
							"\r",
							"/**\r",
							" * Cipher types.\r",
							" * enum { stream, block, aead } CipherType;\r",
							" */\r",
							"tls.CipherType = {\r",
							"  stream: 0,\r",
							"  block: 1,\r",
							"  aead: 2\r",
							"};\r",
							"\r",
							"/**\r",
							" * MAC (Message Authentication Code) algorithms.\r",
							" * enum { null, hmac_md5, hmac_sha1, hmac_sha256,\r",
							" *   hmac_sha384, hmac_sha512} MACAlgorithm;\r",
							" */\r",
							"tls.MACAlgorithm = {\r",
							"  none: null,\r",
							"  hmac_md5: 0,\r",
							"  hmac_sha1: 1,\r",
							"  hmac_sha256: 2,\r",
							"  hmac_sha384: 3,\r",
							"  hmac_sha512: 4\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compression algorithms.\r",
							" * enum { null(0), deflate(1), (255) } CompressionMethod;\r",
							" */\r",
							"tls.CompressionMethod = {\r",
							"  none: 0,\r",
							"  deflate: 1\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS record content types.\r",
							" * enum {\r",
							" *   change_cipher_spec(20), alert(21), handshake(22),\r",
							" *   application_data(23), (255)\r",
							" * } ContentType;\r",
							" */\r",
							"tls.ContentType = {\r",
							"  change_cipher_spec: 20,\r",
							"  alert: 21,\r",
							"  handshake: 22,\r",
							"  application_data: 23,\r",
							"  heartbeat: 24\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS handshake types.\r",
							" * enum {\r",
							" *   hello_request(0), client_hello(1), server_hello(2),\r",
							" *   certificate(11), server_key_exchange (12),\r",
							" *   certificate_request(13), server_hello_done(14),\r",
							" *   certificate_verify(15), client_key_exchange(16),\r",
							" *   finished(20), (255)\r",
							" * } HandshakeType;\r",
							" */\r",
							"tls.HandshakeType = {\r",
							"  hello_request: 0,\r",
							"  client_hello: 1,\r",
							"  server_hello: 2,\r",
							"  certificate: 11,\r",
							"  server_key_exchange: 12,\r",
							"  certificate_request: 13,\r",
							"  server_hello_done: 14,\r",
							"  certificate_verify: 15,\r",
							"  client_key_exchange: 16,\r",
							"  finished: 20\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS Alert Protocol.\r",
							" *\r",
							" * enum { warning(1), fatal(2), (255) } AlertLevel;\r",
							" *\r",
							" * enum {\r",
							" *   close_notify(0),\r",
							" *   unexpected_message(10),\r",
							" *   bad_record_mac(20),\r",
							" *   decryption_failed(21),\r",
							" *   record_overflow(22),\r",
							" *   decompression_failure(30),\r",
							" *   handshake_failure(40),\r",
							" *   bad_certificate(42),\r",
							" *   unsupported_certificate(43),\r",
							" *   certificate_revoked(44),\r",
							" *   certificate_expired(45),\r",
							" *   certificate_unknown(46),\r",
							" *   illegal_parameter(47),\r",
							" *   unknown_ca(48),\r",
							" *   access_denied(49),\r",
							" *   decode_error(50),\r",
							" *   decrypt_error(51),\r",
							" *   export_restriction(60),\r",
							" *   protocol_version(70),\r",
							" *   insufficient_security(71),\r",
							" *   internal_error(80),\r",
							" *   user_canceled(90),\r",
							" *   no_renegotiation(100),\r",
							" *   (255)\r",
							" * } AlertDescription;\r",
							" *\r",
							" * struct {\r",
							" *   AlertLevel level;\r",
							" *   AlertDescription description;\r",
							" * } Alert;\r",
							" */\r",
							"tls.Alert = {};\r",
							"tls.Alert.Level = {\r",
							"  warning: 1,\r",
							"  fatal: 2\r",
							"};\r",
							"tls.Alert.Description = {\r",
							"  close_notify: 0,\r",
							"  unexpected_message: 10,\r",
							"  bad_record_mac: 20,\r",
							"  decryption_failed: 21,\r",
							"  record_overflow: 22,\r",
							"  decompression_failure: 30,\r",
							"  handshake_failure: 40,\r",
							"  bad_certificate: 42,\r",
							"  unsupported_certificate: 43,\r",
							"  certificate_revoked: 44,\r",
							"  certificate_expired: 45,\r",
							"  certificate_unknown: 46,\r",
							"  illegal_parameter: 47,\r",
							"  unknown_ca: 48,\r",
							"  access_denied: 49,\r",
							"  decode_error: 50,\r",
							"  decrypt_error: 51,\r",
							"  export_restriction: 60,\r",
							"  protocol_version: 70,\r",
							"  insufficient_security: 71,\r",
							"  internal_error: 80,\r",
							"  user_canceled: 90,\r",
							"  no_renegotiation: 100\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS Heartbeat Message types.\r",
							" * enum {\r",
							" *   heartbeat_request(1),\r",
							" *   heartbeat_response(2),\r",
							" *   (255)\r",
							" * } HeartbeatMessageType;\r",
							" */\r",
							"tls.HeartbeatMessageType = {\r",
							"  heartbeat_request: 1,\r",
							"  heartbeat_response: 2\r",
							"};\r",
							"\r",
							"/**\r",
							" * Supported cipher suites.\r",
							" */\r",
							"tls.CipherSuites = {};\r",
							"\r",
							"/**\r",
							" * Gets a supported cipher suite from its 2 byte ID.\r",
							" *\r",
							" * @param twoBytes two bytes in a string.\r",
							" *\r",
							" * @return the matching supported cipher suite or null.\r",
							" */\r",
							"tls.getCipherSuite = function(twoBytes) {\r",
							"  var rval = null;\r",
							"  for(var key in tls.CipherSuites) {\r",
							"    var cs = tls.CipherSuites[key];\r",
							"    if(cs.id[0] === twoBytes.charCodeAt(0) &&\r",
							"      cs.id[1] === twoBytes.charCodeAt(1)) {\r",
							"      rval = cs;\r",
							"      break;\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when an unexpected record is encountered.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleUnexpected = function(c, record) {\r",
							"  // if connection is client and closed, ignore unexpected messages\r",
							"  var ignore = (!c.open && c.entity === tls.ConnectionEnd.client);\r",
							"  if(!ignore) {\r",
							"    c.error(c, {\r",
							"      message: 'Unexpected message. Received TLS record out of order.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.unexpected_message\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a HelloRequest record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleHelloRequest = function(c, record, length) {\r",
							"  // ignore renegotiation requests from the server during a handshake, but\r",
							"  // if handshaking, send a warning alert that renegotation is denied\r",
							"  if(!c.handshaking && c.handshakes > 0) {\r",
							"    // send alert warning\r",
							"    tls.queue(c, tls.createAlert(c, {\r",
							"       level: tls.Alert.Level.warning,\r",
							"       description: tls.Alert.Description.no_renegotiation\r",
							"    }));\r",
							"    tls.flush(c);\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses a hello message from a ClientHello or ServerHello record.\r",
							" *\r",
							" * @param record the record to parse.\r",
							" *\r",
							" * @return the parsed message.\r",
							" */\r",
							"tls.parseHelloMessage = function(c, record, length) {\r",
							"  var msg = null;\r",
							"\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"\r",
							"  // minimum of 38 bytes in message\r",
							"  if(length < 38) {\r",
							"    c.error(c, {\r",
							"      message: client ?\r",
							"        'Invalid ServerHello message. Message too short.' :\r",
							"        'Invalid ClientHello message. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  } else {\r",
							"    // use 'remaining' to calculate # of remaining bytes in the message\r",
							"    var b = record.fragment;\r",
							"    var remaining = b.length();\r",
							"    msg = {\r",
							"      version: {\r",
							"        major: b.getByte(),\r",
							"        minor: b.getByte()\r",
							"      },\r",
							"      random: forge.util.createBuffer(b.getBytes(32)),\r",
							"      session_id: readVector(b, 1),\r",
							"      extensions: []\r",
							"    };\r",
							"    if(client) {\r",
							"      msg.cipher_suite = b.getBytes(2);\r",
							"      msg.compression_method = b.getByte();\r",
							"    } else {\r",
							"      msg.cipher_suites = readVector(b, 2);\r",
							"      msg.compression_methods = readVector(b, 1);\r",
							"    }\r",
							"\r",
							"    // read extensions if there are any bytes left in the message\r",
							"    remaining = length - (remaining - b.length());\r",
							"    if(remaining > 0) {\r",
							"      // parse extensions\r",
							"      var exts = readVector(b, 2);\r",
							"      while(exts.length() > 0) {\r",
							"        msg.extensions.push({\r",
							"          type: [exts.getByte(), exts.getByte()],\r",
							"          data: readVector(exts, 2)\r",
							"        });\r",
							"      }\r",
							"\r",
							"      // TODO: make extension support modular\r",
							"      if(!client) {\r",
							"        for(var i = 0; i < msg.extensions.length; ++i) {\r",
							"          var ext = msg.extensions[i];\r",
							"\r",
							"          // support SNI extension\r",
							"          if(ext.type[0] === 0x00 && ext.type[1] === 0x00) {\r",
							"            // get server name list\r",
							"            var snl = readVector(ext.data, 2);\r",
							"            while(snl.length() > 0) {\r",
							"              // read server name type\r",
							"              var snType = snl.getByte();\r",
							"\r",
							"              // only HostName type (0x00) is known, break out if\r",
							"              // another type is detected\r",
							"              if(snType !== 0x00) {\r",
							"                break;\r",
							"              }\r",
							"\r",
							"              // add host name to server name list\r",
							"              c.session.extensions.server_name.serverNameList.push(\r",
							"                readVector(snl, 2).getBytes());\r",
							"            }\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // version already set, do not allow version change\r",
							"    if(c.session.version) {\r",
							"      if(msg.version.major !== c.session.version.major ||\r",
							"        msg.version.minor !== c.session.version.minor) {\r",
							"        return c.error(c, {\r",
							"          message: 'TLS version change is disallowed during renegotiation.',\r",
							"          send: true,\r",
							"          alert: {\r",
							"            level: tls.Alert.Level.fatal,\r",
							"            description: tls.Alert.Description.protocol_version\r",
							"          }\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // get the chosen (ServerHello) cipher suite\r",
							"    if(client) {\r",
							"      // FIXME: should be checking configured acceptable cipher suites\r",
							"      c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);\r",
							"    } else {\r",
							"      // get a supported preferred (ClientHello) cipher suite\r",
							"      // choose the first supported cipher suite\r",
							"      var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());\r",
							"      while(tmp.length() > 0) {\r",
							"        // FIXME: should be checking configured acceptable suites\r",
							"        // cipher suites take up 2 bytes\r",
							"        c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));\r",
							"        if(c.session.cipherSuite !== null) {\r",
							"          break;\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // cipher suite not supported\r",
							"    if(c.session.cipherSuite === null) {\r",
							"      return c.error(c, {\r",
							"        message: 'No cipher suites in common.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.handshake_failure\r",
							"        },\r",
							"        cipherSuite: forge.util.bytesToHex(msg.cipher_suite)\r",
							"      });\r",
							"    }\r",
							"\r",
							"    // TODO: handle compression methods\r",
							"    if(client) {\r",
							"      c.session.compressionMethod = msg.compression_method;\r",
							"    } else {\r",
							"      // no compression\r",
							"      c.session.compressionMethod = tls.CompressionMethod.none;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates security parameters for the given connection based on the given\r",
							" * hello message.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param msg the hello message.\r",
							" */\r",
							"tls.createSecurityParameters = function(c, msg) {\r",
							"  /* Note: security params are from TLS 1.2, some values like prf_algorithm\r",
							"  are ignored for TLS 1.0/1.1 and the builtin as specified in the spec is\r",
							"  used. */\r",
							"\r",
							"  // TODO: handle other options from server when more supported\r",
							"\r",
							"  // get client and server randoms\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var msgRandom = msg.random.bytes();\r",
							"  var cRandom = client ? c.session.sp.client_random : msgRandom;\r",
							"  var sRandom = client ? msgRandom : tls.createRandom().getBytes();\r",
							"\r",
							"  // create new security parameters\r",
							"  c.session.sp = {\r",
							"    entity: c.entity,\r",
							"    prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,\r",
							"    bulk_cipher_algorithm: null,\r",
							"    cipher_type: null,\r",
							"    enc_key_length: null,\r",
							"    block_length: null,\r",
							"    fixed_iv_length: null,\r",
							"    record_iv_length: null,\r",
							"    mac_algorithm: null,\r",
							"    mac_length: null,\r",
							"    mac_key_length: null,\r",
							"    compression_algorithm: c.session.compressionMethod,\r",
							"    pre_master_secret: null,\r",
							"    master_secret: null,\r",
							"    client_random: cRandom,\r",
							"    server_random: sRandom\r",
							"  };\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ServerHello record.\r",
							" *\r",
							" * When a ServerHello message will be sent:\r",
							" *   The server will send this message in response to a client hello message\r",
							" *   when it was able to find an acceptable set of algorithms. If it cannot\r",
							" *   find such a match, it will respond with a handshake failure alert.\r",
							" *\r",
							" * uint24 length;\r",
							" * struct {\r",
							" *   ProtocolVersion server_version;\r",
							" *   Random random;\r",
							" *   SessionID session_id;\r",
							" *   CipherSuite cipher_suite;\r",
							" *   CompressionMethod compression_method;\r",
							" *   select(extensions_present) {\r",
							" *     case false:\r",
							" *       struct {};\r",
							" *     case true:\r",
							" *       Extension extensions<0..2^16-1>;\r",
							" *   };\r",
							" * } ServerHello;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleServerHello = function(c, record, length) {\r",
							"  var msg = tls.parseHelloMessage(c, record, length);\r",
							"  if(c.fail) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // ensure server version is compatible\r",
							"  if(msg.version.minor <= c.version.minor) {\r",
							"    c.version.minor = msg.version.minor;\r",
							"  } else {\r",
							"    return c.error(c, {\r",
							"      message: 'Incompatible TLS version.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.protocol_version\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // indicate session version has been set\r",
							"  c.session.version = c.version;\r",
							"\r",
							"  // get the session ID from the message\r",
							"  var sessionId = msg.session_id.bytes();\r",
							"\r",
							"  // if the session ID is not blank and matches the cached one, resume\r",
							"  // the session\r",
							"  if(sessionId.length > 0 && sessionId === c.session.id) {\r",
							"    // resuming session, expect a ChangeCipherSpec next\r",
							"    c.expect = SCC;\r",
							"    c.session.resuming = true;\r",
							"\r",
							"    // get new server random\r",
							"    c.session.sp.server_random = msg.random.bytes();\r",
							"  } else {\r",
							"    // not resuming, expect a server Certificate message next\r",
							"    c.expect = SCE;\r",
							"    c.session.resuming = false;\r",
							"\r",
							"    // create new security parameters\r",
							"    tls.createSecurityParameters(c, msg);\r",
							"  }\r",
							"\r",
							"  // set new session ID\r",
							"  c.session.id = sessionId;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a server receives a ClientHello record.\r",
							" *\r",
							" * When a ClientHello message will be sent:\r",
							" *   When a client first connects to a server it is required to send the\r",
							" *   client hello as its first message. The client can also send a client\r",
							" *   hello in response to a hello request or on its own initiative in order\r",
							" *   to renegotiate the security parameters in an existing connection.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleClientHello = function(c, record, length) {\r",
							"  var msg = tls.parseHelloMessage(c, record, length);\r",
							"  if(c.fail) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // get the session ID from the message\r",
							"  var sessionId = msg.session_id.bytes();\r",
							"\r",
							"  // see if the given session ID is in the cache\r",
							"  var session = null;\r",
							"  if(c.sessionCache) {\r",
							"    session = c.sessionCache.getSession(sessionId);\r",
							"    if(session === null) {\r",
							"      // session ID not found\r",
							"      sessionId = '';\r",
							"    } else if(session.version.major !== msg.version.major ||\r",
							"      session.version.minor > msg.version.minor) {\r",
							"      // if session version is incompatible with client version, do not resume\r",
							"      session = null;\r",
							"      sessionId = '';\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // no session found to resume, generate a new session ID\r",
							"  if(sessionId.length === 0) {\r",
							"    sessionId = forge.random.getBytes(32);\r",
							"  }\r",
							"\r",
							"  // update session\r",
							"  c.session.id = sessionId;\r",
							"  c.session.clientHelloVersion = msg.version;\r",
							"  c.session.sp = {};\r",
							"  if(session) {\r",
							"    // use version and security parameters from resumed session\r",
							"    c.version = c.session.version = session.version;\r",
							"    c.session.sp = session.sp;\r",
							"  } else {\r",
							"    // use highest compatible minor version\r",
							"    var version;\r",
							"    for(var i = 1; i < tls.SupportedVersions.length; ++i) {\r",
							"      version = tls.SupportedVersions[i];\r",
							"      if(version.minor <= msg.version.minor) {\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"    c.version = {major: version.major, minor: version.minor};\r",
							"    c.session.version = c.version;\r",
							"  }\r",
							"\r",
							"  // if a session is set, resume it\r",
							"  if(session !== null) {\r",
							"    // resuming session, expect a ChangeCipherSpec next\r",
							"    c.expect = CCC;\r",
							"    c.session.resuming = true;\r",
							"\r",
							"    // get new client random\r",
							"    c.session.sp.client_random = msg.random.bytes();\r",
							"  } else {\r",
							"    // not resuming, expect a Certificate or ClientKeyExchange\r",
							"    c.expect = (c.verifyClient !== false) ? CCE : CKE;\r",
							"    c.session.resuming = false;\r",
							"\r",
							"    // create new security parameters\r",
							"    tls.createSecurityParameters(c, msg);\r",
							"  }\r",
							"\r",
							"  // connection now open\r",
							"  c.open = true;\r",
							"\r",
							"  // queue server hello\r",
							"  tls.queue(c, tls.createRecord(c, {\r",
							"    type: tls.ContentType.handshake,\r",
							"    data: tls.createServerHello(c)\r",
							"  }));\r",
							"\r",
							"  if(c.session.resuming) {\r",
							"    // queue change cipher spec message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.change_cipher_spec,\r",
							"      data: tls.createChangeCipherSpec()\r",
							"    }));\r",
							"\r",
							"    // create pending state\r",
							"    c.state.pending = tls.createConnectionState(c);\r",
							"\r",
							"    // change current write state to pending write state\r",
							"    c.state.current.write = c.state.pending.write;\r",
							"\r",
							"    // queue finished\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createFinished(c)\r",
							"    }));\r",
							"  } else {\r",
							"    // queue server certificate\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createCertificate(c)\r",
							"    }));\r",
							"\r",
							"    if(!c.fail) {\r",
							"      // queue server key exchange\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createServerKeyExchange(c)\r",
							"      }));\r",
							"\r",
							"      // request client certificate if set\r",
							"      if(c.verifyClient !== false) {\r",
							"        // queue certificate request\r",
							"        tls.queue(c, tls.createRecord(c, {\r",
							"          type: tls.ContentType.handshake,\r",
							"          data: tls.createCertificateRequest(c)\r",
							"        }));\r",
							"      }\r",
							"\r",
							"      // queue server hello done\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createServerHelloDone(c)\r",
							"      }));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // send records\r",
							"  tls.flush(c);\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a Certificate record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   The server must send a certificate whenever the agreed-upon key exchange\r",
							" *   method is not an anonymous one. This message will always immediately\r",
							" *   follow the server hello message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   The certificate type must be appropriate for the selected cipher suite's\r",
							" *   key exchange algorithm, and is generally an X.509v3 certificate. It must\r",
							" *   contain a key which matches the key exchange method, as follows. Unless\r",
							" *   otherwise specified, the signing algorithm for the certificate must be\r",
							" *   the same as the algorithm for the certificate key. Unless otherwise\r",
							" *   specified, the public key may be of any length.\r",
							" *\r",
							" * opaque ASN.1Cert<1..2^24-1>;\r",
							" * struct {\r",
							" *   ASN.1Cert certificate_list<1..2^24-1>;\r",
							" * } Certificate;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleCertificate = function(c, record, length) {\r",
							"  // minimum of 3 bytes in message\r",
							"  if(length < 3) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid Certificate message. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  var b = record.fragment;\r",
							"  var msg = {\r",
							"    certificate_list: readVector(b, 3)\r",
							"  };\r",
							"\r",
							"  /* The sender's certificate will be first in the list (chain), each\r",
							"    subsequent one that follows will certify the previous one, but root\r",
							"    certificates (self-signed) that specify the certificate authority may\r",
							"    be omitted under the assumption that clients must already possess it. */\r",
							"  var cert, asn1;\r",
							"  var certs = [];\r",
							"  try {\r",
							"    while(msg.certificate_list.length() > 0) {\r",
							"      // each entry in msg.certificate_list is a vector with 3 len bytes\r",
							"      cert = readVector(msg.certificate_list, 3);\r",
							"      asn1 = forge.asn1.fromDer(cert);\r",
							"      cert = forge.pki.certificateFromAsn1(asn1, true);\r",
							"      certs.push(cert);\r",
							"    }\r",
							"  } catch(ex) {\r",
							"    return c.error(c, {\r",
							"      message: 'Could not parse certificate list.',\r",
							"      cause: ex,\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.bad_certificate\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // ensure at least 1 certificate was provided if in client-mode\r",
							"  // or if verifyClient was set to true to require a certificate\r",
							"  // (as opposed to 'optional')\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  if((client || c.verifyClient === true) && certs.length === 0) {\r",
							"    // error, no certificate\r",
							"    c.error(c, {\r",
							"      message: client ?\r",
							"        'No server certificate provided.' :\r",
							"        'No client certificate provided.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  } else if(certs.length === 0) {\r",
							"    // no certs to verify\r",
							"    // expect a ServerKeyExchange or ClientKeyExchange message next\r",
							"    c.expect = client ? SKE : CKE;\r",
							"  } else {\r",
							"    // save certificate in session\r",
							"    if(client) {\r",
							"      c.session.serverCertificate = certs[0];\r",
							"    } else {\r",
							"      c.session.clientCertificate = certs[0];\r",
							"    }\r",
							"\r",
							"    if(tls.verifyCertificateChain(c, certs)) {\r",
							"      // expect a ServerKeyExchange or ClientKeyExchange message next\r",
							"      c.expect = client ? SKE : CKE;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ServerKeyExchange record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This message will be sent immediately after the server certificate\r",
							" *   message (or the server hello message, if this is an anonymous\r",
							" *   negotiation).\r",
							" *\r",
							" *   The server key exchange message is sent by the server only when the\r",
							" *   server certificate message (if sent) does not contain enough data to\r",
							" *   allow the client to exchange a premaster secret.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   This message conveys cryptographic information to allow the client to\r",
							" *   communicate the premaster secret: either an RSA public key to encrypt\r",
							" *   the premaster secret with, or a Diffie-Hellman public key with which the\r",
							" *   client can complete a key exchange (with the result being the premaster\r",
							" *   secret.)\r",
							" *\r",
							" * enum {\r",
							" *   dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa\r",
							" * } KeyExchangeAlgorithm;\r",
							" *\r",
							" * struct {\r",
							" *   opaque dh_p<1..2^16-1>;\r",
							" *   opaque dh_g<1..2^16-1>;\r",
							" *   opaque dh_Ys<1..2^16-1>;\r",
							" * } ServerDHParams;\r",
							" *\r",
							" * struct {\r",
							" *   select(KeyExchangeAlgorithm) {\r",
							" *     case dh_anon:\r",
							" *       ServerDHParams params;\r",
							" *     case dhe_dss:\r",
							" *     case dhe_rsa:\r",
							" *       ServerDHParams params;\r",
							" *       digitally-signed struct {\r",
							" *         opaque client_random[32];\r",
							" *         opaque server_random[32];\r",
							" *         ServerDHParams params;\r",
							" *       } signed_params;\r",
							" *     case rsa:\r",
							" *     case dh_dss:\r",
							" *     case dh_rsa:\r",
							" *       struct {};\r",
							" *   };\r",
							" * } ServerKeyExchange;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleServerKeyExchange = function(c, record, length) {\r",
							"  // this implementation only supports RSA, no Diffie-Hellman support\r",
							"  // so any length > 0 is invalid\r",
							"  if(length > 0) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid key parameters. Only RSA is supported.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.unsupported_certificate\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // expect an optional CertificateRequest message next\r",
							"  c.expect = SCR;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ClientKeyExchange record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleClientKeyExchange = function(c, record, length) {\r",
							"  // this implementation only supports RSA, no Diffie-Hellman support\r",
							"  // so any length < 48 is invalid\r",
							"  if(length < 48) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid key parameters. Only RSA is supported.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.unsupported_certificate\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  var b = record.fragment;\r",
							"  var msg = {\r",
							"    enc_pre_master_secret: readVector(b, 2).getBytes()\r",
							"  };\r",
							"\r",
							"  // do rsa decryption\r",
							"  var privateKey = null;\r",
							"  if(c.getPrivateKey) {\r",
							"    try {\r",
							"      privateKey = c.getPrivateKey(c, c.session.serverCertificate);\r",
							"      privateKey = forge.pki.privateKeyFromPem(privateKey);\r",
							"    } catch(ex) {\r",
							"      c.error(c, {\r",
							"        message: 'Could not get private key.',\r",
							"        cause: ex,\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(privateKey === null) {\r",
							"    return c.error(c, {\r",
							"      message: 'No private key set.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.internal_error\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  try {\r",
							"    // decrypt 48-byte pre-master secret\r",
							"    var sp = c.session.sp;\r",
							"    sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);\r",
							"\r",
							"    // ensure client hello version matches first 2 bytes\r",
							"    var version = c.session.clientHelloVersion;\r",
							"    if(version.major !== sp.pre_master_secret.charCodeAt(0) ||\r",
							"      version.minor !== sp.pre_master_secret.charCodeAt(1)) {\r",
							"      // error, do not send alert (see BLEI attack below)\r",
							"      throw new Error('TLS version rollback attack detected.');\r",
							"    }\r",
							"  } catch(ex) {\r",
							"    /* Note: Daniel Bleichenbacher [BLEI] can be used to attack a\r",
							"      TLS server which is using PKCS#1 encoded RSA, so instead of\r",
							"      failing here, we generate 48 random bytes and use that as\r",
							"      the pre-master secret. */\r",
							"    sp.pre_master_secret = forge.random.getBytes(48);\r",
							"  }\r",
							"\r",
							"  // expect a CertificateVerify message if a Certificate was received that\r",
							"  // does not have fixed Diffie-Hellman params, otherwise expect\r",
							"  // ChangeCipherSpec\r",
							"  c.expect = CCC;\r",
							"  if(c.session.clientCertificate !== null) {\r",
							"    // only RSA support, so expect CertificateVerify\r",
							"    // TODO: support Diffie-Hellman\r",
							"    c.expect = CCV;\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a CertificateRequest record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   A non-anonymous server can optionally request a certificate from the\r",
							" *   client, if appropriate for the selected cipher suite. This message, if\r",
							" *   sent, will immediately follow the Server Key Exchange message (if it is\r",
							" *   sent; otherwise, the Server Certificate message).\r",
							" *\r",
							" * enum {\r",
							" *   rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\r",
							" *   rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\r",
							" *   fortezza_dms_RESERVED(20), (255)\r",
							" * } ClientCertificateType;\r",
							" *\r",
							" * opaque DistinguishedName<1..2^16-1>;\r",
							" *\r",
							" * struct {\r",
							" *   ClientCertificateType certificate_types<1..2^8-1>;\r",
							" *   SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;\r",
							" *   DistinguishedName certificate_authorities<0..2^16-1>;\r",
							" * } CertificateRequest;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleCertificateRequest = function(c, record, length) {\r",
							"  // minimum of 3 bytes in message\r",
							"  if(length < 3) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid CertificateRequest. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // TODO: TLS 1.2+ has different format including\r",
							"  // SignatureAndHashAlgorithm after cert types\r",
							"  var b = record.fragment;\r",
							"  var msg = {\r",
							"    certificate_types: readVector(b, 1),\r",
							"    certificate_authorities: readVector(b, 2)\r",
							"  };\r",
							"\r",
							"  // save certificate request in session\r",
							"  c.session.certificateRequest = msg;\r",
							"\r",
							"  // expect a ServerHelloDone message next\r",
							"  c.expect = SHD;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a server receives a CertificateVerify record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleCertificateVerify = function(c, record, length) {\r",
							"  if(length < 2) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid CertificateVerify. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // rewind to get full bytes for message so it can be manually\r",
							"  // digested below (special case for CertificateVerify messages because\r",
							"  // they must be digested *after* handling as opposed to all others)\r",
							"  var b = record.fragment;\r",
							"  b.read -= 4;\r",
							"  var msgBytes = b.bytes();\r",
							"  b.read += 4;\r",
							"\r",
							"  var msg = {\r",
							"    signature: readVector(b, 2).getBytes()\r",
							"  };\r",
							"\r",
							"  // TODO: add support for DSA\r",
							"\r",
							"  // generate data to verify\r",
							"  var verify = forge.util.createBuffer();\r",
							"  verify.putBuffer(c.session.md5.digest());\r",
							"  verify.putBuffer(c.session.sha1.digest());\r",
							"  verify = verify.getBytes();\r",
							"\r",
							"  try {\r",
							"    var cert = c.session.clientCertificate;\r",
							"    /*b = forge.pki.rsa.decrypt(\r",
							"      msg.signature, cert.publicKey, true, verify.length);\r",
							"    if(b !== verify) {*/\r",
							"    if(!cert.publicKey.verify(verify, msg.signature, 'NONE')) {\r",
							"      throw new Error('CertificateVerify signature does not match.');\r",
							"    }\r",
							"\r",
							"    // digest message now that it has been handled\r",
							"    c.session.md5.update(msgBytes);\r",
							"    c.session.sha1.update(msgBytes);\r",
							"  } catch(ex) {\r",
							"    return c.error(c, {\r",
							"      message: 'Bad signature in CertificateVerify.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.handshake_failure\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // expect ChangeCipherSpec\r",
							"  c.expect = CCC;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ServerHelloDone record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   The server hello done message is sent by the server to indicate the end\r",
							" *   of the server hello and associated messages. After sending this message\r",
							" *   the server will wait for a client response.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   This message means that the server is done sending messages to support\r",
							" *   the key exchange, and the client can proceed with its phase of the key\r",
							" *   exchange.\r",
							" *\r",
							" *   Upon receipt of the server hello done message the client should verify\r",
							" *   that the server provided a valid certificate if required and check that\r",
							" *   the server hello parameters are acceptable.\r",
							" *\r",
							" * struct {} ServerHelloDone;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleServerHelloDone = function(c, record, length) {\r",
							"  // len must be 0 bytes\r",
							"  if(length > 0) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid ServerHelloDone message. Invalid length.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.record_overflow\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  if(c.serverCertificate === null) {\r",
							"    // no server certificate was provided\r",
							"    var error = {\r",
							"      message: 'No server certificate provided. Not enough security.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.insufficient_security\r",
							"      }\r",
							"    };\r",
							"\r",
							"    // call application callback\r",
							"    var depth = 0;\r",
							"    var ret = c.verify(c, error.alert.description, depth, []);\r",
							"    if(ret !== true) {\r",
							"      // check for custom alert info\r",
							"      if(ret || ret === 0) {\r",
							"        // set custom message and alert description\r",
							"        if(typeof ret === 'object' && !forge.util.isArray(ret)) {\r",
							"          if(ret.message) {\r",
							"            error.message = ret.message;\r",
							"          }\r",
							"          if(ret.alert) {\r",
							"            error.alert.description = ret.alert;\r",
							"          }\r",
							"        } else if(typeof ret === 'number') {\r",
							"          // set custom alert description\r",
							"          error.alert.description = ret;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // send error\r",
							"      return c.error(c, error);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // create client certificate message if requested\r",
							"  if(c.session.certificateRequest !== null) {\r",
							"    record = tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createCertificate(c)\r",
							"    });\r",
							"    tls.queue(c, record);\r",
							"  }\r",
							"\r",
							"  // create client key exchange message\r",
							"  record = tls.createRecord(c, {\r",
							"     type: tls.ContentType.handshake,\r",
							"     data: tls.createClientKeyExchange(c)\r",
							"  });\r",
							"  tls.queue(c, record);\r",
							"\r",
							"  // expect no messages until the following callback has been called\r",
							"  c.expect = SER;\r",
							"\r",
							"  // create callback to handle client signature (for client-certs)\r",
							"  var callback = function(c, signature) {\r",
							"    if(c.session.certificateRequest !== null &&\r",
							"      c.session.clientCertificate !== null) {\r",
							"      // create certificate verify message\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createCertificateVerify(c, signature)\r",
							"      }));\r",
							"    }\r",
							"\r",
							"    // create change cipher spec message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.change_cipher_spec,\r",
							"      data: tls.createChangeCipherSpec()\r",
							"    }));\r",
							"\r",
							"    // create pending state\r",
							"    c.state.pending = tls.createConnectionState(c);\r",
							"\r",
							"    // change current write state to pending write state\r",
							"    c.state.current.write = c.state.pending.write;\r",
							"\r",
							"    // create finished message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createFinished(c)\r",
							"    }));\r",
							"\r",
							"    // expect a server ChangeCipherSpec message next\r",
							"    c.expect = SCC;\r",
							"\r",
							"    // send records\r",
							"    tls.flush(c);\r",
							"\r",
							"    // continue\r",
							"    c.process();\r",
							"  };\r",
							"\r",
							"  // if there is no certificate request or no client certificate, do\r",
							"  // callback immediately\r",
							"  if(c.session.certificateRequest === null ||\r",
							"    c.session.clientCertificate === null) {\r",
							"    return callback(c, null);\r",
							"  }\r",
							"\r",
							"  // otherwise get the client signature\r",
							"  tls.getClientSignature(c, callback);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a ChangeCipherSpec record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleChangeCipherSpec = function(c, record) {\r",
							"  if(record.fragment.getByte() !== 0x01) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid ChangeCipherSpec message received.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // create pending state if:\r",
							"  // 1. Resuming session in client mode OR\r",
							"  // 2. NOT resuming session in server mode\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  if((c.session.resuming && client) || (!c.session.resuming && !client)) {\r",
							"    c.state.pending = tls.createConnectionState(c);\r",
							"  }\r",
							"\r",
							"  // change current read state to pending read state\r",
							"  c.state.current.read = c.state.pending.read;\r",
							"\r",
							"  // clear pending state if:\r",
							"  // 1. NOT resuming session in client mode OR\r",
							"  // 2. resuming a session in server mode\r",
							"  if((!c.session.resuming && client) || (c.session.resuming && !client)) {\r",
							"    c.state.pending = null;\r",
							"  }\r",
							"\r",
							"  // expect a Finished record next\r",
							"  c.expect = client ? SFI : CFI;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a Finished record is received.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   A finished message is always sent immediately after a change\r",
							" *   cipher spec message to verify that the key exchange and\r",
							" *   authentication processes were successful. It is essential that a\r",
							" *   change cipher spec message be received between the other\r",
							" *   handshake messages and the Finished message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   The finished message is the first protected with the just-\r",
							" *   negotiated algorithms, keys, and secrets. Recipients of finished\r",
							" *   messages must verify that the contents are correct.  Once a side\r",
							" *   has sent its Finished message and received and validated the\r",
							" *   Finished message from its peer, it may begin to send and receive\r",
							" *   application data over the connection.\r",
							" *\r",
							" * struct {\r",
							" *   opaque verify_data[verify_data_length];\r",
							" * } Finished;\r",
							" *\r",
							" * verify_data\r",
							" *   PRF(master_secret, finished_label, Hash(handshake_messages))\r",
							" *     [0..verify_data_length-1];\r",
							" *\r",
							" * finished_label\r",
							" *   For Finished messages sent by the client, the string\r",
							" *   \"client finished\". For Finished messages sent by the server, the\r",
							" *   string \"server finished\".\r",
							" *\r",
							" * verify_data_length depends on the cipher suite. If it is not specified\r",
							" * by the cipher suite, then it is 12. Versions of TLS < 1.2 always used\r",
							" * 12 bytes.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleFinished = function(c, record, length) {\r",
							"  // rewind to get full bytes for message so it can be manually\r",
							"  // digested below (special case for Finished messages because they\r",
							"  // must be digested *after* handling as opposed to all others)\r",
							"  var b = record.fragment;\r",
							"  b.read -= 4;\r",
							"  var msgBytes = b.bytes();\r",
							"  b.read += 4;\r",
							"\r",
							"  // message contains only verify_data\r",
							"  var vd = record.fragment.getBytes();\r",
							"\r",
							"  // ensure verify data is correct\r",
							"  b = forge.util.createBuffer();\r",
							"  b.putBuffer(c.session.md5.digest());\r",
							"  b.putBuffer(c.session.sha1.digest());\r",
							"\r",
							"  // set label based on entity type\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var label = client ? 'server finished' : 'client finished';\r",
							"\r",
							"  // TODO: determine prf function and verify length for TLS 1.2\r",
							"  var sp = c.session.sp;\r",
							"  var vdl = 12;\r",
							"  var prf = prf_TLS1;\r",
							"  b = prf(sp.master_secret, label, b.getBytes(), vdl);\r",
							"  if(b.getBytes() !== vd) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid verify_data in Finished message.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.decrypt_error\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // digest finished message now that it has been handled\r",
							"  c.session.md5.update(msgBytes);\r",
							"  c.session.sha1.update(msgBytes);\r",
							"\r",
							"  // resuming session as client or NOT resuming session as server\r",
							"  if((c.session.resuming && client) || (!c.session.resuming && !client)) {\r",
							"    // create change cipher spec message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.change_cipher_spec,\r",
							"      data: tls.createChangeCipherSpec()\r",
							"    }));\r",
							"\r",
							"    // change current write state to pending write state, clear pending\r",
							"    c.state.current.write = c.state.pending.write;\r",
							"    c.state.pending = null;\r",
							"\r",
							"    // create finished message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createFinished(c)\r",
							"    }));\r",
							"  }\r",
							"\r",
							"  // expect application data next\r",
							"  c.expect = client ? SAD : CAD;\r",
							"\r",
							"  // handshake complete\r",
							"  c.handshaking = false;\r",
							"  ++c.handshakes;\r",
							"\r",
							"  // save access to peer certificate\r",
							"  c.peerCertificate = client ?\r",
							"    c.session.serverCertificate : c.session.clientCertificate;\r",
							"\r",
							"  // send records\r",
							"  tls.flush(c);\r",
							"\r",
							"  // now connected\r",
							"  c.isConnected = true;\r",
							"  c.connected(c);\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when an Alert record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleAlert = function(c, record) {\r",
							"  // read alert\r",
							"  var b = record.fragment;\r",
							"  var alert = {\r",
							"    level: b.getByte(),\r",
							"    description: b.getByte()\r",
							"  };\r",
							"\r",
							"  // TODO: consider using a table?\r",
							"  // get appropriate message\r",
							"  var msg;\r",
							"  switch(alert.description) {\r",
							"  case tls.Alert.Description.close_notify:\r",
							"    msg = 'Connection closed.';\r",
							"    break;\r",
							"  case tls.Alert.Description.unexpected_message:\r",
							"    msg = 'Unexpected message.';\r",
							"    break;\r",
							"  case tls.Alert.Description.bad_record_mac:\r",
							"    msg = 'Bad record MAC.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decryption_failed:\r",
							"    msg = 'Decryption failed.';\r",
							"    break;\r",
							"  case tls.Alert.Description.record_overflow:\r",
							"    msg = 'Record overflow.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decompression_failure:\r",
							"    msg = 'Decompression failed.';\r",
							"    break;\r",
							"  case tls.Alert.Description.handshake_failure:\r",
							"    msg = 'Handshake failure.';\r",
							"    break;\r",
							"  case tls.Alert.Description.bad_certificate:\r",
							"    msg = 'Bad certificate.';\r",
							"    break;\r",
							"  case tls.Alert.Description.unsupported_certificate:\r",
							"    msg = 'Unsupported certificate.';\r",
							"    break;\r",
							"  case tls.Alert.Description.certificate_revoked:\r",
							"    msg = 'Certificate revoked.';\r",
							"    break;\r",
							"  case tls.Alert.Description.certificate_expired:\r",
							"    msg = 'Certificate expired.';\r",
							"    break;\r",
							"  case tls.Alert.Description.certificate_unknown:\r",
							"    msg = 'Certificate unknown.';\r",
							"    break;\r",
							"  case tls.Alert.Description.illegal_parameter:\r",
							"    msg = 'Illegal parameter.';\r",
							"    break;\r",
							"  case tls.Alert.Description.unknown_ca:\r",
							"    msg = 'Unknown certificate authority.';\r",
							"    break;\r",
							"  case tls.Alert.Description.access_denied:\r",
							"    msg = 'Access denied.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decode_error:\r",
							"    msg = 'Decode error.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decrypt_error:\r",
							"    msg = 'Decrypt error.';\r",
							"    break;\r",
							"  case tls.Alert.Description.export_restriction:\r",
							"    msg = 'Export restriction.';\r",
							"    break;\r",
							"  case tls.Alert.Description.protocol_version:\r",
							"    msg = 'Unsupported protocol version.';\r",
							"    break;\r",
							"  case tls.Alert.Description.insufficient_security:\r",
							"    msg = 'Insufficient security.';\r",
							"    break;\r",
							"  case tls.Alert.Description.internal_error:\r",
							"    msg = 'Internal error.';\r",
							"    break;\r",
							"  case tls.Alert.Description.user_canceled:\r",
							"    msg = 'User canceled.';\r",
							"    break;\r",
							"  case tls.Alert.Description.no_renegotiation:\r",
							"    msg = 'Renegotiation not supported.';\r",
							"    break;\r",
							"  default:\r",
							"    msg = 'Unknown error.';\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  // close connection on close_notify, not an error\r",
							"  if(alert.description === tls.Alert.Description.close_notify) {\r",
							"    return c.close();\r",
							"  }\r",
							"\r",
							"  // call error handler\r",
							"  c.error(c, {\r",
							"    message: msg,\r",
							"    send: false,\r",
							"    // origin is the opposite end\r",
							"    origin: (c.entity === tls.ConnectionEnd.client) ? 'server' : 'client',\r",
							"    alert: alert\r",
							"  });\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a Handshake record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleHandshake = function(c, record) {\r",
							"  // get the handshake type and message length\r",
							"  var b = record.fragment;\r",
							"  var type = b.getByte();\r",
							"  var length = b.getInt24();\r",
							"\r",
							"  // see if the record fragment doesn't yet contain the full message\r",
							"  if(length > b.length()) {\r",
							"    // cache the record, clear its fragment, and reset the buffer read\r",
							"    // pointer before the type and length were read\r",
							"    c.fragmented = record;\r",
							"    record.fragment = forge.util.createBuffer();\r",
							"    b.read -= 4;\r",
							"\r",
							"    // continue\r",
							"    return c.process();\r",
							"  }\r",
							"\r",
							"  // full message now available, clear cache, reset read pointer to\r",
							"  // before type and length\r",
							"  c.fragmented = null;\r",
							"  b.read -= 4;\r",
							"\r",
							"  // save the handshake bytes for digestion after handler is found\r",
							"  // (include type and length of handshake msg)\r",
							"  var bytes = b.bytes(length + 4);\r",
							"\r",
							"  // restore read pointer\r",
							"  b.read += 4;\r",
							"\r",
							"  // handle expected message\r",
							"  if(type in hsTable[c.entity][c.expect]) {\r",
							"    // initialize server session\r",
							"    if(c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {\r",
							"      c.handshaking = true;\r",
							"      c.session = {\r",
							"        version: null,\r",
							"        extensions: {\r",
							"          server_name: {\r",
							"            serverNameList: []\r",
							"          }\r",
							"        },\r",
							"        cipherSuite: null,\r",
							"        compressionMethod: null,\r",
							"        serverCertificate: null,\r",
							"        clientCertificate: null,\r",
							"        md5: forge.md.md5.create(),\r",
							"        sha1: forge.md.sha1.create()\r",
							"      };\r",
							"    }\r",
							"\r",
							"    /* Update handshake messages digest. Finished and CertificateVerify\r",
							"      messages are not digested here. They can't be digested as part of\r",
							"      the verify_data that they contain. These messages are manually\r",
							"      digested in their handlers. HelloRequest messages are simply never\r",
							"      included in the handshake message digest according to spec. */\r",
							"    if(type !== tls.HandshakeType.hello_request &&\r",
							"      type !== tls.HandshakeType.certificate_verify &&\r",
							"      type !== tls.HandshakeType.finished) {\r",
							"      c.session.md5.update(bytes);\r",
							"      c.session.sha1.update(bytes);\r",
							"    }\r",
							"\r",
							"    // handle specific handshake type record\r",
							"    hsTable[c.entity][c.expect][type](c, record, length);\r",
							"  } else {\r",
							"    // unexpected record\r",
							"    tls.handleUnexpected(c, record);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when an ApplicationData record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleApplicationData = function(c, record) {\r",
							"  // buffer data, notify that its ready\r",
							"  c.data.putBuffer(record.fragment);\r",
							"  c.dataReady(c);\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a Heartbeat record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleHeartbeat = function(c, record) {\r",
							"  // get the heartbeat type and payload\r",
							"  var b = record.fragment;\r",
							"  var type = b.getByte();\r",
							"  var length = b.getInt16();\r",
							"  var payload = b.getBytes(length);\r",
							"\r",
							"  if(type === tls.HeartbeatMessageType.heartbeat_request) {\r",
							"    // discard request during handshake or if length is too large\r",
							"    if(c.handshaking || length > payload.length) {\r",
							"      // continue\r",
							"      return c.process();\r",
							"    }\r",
							"    // retransmit payload\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.heartbeat,\r",
							"      data: tls.createHeartbeat(\r",
							"        tls.HeartbeatMessageType.heartbeat_response, payload)\r",
							"    }));\r",
							"    tls.flush(c);\r",
							"  } else if(type === tls.HeartbeatMessageType.heartbeat_response) {\r",
							"    // check payload against expected payload, discard heartbeat if no match\r",
							"    if(payload !== c.expectedHeartbeatPayload) {\r",
							"      // continue\r",
							"      return c.process();\r",
							"    }\r",
							"\r",
							"    // notify that a valid heartbeat was received\r",
							"    if(c.heartbeatReceived) {\r",
							"      c.heartbeatReceived(c, forge.util.createBuffer(payload));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * The transistional state tables for receiving TLS records. It maps the\r",
							" * current TLS engine state and a received record to a function to handle the\r",
							" * record and update the state.\r",
							" *\r",
							" * For instance, if the current state is SHE, then the TLS engine is expecting\r",
							" * a ServerHello record. Once a record is received, the handler function is\r",
							" * looked up using the state SHE and the record's content type.\r",
							" *\r",
							" * The resulting function will either be an error handler or a record handler.\r",
							" * The function will take whatever action is appropriate and update the state\r",
							" * for the next record.\r",
							" *\r",
							" * The states are all based on possible server record types. Note that the\r",
							" * client will never specifically expect to receive a HelloRequest or an alert\r",
							" * from the server so there is no state that reflects this. These messages may\r",
							" * occur at any time.\r",
							" *\r",
							" * There are two tables for mapping states because there is a second tier of\r",
							" * types for handshake messages. Once a record with a content type of handshake\r",
							" * is received, the handshake record handler will look up the handshake type in\r",
							" * the secondary map to get its appropriate handler.\r",
							" *\r",
							" * Valid message orders are as follows:\r",
							" *\r",
							" * =======================FULL HANDSHAKE======================\r",
							" * Client                                               Server\r",
							" *\r",
							" * ClientHello                  -------->\r",
							" *                                                 ServerHello\r",
							" *                                                Certificate*\r",
							" *                                          ServerKeyExchange*\r",
							" *                                         CertificateRequest*\r",
							" *                              <--------      ServerHelloDone\r",
							" * Certificate*\r",
							" * ClientKeyExchange\r",
							" * CertificateVerify*\r",
							" * [ChangeCipherSpec]\r",
							" * Finished                     -------->\r",
							" *                                          [ChangeCipherSpec]\r",
							" *                              <--------             Finished\r",
							" * Application Data             <------->     Application Data\r",
							" *\r",
							" * =====================SESSION RESUMPTION=====================\r",
							" * Client                                                Server\r",
							" *\r",
							" * ClientHello                   -------->\r",
							" *                                                  ServerHello\r",
							" *                                           [ChangeCipherSpec]\r",
							" *                               <--------             Finished\r",
							" * [ChangeCipherSpec]\r",
							" * Finished                      -------->\r",
							" * Application Data              <------->     Application Data\r",
							" */\r",
							"// client expect states (indicate which records are expected to be received)\r",
							"var SHE = 0; // rcv server hello\r",
							"var SCE = 1; // rcv server certificate\r",
							"var SKE = 2; // rcv server key exchange\r",
							"var SCR = 3; // rcv certificate request\r",
							"var SHD = 4; // rcv server hello done\r",
							"var SCC = 5; // rcv change cipher spec\r",
							"var SFI = 6; // rcv finished\r",
							"var SAD = 7; // rcv application data\r",
							"var SER = 8; // not expecting any messages at this point\r",
							"\r",
							"// server expect states\r",
							"var CHE = 0; // rcv client hello\r",
							"var CCE = 1; // rcv client certificate\r",
							"var CKE = 2; // rcv client key exchange\r",
							"var CCV = 3; // rcv certificate verify\r",
							"var CCC = 4; // rcv change cipher spec\r",
							"var CFI = 5; // rcv finished\r",
							"var CAD = 6; // rcv application data\r",
							"var CER = 7; // not expecting any messages at this point\r",
							"\r",
							"// map client current expect state and content type to function\r",
							"var __ = tls.handleUnexpected;\r",
							"var R0 = tls.handleChangeCipherSpec;\r",
							"var R1 = tls.handleAlert;\r",
							"var R2 = tls.handleHandshake;\r",
							"var R3 = tls.handleApplicationData;\r",
							"var R4 = tls.handleHeartbeat;\r",
							"var ctTable = [];\r",
							"ctTable[tls.ConnectionEnd.client] = [\r",
							"//      CC,AL,HS,AD,HB\r",
							"/*SHE*/[__,R1,R2,__,R4],\r",
							"/*SCE*/[__,R1,R2,__,R4],\r",
							"/*SKE*/[__,R1,R2,__,R4],\r",
							"/*SCR*/[__,R1,R2,__,R4],\r",
							"/*SHD*/[__,R1,R2,__,R4],\r",
							"/*SCC*/[R0,R1,__,__,R4],\r",
							"/*SFI*/[__,R1,R2,__,R4],\r",
							"/*SAD*/[__,R1,R2,R3,R4],\r",
							"/*SER*/[__,R1,R2,__,R4]\r",
							"];\r",
							"\r",
							"// map server current expect state and content type to function\r",
							"ctTable[tls.ConnectionEnd.server] = [\r",
							"//      CC,AL,HS,AD\r",
							"/*CHE*/[__,R1,R2,__,R4],\r",
							"/*CCE*/[__,R1,R2,__,R4],\r",
							"/*CKE*/[__,R1,R2,__,R4],\r",
							"/*CCV*/[__,R1,R2,__,R4],\r",
							"/*CCC*/[R0,R1,__,__,R4],\r",
							"/*CFI*/[__,R1,R2,__,R4],\r",
							"/*CAD*/[__,R1,R2,R3,R4],\r",
							"/*CER*/[__,R1,R2,__,R4]\r",
							"];\r",
							"\r",
							"// map client current expect state and handshake type to function\r",
							"var H0 = tls.handleHelloRequest;\r",
							"var H1 = tls.handleServerHello;\r",
							"var H2 = tls.handleCertificate;\r",
							"var H3 = tls.handleServerKeyExchange;\r",
							"var H4 = tls.handleCertificateRequest;\r",
							"var H5 = tls.handleServerHelloDone;\r",
							"var H6 = tls.handleFinished;\r",
							"var hsTable = [];\r",
							"hsTable[tls.ConnectionEnd.client] = [\r",
							"//      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI\r",
							"/*SHE*/[__,__,H1,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*SCE*/[H0,__,__,__,__,__,__,__,__,__,__,H2,H3,H4,H5,__,__,__,__,__,__],\r",
							"/*SKE*/[H0,__,__,__,__,__,__,__,__,__,__,__,H3,H4,H5,__,__,__,__,__,__],\r",
							"/*SCR*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,H4,H5,__,__,__,__,__,__],\r",
							"/*SHD*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,H5,__,__,__,__,__,__],\r",
							"/*SCC*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*SFI*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H6],\r",
							"/*SAD*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*SER*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__]\r",
							"];\r",
							"\r",
							"// map server current expect state and handshake type to function\r",
							"// Note: CAD[CH] does not map to FB because renegotation is prohibited\r",
							"var H7 = tls.handleClientHello;\r",
							"var H8 = tls.handleClientKeyExchange;\r",
							"var H9 = tls.handleCertificateVerify;\r",
							"hsTable[tls.ConnectionEnd.server] = [\r",
							"//      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI\r",
							"/*CHE*/[__,H7,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*CCE*/[__,__,__,__,__,__,__,__,__,__,__,H2,__,__,__,__,__,__,__,__,__],\r",
							"/*CKE*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H8,__,__,__,__],\r",
							"/*CCV*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H9,__,__,__,__,__],\r",
							"/*CCC*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*CFI*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H6],\r",
							"/*CAD*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*CER*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__]\r",
							"];\r",
							"\r",
							"/**\r",
							" * Generates the master_secret and keys using the given security parameters.\r",
							" *\r",
							" * The security parameters for a TLS connection state are defined as such:\r",
							" *\r",
							" * struct {\r",
							" *   ConnectionEnd          entity;\r",
							" *   PRFAlgorithm           prf_algorithm;\r",
							" *   BulkCipherAlgorithm    bulk_cipher_algorithm;\r",
							" *   CipherType             cipher_type;\r",
							" *   uint8                  enc_key_length;\r",
							" *   uint8                  block_length;\r",
							" *   uint8                  fixed_iv_length;\r",
							" *   uint8                  record_iv_length;\r",
							" *   MACAlgorithm           mac_algorithm;\r",
							" *   uint8                  mac_length;\r",
							" *   uint8                  mac_key_length;\r",
							" *   CompressionMethod      compression_algorithm;\r",
							" *   opaque                 master_secret[48];\r",
							" *   opaque                 client_random[32];\r",
							" *   opaque                 server_random[32];\r",
							" * } SecurityParameters;\r",
							" *\r",
							" * Note that this definition is from TLS 1.2. In TLS 1.0 some of these\r",
							" * parameters are ignored because, for instance, the PRFAlgorithm is a\r",
							" * builtin-fixed algorithm combining iterations of MD5 and SHA-1 in TLS 1.0.\r",
							" *\r",
							" * The Record Protocol requires an algorithm to generate keys required by the\r",
							" * current connection state.\r",
							" *\r",
							" * The master secret is expanded into a sequence of secure bytes, which is then\r",
							" * split to a client write MAC key, a server write MAC key, a client write\r",
							" * encryption key, and a server write encryption key. In TLS 1.0 a client write\r",
							" * IV and server write IV are also generated. Each of these is generated from\r",
							" * the byte sequence in that order. Unused values are empty. In TLS 1.2, some\r",
							" * AEAD ciphers may additionally require a client write IV and a server write\r",
							" * IV (see Section 6.2.3.3).\r",
							" *\r",
							" * When keys, MAC keys, and IVs are generated, the master secret is used as an\r",
							" * entropy source.\r",
							" *\r",
							" * To generate the key material, compute:\r",
							" *\r",
							" * master_secret = PRF(pre_master_secret, \"master secret\",\r",
							" *                     ClientHello.random + ServerHello.random)\r",
							" *\r",
							" * key_block = PRF(SecurityParameters.master_secret,\r",
							" *                 \"key expansion\",\r",
							" *                 SecurityParameters.server_random +\r",
							" *                 SecurityParameters.client_random);\r",
							" *\r",
							" * until enough output has been generated. Then, the key_block is\r",
							" * partitioned as follows:\r",
							" *\r",
							" * client_write_MAC_key[SecurityParameters.mac_key_length]\r",
							" * server_write_MAC_key[SecurityParameters.mac_key_length]\r",
							" * client_write_key[SecurityParameters.enc_key_length]\r",
							" * server_write_key[SecurityParameters.enc_key_length]\r",
							" * client_write_IV[SecurityParameters.fixed_iv_length]\r",
							" * server_write_IV[SecurityParameters.fixed_iv_length]\r",
							" *\r",
							" * In TLS 1.2, the client_write_IV and server_write_IV are only generated for\r",
							" * implicit nonce techniques as described in Section 3.2.1 of [AEAD]. This\r",
							" * implementation uses TLS 1.0 so IVs are generated.\r",
							" *\r",
							" * Implementation note: The currently defined cipher suite which requires the\r",
							" * most material is AES_256_CBC_SHA256. It requires 2 x 32 byte keys and 2 x 32\r",
							" * byte MAC keys, for a total 128 bytes of key material. In TLS 1.0 it also\r",
							" * requires 2 x 16 byte IVs, so it actually takes 160 bytes of key material.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param sp the security parameters to use.\r",
							" *\r",
							" * @return the security keys.\r",
							" */\r",
							"tls.generateKeys = function(c, sp) {\r",
							"  // TLS_RSA_WITH_AES_128_CBC_SHA (required to be compliant with TLS 1.2) &\r",
							"  // TLS_RSA_WITH_AES_256_CBC_SHA are the only cipher suites implemented\r",
							"  // at present\r",
							"\r",
							"  // TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA is required to be compliant with\r",
							"  // TLS 1.0 but we don't care right now because AES is better and we have\r",
							"  // an implementation for it\r",
							"\r",
							"  // TODO: TLS 1.2 implementation\r",
							"  /*\r",
							"  // determine the PRF\r",
							"  var prf;\r",
							"  switch(sp.prf_algorithm) {\r",
							"  case tls.PRFAlgorithm.tls_prf_sha256:\r",
							"    prf = prf_sha256;\r",
							"    break;\r",
							"  default:\r",
							"    // should never happen\r",
							"    throw new Error('Invalid PRF');\r",
							"  }\r",
							"  */\r",
							"\r",
							"  // TLS 1.0/1.1 implementation\r",
							"  var prf = prf_TLS1;\r",
							"\r",
							"  // concatenate server and client random\r",
							"  var random = sp.client_random + sp.server_random;\r",
							"\r",
							"  // only create master secret if session is new\r",
							"  if(!c.session.resuming) {\r",
							"    // create master secret, clean up pre-master secret\r",
							"    sp.master_secret = prf(\r",
							"      sp.pre_master_secret, 'master secret', random, 48).bytes();\r",
							"    sp.pre_master_secret = null;\r",
							"  }\r",
							"\r",
							"  // generate the amount of key material needed\r",
							"  random = sp.server_random + sp.client_random;\r",
							"  var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;\r",
							"\r",
							"  // include IV for TLS/1.0\r",
							"  var tls10 = (c.version.major === tls.Versions.TLS_1_0.major &&\r",
							"    c.version.minor === tls.Versions.TLS_1_0.minor);\r",
							"  if(tls10) {\r",
							"    length += 2 * sp.fixed_iv_length;\r",
							"  }\r",
							"  var km = prf(sp.master_secret, 'key expansion', random, length);\r",
							"\r",
							"  // split the key material into the MAC and encryption keys\r",
							"  var rval = {\r",
							"    client_write_MAC_key: km.getBytes(sp.mac_key_length),\r",
							"    server_write_MAC_key: km.getBytes(sp.mac_key_length),\r",
							"    client_write_key: km.getBytes(sp.enc_key_length),\r",
							"    server_write_key: km.getBytes(sp.enc_key_length)\r",
							"  };\r",
							"\r",
							"  // include TLS 1.0 IVs\r",
							"  if(tls10) {\r",
							"    rval.client_write_IV = km.getBytes(sp.fixed_iv_length);\r",
							"    rval.server_write_IV = km.getBytes(sp.fixed_iv_length);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new initialized TLS connection state. A connection state has\r",
							" * a read mode and a write mode.\r",
							" *\r",
							" * compression state:\r",
							" *   The current state of the compression algorithm.\r",
							" *\r",
							" * cipher state:\r",
							" *   The current state of the encryption algorithm. This will consist of the\r",
							" *   scheduled key for that connection. For stream ciphers, this will also\r",
							" *   contain whatever state information is necessary to allow the stream to\r",
							" *   continue to encrypt or decrypt data.\r",
							" *\r",
							" * MAC key:\r",
							" *   The MAC key for the connection.\r",
							" *\r",
							" * sequence number:\r",
							" *   Each connection state contains a sequence number, which is maintained\r",
							" *   separately for read and write states. The sequence number MUST be set to\r",
							" *   zero whenever a connection state is made the active state. Sequence\r",
							" *   numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do\r",
							" *   not wrap. If a TLS implementation would need to wrap a sequence number,\r",
							" *   it must renegotiate instead. A sequence number is incremented after each\r",
							" *   record: specifically, the first record transmitted under a particular\r",
							" *   connection state MUST use sequence number 0.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the new initialized TLS connection state.\r",
							" */\r",
							"tls.createConnectionState = function(c) {\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"\r",
							"  var createMode = function() {\r",
							"    var mode = {\r",
							"      // two 32-bit numbers, first is most significant\r",
							"      sequenceNumber: [0, 0],\r",
							"      macKey: null,\r",
							"      macLength: 0,\r",
							"      macFunction: null,\r",
							"      cipherState: null,\r",
							"      cipherFunction: function(record) {return true;},\r",
							"      compressionState: null,\r",
							"      compressFunction: function(record) {return true;},\r",
							"      updateSequenceNumber: function() {\r",
							"        if(mode.sequenceNumber[1] === 0xFFFFFFFF) {\r",
							"          mode.sequenceNumber[1] = 0;\r",
							"          ++mode.sequenceNumber[0];\r",
							"        } else {\r",
							"          ++mode.sequenceNumber[1];\r",
							"        }\r",
							"      }\r",
							"    };\r",
							"    return mode;\r",
							"  };\r",
							"  var state = {\r",
							"    read: createMode(),\r",
							"    write: createMode()\r",
							"  };\r",
							"\r",
							"  // update function in read mode will decrypt then decompress a record\r",
							"  state.read.update = function(c, record) {\r",
							"    if(!state.read.cipherFunction(record, state.read)) {\r",
							"      c.error(c, {\r",
							"        message: 'Could not decrypt record or bad MAC.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          // doesn't matter if decryption failed or MAC was\r",
							"          // invalid, return the same error so as not to reveal\r",
							"          // which one occurred\r",
							"          description: tls.Alert.Description.bad_record_mac\r",
							"        }\r",
							"      });\r",
							"    } else if(!state.read.compressFunction(c, record, state.read)) {\r",
							"      c.error(c, {\r",
							"        message: 'Could not decompress record.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.decompression_failure\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"    return !c.fail;\r",
							"  };\r",
							"\r",
							"  // update function in write mode will compress then encrypt a record\r",
							"  state.write.update = function(c, record) {\r",
							"    if(!state.write.compressFunction(c, record, state.write)) {\r",
							"      // error, but do not send alert since it would require\r",
							"      // compression as well\r",
							"      c.error(c, {\r",
							"        message: 'Could not compress record.',\r",
							"        send: false,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    } else if(!state.write.cipherFunction(record, state.write)) {\r",
							"      // error, but do not send alert since it would require\r",
							"      // encryption as well\r",
							"      c.error(c, {\r",
							"        message: 'Could not encrypt record.',\r",
							"        send: false,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"    return !c.fail;\r",
							"  };\r",
							"\r",
							"  // handle security parameters\r",
							"  if(c.session) {\r",
							"    var sp = c.session.sp;\r",
							"    c.session.cipherSuite.initSecurityParameters(sp);\r",
							"\r",
							"    // generate keys\r",
							"    sp.keys = tls.generateKeys(c, sp);\r",
							"    state.read.macKey = client ?\r",
							"      sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;\r",
							"    state.write.macKey = client ?\r",
							"      sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;\r",
							"\r",
							"    // cipher suite setup\r",
							"    c.session.cipherSuite.initConnectionState(state, c, sp);\r",
							"\r",
							"    // compression setup\r",
							"    switch(sp.compression_algorithm) {\r",
							"    case tls.CompressionMethod.none:\r",
							"      break;\r",
							"    case tls.CompressionMethod.deflate:\r",
							"      state.read.compressFunction = inflate;\r",
							"      state.write.compressFunction = deflate;\r",
							"      break;\r",
							"    default:\r",
							"      throw new Error('Unsupported compression algorithm.');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return state;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a Random structure.\r",
							" *\r",
							" * struct {\r",
							" *   uint32 gmt_unix_time;\r",
							" *   opaque random_bytes[28];\r",
							" * } Random;\r",
							" *\r",
							" * gmt_unix_time:\r",
							" *   The current time and date in standard UNIX 32-bit format (seconds since\r",
							" *   the midnight starting Jan 1, 1970, UTC, ignoring leap seconds) according\r",
							" *   to the sender's internal clock. Clocks are not required to be set\r",
							" *   correctly by the basic TLS protocol; higher-level or application\r",
							" *   protocols may define additional requirements. Note that, for historical\r",
							" *   reasons, the data element is named using GMT, the predecessor of the\r",
							" *   current worldwide time base, UTC.\r",
							" * random_bytes:\r",
							" *   28 bytes generated by a secure random number generator.\r",
							" *\r",
							" * @return the Random structure as a byte array.\r",
							" */\r",
							"tls.createRandom = function() {\r",
							"  // get UTC milliseconds\r",
							"  var d = new Date();\r",
							"  var utc = +d + d.getTimezoneOffset() * 60000;\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putInt32(utc);\r",
							"  rval.putBytes(forge.random.getBytes(28));\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a TLS record with the given type and data.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param options:\r",
							" *   type: the record type.\r",
							" *   data: the plain text data in a byte buffer.\r",
							" *\r",
							" * @return the created record.\r",
							" */\r",
							"tls.createRecord = function(c, options) {\r",
							"  if(!options.data) {\r",
							"    return null;\r",
							"  }\r",
							"  var record = {\r",
							"    type: options.type,\r",
							"    version: {\r",
							"      major: c.version.major,\r",
							"      minor: c.version.minor\r",
							"    },\r",
							"    length: options.data.length(),\r",
							"    fragment: options.data\r",
							"  };\r",
							"  return record;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a TLS alert record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param alert:\r",
							" *   level: the TLS alert level.\r",
							" *   description: the TLS alert description.\r",
							" *\r",
							" * @return the created alert record.\r",
							" */\r",
							"tls.createAlert = function(c, alert) {\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putByte(alert.level);\r",
							"  b.putByte(alert.description);\r",
							"  return tls.createRecord(c, {\r",
							"    type: tls.ContentType.alert,\r",
							"    data: b\r",
							"  });\r",
							"};\r",
							"\r",
							"/* The structure of a TLS handshake message.\r",
							" *\r",
							" * struct {\r",
							" *    HandshakeType msg_type;    // handshake type\r",
							" *    uint24 length;             // bytes in message\r",
							" *    select(HandshakeType) {\r",
							" *       case hello_request:       HelloRequest;\r",
							" *       case client_hello:        ClientHello;\r",
							" *       case server_hello:        ServerHello;\r",
							" *       case certificate:         Certificate;\r",
							" *       case server_key_exchange: ServerKeyExchange;\r",
							" *       case certificate_request: CertificateRequest;\r",
							" *       case server_hello_done:   ServerHelloDone;\r",
							" *       case certificate_verify:  CertificateVerify;\r",
							" *       case client_key_exchange: ClientKeyExchange;\r",
							" *       case finished:            Finished;\r",
							" *    } body;\r",
							" * } Handshake;\r",
							" */\r",
							"\r",
							"/**\r",
							" * Creates a ClientHello message.\r",
							" *\r",
							" * opaque SessionID<0..32>;\r",
							" * enum { null(0), deflate(1), (255) } CompressionMethod;\r",
							" * uint8 CipherSuite[2];\r",
							" *\r",
							" * struct {\r",
							" *   ProtocolVersion client_version;\r",
							" *   Random random;\r",
							" *   SessionID session_id;\r",
							" *   CipherSuite cipher_suites<2..2^16-2>;\r",
							" *   CompressionMethod compression_methods<1..2^8-1>;\r",
							" *   select(extensions_present) {\r",
							" *     case false:\r",
							" *       struct {};\r",
							" *     case true:\r",
							" *       Extension extensions<0..2^16-1>;\r",
							" *   };\r",
							" * } ClientHello;\r",
							" *\r",
							" * The extension format for extended client hellos and server hellos is:\r",
							" *\r",
							" * struct {\r",
							" *   ExtensionType extension_type;\r",
							" *   opaque extension_data<0..2^16-1>;\r",
							" * } Extension;\r",
							" *\r",
							" * Here:\r",
							" *\r",
							" * - \"extension_type\" identifies the particular extension type.\r",
							" * - \"extension_data\" contains information specific to the particular\r",
							" * extension type.\r",
							" *\r",
							" * The extension types defined in this document are:\r",
							" *\r",
							" * enum {\r",
							" *   server_name(0), max_fragment_length(1),\r",
							" *   client_certificate_url(2), trusted_ca_keys(3),\r",
							" *   truncated_hmac(4), status_request(5), (65535)\r",
							" * } ExtensionType;\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ClientHello byte buffer.\r",
							" */\r",
							"tls.createClientHello = function(c) {\r",
							"  // save hello version\r",
							"  c.session.clientHelloVersion = {\r",
							"    major: c.version.major,\r",
							"    minor: c.version.minor\r",
							"  };\r",
							"\r",
							"  // create supported cipher suites\r",
							"  var cipherSuites = forge.util.createBuffer();\r",
							"  for(var i = 0; i < c.cipherSuites.length; ++i) {\r",
							"    var cs = c.cipherSuites[i];\r",
							"    cipherSuites.putByte(cs.id[0]);\r",
							"    cipherSuites.putByte(cs.id[1]);\r",
							"  }\r",
							"  var cSuites = cipherSuites.length();\r",
							"\r",
							"  // create supported compression methods, null always supported, but\r",
							"  // also support deflate if connection has inflate and deflate methods\r",
							"  var compressionMethods = forge.util.createBuffer();\r",
							"  compressionMethods.putByte(tls.CompressionMethod.none);\r",
							"  // FIXME: deflate support disabled until issues with raw deflate data\r",
							"  // without zlib headers are resolved\r",
							"  /*\r",
							"  if(c.inflate !== null && c.deflate !== null) {\r",
							"    compressionMethods.putByte(tls.CompressionMethod.deflate);\r",
							"  }\r",
							"  */\r",
							"  var cMethods = compressionMethods.length();\r",
							"\r",
							"  // create TLS SNI (server name indication) extension if virtual host\r",
							"  // has been specified, see RFC 3546\r",
							"  var extensions = forge.util.createBuffer();\r",
							"  if(c.virtualHost) {\r",
							"    // create extension struct\r",
							"    var ext = forge.util.createBuffer();\r",
							"    ext.putByte(0x00); // type server_name (ExtensionType is 2 bytes)\r",
							"    ext.putByte(0x00);\r",
							"\r",
							"    /* In order to provide the server name, clients MAY include an\r",
							"     * extension of type \"server_name\" in the (extended) client hello.\r",
							"     * The \"extension_data\" field of this extension SHALL contain\r",
							"     * \"ServerNameList\" where:\r",
							"     *\r",
							"     * struct {\r",
							"     *   NameType name_type;\r",
							"     *   select(name_type) {\r",
							"     *     case host_name: HostName;\r",
							"     *   } name;\r",
							"     * } ServerName;\r",
							"     *\r",
							"     * enum {\r",
							"     *   host_name(0), (255)\r",
							"     * } NameType;\r",
							"     *\r",
							"     * opaque HostName<1..2^16-1>;\r",
							"     *\r",
							"     * struct {\r",
							"     *   ServerName server_name_list<1..2^16-1>\r",
							"     * } ServerNameList;\r",
							"     */\r",
							"    var serverName = forge.util.createBuffer();\r",
							"    serverName.putByte(0x00); // type host_name\r",
							"    writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));\r",
							"\r",
							"    // ServerNameList is in extension_data\r",
							"    var snList = forge.util.createBuffer();\r",
							"    writeVector(snList, 2, serverName);\r",
							"    writeVector(ext, 2, snList);\r",
							"    extensions.putBuffer(ext);\r",
							"  }\r",
							"  var extLength = extensions.length();\r",
							"  if(extLength > 0) {\r",
							"    // add extension vector length\r",
							"    extLength += 2;\r",
							"  }\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  // cipher suites and compression methods size will need to be\r",
							"  // updated if more get added to the list\r",
							"  var sessionId = c.session.id;\r",
							"  var length =\r",
							"    sessionId.length + 1 + // session ID vector\r",
							"    2 +                    // version (major + minor)\r",
							"    4 + 28 +               // random time and random bytes\r",
							"    2 + cSuites +          // cipher suites vector\r",
							"    1 + cMethods +         // compression methods vector\r",
							"    extLength;             // extensions vector\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.client_hello);\r",
							"  rval.putInt24(length);                     // handshake length\r",
							"  rval.putByte(c.version.major);             // major version\r",
							"  rval.putByte(c.version.minor);             // minor version\r",
							"  rval.putBytes(c.session.sp.client_random); // random time + bytes\r",
							"  writeVector(rval, 1, forge.util.createBuffer(sessionId));\r",
							"  writeVector(rval, 2, cipherSuites);\r",
							"  writeVector(rval, 1, compressionMethods);\r",
							"  if(extLength > 0) {\r",
							"    writeVector(rval, 2, extensions);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ServerHello message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ServerHello byte buffer.\r",
							" */\r",
							"tls.createServerHello = function(c) {\r",
							"  // determine length of the handshake message\r",
							"  var sessionId = c.session.id;\r",
							"  var length =\r",
							"    sessionId.length + 1 + // session ID vector\r",
							"    2 +                    // version (major + minor)\r",
							"    4 + 28 +               // random time and random bytes\r",
							"    2 +                    // chosen cipher suite\r",
							"    1;                     // chosen compression method\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.server_hello);\r",
							"  rval.putInt24(length);                     // handshake length\r",
							"  rval.putByte(c.version.major);             // major version\r",
							"  rval.putByte(c.version.minor);             // minor version\r",
							"  rval.putBytes(c.session.sp.server_random); // random time + bytes\r",
							"  writeVector(rval, 1, forge.util.createBuffer(sessionId));\r",
							"  rval.putByte(c.session.cipherSuite.id[0]);\r",
							"  rval.putByte(c.session.cipherSuite.id[1]);\r",
							"  rval.putByte(c.session.compressionMethod);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a Certificate message.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This is the first message the client can send after receiving a server\r",
							" *   hello done message and the first message the server can send after\r",
							" *   sending a ServerHello. This client message is only sent if the server\r",
							" *   requests a certificate. If no suitable certificate is available, the\r",
							" *   client should send a certificate message containing no certificates. If\r",
							" *   client authentication is required by the server for the handshake to\r",
							" *   continue, it may respond with a fatal handshake failure alert.\r",
							" *\r",
							" * opaque ASN.1Cert<1..2^24-1>;\r",
							" *\r",
							" * struct {\r",
							" *   ASN.1Cert certificate_list<0..2^24-1>;\r",
							" * } Certificate;\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the Certificate byte buffer.\r",
							" */\r",
							"tls.createCertificate = function(c) {\r",
							"  // TODO: check certificate request to ensure types are supported\r",
							"\r",
							"  // get a certificate (a certificate as a PEM string)\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var cert = null;\r",
							"  if(c.getCertificate) {\r",
							"    var hint;\r",
							"    if(client) {\r",
							"      hint = c.session.certificateRequest;\r",
							"    } else {\r",
							"      hint = c.session.extensions.server_name.serverNameList;\r",
							"    }\r",
							"    cert = c.getCertificate(c, hint);\r",
							"  }\r",
							"\r",
							"  // buffer to hold certificate list\r",
							"  var certList = forge.util.createBuffer();\r",
							"  if(cert !== null) {\r",
							"    try {\r",
							"      // normalize cert to a chain of certificates\r",
							"      if(!forge.util.isArray(cert)) {\r",
							"        cert = [cert];\r",
							"      }\r",
							"      var asn1 = null;\r",
							"      for(var i = 0; i < cert.length; ++i) {\r",
							"        var msg = forge.pem.decode(cert[i])[0];\r",
							"        if(msg.type !== 'CERTIFICATE' &&\r",
							"          msg.type !== 'X509 CERTIFICATE' &&\r",
							"          msg.type !== 'TRUSTED CERTIFICATE') {\r",
							"          var error = new Error('Could not convert certificate from PEM; PEM ' +\r",
							"            'header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or ' +\r",
							"            '\"TRUSTED CERTIFICATE\".');\r",
							"          error.headerType = msg.type;\r",
							"          throw error;\r",
							"        }\r",
							"        if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"          throw new Error('Could not convert certificate from PEM; PEM is encrypted.');\r",
							"        }\r",
							"\r",
							"        var der = forge.util.createBuffer(msg.body);\r",
							"        if(asn1 === null) {\r",
							"          asn1 = forge.asn1.fromDer(der.bytes(), false);\r",
							"        }\r",
							"\r",
							"        // certificate entry is itself a vector with 3 length bytes\r",
							"        var certBuffer = forge.util.createBuffer();\r",
							"        writeVector(certBuffer, 3, der);\r",
							"\r",
							"        // add cert vector to cert list vector\r",
							"        certList.putBuffer(certBuffer);\r",
							"      }\r",
							"\r",
							"      // save certificate\r",
							"      cert = forge.pki.certificateFromAsn1(asn1);\r",
							"      if(client) {\r",
							"        c.session.clientCertificate = cert;\r",
							"      } else {\r",
							"        c.session.serverCertificate = cert;\r",
							"      }\r",
							"    } catch(ex) {\r",
							"      return c.error(c, {\r",
							"        message: 'Could not send certificate list.',\r",
							"        cause: ex,\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.bad_certificate\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = 3 + certList.length(); // cert list vector\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.certificate);\r",
							"  rval.putInt24(length);\r",
							"  writeVector(rval, 3, certList);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ClientKeyExchange message.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This message is always sent by the client. It will immediately follow the\r",
							" *   client certificate message, if it is sent. Otherwise it will be the first\r",
							" *   message sent by the client after it receives the server hello done\r",
							" *   message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   With this message, the premaster secret is set, either though direct\r",
							" *   transmission of the RSA-encrypted secret, or by the transmission of\r",
							" *   Diffie-Hellman parameters which will allow each side to agree upon the\r",
							" *   same premaster secret. When the key exchange method is DH_RSA or DH_DSS,\r",
							" *   client certification has been requested, and the client was able to\r",
							" *   respond with a certificate which contained a Diffie-Hellman public key\r",
							" *   whose parameters (group and generator) matched those specified by the\r",
							" *   server in its certificate, this message will not contain any data.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   If RSA is being used for key agreement and authentication, the client\r",
							" *   generates a 48-byte premaster secret, encrypts it using the public key\r",
							" *   from the server's certificate or the temporary RSA key provided in a\r",
							" *   server key exchange message, and sends the result in an encrypted\r",
							" *   premaster secret message. This structure is a variant of the client\r",
							" *   key exchange message, not a message in itself.\r",
							" *\r",
							" * struct {\r",
							" *   select(KeyExchangeAlgorithm) {\r",
							" *     case rsa: EncryptedPreMasterSecret;\r",
							" *     case diffie_hellman: ClientDiffieHellmanPublic;\r",
							" *   } exchange_keys;\r",
							" * } ClientKeyExchange;\r",
							" *\r",
							" * struct {\r",
							" *   ProtocolVersion client_version;\r",
							" *   opaque random[46];\r",
							" * } PreMasterSecret;\r",
							" *\r",
							" * struct {\r",
							" *   public-key-encrypted PreMasterSecret pre_master_secret;\r",
							" * } EncryptedPreMasterSecret;\r",
							" *\r",
							" * A public-key-encrypted element is encoded as a vector <0..2^16-1>.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ClientKeyExchange byte buffer.\r",
							" */\r",
							"tls.createClientKeyExchange = function(c) {\r",
							"  // create buffer to encrypt\r",
							"  var b = forge.util.createBuffer();\r",
							"\r",
							"  // add highest client-supported protocol to help server avoid version\r",
							"  // rollback attacks\r",
							"  b.putByte(c.session.clientHelloVersion.major);\r",
							"  b.putByte(c.session.clientHelloVersion.minor);\r",
							"\r",
							"  // generate and add 46 random bytes\r",
							"  b.putBytes(forge.random.getBytes(46));\r",
							"\r",
							"  // save pre-master secret\r",
							"  var sp = c.session.sp;\r",
							"  sp.pre_master_secret = b.getBytes();\r",
							"\r",
							"  // RSA-encrypt the pre-master secret\r",
							"  var key = c.session.serverCertificate.publicKey;\r",
							"  b = key.encrypt(sp.pre_master_secret);\r",
							"\r",
							"  /* Note: The encrypted pre-master secret will be stored in a\r",
							"    public-key-encrypted opaque vector that has the length prefixed using\r",
							"    2 bytes, so include those 2 bytes in the handshake message length. This\r",
							"    is done as a minor optimization instead of calling writeVector(). */\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = b.length + 2;\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.client_key_exchange);\r",
							"  rval.putInt24(length);\r",
							"  // add vector length bytes\r",
							"  rval.putInt16(b.length);\r",
							"  rval.putBytes(b);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ServerKeyExchange message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ServerKeyExchange byte buffer.\r",
							" */\r",
							"tls.createServerKeyExchange = function(c) {\r",
							"  // this implementation only supports RSA, no Diffie-Hellman support,\r",
							"  // so this record is empty\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = 0;\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  if(length > 0) {\r",
							"    rval.putByte(tls.HandshakeType.server_key_exchange);\r",
							"    rval.putInt24(length);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the signed data used to verify a client-side certificate. See\r",
							" * tls.createCertificateVerify() for details.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param callback the callback to call once the signed data is ready.\r",
							" */\r",
							"tls.getClientSignature = function(c, callback) {\r",
							"  // generate data to RSA encrypt\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putBuffer(c.session.md5.digest());\r",
							"  b.putBuffer(c.session.sha1.digest());\r",
							"  b = b.getBytes();\r",
							"\r",
							"  // create default signing function as necessary\r",
							"  c.getSignature = c.getSignature || function(c, b, callback) {\r",
							"    // do rsa encryption, call callback\r",
							"    var privateKey = null;\r",
							"    if(c.getPrivateKey) {\r",
							"      try {\r",
							"        privateKey = c.getPrivateKey(c, c.session.clientCertificate);\r",
							"        privateKey = forge.pki.privateKeyFromPem(privateKey);\r",
							"      } catch(ex) {\r",
							"        c.error(c, {\r",
							"          message: 'Could not get private key.',\r",
							"          cause: ex,\r",
							"          send: true,\r",
							"          alert: {\r",
							"            level: tls.Alert.Level.fatal,\r",
							"            description: tls.Alert.Description.internal_error\r",
							"          }\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"    if(privateKey === null) {\r",
							"      c.error(c, {\r",
							"        message: 'No private key set.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    } else {\r",
							"      b = privateKey.sign(b, null);\r",
							"    }\r",
							"    callback(c, b);\r",
							"  };\r",
							"\r",
							"  // get client signature\r",
							"  c.getSignature(c, b, callback);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a CertificateVerify message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   This structure conveys the client's Diffie-Hellman public value\r",
							" *   (Yc) if it was not already included in the client's certificate.\r",
							" *   The encoding used for Yc is determined by the enumerated\r",
							" *   PublicValueEncoding. This structure is a variant of the client\r",
							" *   key exchange message, not a message in itself.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This message is used to provide explicit verification of a client\r",
							" *   certificate. This message is only sent following a client\r",
							" *   certificate that has signing capability (i.e. all certificates\r",
							" *   except those containing fixed Diffie-Hellman parameters). When\r",
							" *   sent, it will immediately follow the client key exchange message.\r",
							" *\r",
							" * struct {\r",
							" *   Signature signature;\r",
							" * } CertificateVerify;\r",
							" *\r",
							" * CertificateVerify.signature.md5_hash\r",
							" *   MD5(handshake_messages);\r",
							" *\r",
							" * Certificate.signature.sha_hash\r",
							" *   SHA(handshake_messages);\r",
							" *\r",
							" * Here handshake_messages refers to all handshake messages sent or\r",
							" * received starting at client hello up to but not including this\r",
							" * message, including the type and length fields of the handshake\r",
							" * messages.\r",
							" *\r",
							" * select(SignatureAlgorithm) {\r",
							" *   case anonymous: struct { };\r",
							" *   case rsa:\r",
							" *     digitally-signed struct {\r",
							" *       opaque md5_hash[16];\r",
							" *       opaque sha_hash[20];\r",
							" *     };\r",
							" *   case dsa:\r",
							" *     digitally-signed struct {\r",
							" *       opaque sha_hash[20];\r",
							" *     };\r",
							" * } Signature;\r",
							" *\r",
							" * In digital signing, one-way hash functions are used as input for a\r",
							" * signing algorithm. A digitally-signed element is encoded as an opaque\r",
							" * vector <0..2^16-1>, where the length is specified by the signing\r",
							" * algorithm and key.\r",
							" *\r",
							" * In RSA signing, a 36-byte structure of two hashes (one SHA and one\r",
							" * MD5) is signed (encrypted with the private key). It is encoded with\r",
							" * PKCS #1 block type 0 or type 1 as described in [PKCS1].\r",
							" *\r",
							" * In DSS, the 20 bytes of the SHA hash are run directly through the\r",
							" * Digital Signing Algorithm with no additional hashing.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param signature the signature to include in the message.\r",
							" *\r",
							" * @return the CertificateVerify byte buffer.\r",
							" */\r",
							"tls.createCertificateVerify = function(c, signature) {\r",
							"  /* Note: The signature will be stored in a \"digitally-signed\" opaque\r",
							"    vector that has the length prefixed using 2 bytes, so include those\r",
							"    2 bytes in the handshake message length. This is done as a minor\r",
							"    optimization instead of calling writeVector(). */\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = signature.length + 2;\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.certificate_verify);\r",
							"  rval.putInt24(length);\r",
							"  // add vector length bytes\r",
							"  rval.putInt16(signature.length);\r",
							"  rval.putBytes(signature);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a CertificateRequest message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the CertificateRequest byte buffer.\r",
							" */\r",
							"tls.createCertificateRequest = function(c) {\r",
							"  // TODO: support other certificate types\r",
							"  var certTypes = forge.util.createBuffer();\r",
							"\r",
							"  // common RSA certificate type\r",
							"  certTypes.putByte(0x01);\r",
							"\r",
							"  // add distinguished names from CA store\r",
							"  var cAs = forge.util.createBuffer();\r",
							"  for(var key in c.caStore.certs) {\r",
							"    var cert = c.caStore.certs[key];\r",
							"    var dn = forge.pki.distinguishedNameToAsn1(cert.subject);\r",
							"    var byteBuffer = forge.asn1.toDer(dn);\r",
							"    cAs.putInt16(byteBuffer.length());\r",
							"    cAs.putBuffer(byteBuffer);\r",
							"  }\r",
							"\r",
							"  // TODO: TLS 1.2+ has a different format\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length =\r",
							"    1 + certTypes.length() +\r",
							"    2 + cAs.length();\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.certificate_request);\r",
							"  rval.putInt24(length);\r",
							"  writeVector(rval, 1, certTypes);\r",
							"  writeVector(rval, 2, cAs);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ServerHelloDone message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ServerHelloDone byte buffer.\r",
							" */\r",
							"tls.createServerHelloDone = function(c) {\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.server_hello_done);\r",
							"  rval.putInt24(0);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ChangeCipherSpec message.\r",
							" *\r",
							" * The change cipher spec protocol exists to signal transitions in\r",
							" * ciphering strategies. The protocol consists of a single message,\r",
							" * which is encrypted and compressed under the current (not the pending)\r",
							" * connection state. The message consists of a single byte of value 1.\r",
							" *\r",
							" * struct {\r",
							" *   enum { change_cipher_spec(1), (255) } type;\r",
							" * } ChangeCipherSpec;\r",
							" *\r",
							" * @return the ChangeCipherSpec byte buffer.\r",
							" */\r",
							"tls.createChangeCipherSpec = function() {\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(0x01);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a Finished message.\r",
							" *\r",
							" * struct {\r",
							" *   opaque verify_data[12];\r",
							" * } Finished;\r",
							" *\r",
							" * verify_data\r",
							" *   PRF(master_secret, finished_label, MD5(handshake_messages) +\r",
							" *   SHA-1(handshake_messages)) [0..11];\r",
							" *\r",
							" * finished_label\r",
							" *   For Finished messages sent by the client, the string \"client\r",
							" *   finished\". For Finished messages sent by the server, the\r",
							" *   string \"server finished\".\r",
							" *\r",
							" * handshake_messages\r",
							" *   All of the data from all handshake messages up to but not\r",
							" *   including this message. This is only data visible at the\r",
							" *   handshake layer and does not include record layer headers.\r",
							" *   This is the concatenation of all the Handshake structures as\r",
							" *   defined in 7.4 exchanged thus far.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the Finished byte buffer.\r",
							" */\r",
							"tls.createFinished = function(c) {\r",
							"  // generate verify_data\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putBuffer(c.session.md5.digest());\r",
							"  b.putBuffer(c.session.sha1.digest());\r",
							"\r",
							"  // TODO: determine prf function and verify length for TLS 1.2\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var sp = c.session.sp;\r",
							"  var vdl = 12;\r",
							"  var prf = prf_TLS1;\r",
							"  var label = client ? 'client finished' : 'server finished';\r",
							"  b = prf(sp.master_secret, label, b.getBytes(), vdl);\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.finished);\r",
							"  rval.putInt24(b.length());\r",
							"  rval.putBuffer(b);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a HeartbeatMessage (See RFC 6520).\r",
							" *\r",
							" * struct {\r",
							" *   HeartbeatMessageType type;\r",
							" *   uint16 payload_length;\r",
							" *   opaque payload[HeartbeatMessage.payload_length];\r",
							" *   opaque padding[padding_length];\r",
							" * } HeartbeatMessage;\r",
							" *\r",
							" * The total length of a HeartbeatMessage MUST NOT exceed 2^14 or\r",
							" * max_fragment_length when negotiated as defined in [RFC6066].\r",
							" *\r",
							" * type: The message type, either heartbeat_request or heartbeat_response.\r",
							" *\r",
							" * payload_length: The length of the payload.\r",
							" *\r",
							" * payload: The payload consists of arbitrary content.\r",
							" *\r",
							" * padding: The padding is random content that MUST be ignored by the\r",
							" *   receiver. The length of a HeartbeatMessage is TLSPlaintext.length\r",
							" *   for TLS and DTLSPlaintext.length for DTLS. Furthermore, the\r",
							" *   length of the type field is 1 byte, and the length of the\r",
							" *   payload_length is 2. Therefore, the padding_length is\r",
							" *   TLSPlaintext.length - payload_length - 3 for TLS and\r",
							" *   DTLSPlaintext.length - payload_length - 3 for DTLS. The\r",
							" *   padding_length MUST be at least 16.\r",
							" *\r",
							" * The sender of a HeartbeatMessage MUST use a random padding of at\r",
							" * least 16 bytes. The padding of a received HeartbeatMessage message\r",
							" * MUST be ignored.\r",
							" *\r",
							" * If the payload_length of a received HeartbeatMessage is too large,\r",
							" * the received HeartbeatMessage MUST be discarded silently.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param type the tls.HeartbeatMessageType.\r",
							" * @param payload the heartbeat data to send as the payload.\r",
							" * @param [payloadLength] the payload length to use, defaults to the\r",
							" *          actual payload length.\r",
							" *\r",
							" * @return the HeartbeatRequest byte buffer.\r",
							" */\r",
							"tls.createHeartbeat = function(type, payload, payloadLength) {\r",
							"  if(typeof payloadLength === 'undefined') {\r",
							"    payloadLength = payload.length;\r",
							"  }\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(type);               // heartbeat message type\r",
							"  rval.putInt16(payloadLength);     // payload length\r",
							"  rval.putBytes(payload);           // payload\r",
							"  // padding\r",
							"  var plaintextLength = rval.length();\r",
							"  var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);\r",
							"  rval.putBytes(forge.random.getBytes(paddingLength));\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Fragments, compresses, encrypts, and queues a record for delivery.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record to queue.\r",
							" */\r",
							"tls.queue = function(c, record) {\r",
							"  // error during record creation\r",
							"  if(!record) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  if(record.fragment.length() === 0) {\r",
							"    if(record.type === tls.ContentType.handshake ||\r",
							"      record.type === tls.ContentType.alert ||\r",
							"      record.type === tls.ContentType.change_cipher_spec) {\r",
							"      // Empty handshake, alert of change cipher spec messages are not allowed per the TLS specification and should not be sent.\r",
							"      return;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // if the record is a handshake record, update handshake hashes\r",
							"  if(record.type === tls.ContentType.handshake) {\r",
							"    var bytes = record.fragment.bytes();\r",
							"    c.session.md5.update(bytes);\r",
							"    c.session.sha1.update(bytes);\r",
							"    bytes = null;\r",
							"  }\r",
							"\r",
							"  // handle record fragmentation\r",
							"  var records;\r",
							"  if(record.fragment.length() <= tls.MaxFragment) {\r",
							"    records = [record];\r",
							"  } else {\r",
							"    // fragment data as long as it is too long\r",
							"    records = [];\r",
							"    var data = record.fragment.bytes();\r",
							"    while(data.length > tls.MaxFragment) {\r",
							"      records.push(tls.createRecord(c, {\r",
							"        type: record.type,\r",
							"        data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))\r",
							"      }));\r",
							"      data = data.slice(tls.MaxFragment);\r",
							"    }\r",
							"    // add last record\r",
							"    if(data.length > 0) {\r",
							"      records.push(tls.createRecord(c, {\r",
							"        type: record.type,\r",
							"        data: forge.util.createBuffer(data)\r",
							"      }));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // compress and encrypt all fragmented records\r",
							"  for(var i = 0; i < records.length && !c.fail; ++i) {\r",
							"    // update the record using current write state\r",
							"    var rec = records[i];\r",
							"    var s = c.state.current.write;\r",
							"    if(s.update(c, rec)) {\r",
							"      // store record\r",
							"      c.records.push(rec);\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Flushes all queued records to the output buffer and calls the\r",
							" * tlsDataReady() handler on the given connection.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"tls.flush = function(c) {\r",
							"  for(var i = 0; i < c.records.length; ++i) {\r",
							"    var record = c.records[i];\r",
							"\r",
							"    // add record header and fragment\r",
							"    c.tlsData.putByte(record.type);\r",
							"    c.tlsData.putByte(record.version.major);\r",
							"    c.tlsData.putByte(record.version.minor);\r",
							"    c.tlsData.putInt16(record.fragment.length());\r",
							"    c.tlsData.putBuffer(c.records[i].fragment);\r",
							"  }\r",
							"  c.records = [];\r",
							"  return c.tlsDataReady(c);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Maps a pki.certificateError to a tls.Alert.Description.\r",
							" *\r",
							" * @param error the error to map.\r",
							" *\r",
							" * @return the alert description.\r",
							" */\r",
							"var _certErrorToAlertDesc = function(error) {\r",
							"  switch(error) {\r",
							"  case true:\r",
							"    return true;\r",
							"  case forge.pki.certificateError.bad_certificate:\r",
							"    return tls.Alert.Description.bad_certificate;\r",
							"  case forge.pki.certificateError.unsupported_certificate:\r",
							"    return tls.Alert.Description.unsupported_certificate;\r",
							"  case forge.pki.certificateError.certificate_revoked:\r",
							"    return tls.Alert.Description.certificate_revoked;\r",
							"  case forge.pki.certificateError.certificate_expired:\r",
							"    return tls.Alert.Description.certificate_expired;\r",
							"  case forge.pki.certificateError.certificate_unknown:\r",
							"    return tls.Alert.Description.certificate_unknown;\r",
							"  case forge.pki.certificateError.unknown_ca:\r",
							"    return tls.Alert.Description.unknown_ca;\r",
							"  default:\r",
							"    return tls.Alert.Description.bad_certificate;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Maps a tls.Alert.Description to a pki.certificateError.\r",
							" *\r",
							" * @param desc the alert description.\r",
							" *\r",
							" * @return the certificate error.\r",
							" */\r",
							"var _alertDescToCertError = function(desc) {\r",
							"  switch(desc) {\r",
							"  case true:\r",
							"    return true;\r",
							"  case tls.Alert.Description.bad_certificate:\r",
							"    return forge.pki.certificateError.bad_certificate;\r",
							"  case tls.Alert.Description.unsupported_certificate:\r",
							"    return forge.pki.certificateError.unsupported_certificate;\r",
							"  case tls.Alert.Description.certificate_revoked:\r",
							"    return forge.pki.certificateError.certificate_revoked;\r",
							"  case tls.Alert.Description.certificate_expired:\r",
							"    return forge.pki.certificateError.certificate_expired;\r",
							"  case tls.Alert.Description.certificate_unknown:\r",
							"    return forge.pki.certificateError.certificate_unknown;\r",
							"  case tls.Alert.Description.unknown_ca:\r",
							"    return forge.pki.certificateError.unknown_ca;\r",
							"  default:\r",
							"    return forge.pki.certificateError.bad_certificate;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Verifies a certificate chain against the given connection's\r",
							" * Certificate Authority store.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param chain the certificate chain to verify, with the root or highest\r",
							" *          authority at the end.\r",
							" *\r",
							" * @return true if successful, false if not.\r",
							" */\r",
							"tls.verifyCertificateChain = function(c, chain) {\r",
							"  try {\r",
							"    // verify chain\r",
							"    forge.pki.verifyCertificateChain(c.caStore, chain,\r",
							"      function verify(vfd, depth, chain) {\r",
							"        // convert pki.certificateError to tls alert description\r",
							"        var desc = _certErrorToAlertDesc(vfd);\r",
							"\r",
							"        // call application callback\r",
							"        var ret = c.verify(c, vfd, depth, chain);\r",
							"        if(ret !== true) {\r",
							"          if(typeof ret === 'object' && !forge.util.isArray(ret)) {\r",
							"            // throw custom error\r",
							"            var error = new Error('The application rejected the certificate.');\r",
							"            error.send = true;\r",
							"            error.alert = {\r",
							"              level: tls.Alert.Level.fatal,\r",
							"              description: tls.Alert.Description.bad_certificate\r",
							"            };\r",
							"            if(ret.message) {\r",
							"              error.message = ret.message;\r",
							"            }\r",
							"            if(ret.alert) {\r",
							"              error.alert.description = ret.alert;\r",
							"            }\r",
							"            throw error;\r",
							"          }\r",
							"\r",
							"          // convert tls alert description to pki.certificateError\r",
							"          if(ret !== vfd) {\r",
							"            ret = _alertDescToCertError(ret);\r",
							"          }\r",
							"        }\r",
							"\r",
							"        return ret;\r",
							"      });\r",
							"  } catch(ex) {\r",
							"    // build tls error if not already customized\r",
							"    var err = ex;\r",
							"    if(typeof err !== 'object' || forge.util.isArray(err)) {\r",
							"      err = {\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: _certErrorToAlertDesc(ex)\r",
							"        }\r",
							"      };\r",
							"    }\r",
							"    if(!('send' in err)) {\r",
							"      err.send = true;\r",
							"    }\r",
							"    if(!('alert' in err)) {\r",
							"      err.alert = {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: _certErrorToAlertDesc(err.error)\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // send error\r",
							"    c.error(c, err);\r",
							"  }\r",
							"\r",
							"  return !c.fail;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new TLS session cache.\r",
							" *\r",
							" * @param cache optional map of session ID to cached session.\r",
							" * @param capacity the maximum size for the cache (default: 100).\r",
							" *\r",
							" * @return the new TLS session cache.\r",
							" */\r",
							"tls.createSessionCache = function(cache, capacity) {\r",
							"  var rval = null;\r",
							"\r",
							"  // assume input is already a session cache object\r",
							"  if(cache && cache.getSession && cache.setSession && cache.order) {\r",
							"    rval = cache;\r",
							"  } else {\r",
							"    // create cache\r",
							"    rval = {};\r",
							"    rval.cache = cache || {};\r",
							"    rval.capacity = Math.max(capacity || 100, 1);\r",
							"    rval.order = [];\r",
							"\r",
							"    // store order for sessions, delete session overflow\r",
							"    for(var key in cache) {\r",
							"      if(rval.order.length <= capacity) {\r",
							"        rval.order.push(key);\r",
							"      } else {\r",
							"        delete cache[key];\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // get a session from a session ID (or get any session)\r",
							"    rval.getSession = function(sessionId) {\r",
							"      var session = null;\r",
							"      var key = null;\r",
							"\r",
							"      // if session ID provided, use it\r",
							"      if(sessionId) {\r",
							"        key = forge.util.bytesToHex(sessionId);\r",
							"      } else if(rval.order.length > 0) {\r",
							"        // get first session from cache\r",
							"        key = rval.order[0];\r",
							"      }\r",
							"\r",
							"      if(key !== null && key in rval.cache) {\r",
							"        // get cached session and remove from cache\r",
							"        session = rval.cache[key];\r",
							"        delete rval.cache[key];\r",
							"        for(var i in rval.order) {\r",
							"          if(rval.order[i] === key) {\r",
							"            rval.order.splice(i, 1);\r",
							"            break;\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"\r",
							"      return session;\r",
							"    };\r",
							"\r",
							"    // set a session in the cache\r",
							"    rval.setSession = function(sessionId, session) {\r",
							"      // remove session from cache if at capacity\r",
							"      if(rval.order.length === rval.capacity) {\r",
							"        var key = rval.order.shift();\r",
							"        delete rval.cache[key];\r",
							"      }\r",
							"      // add session to cache\r",
							"      var key = forge.util.bytesToHex(sessionId);\r",
							"      rval.order.push(key);\r",
							"      rval.cache[key] = session;\r",
							"    };\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new TLS connection.\r",
							" *\r",
							" * See public createConnection() docs for more details.\r",
							" *\r",
							" * @param options the options for this connection.\r",
							" *\r",
							" * @return the new TLS connection.\r",
							" */\r",
							"tls.createConnection = function(options) {\r",
							"  var caStore = null;\r",
							"  if(options.caStore) {\r",
							"    // if CA store is an array, convert it to a CA store object\r",
							"    if(forge.util.isArray(options.caStore)) {\r",
							"      caStore = forge.pki.createCaStore(options.caStore);\r",
							"    } else {\r",
							"      caStore = options.caStore;\r",
							"    }\r",
							"  } else {\r",
							"    // create empty CA store\r",
							"    caStore = forge.pki.createCaStore();\r",
							"  }\r",
							"\r",
							"  // setup default cipher suites\r",
							"  var cipherSuites = options.cipherSuites || null;\r",
							"  if(cipherSuites === null) {\r",
							"    cipherSuites = [];\r",
							"    for(var key in tls.CipherSuites) {\r",
							"      cipherSuites.push(tls.CipherSuites[key]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // set default entity\r",
							"  var entity = (options.server || false) ?\r",
							"    tls.ConnectionEnd.server : tls.ConnectionEnd.client;\r",
							"\r",
							"  // create session cache if requested\r",
							"  var sessionCache = options.sessionCache ?\r",
							"    tls.createSessionCache(options.sessionCache) : null;\r",
							"\r",
							"  // create TLS connection\r",
							"  var c = {\r",
							"    version: {major: tls.Version.major, minor: tls.Version.minor},\r",
							"    entity: entity,\r",
							"    sessionId: options.sessionId,\r",
							"    caStore: caStore,\r",
							"    sessionCache: sessionCache,\r",
							"    cipherSuites: cipherSuites,\r",
							"    connected: options.connected,\r",
							"    virtualHost: options.virtualHost || null,\r",
							"    verifyClient: options.verifyClient || false,\r",
							"    verify: options.verify || function(cn, vfd, dpth, cts) {return vfd;},\r",
							"    getCertificate: options.getCertificate || null,\r",
							"    getPrivateKey: options.getPrivateKey || null,\r",
							"    getSignature: options.getSignature || null,\r",
							"    input: forge.util.createBuffer(),\r",
							"    tlsData: forge.util.createBuffer(),\r",
							"    data: forge.util.createBuffer(),\r",
							"    tlsDataReady: options.tlsDataReady,\r",
							"    dataReady: options.dataReady,\r",
							"    heartbeatReceived: options.heartbeatReceived,\r",
							"    closed: options.closed,\r",
							"    error: function(c, ex) {\r",
							"      // set origin if not set\r",
							"      ex.origin = ex.origin ||\r",
							"        ((c.entity === tls.ConnectionEnd.client) ? 'client' : 'server');\r",
							"\r",
							"      // send TLS alert\r",
							"      if(ex.send) {\r",
							"        tls.queue(c, tls.createAlert(c, ex.alert));\r",
							"        tls.flush(c);\r",
							"      }\r",
							"\r",
							"      // error is fatal by default\r",
							"      var fatal = (ex.fatal !== false);\r",
							"      if(fatal) {\r",
							"        // set fail flag\r",
							"        c.fail = true;\r",
							"      }\r",
							"\r",
							"      // call error handler first\r",
							"      options.error(c, ex);\r",
							"\r",
							"      if(fatal) {\r",
							"        // fatal error, close connection, do not clear fail\r",
							"        c.close(false);\r",
							"      }\r",
							"    },\r",
							"    deflate: options.deflate || null,\r",
							"    inflate: options.inflate || null\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Resets a closed TLS connection for reuse. Called in c.close().\r",
							"   *\r",
							"   * @param clearFail true to clear the fail flag (default: true).\r",
							"   */\r",
							"  c.reset = function(clearFail) {\r",
							"    c.version = {major: tls.Version.major, minor: tls.Version.minor};\r",
							"    c.record = null;\r",
							"    c.session = null;\r",
							"    c.peerCertificate = null;\r",
							"    c.state = {\r",
							"      pending: null,\r",
							"      current: null\r",
							"    };\r",
							"    c.expect = (c.entity === tls.ConnectionEnd.client) ? SHE : CHE;\r",
							"    c.fragmented = null;\r",
							"    c.records = [];\r",
							"    c.open = false;\r",
							"    c.handshakes = 0;\r",
							"    c.handshaking = false;\r",
							"    c.isConnected = false;\r",
							"    c.fail = !(clearFail || typeof(clearFail) === 'undefined');\r",
							"    c.input.clear();\r",
							"    c.tlsData.clear();\r",
							"    c.data.clear();\r",
							"    c.state.current = tls.createConnectionState(c);\r",
							"  };\r",
							"\r",
							"  // do initial reset of connection\r",
							"  c.reset();\r",
							"\r",
							"  /**\r",
							"   * Updates the current TLS engine state based on the given record.\r",
							"   *\r",
							"   * @param c the TLS connection.\r",
							"   * @param record the TLS record to act on.\r",
							"   */\r",
							"  var _update = function(c, record) {\r",
							"    // get record handler (align type in table by subtracting lowest)\r",
							"    var aligned = record.type - tls.ContentType.change_cipher_spec;\r",
							"    var handlers = ctTable[c.entity][c.expect];\r",
							"    if(aligned in handlers) {\r",
							"      handlers[aligned](c, record);\r",
							"    } else {\r",
							"      // unexpected record\r",
							"      tls.handleUnexpected(c, record);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Reads the record header and initializes the next record on the given\r",
							"   * connection.\r",
							"   *\r",
							"   * @param c the TLS connection with the next record.\r",
							"   *\r",
							"   * @return 0 if the input data could be processed, otherwise the\r",
							"   *         number of bytes required for data to be processed.\r",
							"   */\r",
							"  var _readRecordHeader = function(c) {\r",
							"    var rval = 0;\r",
							"\r",
							"    // get input buffer and its length\r",
							"    var b = c.input;\r",
							"    var len = b.length();\r",
							"\r",
							"    // need at least 5 bytes to initialize a record\r",
							"    if(len < 5) {\r",
							"      rval = 5 - len;\r",
							"    } else {\r",
							"      // enough bytes for header\r",
							"      // initialize record\r",
							"      c.record = {\r",
							"        type: b.getByte(),\r",
							"        version: {\r",
							"          major: b.getByte(),\r",
							"          minor: b.getByte()\r",
							"        },\r",
							"        length: b.getInt16(),\r",
							"        fragment: forge.util.createBuffer(),\r",
							"        ready: false\r",
							"      };\r",
							"\r",
							"      // check record version\r",
							"      var compatibleVersion = (c.record.version.major === c.version.major);\r",
							"      if(compatibleVersion && c.session && c.session.version) {\r",
							"        // session version already set, require same minor version\r",
							"        compatibleVersion = (c.record.version.minor === c.version.minor);\r",
							"      }\r",
							"      if(!compatibleVersion) {\r",
							"        c.error(c, {\r",
							"          message: 'Incompatible TLS version.',\r",
							"          send: true,\r",
							"          alert: {\r",
							"            level: tls.Alert.Level.fatal,\r",
							"            description: tls.Alert.Description.protocol_version\r",
							"          }\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Reads the next record's contents and appends its message to any\r",
							"   * previously fragmented message.\r",
							"   *\r",
							"   * @param c the TLS connection with the next record.\r",
							"   *\r",
							"   * @return 0 if the input data could be processed, otherwise the\r",
							"   *         number of bytes required for data to be processed.\r",
							"   */\r",
							"  var _readRecord = function(c) {\r",
							"    var rval = 0;\r",
							"\r",
							"    // ensure there is enough input data to get the entire record\r",
							"    var b = c.input;\r",
							"    var len = b.length();\r",
							"    if(len < c.record.length) {\r",
							"      // not enough data yet, return how much is required\r",
							"      rval = c.record.length - len;\r",
							"    } else {\r",
							"      // there is enough data to parse the pending record\r",
							"      // fill record fragment and compact input buffer\r",
							"      c.record.fragment.putBytes(b.getBytes(c.record.length));\r",
							"      b.compact();\r",
							"\r",
							"      // update record using current read state\r",
							"      var s = c.state.current.read;\r",
							"      if(s.update(c, c.record)) {\r",
							"        // see if there is a previously fragmented message that the\r",
							"        // new record's message fragment should be appended to\r",
							"        if(c.fragmented !== null) {\r",
							"          // if the record type matches a previously fragmented\r",
							"          // record, append the record fragment to it\r",
							"          if(c.fragmented.type === c.record.type) {\r",
							"            // concatenate record fragments\r",
							"            c.fragmented.fragment.putBuffer(c.record.fragment);\r",
							"            c.record = c.fragmented;\r",
							"          } else {\r",
							"            // error, invalid fragmented record\r",
							"            c.error(c, {\r",
							"              message: 'Invalid fragmented record.',\r",
							"              send: true,\r",
							"              alert: {\r",
							"                level: tls.Alert.Level.fatal,\r",
							"                description:\r",
							"                  tls.Alert.Description.unexpected_message\r",
							"              }\r",
							"            });\r",
							"          }\r",
							"        }\r",
							"\r",
							"        // record is now ready\r",
							"        c.record.ready = true;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Performs a handshake using the TLS Handshake Protocol, as a client.\r",
							"   *\r",
							"   * This method should only be called if the connection is in client mode.\r",
							"   *\r",
							"   * @param sessionId the session ID to use, null to start a new one.\r",
							"   */\r",
							"  c.handshake = function(sessionId) {\r",
							"    // error to call this in non-client mode\r",
							"    if(c.entity !== tls.ConnectionEnd.client) {\r",
							"      // not fatal error\r",
							"      c.error(c, {\r",
							"        message: 'Cannot initiate handshake as a server.',\r",
							"        fatal: false\r",
							"      });\r",
							"    } else if(c.handshaking) {\r",
							"      // handshake is already in progress, fail but not fatal error\r",
							"      c.error(c, {\r",
							"        message: 'Handshake already in progress.',\r",
							"        fatal: false\r",
							"      });\r",
							"    } else {\r",
							"      // clear fail flag on reuse\r",
							"      if(c.fail && !c.open && c.handshakes === 0) {\r",
							"        c.fail = false;\r",
							"      }\r",
							"\r",
							"      // now handshaking\r",
							"      c.handshaking = true;\r",
							"\r",
							"      // default to blank (new session)\r",
							"      sessionId = sessionId || '';\r",
							"\r",
							"      // if a session ID was specified, try to find it in the cache\r",
							"      var session = null;\r",
							"      if(sessionId.length > 0) {\r",
							"        if(c.sessionCache) {\r",
							"          session = c.sessionCache.getSession(sessionId);\r",
							"        }\r",
							"\r",
							"        // matching session not found in cache, clear session ID\r",
							"        if(session === null) {\r",
							"          sessionId = '';\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // no session given, grab a session from the cache, if available\r",
							"      if(sessionId.length === 0 && c.sessionCache) {\r",
							"        session = c.sessionCache.getSession();\r",
							"        if(session !== null) {\r",
							"          sessionId = session.id;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // set up session\r",
							"      c.session = {\r",
							"        id: sessionId,\r",
							"        version: null,\r",
							"        cipherSuite: null,\r",
							"        compressionMethod: null,\r",
							"        serverCertificate: null,\r",
							"        certificateRequest: null,\r",
							"        clientCertificate: null,\r",
							"        sp: {},\r",
							"        md5: forge.md.md5.create(),\r",
							"        sha1: forge.md.sha1.create()\r",
							"      };\r",
							"\r",
							"      // use existing session information\r",
							"      if(session) {\r",
							"        // only update version on connection, session version not yet set\r",
							"        c.version = session.version;\r",
							"        c.session.sp = session.sp;\r",
							"      }\r",
							"\r",
							"      // generate new client random\r",
							"      c.session.sp.client_random = tls.createRandom().getBytes();\r",
							"\r",
							"      // connection now open\r",
							"      c.open = true;\r",
							"\r",
							"      // send hello\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createClientHello(c)\r",
							"      }));\r",
							"      tls.flush(c);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Called when TLS protocol data has been received from somewhere and should\r",
							"   * be processed by the TLS engine.\r",
							"   *\r",
							"   * @param data the TLS protocol data, as a string, to process.\r",
							"   *\r",
							"   * @return 0 if the data could be processed, otherwise the number of bytes\r",
							"   *         required for data to be processed.\r",
							"   */\r",
							"  c.process = function(data) {\r",
							"    var rval = 0;\r",
							"\r",
							"    // buffer input data\r",
							"    if(data) {\r",
							"      c.input.putBytes(data);\r",
							"    }\r",
							"\r",
							"    // process next record if no failure, process will be called after\r",
							"    // each record is handled (since handling can be asynchronous)\r",
							"    if(!c.fail) {\r",
							"      // reset record if ready and now empty\r",
							"      if(c.record !== null &&\r",
							"        c.record.ready && c.record.fragment.isEmpty()) {\r",
							"        c.record = null;\r",
							"      }\r",
							"\r",
							"      // if there is no pending record, try to read record header\r",
							"      if(c.record === null) {\r",
							"        rval = _readRecordHeader(c);\r",
							"      }\r",
							"\r",
							"      // read the next record (if record not yet ready)\r",
							"      if(!c.fail && c.record !== null && !c.record.ready) {\r",
							"        rval = _readRecord(c);\r",
							"      }\r",
							"\r",
							"      // record ready to be handled, update engine state\r",
							"      if(!c.fail && c.record !== null && c.record.ready) {\r",
							"        _update(c, c.record);\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Requests that application data be packaged into a TLS record. The\r",
							"   * tlsDataReady handler will be called when the TLS record(s) have been\r",
							"   * prepared.\r",
							"   *\r",
							"   * @param data the application data, as a raw 'binary' encoded string, to\r",
							"   *          be sent; to send utf-16/utf-8 string data, use the return value\r",
							"   *          of util.encodeUtf8(str).\r",
							"   *\r",
							"   * @return true on success, false on failure.\r",
							"   */\r",
							"  c.prepare = function(data) {\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.application_data,\r",
							"      data: forge.util.createBuffer(data)\r",
							"    }));\r",
							"    return tls.flush(c);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Requests that a heartbeat request be packaged into a TLS record for\r",
							"   * transmission. The tlsDataReady handler will be called when TLS record(s)\r",
							"   * have been prepared.\r",
							"   *\r",
							"   * When a heartbeat response has been received, the heartbeatReceived\r",
							"   * handler will be called with the matching payload. This handler can\r",
							"   * be used to clear a retransmission timer, etc.\r",
							"   *\r",
							"   * @param payload the heartbeat data to send as the payload in the message.\r",
							"   * @param [payloadLength] the payload length to use, defaults to the\r",
							"   *          actual payload length.\r",
							"   *\r",
							"   * @return true on success, false on failure.\r",
							"   */\r",
							"  c.prepareHeartbeatRequest = function(payload, payloadLength) {\r",
							"    if(payload instanceof forge.util.ByteBuffer) {\r",
							"      payload = payload.bytes();\r",
							"    }\r",
							"    if(typeof payloadLength === 'undefined') {\r",
							"      payloadLength = payload.length;\r",
							"    }\r",
							"    c.expectedHeartbeatPayload = payload;\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.heartbeat,\r",
							"      data: tls.createHeartbeat(\r",
							"        tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)\r",
							"    }));\r",
							"    return tls.flush(c);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Closes the connection (sends a close_notify alert).\r",
							"   *\r",
							"   * @param clearFail true to clear the fail flag (default: true).\r",
							"   */\r",
							"  c.close = function(clearFail) {\r",
							"    // save session if connection didn't fail\r",
							"    if(!c.fail && c.sessionCache && c.session) {\r",
							"      // only need to preserve session ID, version, and security params\r",
							"      var session = {\r",
							"        id: c.session.id,\r",
							"        version: c.session.version,\r",
							"        sp: c.session.sp\r",
							"      };\r",
							"      session.sp.keys = null;\r",
							"      c.sessionCache.setSession(session.id, session);\r",
							"    }\r",
							"\r",
							"    if(c.open) {\r",
							"      // connection no longer open, clear input\r",
							"      c.open = false;\r",
							"      c.input.clear();\r",
							"\r",
							"      // if connected or handshaking, send an alert\r",
							"      if(c.isConnected || c.handshaking) {\r",
							"        c.isConnected = c.handshaking = false;\r",
							"\r",
							"        // send close_notify alert\r",
							"        tls.queue(c, tls.createAlert(c, {\r",
							"          level: tls.Alert.Level.warning,\r",
							"          description: tls.Alert.Description.close_notify\r",
							"        }));\r",
							"        tls.flush(c);\r",
							"      }\r",
							"\r",
							"      // call handler\r",
							"      c.closed(c);\r",
							"    }\r",
							"\r",
							"    // reset TLS connection, do not clear fail flag\r",
							"    c.reset(clearFail);\r",
							"  };\r",
							"\r",
							"  return c;\r",
							"};\r",
							"\r",
							"/* TLS API */\r",
							"module.exports = forge.tls = forge.tls || {};\r",
							"\r",
							"// expose non-functions\r",
							"for(var key in tls) {\r",
							"  if(typeof tls[key] !== 'function') {\r",
							"    forge.tls[key] = tls[key];\r",
							"  }\r",
							"}\r",
							"\r",
							"// expose prf_tls1 for testing\r",
							"forge.tls.prf_tls1 = prf_TLS1;\r",
							"\r",
							"// expose sha1 hmac method\r",
							"forge.tls.hmac_sha1 = hmac_sha1;\r",
							"\r",
							"// expose session cache creation\r",
							"forge.tls.createSessionCache = tls.createSessionCache;\r",
							"\r",
							"/**\r",
							" * Creates a new TLS connection. This does not make any assumptions about the\r",
							" * transport layer that TLS is working on top of, ie: it does not assume there\r",
							" * is a TCP/IP connection or establish one. A TLS connection is totally\r",
							" * abstracted away from the layer is runs on top of, it merely establishes a\r",
							" * secure channel between a client\" and a \"server\".\r",
							" *\r",
							" * A TLS connection contains 4 connection states: pending read and write, and\r",
							" * current read and write.\r",
							" *\r",
							" * At initialization, the current read and write states will be null. Only once\r",
							" * the security parameters have been set and the keys have been generated can\r",
							" * the pending states be converted into current states. Current states will be\r",
							" * updated for each record processed.\r",
							" *\r",
							" * A custom certificate verify callback may be provided to check information\r",
							" * like the common name on the server's certificate. It will be called for\r",
							" * every certificate in the chain. It has the following signature:\r",
							" *\r",
							" * variable func(c, certs, index, preVerify)\r",
							" * Where:\r",
							" * c         The TLS connection\r",
							" * verified  Set to true if certificate was verified, otherwise the alert\r",
							" *           tls.Alert.Description for why the certificate failed.\r",
							" * depth     The current index in the chain, where 0 is the server's cert.\r",
							" * certs     The certificate chain, *NOTE* if the server was anonymous then\r",
							" *           the chain will be empty.\r",
							" *\r",
							" * The function returns true on success and on failure either the appropriate\r",
							" * tls.Alert.Description or an object with 'alert' set to the appropriate\r",
							" * tls.Alert.Description and 'message' set to a custom error message. If true\r",
							" * is not returned then the connection will abort using, in order of\r",
							" * availability, first the returned alert description, second the preVerify\r",
							" * alert description, and lastly the default 'bad_certificate'.\r",
							" *\r",
							" * There are three callbacks that can be used to make use of client-side\r",
							" * certificates where each takes the TLS connection as the first parameter:\r",
							" *\r",
							" * getCertificate(conn, hint)\r",
							" *   The second parameter is a hint as to which certificate should be\r",
							" *   returned. If the connection entity is a client, then the hint will be\r",
							" *   the CertificateRequest message from the server that is part of the\r",
							" *   TLS protocol. If the connection entity is a server, then it will be\r",
							" *   the servername list provided via an SNI extension the ClientHello, if\r",
							" *   one was provided (empty array if not). The hint can be examined to\r",
							" *   determine which certificate to use (advanced). Most implementations\r",
							" *   will just return a certificate. The return value must be a\r",
							" *   PEM-formatted certificate or an array of PEM-formatted certificates\r",
							" *   that constitute a certificate chain, with the first in the array/chain\r",
							" *   being the client's certificate.\r",
							" * getPrivateKey(conn, certificate)\r",
							" *   The second parameter is an forge.pki X.509 certificate object that\r",
							" *   is associated with the requested private key. The return value must\r",
							" *   be a PEM-formatted private key.\r",
							" * getSignature(conn, bytes, callback)\r",
							" *   This callback can be used instead of getPrivateKey if the private key\r",
							" *   is not directly accessible in javascript or should not be. For\r",
							" *   instance, a secure external web service could provide the signature\r",
							" *   in exchange for appropriate credentials. The second parameter is a\r",
							" *   string of bytes to be signed that are part of the TLS protocol. These\r",
							" *   bytes are used to verify that the private key for the previously\r",
							" *   provided client-side certificate is accessible to the client. The\r",
							" *   callback is a function that takes 2 parameters, the TLS connection\r",
							" *   and the RSA encrypted (signed) bytes as a string. This callback must\r",
							" *   be called once the signature is ready.\r",
							" *\r",
							" * @param options the options for this connection:\r",
							" *   server: true if the connection is server-side, false for client.\r",
							" *   sessionId: a session ID to reuse, null for a new connection.\r",
							" *   caStore: an array of certificates to trust.\r",
							" *   sessionCache: a session cache to use.\r",
							" *   cipherSuites: an optional array of cipher suites to use,\r",
							" *     see tls.CipherSuites.\r",
							" *   connected: function(conn) called when the first handshake completes.\r",
							" *   virtualHost: the virtual server name to use in a TLS SNI extension.\r",
							" *   verifyClient: true to require a client certificate in server mode,\r",
							" *     'optional' to request one, false not to (default: false).\r",
							" *   verify: a handler used to custom verify certificates in the chain.\r",
							" *   getCertificate: an optional callback used to get a certificate or\r",
							" *     a chain of certificates (as an array).\r",
							" *   getPrivateKey: an optional callback used to get a private key.\r",
							" *   getSignature: an optional callback used to get a signature.\r",
							" *   tlsDataReady: function(conn) called when TLS protocol data has been\r",
							" *     prepared and is ready to be used (typically sent over a socket\r",
							" *     connection to its destination), read from conn.tlsData buffer.\r",
							" *   dataReady: function(conn) called when application data has\r",
							" *     been parsed from a TLS record and should be consumed by the\r",
							" *     application, read from conn.data buffer.\r",
							" *   closed: function(conn) called when the connection has been closed.\r",
							" *   error: function(conn, error) called when there was an error.\r",
							" *   deflate: function(inBytes) if provided, will deflate TLS records using\r",
							" *     the deflate algorithm if the server supports it.\r",
							" *   inflate: function(inBytes) if provided, will inflate TLS records using\r",
							" *     the deflate algorithm if the server supports it.\r",
							" *\r",
							" * @return the new TLS connection.\r",
							" */\r",
							"forge.tls.createConnection = tls.createConnection;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 20 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of a basic Public Key Infrastructure, including\r",
							" * support for RSA public and private keys.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(21);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(15);\r",
							"__webpack_require__(28);\r",
							"__webpack_require__(17);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(16);\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/* Public Key Infrastructure (PKI) implementation. */\r",
							"var pki = module.exports = forge.pki = forge.pki || {};\r",
							"\r",
							"/**\r",
							" * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.\r",
							" *\r",
							" * Converts PEM-formatted data to DER.\r",
							" *\r",
							" * @param pem the PEM-formatted data.\r",
							" *\r",
							" * @return the DER-formatted data.\r",
							" */\r",
							"pki.pemToDer = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert PEM to DER; PEM is encrypted.');\r",
							"  }\r",
							"  return forge.util.createBuffer(msg.body);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA private key from PEM format.\r",
							" *\r",
							" * @param pem the PEM-formatted private key.\r",
							" *\r",
							" * @return the private key.\r",
							" */\r",
							"pki.privateKeyFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {\r",
							"    var error = new Error('Could not convert private key from PEM; PEM ' +\r",
							"      'header type is not \"PRIVATE KEY\" or \"RSA PRIVATE KEY\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert private key from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body);\r",
							"\r",
							"  return pki.privateKeyFromAsn1(obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA private key to PEM format.\r",
							" *\r",
							" * @param key the private key.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted private key.\r",
							" */\r",
							"pki.privateKeyToPem = function(key, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'RSA PRIVATE KEY',\r",
							"    body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PrivateKeyInfo to PEM format.\r",
							" *\r",
							" * @param pki the PrivateKeyInfo.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted private key.\r",
							" */\r",
							"pki.privateKeyInfoToPem = function(pki, maxline) {\r",
							"  // convert to DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'PRIVATE KEY',\r",
							"    body: asn1.toDer(pki).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 21 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Password-based encryption functions.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * An EncryptedPrivateKeyInfo:\r",
							" *\r",
							" * EncryptedPrivateKeyInfo ::= SEQUENCE {\r",
							" *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,\r",
							" *   encryptedData        EncryptedData }\r",
							" *\r",
							" * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * EncryptedData ::= OCTET STRING\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(15);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(25);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(1);\r",
							"\r",
							"if(typeof BigInteger === 'undefined') {\r",
							"  var BigInteger = forge.jsbn.BigInteger;\r",
							"}\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/* Password-based encryption implementation. */\r",
							"var pki = forge.pki = forge.pki || {};\r",
							"module.exports = pki.pbe = forge.pbe = forge.pbe || {};\r",
							"var oids = pki.oids;\r",
							"\r",
							"// validator for an EncryptedPrivateKeyInfo structure\r",
							"// Note: Currently only works w/algorithm params\r",
							"var encryptedPrivateKeyValidator = {\r",
							"  name: 'EncryptedPrivateKeyInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'AlgorithmIdentifier.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encryptionOid'\r",
							"    }, {\r",
							"      name: 'AlgorithmIdentifier.parameters',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'encryptionParams'\r",
							"    }]\r",
							"  }, {\r",
							"    // encryptedData\r",
							"    name: 'EncryptedPrivateKeyInfo.encryptedData',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'encryptedData'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for a PBES2Algorithms structure\r",
							"// Note: Currently only works w/PBKDF2 + AES encryption schemes\r",
							"var PBES2AlgorithmsValidator = {\r",
							"  name: 'PBES2Algorithms',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'PBES2Algorithms.keyDerivationFunc',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'PBES2Algorithms.keyDerivationFunc.oid',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'kdfOid'\r",
							"    }, {\r",
							"      name: 'PBES2Algorithms.params',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'PBES2Algorithms.params.salt',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OCTETSTRING,\r",
							"        constructed: false,\r",
							"        capture: 'kdfSalt'\r",
							"      }, {\r",
							"        name: 'PBES2Algorithms.params.iterationCount',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.INTEGER,\r",
							"        constructed: false,\r",
							"        capture: 'kdfIterationCount'\r",
							"      }, {\r",
							"        name: 'PBES2Algorithms.params.keyLength',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.INTEGER,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'keyLength'\r",
							"      }, {\r",
							"        // prf\r",
							"        name: 'PBES2Algorithms.params.prf',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SEQUENCE,\r",
							"        constructed: true,\r",
							"        optional: true,\r",
							"        value: [{\r",
							"          name: 'PBES2Algorithms.params.prf.algorithm',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          type: asn1.Type.OID,\r",
							"          constructed: false,\r",
							"          capture: 'prfOid'\r",
							"        }]\r",
							"      }]\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'PBES2Algorithms.encryptionScheme',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'PBES2Algorithms.encryptionScheme.oid',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encOid'\r",
							"    }, {\r",
							"      name: 'PBES2Algorithms.encryptionScheme.iv',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OCTETSTRING,\r",
							"      constructed: false,\r",
							"      capture: 'encIv'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"var pkcs12PbeParamsValidator = {\r",
							"  name: 'pkcs-12PbeParams',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'pkcs-12PbeParams.salt',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'salt'\r",
							"  }, {\r",
							"    name: 'pkcs-12PbeParams.iterations',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'iterations'\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.\r",
							" *\r",
							" * PBES2Algorithms ALGORITHM-IDENTIFIER ::=\r",
							" *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}\r",
							" *\r",
							" * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}\r",
							" *\r",
							" * PBES2-params ::= SEQUENCE {\r",
							" *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},\r",
							" *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}\r",
							" * }\r",
							" *\r",
							" * PBES2-KDFs ALGORITHM-IDENTIFIER ::=\r",
							" *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\r",
							" *\r",
							" * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }\r",
							" *\r",
							" * PBKDF2-params ::= SEQUENCE {\r",
							" *   salt CHOICE {\r",
							" *     specified OCTET STRING,\r",
							" *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\r",
							" *   },\r",
							" *   iterationCount INTEGER (1..MAX),\r",
							" *   keyLength INTEGER (1..MAX) OPTIONAL,\r",
							" *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\r",
							" * }\r",
							" *\r",
							" * @param obj the ASN.1 PrivateKeyInfo object.\r",
							" * @param password the password to encrypt with.\r",
							" * @param options:\r",
							" *          algorithm the encryption algorithm to use\r",
							" *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r",
							" *          count the iteration count to use.\r",
							" *          saltSize the salt size to use.\r",
							" *          prfAlgorithm the PRF message digest algorithm to use\r",
							" *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')\r",
							" *\r",
							" * @return the ASN.1 EncryptedPrivateKeyInfo.\r",
							" */\r",
							"pki.encryptPrivateKeyInfo = function(obj, password, options) {\r",
							"  // set default options\r",
							"  options = options || {};\r",
							"  options.saltSize = options.saltSize || 8;\r",
							"  options.count = options.count || 2048;\r",
							"  options.algorithm = options.algorithm || 'aes128';\r",
							"  options.prfAlgorithm = options.prfAlgorithm || 'sha1';\r",
							"\r",
							"  // generate PBE params\r",
							"  var salt = forge.random.getBytesSync(options.saltSize);\r",
							"  var count = options.count;\r",
							"  var countBytes = asn1.integerToDer(count);\r",
							"  var dkLen;\r",
							"  var encryptionAlgorithm;\r",
							"  var encryptedData;\r",
							"  if(options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {\r",
							"    // do PBES2\r",
							"    var ivLen, encOid, cipherFn;\r",
							"    switch(options.algorithm) {\r",
							"    case 'aes128':\r",
							"      dkLen = 16;\r",
							"      ivLen = 16;\r",
							"      encOid = oids['aes128-CBC'];\r",
							"      cipherFn = forge.aes.createEncryptionCipher;\r",
							"      break;\r",
							"    case 'aes192':\r",
							"      dkLen = 24;\r",
							"      ivLen = 16;\r",
							"      encOid = oids['aes192-CBC'];\r",
							"      cipherFn = forge.aes.createEncryptionCipher;\r",
							"      break;\r",
							"    case 'aes256':\r",
							"      dkLen = 32;\r",
							"      ivLen = 16;\r",
							"      encOid = oids['aes256-CBC'];\r",
							"      cipherFn = forge.aes.createEncryptionCipher;\r",
							"      break;\r",
							"    case 'des':\r",
							"      dkLen = 8;\r",
							"      ivLen = 8;\r",
							"      encOid = oids['desCBC'];\r",
							"      cipherFn = forge.des.createEncryptionCipher;\r",
							"      break;\r",
							"    default:\r",
							"      var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');\r",
							"      error.algorithm = options.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // get PRF message digest\r",
							"    var prfAlgorithm = 'hmacWith' + options.prfAlgorithm.toUpperCase();\r",
							"    var md = prfAlgorithmToMessageDigest(prfAlgorithm);\r",
							"\r",
							"    // encrypt private key using pbe SHA-1 and AES/DES\r",
							"    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\r",
							"    var iv = forge.random.getBytesSync(ivLen);\r",
							"    var cipher = cipherFn(dk);\r",
							"    cipher.start(iv);\r",
							"    cipher.update(asn1.toDer(obj));\r",
							"    cipher.finish();\r",
							"    encryptedData = cipher.output.getBytes();\r",
							"\r",
							"    // get PBKDF2-params\r",
							"    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);\r",
							"\r",
							"    encryptionAlgorithm = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // keyDerivationFunc\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),\r",
							"          // PBKDF2-params\r",
							"          params\r",
							"        ]),\r",
							"        // encryptionScheme\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(encOid).getBytes()),\r",
							"          // iv\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)\r",
							"        ])\r",
							"      ])\r",
							"    ]);\r",
							"  } else if(options.algorithm === '3des') {\r",
							"    // Do PKCS12 PBE\r",
							"    dkLen = 24;\r",
							"\r",
							"    var saltBytes = new forge.util.ByteBuffer(salt);\r",
							"    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);\r",
							"    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);\r",
							"    var cipher = forge.des.createEncryptionCipher(dk);\r",
							"    cipher.start(iv);\r",
							"    cipher.update(asn1.toDer(obj));\r",
							"    cipher.finish();\r",
							"    encryptedData = cipher.output.getBytes();\r",
							"\r",
							"    encryptionAlgorithm = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),\r",
							"      // pkcs-12PbeParams\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // salt\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\r",
							"        // iteration count\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"          countBytes.getBytes())\r",
							"      ])\r",
							"    ]);\r",
							"  } else {\r",
							"    var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');\r",
							"    error.algorithm = options.algorithm;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // EncryptedPrivateKeyInfo\r",
							"  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // encryptionAlgorithm\r",
							"    encryptionAlgorithm,\r",
							"    // encryptedData\r",
							"    asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)\r",
							"  ]);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decrypts a ASN.1 PrivateKeyInfo object.\r",
							" *\r",
							" * @param obj the ASN.1 EncryptedPrivateKeyInfo object.\r",
							" * @param password the password to decrypt with.\r",
							" *\r",
							" * @return the ASN.1 PrivateKeyInfo on success, null on failure.\r",
							" */\r",
							"pki.decryptPrivateKeyInfo = function(obj, password) {\r",
							"  var rval = null;\r",
							"\r",
							"  // get PBE params\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read encrypted private key. ' +\r",
							"      'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get cipher\r",
							"  var oid = asn1.derToOid(capture.encryptionOid);\r",
							"  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);\r",
							"\r",
							"  // get encrypted data\r",
							"  var encrypted = forge.util.createBuffer(capture.encryptedData);\r",
							"\r",
							"  cipher.update(encrypted);\r",
							"  if(cipher.finish()) {\r",
							"    rval = asn1.fromDer(cipher.output);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a EncryptedPrivateKeyInfo to PEM format.\r",
							" *\r",
							" * @param epki the EncryptedPrivateKeyInfo.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted encrypted private key.\r",
							" */\r",
							"pki.encryptedPrivateKeyToPem = function(epki, maxline) {\r",
							"  // convert to DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'ENCRYPTED PRIVATE KEY',\r",
							"    body: asn1.toDer(epki).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption\r",
							" * is not performed.\r",
							" *\r",
							" * @param pem the EncryptedPrivateKeyInfo in PEM-format.\r",
							" *\r",
							" * @return the ASN.1 EncryptedPrivateKeyInfo.\r",
							" */\r",
							"pki.encryptedPrivateKeyFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'ENCRYPTED PRIVATE KEY') {\r",
							"    var error = new Error('Could not convert encrypted private key from PEM; ' +\r",
							"      'PEM header type is \"ENCRYPTED PRIVATE KEY\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert encrypted private key from PEM; ' +\r",
							"      'PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  return asn1.fromDer(msg.body);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encrypts an RSA private key. By default, the key will be wrapped in\r",
							" * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.\r",
							" * This is the standard, preferred way to encrypt a private key.\r",
							" *\r",
							" * To produce a non-standard PEM-encrypted private key that uses encapsulated\r",
							" * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL\r",
							" * private key encryption), set the 'legacy' option to true. Note: Using this\r",
							" * option will cause the iteration count to be forced to 1.\r",
							" *\r",
							" * Note: The 'des' algorithm is supported, but it is not considered to be\r",
							" * secure because it only uses a single 56-bit key. If possible, it is highly\r",
							" * recommended that a different algorithm be used.\r",
							" *\r",
							" * @param rsaKey the RSA key to encrypt.\r",
							" * @param password the password to use.\r",
							" * @param options:\r",
							" *          algorithm: the encryption algorithm to use\r",
							" *            ('aes128', 'aes192', 'aes256', '3des', 'des').\r",
							" *          count: the iteration count to use.\r",
							" *          saltSize: the salt size to use.\r",
							" *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated\r",
							" *            headers (DEK-Info) private key.\r",
							" *\r",
							" * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.\r",
							" */\r",
							"pki.encryptRsaPrivateKey = function(rsaKey, password, options) {\r",
							"  // standard PKCS#8\r",
							"  options = options || {};\r",
							"  if(!options.legacy) {\r",
							"    // encrypt PrivateKeyInfo\r",
							"    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));\r",
							"    rval = pki.encryptPrivateKeyInfo(rval, password, options);\r",
							"    return pki.encryptedPrivateKeyToPem(rval);\r",
							"  }\r",
							"\r",
							"  // legacy non-PKCS#8\r",
							"  var algorithm;\r",
							"  var iv;\r",
							"  var dkLen;\r",
							"  var cipherFn;\r",
							"  switch(options.algorithm) {\r",
							"  case 'aes128':\r",
							"    algorithm = 'AES-128-CBC';\r",
							"    dkLen = 16;\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"    cipherFn = forge.aes.createEncryptionCipher;\r",
							"    break;\r",
							"  case 'aes192':\r",
							"    algorithm = 'AES-192-CBC';\r",
							"    dkLen = 24;\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"    cipherFn = forge.aes.createEncryptionCipher;\r",
							"    break;\r",
							"  case 'aes256':\r",
							"    algorithm = 'AES-256-CBC';\r",
							"    dkLen = 32;\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"    cipherFn = forge.aes.createEncryptionCipher;\r",
							"    break;\r",
							"  case '3des':\r",
							"    algorithm = 'DES-EDE3-CBC';\r",
							"    dkLen = 24;\r",
							"    iv = forge.random.getBytesSync(8);\r",
							"    cipherFn = forge.des.createEncryptionCipher;\r",
							"    break;\r",
							"  case 'des':\r",
							"    algorithm = 'DES-CBC';\r",
							"    dkLen = 8;\r",
							"    iv = forge.random.getBytesSync(8);\r",
							"    cipherFn = forge.des.createEncryptionCipher;\r",
							"    break;\r",
							"  default:\r",
							"    var error = new Error('Could not encrypt RSA private key; unsupported ' +\r",
							"      'encryption algorithm \"' + options.algorithm + '\".');\r",
							"    error.algorithm = options.algorithm;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // encrypt private key using OpenSSL legacy key derivation\r",
							"  var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\r",
							"  var cipher = cipherFn(dk);\r",
							"  cipher.start(iv);\r",
							"  cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));\r",
							"  cipher.finish();\r",
							"\r",
							"  var msg = {\r",
							"    type: 'RSA PRIVATE KEY',\r",
							"    procType: {\r",
							"      version: '4',\r",
							"      type: 'ENCRYPTED'\r",
							"    },\r",
							"    dekInfo: {\r",
							"      algorithm: algorithm,\r",
							"      parameters: forge.util.bytesToHex(iv).toUpperCase()\r",
							"    },\r",
							"    body: cipher.output.getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decrypts an RSA private key.\r",
							" *\r",
							" * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.\r",
							" * @param password the password to use.\r",
							" *\r",
							" * @return the RSA key on success, null on failure.\r",
							" */\r",
							"pki.decryptRsaPrivateKey = function(pem, password) {\r",
							"  var rval = null;\r",
							"\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'ENCRYPTED PRIVATE KEY' &&\r",
							"    msg.type !== 'PRIVATE KEY' &&\r",
							"    msg.type !== 'RSA PRIVATE KEY') {\r",
							"    var error = new Error('Could not convert private key from PEM; PEM header type ' +\r",
							"      'is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".');\r",
							"    error.headerType = error;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    var dkLen;\r",
							"    var cipherFn;\r",
							"    switch(msg.dekInfo.algorithm) {\r",
							"    case 'DES-CBC':\r",
							"      dkLen = 8;\r",
							"      cipherFn = forge.des.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'DES-EDE3-CBC':\r",
							"      dkLen = 24;\r",
							"      cipherFn = forge.des.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'AES-128-CBC':\r",
							"      dkLen = 16;\r",
							"      cipherFn = forge.aes.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'AES-192-CBC':\r",
							"      dkLen = 24;\r",
							"      cipherFn = forge.aes.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'AES-256-CBC':\r",
							"      dkLen = 32;\r",
							"      cipherFn = forge.aes.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'RC2-40-CBC':\r",
							"      dkLen = 5;\r",
							"      cipherFn = function(key) {\r",
							"        return forge.rc2.createDecryptionCipher(key, 40);\r",
							"      };\r",
							"      break;\r",
							"    case 'RC2-64-CBC':\r",
							"      dkLen = 8;\r",
							"      cipherFn = function(key) {\r",
							"        return forge.rc2.createDecryptionCipher(key, 64);\r",
							"      };\r",
							"      break;\r",
							"    case 'RC2-128-CBC':\r",
							"      dkLen = 16;\r",
							"      cipherFn = function(key) {\r",
							"        return forge.rc2.createDecryptionCipher(key, 128);\r",
							"      };\r",
							"      break;\r",
							"    default:\r",
							"      var error = new Error('Could not decrypt private key; unsupported ' +\r",
							"        'encryption algorithm \"' + msg.dekInfo.algorithm + '\".');\r",
							"      error.algorithm = msg.dekInfo.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // use OpenSSL legacy key derivation\r",
							"    var iv = forge.util.hexToBytes(msg.dekInfo.parameters);\r",
							"    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\r",
							"    var cipher = cipherFn(dk);\r",
							"    cipher.start(iv);\r",
							"    cipher.update(forge.util.createBuffer(msg.body));\r",
							"    if(cipher.finish()) {\r",
							"      rval = cipher.output.getBytes();\r",
							"    } else {\r",
							"      return rval;\r",
							"    }\r",
							"  } else {\r",
							"    rval = msg.body;\r",
							"  }\r",
							"\r",
							"  if(msg.type === 'ENCRYPTED PRIVATE KEY') {\r",
							"    rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);\r",
							"  } else {\r",
							"    // decryption already performed above\r",
							"    rval = asn1.fromDer(rval);\r",
							"  }\r",
							"\r",
							"  if(rval !== null) {\r",
							"    rval = pki.privateKeyFromAsn1(rval);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Derives a PKCS#12 key.\r",
							" *\r",
							" * @param password the password to derive the key material from, null or\r",
							" *          undefined for none.\r",
							" * @param salt the salt, as a ByteBuffer, to use.\r",
							" * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r",
							" * @param iter the iteration count.\r",
							" * @param n the number of bytes to derive from the password.\r",
							" * @param md the message digest to use, defaults to SHA-1.\r",
							" *\r",
							" * @return a ByteBuffer with the bytes derived from the password.\r",
							" */\r",
							"pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {\r",
							"  var j, l;\r",
							"\r",
							"  if(typeof md === 'undefined' || md === null) {\r",
							"    if(!('sha1' in forge.md)) {\r",
							"      throw new Error('\"sha1\" hash algorithm unavailable.');\r",
							"    }\r",
							"    md = forge.md.sha1.create();\r",
							"  }\r",
							"\r",
							"  var u = md.digestLength;\r",
							"  var v = md.blockLength;\r",
							"  var result = new forge.util.ByteBuffer();\r",
							"\r",
							"  /* Convert password to Unicode byte buffer + trailing 0-byte. */\r",
							"  var passBuf = new forge.util.ByteBuffer();\r",
							"  if(password !== null && password !== undefined) {\r",
							"    for(l = 0; l < password.length; l++) {\r",
							"      passBuf.putInt16(password.charCodeAt(l));\r",
							"    }\r",
							"    passBuf.putInt16(0);\r",
							"  }\r",
							"\r",
							"  /* Length of salt and password in BYTES. */\r",
							"  var p = passBuf.length();\r",
							"  var s = salt.length();\r",
							"\r",
							"  /* 1. Construct a string, D (the \"diversifier\"), by concatenating\r",
							"        v copies of ID. */\r",
							"  var D = new forge.util.ByteBuffer();\r",
							"  D.fillWithByte(id, v);\r",
							"\r",
							"  /* 2. Concatenate copies of the salt together to create a string S of length\r",
							"        v * ceil(s / v) bytes (the final copy of the salt may be trunacted\r",
							"        to create S).\r",
							"        Note that if the salt is the empty string, then so is S. */\r",
							"  var Slen = v * Math.ceil(s / v);\r",
							"  var S = new forge.util.ByteBuffer();\r",
							"  for(l = 0; l < Slen; l++) {\r",
							"    S.putByte(salt.at(l % s));\r",
							"  }\r",
							"\r",
							"  /* 3. Concatenate copies of the password together to create a string P of\r",
							"        length v * ceil(p / v) bytes (the final copy of the password may be\r",
							"        truncated to create P).\r",
							"        Note that if the password is the empty string, then so is P. */\r",
							"  var Plen = v * Math.ceil(p / v);\r",
							"  var P = new forge.util.ByteBuffer();\r",
							"  for(l = 0; l < Plen; l++) {\r",
							"    P.putByte(passBuf.at(l % p));\r",
							"  }\r",
							"\r",
							"  /* 4. Set I=S||P to be the concatenation of S and P. */\r",
							"  var I = S;\r",
							"  I.putBuffer(P);\r",
							"\r",
							"  /* 5. Set c=ceil(n / u). */\r",
							"  var c = Math.ceil(n / u);\r",
							"\r",
							"  /* 6. For i=1, 2, ..., c, do the following: */\r",
							"  for(var i = 1; i <= c; i++) {\r",
							"    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */\r",
							"    var buf = new forge.util.ByteBuffer();\r",
							"    buf.putBytes(D.bytes());\r",
							"    buf.putBytes(I.bytes());\r",
							"    for(var round = 0; round < iter; round++) {\r",
							"      md.start();\r",
							"      md.update(buf.getBytes());\r",
							"      buf = md.digest();\r",
							"    }\r",
							"\r",
							"    /* b) Concatenate copies of Ai to create a string B of length v bytes (the\r",
							"          final copy of Ai may be truncated to create B). */\r",
							"    var B = new forge.util.ByteBuffer();\r",
							"    for(l = 0; l < v; l++) {\r",
							"      B.putByte(buf.at(l % u));\r",
							"    }\r",
							"\r",
							"    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,\r",
							"          where k=ceil(s / v) + ceil(p / v), modify I by setting\r",
							"          Ij=(Ij+B+1) mod 2v for each j.  */\r",
							"    var k = Math.ceil(s / v) + Math.ceil(p / v);\r",
							"    var Inew = new forge.util.ByteBuffer();\r",
							"    for(j = 0; j < k; j++) {\r",
							"      var chunk = new forge.util.ByteBuffer(I.getBytes(v));\r",
							"      var x = 0x1ff;\r",
							"      for(l = B.length() - 1; l >= 0; l--) {\r",
							"        x = x >> 8;\r",
							"        x += B.at(l) + chunk.at(l);\r",
							"        chunk.setAt(l, x & 0xff);\r",
							"      }\r",
							"      Inew.putBuffer(chunk);\r",
							"    }\r",
							"    I = Inew;\r",
							"\r",
							"    /* Add Ai to A. */\r",
							"    result.putBuffer(buf);\r",
							"  }\r",
							"\r",
							"  result.truncate(result.length() - n);\r",
							"  return result;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Get new Forge cipher object instance.\r",
							" *\r",
							" * @param oid the OID (in string notation).\r",
							" * @param params the ASN.1 params object.\r",
							" * @param password the password to decrypt with.\r",
							" *\r",
							" * @return new cipher object instance.\r",
							" */\r",
							"pki.pbe.getCipher = function(oid, params, password) {\r",
							"  switch(oid) {\r",
							"  case pki.oids['pkcs5PBES2']:\r",
							"    return pki.pbe.getCipherForPBES2(oid, params, password);\r",
							"\r",
							"  case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:\r",
							"  case pki.oids['pbewithSHAAnd40BitRC2-CBC']:\r",
							"    return pki.pbe.getCipherForPKCS12PBE(oid, params, password);\r",
							"\r",
							"  default:\r",
							"    var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');\r",
							"    error.oid = oid;\r",
							"    error.supportedOids = [\r",
							"      'pkcs5PBES2',\r",
							"      'pbeWithSHAAnd3-KeyTripleDES-CBC',\r",
							"      'pbewithSHAAnd40BitRC2-CBC'\r",
							"    ];\r",
							"    throw error;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Get new Forge cipher object instance according to PBES2 params block.\r",
							" *\r",
							" * The returned cipher instance is already started using the IV\r",
							" * from PBES2 parameter block.\r",
							" *\r",
							" * @param oid the PKCS#5 PBKDF2 OID (in string notation).\r",
							" * @param params the ASN.1 PBES2-params object.\r",
							" * @param password the password to decrypt with.\r",
							" *\r",
							" * @return new cipher object instance.\r",
							" */\r",
							"pki.pbe.getCipherForPBES2 = function(oid, params, password) {\r",
							"  // get PBE params\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read password-based-encryption algorithm ' +\r",
							"      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // check oids\r",
							"  oid = asn1.derToOid(capture.kdfOid);\r",
							"  if(oid !== pki.oids['pkcs5PBKDF2']) {\r",
							"    var error = new Error('Cannot read encrypted private key. ' +\r",
							"      'Unsupported key derivation function OID.');\r",
							"    error.oid = oid;\r",
							"    error.supportedOids = ['pkcs5PBKDF2'];\r",
							"    throw error;\r",
							"  }\r",
							"  oid = asn1.derToOid(capture.encOid);\r",
							"  if(oid !== pki.oids['aes128-CBC'] &&\r",
							"    oid !== pki.oids['aes192-CBC'] &&\r",
							"    oid !== pki.oids['aes256-CBC'] &&\r",
							"    oid !== pki.oids['des-EDE3-CBC'] &&\r",
							"    oid !== pki.oids['desCBC']) {\r",
							"    var error = new Error('Cannot read encrypted private key. ' +\r",
							"      'Unsupported encryption scheme OID.');\r",
							"    error.oid = oid;\r",
							"    error.supportedOids = [\r",
							"      'aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // set PBE params\r",
							"  var salt = capture.kdfSalt;\r",
							"  var count = forge.util.createBuffer(capture.kdfIterationCount);\r",
							"  count = count.getInt(count.length() << 3);\r",
							"  var dkLen;\r",
							"  var cipherFn;\r",
							"  switch(pki.oids[oid]) {\r",
							"  case 'aes128-CBC':\r",
							"    dkLen = 16;\r",
							"    cipherFn = forge.aes.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'aes192-CBC':\r",
							"    dkLen = 24;\r",
							"    cipherFn = forge.aes.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'aes256-CBC':\r",
							"    dkLen = 32;\r",
							"    cipherFn = forge.aes.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'des-EDE3-CBC':\r",
							"    dkLen = 24;\r",
							"    cipherFn = forge.des.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'desCBC':\r",
							"    dkLen = 8;\r",
							"    cipherFn = forge.des.createDecryptionCipher;\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  // get PRF message digest\r",
							"  var md = prfOidToMessageDigest(capture.prfOid);\r",
							"\r",
							"  // decrypt private key using pbe with chosen PRF and AES/DES\r",
							"  var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\r",
							"  var iv = capture.encIv;\r",
							"  var cipher = cipherFn(dk);\r",
							"  cipher.start(iv);\r",
							"\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Get new Forge cipher object instance for PKCS#12 PBE.\r",
							" *\r",
							" * The returned cipher instance is already started using the key & IV\r",
							" * derived from the provided password and PKCS#12 PBE salt.\r",
							" *\r",
							" * @param oid The PKCS#12 PBE OID (in string notation).\r",
							" * @param params The ASN.1 PKCS#12 PBE-params object.\r",
							" * @param password The password to decrypt with.\r",
							" *\r",
							" * @return the new cipher object instance.\r",
							" */\r",
							"pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {\r",
							"  // get PBE params\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read password-based-encryption algorithm ' +\r",
							"      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var salt = forge.util.createBuffer(capture.salt);\r",
							"  var count = forge.util.createBuffer(capture.iterations);\r",
							"  count = count.getInt(count.length() << 3);\r",
							"\r",
							"  var dkLen, dIvLen, cipherFn;\r",
							"  switch(oid) {\r",
							"    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:\r",
							"      dkLen = 24;\r",
							"      dIvLen = 8;\r",
							"      cipherFn = forge.des.startDecrypting;\r",
							"      break;\r",
							"\r",
							"    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:\r",
							"      dkLen = 5;\r",
							"      dIvLen = 8;\r",
							"      cipherFn = function(key, iv) {\r",
							"        var cipher = forge.rc2.createDecryptionCipher(key, 40);\r",
							"        cipher.start(iv, null);\r",
							"        return cipher;\r",
							"      };\r",
							"      break;\r",
							"\r",
							"    default:\r",
							"      var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');\r",
							"      error.oid = oid;\r",
							"      throw error;\r",
							"  }\r",
							"\r",
							"  // get PRF message digest\r",
							"  var md = prfOidToMessageDigest(capture.prfOid);\r",
							"  var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);\r",
							"  md.start();\r",
							"  var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);\r",
							"\r",
							"  return cipherFn(key, iv);\r",
							"};\r",
							"\r",
							"/**\r",
							" * OpenSSL's legacy key derivation function.\r",
							" *\r",
							" * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html\r",
							" *\r",
							" * @param password the password to derive the key from.\r",
							" * @param salt the salt to use, null for none.\r",
							" * @param dkLen the number of bytes needed for the derived key.\r",
							" * @param [options] the options to use:\r",
							" *          [md] an optional message digest object to use.\r",
							" */\r",
							"pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {\r",
							"  if(typeof md === 'undefined' || md === null) {\r",
							"    if(!('md5' in forge.md)) {\r",
							"      throw new Error('\"md5\" hash algorithm unavailable.');\r",
							"    }\r",
							"    md = forge.md.md5.create();\r",
							"  }\r",
							"  if(salt === null) {\r",
							"    salt = '';\r",
							"  }\r",
							"  var digests = [hash(md, password + salt)];\r",
							"  for(var length = 16, i = 1; length < dkLen; ++i, length += 16) {\r",
							"    digests.push(hash(md, digests[i - 1] + password + salt));\r",
							"  }\r",
							"  return digests.join('').substr(0, dkLen);\r",
							"};\r",
							"\r",
							"function hash(md, bytes) {\r",
							"  return md.start().update(bytes).digest().getBytes();\r",
							"}\r",
							"\r",
							"function prfOidToMessageDigest(prfOid) {\r",
							"  // get PRF algorithm, default to SHA-1\r",
							"  var prfAlgorithm;\r",
							"  if(!prfOid) {\r",
							"    prfAlgorithm = 'hmacWithSHA1';\r",
							"  } else {\r",
							"    prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];\r",
							"    if(!prfAlgorithm) {\r",
							"      var error = new Error('Unsupported PRF OID.');\r",
							"      error.oid = prfOid;\r",
							"      error.supported = [\r",
							"        'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',\r",
							"        'hmacWithSHA512'];\r",
							"      throw error;\r",
							"    }\r",
							"  }\r",
							"  return prfAlgorithmToMessageDigest(prfAlgorithm);\r",
							"}\r",
							"\r",
							"function prfAlgorithmToMessageDigest(prfAlgorithm) {\r",
							"  var factory = forge.md;\r",
							"  switch(prfAlgorithm) {\r",
							"  case 'hmacWithSHA224':\r",
							"    factory = forge.md.sha512;\r",
							"  case 'hmacWithSHA1':\r",
							"  case 'hmacWithSHA256':\r",
							"  case 'hmacWithSHA384':\r",
							"  case 'hmacWithSHA512':\r",
							"    prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();\r",
							"    break;\r",
							"  default:\r",
							"    var error = new Error('Unsupported PRF algorithm.');\r",
							"    error.algorithm = prfAlgorithm;\r",
							"    error.supported = [\r",
							"      'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',\r",
							"      'hmacWithSHA512'];\r",
							"    throw error;\r",
							"  }\r",
							"  if(!factory || !(prfAlgorithm in factory)) {\r",
							"    throw new Error('Unknown hash algorithm: ' + prfAlgorithm);\r",
							"  }\r",
							"  return factory[prfAlgorithm].create();\r",
							"}\r",
							"\r",
							"function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {\r",
							"  var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // salt\r",
							"    asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\r",
							"    // iteration count\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      countBytes.getBytes())\r",
							"  ]);\r",
							"  // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm\r",
							"  if(prfAlgorithm !== 'hmacWithSHA1') {\r",
							"    params.value.push(\r",
							"      // key length\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        forge.util.hexToBytes(dkLen.toString(16))),\r",
							"      // AlgorithmIdentifier\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // algorithm\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),\r",
							"        // parameters (null)\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"      ]));\r",
							"  }\r",
							"  return params;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 22 */\r",
							"/***/ (function(module, exports) {\r",
							"\r",
							"/* (ignored) */\r",
							"\r",
							"/***/ }),\r",
							"/* 23 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.\r",
							" *\r",
							" * See FIPS 180-2 for details.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2015 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var sha256 = module.exports = forge.sha256 = forge.sha256 || {};\r",
							"forge.md.sha256 = forge.md.algorithms.sha256 = sha256;\r",
							"\r",
							"/**\r",
							" * Creates a SHA-256 message digest object.\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"sha256.create = function() {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  // SHA-256 state contains eight 32-bit integers\r",
							"  var _state = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for word storage\r",
							"  var _w = new Array(64);\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    algorithm: 'sha256',\r",
							"    blockLength: 64,\r",
							"    digestLength: 32,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 8\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength64 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength64 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _state = {\r",
							"      h0: 0x6A09E667,\r",
							"      h1: 0xBB67AE85,\r",
							"      h2: 0x3C6EF372,\r",
							"      h3: 0xA54FF53A,\r",
							"      h4: 0x510E527F,\r",
							"      h5: 0x9B05688C,\r",
							"      h6: 0x1F83D9AB,\r",
							"      h7: 0x5BE0CD19\r",
							"    };\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = ((len[1] / 0x100000000) >>> 0);\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_state, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the digest.\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate SHA-256 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 448 mod 512. In other words,\r",
							"    the data to be digested must be a multiple of 512 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 8 bytes (64\r",
							"    bits), that means that the last segment of the data must have 56 bytes\r",
							"    (448 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 448 mod 512 because\r",
							"    512 - 128 = 448.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 448 mod 512, then 512 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in big-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry from next int\r",
							"    var next, carry;\r",
							"    var bits = md.fullMessageLength[0] * 8;\r",
							"    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\r",
							"      next = md.fullMessageLength[i + 1] * 8;\r",
							"      carry = (next / 0x100000000) >>> 0;\r",
							"      bits += carry;\r",
							"      finalBlock.putInt32(bits >>> 0);\r",
							"      bits = next >>> 0;\r",
							"    }\r",
							"    finalBlock.putInt32(bits);\r",
							"\r",
							"    var s2 = {\r",
							"      h0: _state.h0,\r",
							"      h1: _state.h1,\r",
							"      h2: _state.h2,\r",
							"      h3: _state.h3,\r",
							"      h4: _state.h4,\r",
							"      h5: _state.h5,\r",
							"      h6: _state.h6,\r",
							"      h7: _state.h7\r",
							"    };\r",
							"    _update(s2, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    rval.putInt32(s2.h0);\r",
							"    rval.putInt32(s2.h1);\r",
							"    rval.putInt32(s2.h2);\r",
							"    rval.putInt32(s2.h3);\r",
							"    rval.putInt32(s2.h4);\r",
							"    rval.putInt32(s2.h5);\r",
							"    rval.putInt32(s2.h6);\r",
							"    rval.putInt32(s2.h7);\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// sha-256 padding bytes not initialized yet\r",
							"var _padding = null;\r",
							"var _initialized = false;\r",
							"\r",
							"// table of constants\r",
							"var _k = null;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\r",
							"\r",
							"  // create K table for SHA-256\r",
							"  _k = [\r",
							"    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\r",
							"    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\r",
							"    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\r",
							"    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\r",
							"    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\r",
							"    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\r",
							"    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\r",
							"    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\r",
							"    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\r",
							"    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\r",
							"    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\r",
							"    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\r",
							"    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\r",
							"    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\r",
							"    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\r",
							"    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a SHA-256 state with the given byte buffer.\r",
							" *\r",
							" * @param s the SHA-256 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (64 byte) chunks\r",
							"  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 64) {\r",
							"    // the w array will be populated with sixteen 32-bit big-endian words\r",
							"    // and then extended into 64 32-bit words according to SHA-256\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      w[i] = bytes.getInt32();\r",
							"    }\r",
							"    for(; i < 64; ++i) {\r",
							"      // XOR word 2 words ago rot right 17, rot right 19, shft right 10\r",
							"      t1 = w[i - 2];\r",
							"      t1 =\r",
							"        ((t1 >>> 17) | (t1 << 15)) ^\r",
							"        ((t1 >>> 19) | (t1 << 13)) ^\r",
							"        (t1 >>> 10);\r",
							"      // XOR word 15 words ago rot right 7, rot right 18, shft right 3\r",
							"      t2 = w[i - 15];\r",
							"      t2 =\r",
							"        ((t2 >>> 7) | (t2 << 25)) ^\r",
							"        ((t2 >>> 18) | (t2 << 14)) ^\r",
							"        (t2 >>> 3);\r",
							"      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32\r",
							"      w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;\r",
							"    }\r",
							"\r",
							"    // initialize hash value for this chunk\r",
							"    a = s.h0;\r",
							"    b = s.h1;\r",
							"    c = s.h2;\r",
							"    d = s.h3;\r",
							"    e = s.h4;\r",
							"    f = s.h5;\r",
							"    g = s.h6;\r",
							"    h = s.h7;\r",
							"\r",
							"    // round function\r",
							"    for(i = 0; i < 64; ++i) {\r",
							"      // Sum1(e)\r",
							"      s1 =\r",
							"        ((e >>> 6) | (e << 26)) ^\r",
							"        ((e >>> 11) | (e << 21)) ^\r",
							"        ((e >>> 25) | (e << 7));\r",
							"      // Ch(e, f, g) (optimized the same way as SHA-1)\r",
							"      ch = g ^ (e & (f ^ g));\r",
							"      // Sum0(a)\r",
							"      s0 =\r",
							"        ((a >>> 2) | (a << 30)) ^\r",
							"        ((a >>> 13) | (a << 19)) ^\r",
							"        ((a >>> 22) | (a << 10));\r",
							"      // Maj(a, b, c) (optimized the same way as SHA-1)\r",
							"      maj = (a & b) | (c & (a ^ b));\r",
							"\r",
							"      // main algorithm\r",
							"      t1 = h + s1 + ch + _k[i] + w[i];\r",
							"      t2 = s0 + maj;\r",
							"      h = g;\r",
							"      g = f;\r",
							"      f = e;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      // can't truncate with `| 0`\r",
							"      e = (d + t1) >>> 0;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b = a;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      // can't truncate with `| 0`\r",
							"      a = (t1 + t2) >>> 0;\r",
							"    }\r",
							"\r",
							"    // update hash state\r",
							"    s.h0 = (s.h0 + a) | 0;\r",
							"    s.h1 = (s.h1 + b) | 0;\r",
							"    s.h2 = (s.h2 + c) | 0;\r",
							"    s.h3 = (s.h3 + d) | 0;\r",
							"    s.h4 = (s.h4 + e) | 0;\r",
							"    s.h5 = (s.h5 + f) | 0;\r",
							"    s.h6 = (s.h6 + g) | 0;\r",
							"    s.h7 = (s.h7 + h) | 0;\r",
							"    len -= 64;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 24 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * A javascript implementation of a cryptographically-secure\r",
							" * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\r",
							" * here though the use of SHA-256 is not enforced; when generating an\r",
							" * a PRNG context, the hashing algorithm and block cipher used for\r",
							" * the generator are specified via a plugin.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var _crypto = null;\r",
							"if(forge.util.isNodejs && !forge.options.usePureJavaScript &&\r",
							"  !process.versions['node-webkit']) {\r",
							"  _crypto = __webpack_require__(22);\r",
							"}\r",
							"\r",
							"/* PRNG API */\r",
							"var prng = module.exports = forge.prng = forge.prng || {};\r",
							"\r",
							"/**\r",
							" * Creates a new PRNG context.\r",
							" *\r",
							" * A PRNG plugin must be passed in that will provide:\r",
							" *\r",
							" * 1. A function that initializes the key and seed of a PRNG context. It\r",
							" *   will be given a 16 byte key and a 16 byte seed. Any key expansion\r",
							" *   or transformation of the seed from a byte string into an array of\r",
							" *   integers (or similar) should be performed.\r",
							" * 2. The cryptographic function used by the generator. It takes a key and\r",
							" *   a seed.\r",
							" * 3. A seed increment function. It takes the seed and returns seed + 1.\r",
							" * 4. An api to create a message digest.\r",
							" *\r",
							" * For an example, see random.js.\r",
							" *\r",
							" * @param plugin the PRNG plugin to use.\r",
							" */\r",
							"prng.create = function(plugin) {\r",
							"  var ctx = {\r",
							"    plugin: plugin,\r",
							"    key: null,\r",
							"    seed: null,\r",
							"    time: null,\r",
							"    // number of reseeds so far\r",
							"    reseeds: 0,\r",
							"    // amount of data generated so far\r",
							"    generated: 0,\r",
							"    // no initial key bytes\r",
							"    keyBytes: ''\r",
							"  };\r",
							"\r",
							"  // create 32 entropy pools (each is a message digest)\r",
							"  var md = plugin.md;\r",
							"  var pools = new Array(32);\r",
							"  for(var i = 0; i < 32; ++i) {\r",
							"    pools[i] = md.create();\r",
							"  }\r",
							"  ctx.pools = pools;\r",
							"\r",
							"  // entropy pools are written to cyclically, starting at index 0\r",
							"  ctx.pool = 0;\r",
							"\r",
							"  /**\r",
							"   * Generates random bytes. The bytes may be generated synchronously or\r",
							"   * asynchronously. Web workers must use the asynchronous interface or\r",
							"   * else the behavior is undefined.\r",
							"   *\r",
							"   * @param count the number of random bytes to generate.\r",
							"   * @param [callback(err, bytes)] called once the operation completes.\r",
							"   *\r",
							"   * @return count random bytes as a string.\r",
							"   */\r",
							"  ctx.generate = function(count, callback) {\r",
							"    // do synchronously\r",
							"    if(!callback) {\r",
							"      return ctx.generateSync(count);\r",
							"    }\r",
							"\r",
							"    // simple generator using counter-based CBC\r",
							"    var cipher = ctx.plugin.cipher;\r",
							"    var increment = ctx.plugin.increment;\r",
							"    var formatKey = ctx.plugin.formatKey;\r",
							"    var formatSeed = ctx.plugin.formatSeed;\r",
							"    var b = forge.util.createBuffer();\r",
							"\r",
							"    // paranoid deviation from Fortuna:\r",
							"    // reset key for every request to protect previously\r",
							"    // generated random bytes should the key be discovered;\r",
							"    // there is no 100ms based reseeding because of this\r",
							"    // forced reseed for every `generate` call\r",
							"    ctx.key = null;\r",
							"\r",
							"    generate();\r",
							"\r",
							"    function generate(err) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"\r",
							"      // sufficient bytes generated\r",
							"      if(b.length() >= count) {\r",
							"        return callback(null, b.getBytes(count));\r",
							"      }\r",
							"\r",
							"      // if amount of data generated is greater than 1 MiB, trigger reseed\r",
							"      if(ctx.generated > 0xfffff) {\r",
							"        ctx.key = null;\r",
							"      }\r",
							"\r",
							"      if(ctx.key === null) {\r",
							"        // prevent stack overflow\r",
							"        return forge.util.nextTick(function() {\r",
							"          _reseed(generate);\r",
							"        });\r",
							"      }\r",
							"\r",
							"      // generate the random bytes\r",
							"      var bytes = cipher(ctx.key, ctx.seed);\r",
							"      ctx.generated += bytes.length;\r",
							"      b.putBytes(bytes);\r",
							"\r",
							"      // generate bytes for a new key and seed\r",
							"      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\r",
							"      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\r",
							"\r",
							"      forge.util.setImmediate(generate);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Generates random bytes synchronously.\r",
							"   *\r",
							"   * @param count the number of random bytes to generate.\r",
							"   *\r",
							"   * @return count random bytes as a string.\r",
							"   */\r",
							"  ctx.generateSync = function(count) {\r",
							"    // simple generator using counter-based CBC\r",
							"    var cipher = ctx.plugin.cipher;\r",
							"    var increment = ctx.plugin.increment;\r",
							"    var formatKey = ctx.plugin.formatKey;\r",
							"    var formatSeed = ctx.plugin.formatSeed;\r",
							"\r",
							"    // paranoid deviation from Fortuna:\r",
							"    // reset key for every request to protect previously\r",
							"    // generated random bytes should the key be discovered;\r",
							"    // there is no 100ms based reseeding because of this\r",
							"    // forced reseed for every `generateSync` call\r",
							"    ctx.key = null;\r",
							"\r",
							"    var b = forge.util.createBuffer();\r",
							"    while(b.length() < count) {\r",
							"      // if amount of data generated is greater than 1 MiB, trigger reseed\r",
							"      if(ctx.generated > 0xfffff) {\r",
							"        ctx.key = null;\r",
							"      }\r",
							"\r",
							"      if(ctx.key === null) {\r",
							"        _reseedSync();\r",
							"      }\r",
							"\r",
							"      // generate the random bytes\r",
							"      var bytes = cipher(ctx.key, ctx.seed);\r",
							"      ctx.generated += bytes.length;\r",
							"      b.putBytes(bytes);\r",
							"\r",
							"      // generate bytes for a new key and seed\r",
							"      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\r",
							"      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\r",
							"    }\r",
							"\r",
							"    return b.getBytes(count);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Private function that asynchronously reseeds a generator.\r",
							"   *\r",
							"   * @param callback(err) called once the operation completes.\r",
							"   */\r",
							"  function _reseed(callback) {\r",
							"    if(ctx.pools[0].messageLength >= 32) {\r",
							"      _seed();\r",
							"      return callback();\r",
							"    }\r",
							"    // not enough seed data...\r",
							"    var needed = (32 - ctx.pools[0].messageLength) << 5;\r",
							"    ctx.seedFile(needed, function(err, bytes) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"      ctx.collect(bytes);\r",
							"      _seed();\r",
							"      callback();\r",
							"    });\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Private function that synchronously reseeds a generator.\r",
							"   */\r",
							"  function _reseedSync() {\r",
							"    if(ctx.pools[0].messageLength >= 32) {\r",
							"      return _seed();\r",
							"    }\r",
							"    // not enough seed data...\r",
							"    var needed = (32 - ctx.pools[0].messageLength) << 5;\r",
							"    ctx.collect(ctx.seedFileSync(needed));\r",
							"    _seed();\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Private function that seeds a generator once enough bytes are available.\r",
							"   */\r",
							"  function _seed() {\r",
							"    // update reseed count\r",
							"    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;\r",
							"\r",
							"    // goal is to update `key` via:\r",
							"    // key = hash(key + s)\r",
							"    //   where 's' is all collected entropy from selected pools, then...\r",
							"\r",
							"    // create a plugin-based message digest\r",
							"    var md = ctx.plugin.md.create();\r",
							"\r",
							"    // consume current key bytes\r",
							"    md.update(ctx.keyBytes);\r",
							"\r",
							"    // digest the entropy of pools whose index k meet the\r",
							"    // condition 'n mod 2^k == 0' where n is the number of reseeds\r",
							"    var _2powK = 1;\r",
							"    for(var k = 0; k < 32; ++k) {\r",
							"      if(ctx.reseeds % _2powK === 0) {\r",
							"        md.update(ctx.pools[k].digest().getBytes());\r",
							"        ctx.pools[k].start();\r",
							"      }\r",
							"      _2powK = _2powK << 1;\r",
							"    }\r",
							"\r",
							"    // get digest for key bytes\r",
							"    ctx.keyBytes = md.digest().getBytes();\r",
							"\r",
							"    // paranoid deviation from Fortuna:\r",
							"    // update `seed` via `seed = hash(key)`\r",
							"    // instead of initializing to zero once and only\r",
							"    // ever incrementing it\r",
							"    md.start();\r",
							"    md.update(ctx.keyBytes);\r",
							"    var seedBytes = md.digest().getBytes();\r",
							"\r",
							"    // update state\r",
							"    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\r",
							"    ctx.seed = ctx.plugin.formatSeed(seedBytes);\r",
							"    ctx.generated = 0;\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * The built-in default seedFile. This seedFile is used when entropy\r",
							"   * is needed immediately.\r",
							"   *\r",
							"   * @param needed the number of bytes that are needed.\r",
							"   *\r",
							"   * @return the random bytes.\r",
							"   */\r",
							"  function defaultSeedFile(needed) {\r",
							"    // use window.crypto.getRandomValues strong source of entropy if available\r",
							"    var getRandomValues = null;\r",
							"    if(typeof window !== 'undefined') {\r",
							"      var _crypto = window.crypto || window.msCrypto;\r",
							"      if(_crypto && _crypto.getRandomValues) {\r",
							"        getRandomValues = function(arr) {\r",
							"          return _crypto.getRandomValues(arr);\r",
							"        };\r",
							"      }\r",
							"    }\r",
							"\r",
							"    var b = forge.util.createBuffer();\r",
							"    if(getRandomValues) {\r",
							"      while(b.length() < needed) {\r",
							"        // max byte length is 65536 before QuotaExceededError is thrown\r",
							"        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\r",
							"        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\r",
							"        var entropy = new Uint32Array(Math.floor(count));\r",
							"        try {\r",
							"          getRandomValues(entropy);\r",
							"          for(var i = 0; i < entropy.length; ++i) {\r",
							"            b.putInt32(entropy[i]);\r",
							"          }\r",
							"        } catch(e) {\r",
							"          /* only ignore QuotaExceededError */\r",
							"          if(!(typeof QuotaExceededError !== 'undefined' &&\r",
							"            e instanceof QuotaExceededError)) {\r",
							"            throw e;\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // be sad and add some weak random data\r",
							"    if(b.length() < needed) {\r",
							"      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\r",
							"      implemented with David G. Carta's optimization: with 32 bit math\r",
							"      and without division (Public Domain). */\r",
							"      var hi, lo, next;\r",
							"      var seed = Math.floor(Math.random() * 0x010000);\r",
							"      while(b.length() < needed) {\r",
							"        lo = 16807 * (seed & 0xFFFF);\r",
							"        hi = 16807 * (seed >> 16);\r",
							"        lo += (hi & 0x7FFF) << 16;\r",
							"        lo += hi >> 15;\r",
							"        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\r",
							"        seed = lo & 0xFFFFFFFF;\r",
							"\r",
							"        // consume lower 3 bytes of seed\r",
							"        for(var i = 0; i < 3; ++i) {\r",
							"          // throw in more pseudo random\r",
							"          next = seed >>> (i << 3);\r",
							"          next ^= Math.floor(Math.random() * 0x0100);\r",
							"          b.putByte(String.fromCharCode(next & 0xFF));\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return b.getBytes(needed);\r",
							"  }\r",
							"  // initialize seed file APIs\r",
							"  if(_crypto) {\r",
							"    // use nodejs async API\r",
							"    ctx.seedFile = function(needed, callback) {\r",
							"      _crypto.randomBytes(needed, function(err, bytes) {\r",
							"        if(err) {\r",
							"          return callback(err);\r",
							"        }\r",
							"        callback(null, bytes.toString());\r",
							"      });\r",
							"    };\r",
							"    // use nodejs sync API\r",
							"    ctx.seedFileSync = function(needed) {\r",
							"      return _crypto.randomBytes(needed).toString();\r",
							"    };\r",
							"  } else {\r",
							"    ctx.seedFile = function(needed, callback) {\r",
							"      try {\r",
							"        callback(null, defaultSeedFile(needed));\r",
							"      } catch(e) {\r",
							"        callback(e);\r",
							"      }\r",
							"    };\r",
							"    ctx.seedFileSync = defaultSeedFile;\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Adds entropy to a prng ctx's accumulator.\r",
							"   *\r",
							"   * @param bytes the bytes of entropy as a string.\r",
							"   */\r",
							"  ctx.collect = function(bytes) {\r",
							"    // iterate over pools distributing entropy cyclically\r",
							"    var count = bytes.length;\r",
							"    for(var i = 0; i < count; ++i) {\r",
							"      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\r",
							"      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Collects an integer of n bits.\r",
							"   *\r",
							"   * @param i the integer entropy.\r",
							"   * @param n the number of bits in the integer.\r",
							"   */\r",
							"  ctx.collectInt = function(i, n) {\r",
							"    var bytes = '';\r",
							"    for(var x = 0; x < n; x += 8) {\r",
							"      bytes += String.fromCharCode((i >> x) & 0xFF);\r",
							"    }\r",
							"    ctx.collect(bytes);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Registers a Web Worker to receive immediate entropy from the main thread.\r",
							"   * This method is required until Web Workers can access the native crypto\r",
							"   * API. This method should be called twice for each created worker, once in\r",
							"   * the main thread, and once in the worker itself.\r",
							"   *\r",
							"   * @param worker the worker to register.\r",
							"   */\r",
							"  ctx.registerWorker = function(worker) {\r",
							"    // worker receives random bytes\r",
							"    if(worker === self) {\r",
							"      ctx.seedFile = function(needed, callback) {\r",
							"        function listener(e) {\r",
							"          var data = e.data;\r",
							"          if(data.forge && data.forge.prng) {\r",
							"            self.removeEventListener('message', listener);\r",
							"            callback(data.forge.prng.err, data.forge.prng.bytes);\r",
							"          }\r",
							"        }\r",
							"        self.addEventListener('message', listener);\r",
							"        self.postMessage({forge: {prng: {needed: needed}}});\r",
							"      };\r",
							"    } else {\r",
							"      // main thread sends random bytes upon request\r",
							"      var listener = function(e) {\r",
							"        var data = e.data;\r",
							"        if(data.forge && data.forge.prng) {\r",
							"          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\r",
							"            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});\r",
							"          });\r",
							"        }\r",
							"      };\r",
							"      // TODO: do we need to remove the event listener when the worker dies?\r",
							"      worker.addEventListener('message', listener);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return ctx;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 25 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * RC2 implementation.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * Information on the RC2 cipher is available from RFC #2268,\r",
							" * http://www.ietf.org/rfc/rfc2268.txt\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var piTable = [\r",
							"  0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d,\r",
							"  0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2,\r",
							"  0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32,\r",
							"  0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82,\r",
							"  0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc,\r",
							"  0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26,\r",
							"  0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03,\r",
							"  0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7,\r",
							"  0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a,\r",
							"  0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec,\r",
							"  0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39,\r",
							"  0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31,\r",
							"  0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9,\r",
							"  0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9,\r",
							"  0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e,\r",
							"  0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad\r",
							"];\r",
							"\r",
							"var s = [1, 2, 3, 5];\r",
							"\r",
							"/**\r",
							" * Rotate a word left by given number of bits.\r",
							" *\r",
							" * Bits that are shifted out on the left are put back in on the right\r",
							" * hand side.\r",
							" *\r",
							" * @param word The word to shift left.\r",
							" * @param bits The number of bits to shift by.\r",
							" * @return The rotated word.\r",
							" */\r",
							"var rol = function(word, bits) {\r",
							"  return ((word << bits) & 0xffff) | ((word & 0xffff) >> (16 - bits));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Rotate a word right by given number of bits.\r",
							" *\r",
							" * Bits that are shifted out on the right are put back in on the left\r",
							" * hand side.\r",
							" *\r",
							" * @param word The word to shift right.\r",
							" * @param bits The number of bits to shift by.\r",
							" * @return The rotated word.\r",
							" */\r",
							"var ror = function(word, bits) {\r",
							"  return ((word & 0xffff) >> bits) | ((word << (16 - bits)) & 0xffff);\r",
							"};\r",
							"\r",
							"/* RC2 API */\r",
							"module.exports = forge.rc2 = forge.rc2 || {};\r",
							"\r",
							"/**\r",
							" * Perform RC2 key expansion as per RFC #2268, section 2.\r",
							" *\r",
							" * @param key variable-length user key (between 1 and 128 bytes)\r",
							" * @param effKeyBits number of effective key bits (default: 128)\r",
							" * @return the expanded RC2 key (ByteBuffer of 128 bytes)\r",
							" */\r",
							"forge.rc2.expandKey = function(key, effKeyBits) {\r",
							"  if(typeof key === 'string') {\r",
							"    key = forge.util.createBuffer(key);\r",
							"  }\r",
							"  effKeyBits = effKeyBits || 128;\r",
							"\r",
							"  /* introduce variables that match the names used in RFC #2268 */\r",
							"  var L = key;\r",
							"  var T = key.length();\r",
							"  var T1 = effKeyBits;\r",
							"  var T8 = Math.ceil(T1 / 8);\r",
							"  var TM = 0xff >> (T1 & 0x07);\r",
							"  var i;\r",
							"\r",
							"  for(i = T; i < 128; i++) {\r",
							"    L.putByte(piTable[(L.at(i - 1) + L.at(i - T)) & 0xff]);\r",
							"  }\r",
							"\r",
							"  L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);\r",
							"\r",
							"  for(i = 127 - T8; i >= 0; i--) {\r",
							"    L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);\r",
							"  }\r",
							"\r",
							"  return L;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a RC2 cipher object.\r",
							" *\r",
							" * @param key the symmetric key to use (as base for key generation).\r",
							" * @param bits the number of effective key bits.\r",
							" * @param encrypt false for decryption, true for encryption.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"var createCipher = function(key, bits, encrypt) {\r",
							"  var _finish = false, _input = null, _output = null, _iv = null;\r",
							"  var mixRound, mashRound;\r",
							"  var i, j, K = [];\r",
							"\r",
							"  /* Expand key and fill into K[] Array */\r",
							"  key = forge.rc2.expandKey(key, bits);\r",
							"  for(i = 0; i < 64; i++) {\r",
							"    K.push(key.getInt16Le());\r",
							"  }\r",
							"\r",
							"  if(encrypt) {\r",
							"    /**\r",
							"     * Perform one mixing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mixing on.\r",
							"     */\r",
							"    mixRound = function(R) {\r",
							"      for(i = 0; i < 4; i++) {\r",
							"        R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +\r",
							"          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);\r",
							"        R[i] = rol(R[i], s[i]);\r",
							"        j++;\r",
							"      }\r",
							"    };\r",
							"\r",
							"    /**\r",
							"     * Perform one mashing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mashing on.\r",
							"     */\r",
							"    mashRound = function(R) {\r",
							"      for(i = 0; i < 4; i++) {\r",
							"        R[i] += K[R[(i + 3) % 4] & 63];\r",
							"      }\r",
							"    };\r",
							"  } else {\r",
							"    /**\r",
							"     * Perform one r-mixing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mixing on.\r",
							"     */\r",
							"    mixRound = function(R) {\r",
							"      for(i = 3; i >= 0; i--) {\r",
							"        R[i] = ror(R[i], s[i]);\r",
							"        R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +\r",
							"          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);\r",
							"        j--;\r",
							"      }\r",
							"    };\r",
							"\r",
							"    /**\r",
							"     * Perform one r-mashing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mashing on.\r",
							"     */\r",
							"    mashRound = function(R) {\r",
							"      for(i = 3; i >= 0; i--) {\r",
							"        R[i] -= K[R[(i + 3) % 4] & 63];\r",
							"      }\r",
							"    };\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Run the specified cipher execution plan.\r",
							"   *\r",
							"   * This function takes four words from the input buffer, applies the IV on\r",
							"   * it (if requested) and runs the provided execution plan.\r",
							"   *\r",
							"   * The plan must be put together in form of a array of arrays.  Where the\r",
							"   * outer one is simply a list of steps to perform and the inner one needs\r",
							"   * to have two elements: the first one telling how many rounds to perform,\r",
							"   * the second one telling what to do (i.e. the function to call).\r",
							"   *\r",
							"   * @param {Array} plan The plan to execute.\r",
							"   */\r",
							"  var runPlan = function(plan) {\r",
							"    var R = [];\r",
							"\r",
							"    /* Get data from input buffer and fill the four words into R */\r",
							"    for(i = 0; i < 4; i++) {\r",
							"      var val = _input.getInt16Le();\r",
							"\r",
							"      if(_iv !== null) {\r",
							"        if(encrypt) {\r",
							"          /* We're encrypting, apply the IV first. */\r",
							"          val ^= _iv.getInt16Le();\r",
							"        } else {\r",
							"          /* We're decryption, keep cipher text for next block. */\r",
							"          _iv.putInt16Le(val);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      R.push(val & 0xffff);\r",
							"    }\r",
							"\r",
							"    /* Reset global \"j\" variable as per spec. */\r",
							"    j = encrypt ? 0 : 63;\r",
							"\r",
							"    /* Run execution plan. */\r",
							"    for(var ptr = 0; ptr < plan.length; ptr++) {\r",
							"      for(var ctr = 0; ctr < plan[ptr][0]; ctr++) {\r",
							"        plan[ptr][1](R);\r",
							"      }\r",
							"    }\r",
							"\r",
							"    /* Write back result to output buffer. */\r",
							"    for(i = 0; i < 4; i++) {\r",
							"      if(_iv !== null) {\r",
							"        if(encrypt) {\r",
							"          /* We're encrypting in CBC-mode, feed back encrypted bytes into\r",
							"             IV buffer to carry it forward to next block. */\r",
							"          _iv.putInt16Le(R[i]);\r",
							"        } else {\r",
							"          R[i] ^= _iv.getInt16Le();\r",
							"        }\r",
							"      }\r",
							"\r",
							"      _output.putInt16Le(R[i]);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /* Create cipher object */\r",
							"  var cipher = null;\r",
							"  cipher = {\r",
							"    /**\r",
							"     * Starts or restarts the encryption or decryption process, whichever\r",
							"     * was previously configured.\r",
							"     *\r",
							"     * To use the cipher in CBC mode, iv may be given either as a string\r",
							"     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.\r",
							"     *\r",
							"     * @param iv the initialization vector to use, null for ECB mode.\r",
							"     * @param output the output the buffer to write to, null to create one.\r",
							"     */\r",
							"    start: function(iv, output) {\r",
							"      if(iv) {\r",
							"        /* CBC mode */\r",
							"        if(typeof iv === 'string') {\r",
							"          iv = forge.util.createBuffer(iv);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      _finish = false;\r",
							"      _input = forge.util.createBuffer();\r",
							"      _output = output || new forge.util.createBuffer();\r",
							"      _iv = iv;\r",
							"\r",
							"      cipher.output = _output;\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Updates the next block.\r",
							"     *\r",
							"     * @param input the buffer to read from.\r",
							"     */\r",
							"    update: function(input) {\r",
							"      if(!_finish) {\r",
							"        // not finishing, so fill the input buffer with more input\r",
							"        _input.putBuffer(input);\r",
							"      }\r",
							"\r",
							"      while(_input.length() >= 8) {\r",
							"        runPlan([\r",
							"            [ 5, mixRound ],\r",
							"            [ 1, mashRound ],\r",
							"            [ 6, mixRound ],\r",
							"            [ 1, mashRound ],\r",
							"            [ 5, mixRound ]\r",
							"          ]);\r",
							"      }\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Finishes encrypting or decrypting.\r",
							"     *\r",
							"     * @param pad a padding function to use, null for PKCS#7 padding,\r",
							"     *           signature(blockSize, buffer, decrypt).\r",
							"     *\r",
							"     * @return true if successful, false on error.\r",
							"     */\r",
							"    finish: function(pad) {\r",
							"      var rval = true;\r",
							"\r",
							"      if(encrypt) {\r",
							"        if(pad) {\r",
							"          rval = pad(8, _input, !encrypt);\r",
							"        } else {\r",
							"          // add PKCS#7 padding to block (each pad byte is the\r",
							"          // value of the number of pad bytes)\r",
							"          var padding = (_input.length() === 8) ? 8 : (8 - _input.length());\r",
							"          _input.fillWithByte(padding, padding);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(rval) {\r",
							"        // do final update\r",
							"        _finish = true;\r",
							"        cipher.update();\r",
							"      }\r",
							"\r",
							"      if(!encrypt) {\r",
							"        // check for error: input data not a multiple of block size\r",
							"        rval = (_input.length() === 0);\r",
							"        if(rval) {\r",
							"          if(pad) {\r",
							"            rval = pad(8, _output, !encrypt);\r",
							"          } else {\r",
							"            // ensure padding byte count is valid\r",
							"            var len = _output.length();\r",
							"            var count = _output.at(len - 1);\r",
							"\r",
							"            if(count > len) {\r",
							"              rval = false;\r",
							"            } else {\r",
							"              // trim off padding bytes\r",
							"              _output.truncate(count);\r",
							"            }\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"\r",
							"      return rval;\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\r",
							" * given symmetric key. The output will be stored in the 'output' member\r",
							" * of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes or a byte buffer.\r",
							" * The cipher is initialized to use 128 effective key bits.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.startEncrypting = function(key, iv, output) {\r",
							"  var cipher = forge.rc2.createEncryptionCipher(key, 128);\r",
							"  cipher.start(iv, output);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\r",
							" * given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes or a byte buffer.\r",
							" *\r",
							" * To start encrypting call start() on the cipher with an iv and optional\r",
							" * output buffer.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.createEncryptionCipher = function(key, bits) {\r",
							"  return createCipher(key, bits, true);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\r",
							" * given symmetric key. The output will be stored in the 'output' member\r",
							" * of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes or a byte buffer.\r",
							" * The cipher is initialized to use 128 effective key bits.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.startDecrypting = function(key, iv, output) {\r",
							"  var cipher = forge.rc2.createDecryptionCipher(key, 128);\r",
							"  cipher.start(iv, output);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\r",
							" * given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes or a byte buffer.\r",
							" *\r",
							" * To start decrypting call start() on the cipher with an iv and optional\r",
							" * output buffer.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.createDecryptionCipher = function(key, bits) {\r",
							"  return createCipher(key, bits, false);\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 26 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Partial implementation of PKCS#1 v2.2: RSA-OEAP\r",
							" *\r",
							" * Modified but based on the following MIT and BSD licensed code:\r",
							" *\r",
							" * https://github.com/kjur/jsjws/blob/master/rsa.js:\r",
							" *\r",
							" * The 'jsjws'(JSON Web Signature JavaScript Library) License\r",
							" *\r",
							" * Copyright (c) 2012 Kenji Urushima\r",
							" *\r",
							" * Permission is hereby granted, free of charge, to any person obtaining a copy\r",
							" * of this software and associated documentation files (the \"Software\"), to deal\r",
							" * in the Software without restriction, including without limitation the rights\r",
							" * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r",
							" * copies of the Software, and to permit persons to whom the Software is\r",
							" * furnished to do so, subject to the following conditions:\r",
							" *\r",
							" * The above copyright notice and this permission notice shall be included in\r",
							" * all copies or substantial portions of the Software.\r",
							" *\r",
							" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r",
							" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r",
							" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r",
							" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r",
							" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r",
							" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r",
							" * THE SOFTWARE.\r",
							" *\r",
							" * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\r",
							" *\r",
							" * RSAES-OAEP.js\r",
							" * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\r",
							" * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\r",
							" * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\r",
							" * Contact: ellis@nukinetics.com\r",
							" * Distributed under the BSD License.\r",
							" *\r",
							" * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\r",
							" *\r",
							" * @author Evan Jones (http://evanjones.ca/)\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2013-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(9);\r",
							"\r",
							"// shortcut for PKCS#1 API\r",
							"var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\r",
							"\r",
							"/**\r",
							" * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\r",
							" * and seed.\r",
							" *\r",
							" * This method does not perform RSA encryption, it only encodes the message\r",
							" * using RSAES-OAEP.\r",
							" *\r",
							" * @param key the RSA key to use.\r",
							" * @param message the message to encode.\r",
							" * @param options the options to use:\r",
							" *          label an optional label to use.\r",
							" *          seed the seed to use.\r",
							" *          md the message digest object to use, undefined for SHA-1.\r",
							" *          mgf1 optional mgf1 parameters:\r",
							" *            md the message digest object to use for MGF1.\r",
							" *\r",
							" * @return the encoded message bytes.\r",
							" */\r",
							"pkcs1.encode_rsa_oaep = function(key, message, options) {\r",
							"  // parse arguments\r",
							"  var label;\r",
							"  var seed;\r",
							"  var md;\r",
							"  var mgf1Md;\r",
							"  // legacy args (label, seed, md)\r",
							"  if(typeof options === 'string') {\r",
							"    label = options;\r",
							"    seed = arguments[3] || undefined;\r",
							"    md = arguments[4] || undefined;\r",
							"  } else if(options) {\r",
							"    label = options.label || undefined;\r",
							"    seed = options.seed || undefined;\r",
							"    md = options.md || undefined;\r",
							"    if(options.mgf1 && options.mgf1.md) {\r",
							"      mgf1Md = options.mgf1.md;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // default OAEP to SHA-1 message digest\r",
							"  if(!md) {\r",
							"    md = forge.md.sha1.create();\r",
							"  } else {\r",
							"    md.start();\r",
							"  }\r",
							"\r",
							"  // default MGF-1 to same as OAEP\r",
							"  if(!mgf1Md) {\r",
							"    mgf1Md = md;\r",
							"  }\r",
							"\r",
							"  // compute length in bytes and check output\r",
							"  var keyLength = Math.ceil(key.n.bitLength() / 8);\r",
							"  var maxLength = keyLength - 2 * md.digestLength - 2;\r",
							"  if(message.length > maxLength) {\r",
							"    var error = new Error('RSAES-OAEP input message length is too long.');\r",
							"    error.length = message.length;\r",
							"    error.maxLength = maxLength;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(!label) {\r",
							"    label = '';\r",
							"  }\r",
							"  md.update(label, 'raw');\r",
							"  var lHash = md.digest();\r",
							"\r",
							"  var PS = '';\r",
							"  var PS_length = maxLength - message.length;\r",
							"  for (var i = 0; i < PS_length; i++) {\r",
							"    PS += '\\x00';\r",
							"  }\r",
							"\r",
							"  var DB = lHash.getBytes() + PS + '\\x01' + message;\r",
							"\r",
							"  if(!seed) {\r",
							"    seed = forge.random.getBytes(md.digestLength);\r",
							"  } else if(seed.length !== md.digestLength) {\r",
							"    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +\r",
							"      'match the digest length.');\r",
							"    error.seedLength = seed.length;\r",
							"    error.digestLength = md.digestLength;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\r",
							"  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\r",
							"\r",
							"  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\r",
							"  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\r",
							"\r",
							"  // return encoded message\r",
							"  return '\\x00' + maskedSeed + maskedDB;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\r",
							" * label (L).\r",
							" *\r",
							" * This method does not perform RSA decryption, it only decodes the message\r",
							" * using RSAES-OAEP.\r",
							" *\r",
							" * @param key the RSA key to use.\r",
							" * @param em the encoded message to decode.\r",
							" * @param options the options to use:\r",
							" *          label an optional label to use.\r",
							" *          md the message digest object to use for OAEP, undefined for SHA-1.\r",
							" *          mgf1 optional mgf1 parameters:\r",
							" *            md the message digest object to use for MGF1.\r",
							" *\r",
							" * @return the decoded message bytes.\r",
							" */\r",
							"pkcs1.decode_rsa_oaep = function(key, em, options) {\r",
							"  // parse args\r",
							"  var label;\r",
							"  var md;\r",
							"  var mgf1Md;\r",
							"  // legacy args\r",
							"  if(typeof options === 'string') {\r",
							"    label = options;\r",
							"    md = arguments[3] || undefined;\r",
							"  } else if(options) {\r",
							"    label = options.label || undefined;\r",
							"    md = options.md || undefined;\r",
							"    if(options.mgf1 && options.mgf1.md) {\r",
							"      mgf1Md = options.mgf1.md;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // compute length in bytes\r",
							"  var keyLength = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  if(em.length !== keyLength) {\r",
							"    var error = new Error('RSAES-OAEP encoded message length is invalid.');\r",
							"    error.length = em.length;\r",
							"    error.expectedLength = keyLength;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // default OAEP to SHA-1 message digest\r",
							"  if(md === undefined) {\r",
							"    md = forge.md.sha1.create();\r",
							"  } else {\r",
							"    md.start();\r",
							"  }\r",
							"\r",
							"  // default MGF-1 to same as OAEP\r",
							"  if(!mgf1Md) {\r",
							"    mgf1Md = md;\r",
							"  }\r",
							"\r",
							"  if(keyLength < 2 * md.digestLength + 2) {\r",
							"    throw new Error('RSAES-OAEP key is too short for the hash function.');\r",
							"  }\r",
							"\r",
							"  if(!label) {\r",
							"    label = '';\r",
							"  }\r",
							"  md.update(label, 'raw');\r",
							"  var lHash = md.digest().getBytes();\r",
							"\r",
							"  // split the message into its parts\r",
							"  var y = em.charAt(0);\r",
							"  var maskedSeed = em.substring(1, md.digestLength + 1);\r",
							"  var maskedDB = em.substring(1 + md.digestLength);\r",
							"\r",
							"  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\r",
							"  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\r",
							"\r",
							"  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\r",
							"  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\r",
							"\r",
							"  var lHashPrime = db.substring(0, md.digestLength);\r",
							"\r",
							"  // constant time check that all values match what is expected\r",
							"  var error = (y !== '\\x00');\r",
							"\r",
							"  // constant time check lHash vs lHashPrime\r",
							"  for(var i = 0; i < md.digestLength; ++i) {\r",
							"    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));\r",
							"  }\r",
							"\r",
							"  // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\r",
							"  // message\r",
							"  // TODO: It must be possible to do this in a better/smarter way?\r",
							"  var in_ps = 1;\r",
							"  var index = md.digestLength;\r",
							"  for(var j = md.digestLength; j < db.length; j++) {\r",
							"    var code = db.charCodeAt(j);\r",
							"\r",
							"    var is_0 = (code & 0x1) ^ 0x1;\r",
							"\r",
							"    // non-zero if not 0 or 1 in the ps section\r",
							"    var error_mask = in_ps ? 0xfffe : 0x0000;\r",
							"    error |= (code & error_mask);\r",
							"\r",
							"    // latch in_ps to zero after we find 0x1\r",
							"    in_ps = in_ps & is_0;\r",
							"    index += in_ps;\r",
							"  }\r",
							"\r",
							"  if(error || db.charCodeAt(index) !== 0x1) {\r",
							"    throw new Error('Invalid RSAES-OAEP padding.');\r",
							"  }\r",
							"\r",
							"  return db.substring(index + 1);\r",
							"};\r",
							"\r",
							"function rsa_mgf1(seed, maskLength, hash) {\r",
							"  // default to SHA-1 message digest\r",
							"  if(!hash) {\r",
							"    hash = forge.md.sha1.create();\r",
							"  }\r",
							"  var t = '';\r",
							"  var count = Math.ceil(maskLength / hash.digestLength);\r",
							"  for(var i = 0; i < count; ++i) {\r",
							"    var c = String.fromCharCode(\r",
							"      (i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);\r",
							"    hash.start();\r",
							"    hash.update(seed + c);\r",
							"    t += hash.digest().getBytes();\r",
							"  }\r",
							"  return t.substring(0, maskLength);\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 27 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Prime number generation API.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(12);\r",
							"__webpack_require__(2);\r",
							"\r",
							"(function() {\r",
							"\r",
							"// forge.prime already defined\r",
							"if(forge.prime) {\r",
							"  module.exports = forge.prime;\r",
							"  return;\r",
							"}\r",
							"\r",
							"/* PRIME API */\r",
							"var prime = module.exports = forge.prime = forge.prime || {};\r",
							"\r",
							"var BigInteger = forge.jsbn.BigInteger;\r",
							"\r",
							"// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\r",
							"var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\r",
							"var THIRTY = new BigInteger(null);\r",
							"THIRTY.fromInt(30);\r",
							"var op_or = function(x, y) {return x|y;};\r",
							"\r",
							"/**\r",
							" * Generates a random probable prime with the given number of bits.\r",
							" *\r",
							" * Alternative algorithms can be specified by name as a string or as an\r",
							" * object with custom options like so:\r",
							" *\r",
							" * {\r",
							" *   name: 'PRIMEINC',\r",
							" *   options: {\r",
							" *     maxBlockTime: <the maximum amount of time to block the main\r",
							" *       thread before allowing I/O other JS to run>,\r",
							" *     millerRabinTests: <the number of miller-rabin tests to run>,\r",
							" *     workerScript: <the worker script URL>,\r",
							" *     workers: <the number of web workers (if supported) to use,\r",
							" *       -1 to use estimated cores minus one>.\r",
							" *     workLoad: the size of the work load, ie: number of possible prime\r",
							" *       numbers for each web worker to check per work assignment,\r",
							" *       (default: 100).\r",
							" *   }\r",
							" * }\r",
							" *\r",
							" * @param bits the number of bits for the prime number.\r",
							" * @param options the options to use.\r",
							" *          [algorithm] the algorithm to use (default: 'PRIMEINC').\r",
							" *          [prng] a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" *\r",
							" * @return callback(err, num) called once the operation completes.\r",
							" */\r",
							"prime.generateProbablePrime = function(bits, options, callback) {\r",
							"  if(typeof options === 'function') {\r",
							"    callback = options;\r",
							"    options = {};\r",
							"  }\r",
							"  options = options || {};\r",
							"\r",
							"  // default to PRIMEINC algorithm\r",
							"  var algorithm = options.algorithm || 'PRIMEINC';\r",
							"  if(typeof algorithm === 'string') {\r",
							"    algorithm = {name: algorithm};\r",
							"  }\r",
							"  algorithm.options = algorithm.options || {};\r",
							"\r",
							"  // create prng with api that matches BigInteger secure random\r",
							"  var prng = options.prng || forge.random;\r",
							"  var rng = {\r",
							"    // x is an array to fill with bytes\r",
							"    nextBytes: function(x) {\r",
							"      var b = prng.getBytesSync(x.length);\r",
							"      for(var i = 0; i < x.length; ++i) {\r",
							"        x[i] = b.charCodeAt(i);\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  if(algorithm.name === 'PRIMEINC') {\r",
							"    return primeincFindPrime(bits, rng, algorithm.options, callback);\r",
							"  }\r",
							"\r",
							"  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);\r",
							"};\r",
							"\r",
							"function primeincFindPrime(bits, rng, options, callback) {\r",
							"  if('workers' in options) {\r",
							"    return primeincFindPrimeWithWorkers(bits, rng, options, callback);\r",
							"  }\r",
							"  return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\r",
							"}\r",
							"\r",
							"function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\r",
							"  // initialize random number\r",
							"  var num = generateRandom(bits, rng);\r",
							"\r",
							"  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\r",
							"  number we are given is always aligned at 30k + 1. Each time the number is\r",
							"  determined not to be prime we add to get to the next 'i', eg: if the number\r",
							"  was at 30k + 1 we add 6. */\r",
							"  var deltaIdx = 0;\r",
							"\r",
							"  // get required number of MR tests\r",
							"  var mrTests = getMillerRabinTests(num.bitLength());\r",
							"  if('millerRabinTests' in options) {\r",
							"    mrTests = options.millerRabinTests;\r",
							"  }\r",
							"\r",
							"  // find prime nearest to 'num' for maxBlockTime ms\r",
							"  // 10 ms gives 5ms of leeway for other calculations before dropping\r",
							"  // below 60fps (1000/60 == 16.67), but in reality, the number will\r",
							"  // likely be higher due to an 'atomic' big int modPow\r",
							"  var maxBlockTime = 10;\r",
							"  if('maxBlockTime' in options) {\r",
							"    maxBlockTime = options.maxBlockTime;\r",
							"  }\r",
							"\r",
							"  _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\r",
							"}\r",
							"\r",
							"function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\r",
							"  var start = +new Date();\r",
							"  do {\r",
							"    // overflow, regenerate random number\r",
							"    if(num.bitLength() > bits) {\r",
							"      num = generateRandom(bits, rng);\r",
							"    }\r",
							"    // do primality test\r",
							"    if(num.isProbablePrime(mrTests)) {\r",
							"      return callback(null, num);\r",
							"    }\r",
							"    // get next potential prime\r",
							"    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\r",
							"  } while(maxBlockTime < 0 || (+new Date() - start < maxBlockTime));\r",
							"\r",
							"  // keep trying later\r",
							"  forge.util.setImmediate(function() {\r",
							"    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\r",
							"  });\r",
							"}\r",
							"\r",
							"// NOTE: This algorithm is indeterminate in nature because workers\r",
							"// run in parallel looking at different segments of numbers. Even if this\r",
							"// algorithm is run twice with the same input from a predictable RNG, it\r",
							"// may produce different outputs.\r",
							"function primeincFindPrimeWithWorkers(bits, rng, options, callback) {\r",
							"  // web workers unavailable\r",
							"  if(typeof Worker === 'undefined') {\r",
							"    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\r",
							"  }\r",
							"\r",
							"  // initialize random number\r",
							"  var num = generateRandom(bits, rng);\r",
							"\r",
							"  // use web workers to generate keys\r",
							"  var numWorkers = options.workers;\r",
							"  var workLoad = options.workLoad || 100;\r",
							"  var range = workLoad * 30 / 8;\r",
							"  var workerScript = options.workerScript || 'forge/prime.worker.js';\r",
							"  if(numWorkers === -1) {\r",
							"    return forge.util.estimateCores(function(err, cores) {\r",
							"      if(err) {\r",
							"        // default to 2\r",
							"        cores = 2;\r",
							"      }\r",
							"      numWorkers = cores - 1;\r",
							"      generate();\r",
							"    });\r",
							"  }\r",
							"  generate();\r",
							"\r",
							"  function generate() {\r",
							"    // require at least 1 worker\r",
							"    numWorkers = Math.max(1, numWorkers);\r",
							"\r",
							"    // TODO: consider optimizing by starting workers outside getPrime() ...\r",
							"    // note that in order to clean up they will have to be made internally\r",
							"    // asynchronous which may actually be slower\r",
							"\r",
							"    // start workers immediately\r",
							"    var workers = [];\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      // FIXME: fix path or use blob URLs\r",
							"      workers[i] = new Worker(workerScript);\r",
							"    }\r",
							"    var running = numWorkers;\r",
							"\r",
							"    // listen for requests from workers and assign ranges to find prime\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      workers[i].addEventListener('message', workerMessage);\r",
							"    }\r",
							"\r",
							"    /* Note: The distribution of random numbers is unknown. Therefore, each\r",
							"    web worker is continuously allocated a range of numbers to check for a\r",
							"    random number until one is found.\r",
							"\r",
							"    Every 30 numbers will be checked just 8 times, because prime numbers\r",
							"    have the form:\r",
							"\r",
							"    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\r",
							"\r",
							"    Therefore, if we want a web worker to run N checks before asking for\r",
							"    a new range of numbers, each range must contain N*30/8 numbers.\r",
							"\r",
							"    For 100 checks (workLoad), this is a range of 375. */\r",
							"\r",
							"    var found = false;\r",
							"    function workerMessage(e) {\r",
							"      // ignore message, prime already found\r",
							"      if(found) {\r",
							"        return;\r",
							"      }\r",
							"\r",
							"      --running;\r",
							"      var data = e.data;\r",
							"      if(data.found) {\r",
							"        // terminate all workers\r",
							"        for(var i = 0; i < workers.length; ++i) {\r",
							"          workers[i].terminate();\r",
							"        }\r",
							"        found = true;\r",
							"        return callback(null, new BigInteger(data.prime, 16));\r",
							"      }\r",
							"\r",
							"      // overflow, regenerate random number\r",
							"      if(num.bitLength() > bits) {\r",
							"        num = generateRandom(bits, rng);\r",
							"      }\r",
							"\r",
							"      // assign new range to check\r",
							"      var hex = num.toString(16);\r",
							"\r",
							"      // start prime search\r",
							"      e.target.postMessage({\r",
							"        hex: hex,\r",
							"        workLoad: workLoad\r",
							"      });\r",
							"\r",
							"      num.dAddOffset(range, 0);\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Generates a random number using the given number of bits and RNG.\r",
							" *\r",
							" * @param bits the number of bits for the number.\r",
							" * @param rng the random number generator to use.\r",
							" *\r",
							" * @return the random number.\r",
							" */\r",
							"function generateRandom(bits, rng) {\r",
							"  var num = new BigInteger(bits, rng);\r",
							"  // force MSB set\r",
							"  var bits1 = bits - 1;\r",
							"  if(!num.testBit(bits1)) {\r",
							"    num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\r",
							"  }\r",
							"  // align number on 30k+1 boundary\r",
							"  num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\r",
							"  return num;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Returns the required number of Miller-Rabin tests to generate a\r",
							" * prime with an error probability of (1/2)^80.\r",
							" *\r",
							" * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\r",
							" *\r",
							" * @param bits the bit size.\r",
							" *\r",
							" * @return the required number of iterations.\r",
							" */\r",
							"function getMillerRabinTests(bits) {\r",
							"  if(bits <= 100) return 27;\r",
							"  if(bits <= 150) return 18;\r",
							"  if(bits <= 200) return 15;\r",
							"  if(bits <= 250) return 12;\r",
							"  if(bits <= 300) return 9;\r",
							"  if(bits <= 350) return 8;\r",
							"  if(bits <= 400) return 7;\r",
							"  if(bits <= 500) return 6;\r",
							"  if(bits <= 600) return 5;\r",
							"  if(bits <= 800) return 4;\r",
							"  if(bits <= 1250) return 3;\r",
							"  return 2;\r",
							"}\r",
							"\r",
							"})();\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 28 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of PKCS#12.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * The ASN.1 representation of PKCS#12 is as follows\r",
							" * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\r",
							" *\r",
							" * PFX ::= SEQUENCE {\r",
							" *   version  INTEGER {v3(3)}(v3,...),\r",
							" *   authSafe ContentInfo,\r",
							" *   macData  MacData OPTIONAL\r",
							" * }\r",
							" *\r",
							" * MacData ::= SEQUENCE {\r",
							" *   mac DigestInfo,\r",
							" *   macSalt OCTET STRING,\r",
							" *   iterations INTEGER DEFAULT 1\r",
							" * }\r",
							" * Note: The iterations default is for historical reasons and its use is\r",
							" * deprecated. A higher value, like 1024, is recommended.\r",
							" *\r",
							" * DigestInfo is defined in PKCS#7 as follows:\r",
							" *\r",
							" * DigestInfo ::= SEQUENCE {\r",
							" *   digestAlgorithm DigestAlgorithmIdentifier,\r",
							" *   digest Digest\r",
							" * }\r",
							" *\r",
							" * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r",
							" * for the algorithm, if any. In the case of SHA1 there is none.\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *    algorithm OBJECT IDENTIFIER,\r",
							" *    parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * Digest ::= OCTET STRING\r",
							" *\r",
							" *\r",
							" * ContentInfo ::= SEQUENCE {\r",
							" *   contentType ContentType,\r",
							" *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\r",
							" * }\r",
							" *\r",
							" * ContentType ::= OBJECT IDENTIFIER\r",
							" *\r",
							" * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r",
							" * -- Data if unencrypted\r",
							" * -- EncryptedData if password-encrypted\r",
							" * -- EnvelopedData if public key-encrypted\r",
							" *\r",
							" *\r",
							" * SafeContents ::= SEQUENCE OF SafeBag\r",
							" *\r",
							" * SafeBag ::= SEQUENCE {\r",
							" *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\r",
							" *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r",
							" *   bagAttributes SET OF PKCS12Attribute OPTIONAL\r",
							" * }\r",
							" *\r",
							" * PKCS12Attribute ::= SEQUENCE {\r",
							" *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\r",
							" *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\r",
							" * } -- This type is compatible with the X.500 type Attribute\r",
							" *\r",
							" * PKCS12AttrSet ATTRIBUTE ::= {\r",
							" *   friendlyName | -- from PKCS #9\r",
							" *   localKeyId, -- from PKCS #9\r",
							" *   ... -- Other attributes are allowed\r",
							" * }\r",
							" *\r",
							" * CertBag ::= SEQUENCE {\r",
							" *   certId    BAG-TYPE.&id   ({CertTypes}),\r",
							" *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r",
							" * }\r",
							" *\r",
							" * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\r",
							" *   -- DER-encoded X.509 certificate stored in OCTET STRING\r",
							" *\r",
							" * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\r",
							" * -- Base64-encoded SDSI certificate stored in IA5String\r",
							" *\r",
							" * CertTypes BAG-TYPE ::= {\r",
							" *   x509Certificate |\r",
							" *   sdsiCertificate,\r",
							" *   ... -- For future extensions\r",
							" * }\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(29);\r",
							"__webpack_require__(21);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(16);\r",
							"\r",
							"// shortcut for asn.1 & PKI API\r",
							"var asn1 = forge.asn1;\r",
							"var pki = forge.pki;\r",
							"\r",
							"// shortcut for PKCS#12 API\r",
							"var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\r",
							"\r",
							"var contentInfoValidator = {\r",
							"  name: 'ContentInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,  // a ContentInfo\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'ContentInfo.contentType',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'contentType'\r",
							"  }, {\r",
							"    name: 'ContentInfo.content',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'content'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var pfxValidator = {\r",
							"  name: 'PFX',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'PFX.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  },\r",
							"  contentInfoValidator, {\r",
							"    name: 'PFX.macData',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    captureAsn1: 'mac',\r",
							"    value: [{\r",
							"      name: 'PFX.macData.mac',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,  // DigestInfo\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'PFX.macData.mac.digestAlgorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier\r",
							"        constructed: true,\r",
							"        value: [{\r",
							"          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          type: asn1.Type.OID,\r",
							"          constructed: false,\r",
							"          capture: 'macAlgorithm'\r",
							"        }, {\r",
							"          name: 'PFX.macData.mac.digestAlgorithm.parameters',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          captureAsn1: 'macAlgorithmParameters'\r",
							"        }]\r",
							"      }, {\r",
							"        name: 'PFX.macData.mac.digest',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OCTETSTRING,\r",
							"        constructed: false,\r",
							"        capture: 'macDigest'\r",
							"      }]\r",
							"    }, {\r",
							"      name: 'PFX.macData.macSalt',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OCTETSTRING,\r",
							"      constructed: false,\r",
							"      capture: 'macSalt'\r",
							"    }, {\r",
							"      name: 'PFX.macData.iterations',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      optional: true,\r",
							"      capture: 'macIterations'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"var safeBagValidator = {\r",
							"  name: 'SafeBag',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'SafeBag.bagId',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'bagId'\r",
							"  }, {\r",
							"    name: 'SafeBag.bagValue',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'bagValue'\r",
							"  }, {\r",
							"    name: 'SafeBag.bagAttributes',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'bagAttributes'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var attributeValidator = {\r",
							"  name: 'Attribute',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'Attribute.attrId',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'oid'\r",
							"  }, {\r",
							"    name: 'Attribute.attrValues',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    capture: 'values'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var certBagValidator = {\r",
							"  name: 'CertBag',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'CertBag.certId',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'certId'\r",
							"  }, {\r",
							"    name: 'CertBag.certValue',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    constructed: true,\r",
							"    /* So far we only support X.509 certificates (which are wrapped in\r",
							"       an OCTET STRING, hence hard code that here). */\r",
							"    value: [{\r",
							"      name: 'CertBag.certValue[0]',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.OCTETSTRING,\r",
							"      constructed: false,\r",
							"      capture: 'cert'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Search SafeContents structure for bags with matching attributes.\r",
							" *\r",
							" * The search can optionally be narrowed by a certain bag type.\r",
							" *\r",
							" * @param safeContents the SafeContents structure to search in.\r",
							" * @param attrName the name of the attribute to compare against.\r",
							" * @param attrValue the attribute value to search for.\r",
							" * @param [bagType] bag type to narrow search by.\r",
							" *\r",
							" * @return an array of matching bags.\r",
							" */\r",
							"function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\r",
							"  var result = [];\r",
							"\r",
							"  for(var i = 0; i < safeContents.length; i++) {\r",
							"    for(var j = 0; j < safeContents[i].safeBags.length; j++) {\r",
							"      var bag = safeContents[i].safeBags[j];\r",
							"      if(bagType !== undefined && bag.type !== bagType) {\r",
							"        continue;\r",
							"      }\r",
							"      // only filter by bag type, no attribute specified\r",
							"      if(attrName === null) {\r",
							"        result.push(bag);\r",
							"        continue;\r",
							"      }\r",
							"      if(bag.attributes[attrName] !== undefined &&\r",
							"        bag.attributes[attrName].indexOf(attrValue) >= 0) {\r",
							"        result.push(bag);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return result;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\r",
							" *\r",
							" * @param obj The PKCS#12 PFX in ASN.1 notation.\r",
							" * @param strict true to use strict DER decoding, false not to (default: true).\r",
							" * @param {String} password Password to decrypt with (optional).\r",
							" *\r",
							" * @return PKCS#12 PFX object.\r",
							" */\r",
							"p12.pkcs12FromAsn1 = function(obj, strict, password) {\r",
							"  // handle args\r",
							"  if(typeof strict === 'string') {\r",
							"    password = strict;\r",
							"    strict = true;\r",
							"  } else if(strict === undefined) {\r",
							"    strict = true;\r",
							"  }\r",
							"\r",
							"  // validate PFX and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, pfxValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#12 PFX. ' +\r",
							"      'ASN.1 object is not an PKCS#12 PFX.');\r",
							"    error.errors = error;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var pfx = {\r",
							"    version: capture.version.charCodeAt(0),\r",
							"    safeContents: [],\r",
							"\r",
							"    /**\r",
							"     * Gets bags with matching attributes.\r",
							"     *\r",
							"     * @param filter the attributes to filter by:\r",
							"     *          [localKeyId] the localKeyId to search for.\r",
							"     *          [localKeyIdHex] the localKeyId in hex to search for.\r",
							"     *          [friendlyName] the friendly name to search for.\r",
							"     *          [bagType] bag type to narrow each attribute search by.\r",
							"     *\r",
							"     * @return a map of attribute type to an array of matching bags or, if no\r",
							"     *           attribute was given but a bag type, the map key will be the\r",
							"     *           bag type.\r",
							"     */\r",
							"    getBags: function(filter) {\r",
							"      var rval = {};\r",
							"\r",
							"      var localKeyId;\r",
							"      if('localKeyId' in filter) {\r",
							"        localKeyId = filter.localKeyId;\r",
							"      } else if('localKeyIdHex' in filter) {\r",
							"        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\r",
							"      }\r",
							"\r",
							"      // filter on bagType only\r",
							"      if(localKeyId === undefined && !('friendlyName' in filter) &&\r",
							"        'bagType' in filter) {\r",
							"        rval[filter.bagType] = _getBagsByAttribute(\r",
							"          pfx.safeContents, null, null, filter.bagType);\r",
							"      }\r",
							"\r",
							"      if(localKeyId !== undefined) {\r",
							"        rval.localKeyId = _getBagsByAttribute(\r",
							"          pfx.safeContents, 'localKeyId',\r",
							"          localKeyId, filter.bagType);\r",
							"      }\r",
							"      if('friendlyName' in filter) {\r",
							"        rval.friendlyName = _getBagsByAttribute(\r",
							"          pfx.safeContents, 'friendlyName',\r",
							"          filter.friendlyName, filter.bagType);\r",
							"      }\r",
							"\r",
							"      return rval;\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * DEPRECATED: use getBags() instead.\r",
							"     *\r",
							"     * Get bags with matching friendlyName attribute.\r",
							"     *\r",
							"     * @param friendlyName the friendly name to search for.\r",
							"     * @param [bagType] bag type to narrow search by.\r",
							"     *\r",
							"     * @return an array of bags with matching friendlyName attribute.\r",
							"     */\r",
							"    getBagsByFriendlyName: function(friendlyName, bagType) {\r",
							"      return _getBagsByAttribute(\r",
							"        pfx.safeContents, 'friendlyName', friendlyName, bagType);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * DEPRECATED: use getBags() instead.\r",
							"     *\r",
							"     * Get bags with matching localKeyId attribute.\r",
							"     *\r",
							"     * @param localKeyId the localKeyId to search for.\r",
							"     * @param [bagType] bag type to narrow search by.\r",
							"     *\r",
							"     * @return an array of bags with matching localKeyId attribute.\r",
							"     */\r",
							"    getBagsByLocalKeyId: function(localKeyId, bagType) {\r",
							"      return _getBagsByAttribute(\r",
							"        pfx.safeContents, 'localKeyId', localKeyId, bagType);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  if(capture.version.charCodeAt(0) !== 3) {\r",
							"    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\r",
							"    error.version = capture.version.charCodeAt(0);\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {\r",
							"    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\r",
							"    error.oid = asn1.derToOid(capture.contentType);\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var data = capture.content.value[0];\r",
							"  if(data.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"     data.type !== asn1.Type.OCTETSTRING) {\r",
							"    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\r",
							"  }\r",
							"  data = _decodePkcs7Data(data);\r",
							"\r",
							"  // check for MAC\r",
							"  if(capture.mac) {\r",
							"    var md = null;\r",
							"    var macKeyBytes = 0;\r",
							"    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\r",
							"    switch(macAlgorithm) {\r",
							"    case pki.oids.sha1:\r",
							"      md = forge.md.sha1.create();\r",
							"      macKeyBytes = 20;\r",
							"      break;\r",
							"    case pki.oids.sha256:\r",
							"      md = forge.md.sha256.create();\r",
							"      macKeyBytes = 32;\r",
							"      break;\r",
							"    case pki.oids.sha384:\r",
							"      md = forge.md.sha384.create();\r",
							"      macKeyBytes = 48;\r",
							"      break;\r",
							"    case pki.oids.sha512:\r",
							"      md = forge.md.sha512.create();\r",
							"      macKeyBytes = 64;\r",
							"      break;\r",
							"    case pki.oids.md5:\r",
							"      md = forge.md.md5.create();\r",
							"      macKeyBytes = 16;\r",
							"      break;\r",
							"    }\r",
							"    if(md === null) {\r",
							"      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\r",
							"    }\r",
							"\r",
							"    // verify MAC (iterations default to 1)\r",
							"    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\r",
							"    var macIterations = (('macIterations' in capture) ?\r",
							"      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);\r",
							"    var macKey = p12.generateKey(\r",
							"      password, macSalt, 3, macIterations, macKeyBytes, md);\r",
							"    var mac = forge.hmac.create();\r",
							"    mac.start(md, macKey);\r",
							"    mac.update(data.value);\r",
							"    var macValue = mac.getMac();\r",
							"    if(macValue.getBytes() !== capture.macDigest) {\r",
							"      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\r",
							"  return pfx;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\r",
							" * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\r",
							" * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\r",
							" * function transforms this corner-case into the usual simple,\r",
							" * non-composed/constructed OCTET STRING.\r",
							" *\r",
							" * This function may be moved to ASN.1 at some point to better deal with\r",
							" * more BER-encoding issues, should they arise.\r",
							" *\r",
							" * @param data the ASN.1 Data object to transform.\r",
							" */\r",
							"function _decodePkcs7Data(data) {\r",
							"  // handle special case of \"chunked\" data content: an octet string composed\r",
							"  // of other octet strings\r",
							"  if(data.composed || data.constructed) {\r",
							"    var value = forge.util.createBuffer();\r",
							"    for(var i = 0; i < data.value.length; ++i) {\r",
							"      value.putBytes(data.value[i].value);\r",
							"    }\r",
							"    data.composed = data.constructed = false;\r",
							"    data.value = value.getBytes();\r",
							"  }\r",
							"  return data;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\r",
							" *\r",
							" * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\r",
							" *\r",
							" * @param pfx The PKCS#12 PFX object to fill.\r",
							" * @param {String} authSafe BER-encoded AuthenticatedSafe.\r",
							" * @param strict true to use strict DER decoding, false not to.\r",
							" * @param {String} password Password to decrypt with (optional).\r",
							" */\r",
							"function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\r",
							"  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */\r",
							"\r",
							"  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"     authSafe.type !== asn1.Type.SEQUENCE ||\r",
							"     authSafe.constructed !== true) {\r",
							"    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +\r",
							"      'SEQUENCE OF ContentInfo');\r",
							"  }\r",
							"\r",
							"  for(var i = 0; i < authSafe.value.length; i++) {\r",
							"    var contentInfo = authSafe.value[i];\r",
							"\r",
							"    // validate contentInfo and capture data\r",
							"    var capture = {};\r",
							"    var errors = [];\r",
							"    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\r",
							"      var error = new Error('Cannot read ContentInfo.');\r",
							"      error.errors = errors;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    var obj = {\r",
							"      encrypted: false\r",
							"    };\r",
							"    var safeContents = null;\r",
							"    var data = capture.content.value[0];\r",
							"    switch(asn1.derToOid(capture.contentType)) {\r",
							"    case pki.oids.data:\r",
							"      if(data.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"         data.type !== asn1.Type.OCTETSTRING) {\r",
							"        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\r",
							"      }\r",
							"      safeContents = _decodePkcs7Data(data).value;\r",
							"      break;\r",
							"    case pki.oids.encryptedData:\r",
							"      safeContents = _decryptSafeContents(data, password);\r",
							"      obj.encrypted = true;\r",
							"      break;\r",
							"    default:\r",
							"      var error = new Error('Unsupported PKCS#12 contentType.');\r",
							"      error.contentType = asn1.derToOid(capture.contentType);\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\r",
							"    pfx.safeContents.push(obj);\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decrypt PKCS#7 EncryptedData structure.\r",
							" *\r",
							" * @param data ASN.1 encoded EncryptedContentInfo object.\r",
							" * @param password The user-provided password.\r",
							" *\r",
							" * @return The decrypted SafeContents (ASN.1 object).\r",
							" */\r",
							"function _decryptSafeContents(data, password) {\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(\r",
							"    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read EncryptedContentInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var oid = asn1.derToOid(capture.contentType);\r",
							"  if(oid !== pki.oids.data) {\r",
							"    var error = new Error(\r",
							"      'PKCS#12 EncryptedContentInfo ContentType is not Data.');\r",
							"    error.oid = oid;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get cipher\r",
							"  oid = asn1.derToOid(capture.encAlgorithm);\r",
							"  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\r",
							"\r",
							"  // get encrypted data\r",
							"  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\r",
							"  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\r",
							"\r",
							"  cipher.update(encrypted);\r",
							"  if(!cipher.finish()) {\r",
							"    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\r",
							"  }\r",
							"\r",
							"  return cipher.output.getBytes();\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\r",
							" *\r",
							" * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\r",
							" *\r",
							" * @param {String} safeContents BER-encoded safeContents.\r",
							" * @param strict true to use strict DER decoding, false not to.\r",
							" * @param {String} password Password to decrypt with (optional).\r",
							" *\r",
							" * @return {Array} Array of Bag objects.\r",
							" */\r",
							"function _decodeSafeContents(safeContents, strict, password) {\r",
							"  // if strict and no safe contents, return empty safes\r",
							"  if(!strict && safeContents.length === 0) {\r",
							"    return [];\r",
							"  }\r",
							"\r",
							"  // actually it's BER-encoded\r",
							"  safeContents = asn1.fromDer(safeContents, strict);\r",
							"\r",
							"  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"    safeContents.type !== asn1.Type.SEQUENCE ||\r",
							"    safeContents.constructed !== true) {\r",
							"    throw new Error(\r",
							"      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\r",
							"  }\r",
							"\r",
							"  var res = [];\r",
							"  for(var i = 0; i < safeContents.value.length; i++) {\r",
							"    var safeBag = safeContents.value[i];\r",
							"\r",
							"    // validate SafeBag and capture data\r",
							"    var capture = {};\r",
							"    var errors = [];\r",
							"    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\r",
							"      var error = new Error('Cannot read SafeBag.');\r",
							"      error.errors = errors;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    /* Create bag object and push to result array. */\r",
							"    var bag = {\r",
							"      type: asn1.derToOid(capture.bagId),\r",
							"      attributes: _decodeBagAttributes(capture.bagAttributes)\r",
							"    };\r",
							"    res.push(bag);\r",
							"\r",
							"    var validator, decoder;\r",
							"    var bagAsn1 = capture.bagValue.value[0];\r",
							"    switch(bag.type) {\r",
							"      case pki.oids.pkcs8ShroudedKeyBag:\r",
							"        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\r",
							"           Afterwards we can handle it like a keyBag,\r",
							"           which is a PrivateKeyInfo. */\r",
							"        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\r",
							"        if(bagAsn1 === null) {\r",
							"          throw new Error(\r",
							"            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\r",
							"        }\r",
							"\r",
							"        /* fall through */\r",
							"      case pki.oids.keyBag:\r",
							"        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\r",
							"           PKI module, hence we don't have to do validation/capturing here,\r",
							"           just pass what we already got. */\r",
							"        try {\r",
							"          bag.key = pki.privateKeyFromAsn1(bagAsn1);\r",
							"        } catch(e) {\r",
							"          // ignore unknown key type, pass asn1 value\r",
							"          bag.key = null;\r",
							"          bag.asn1 = bagAsn1;\r",
							"        }\r",
							"        continue;  /* Nothing more to do. */\r",
							"\r",
							"      case pki.oids.certBag:\r",
							"        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\r",
							"           Therefore put the SafeBag content through another validator to\r",
							"           capture the fields.  Afterwards check & store the results. */\r",
							"        validator = certBagValidator;\r",
							"        decoder = function() {\r",
							"          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\r",
							"            var error = new Error(\r",
							"              'Unsupported certificate type, only X.509 supported.');\r",
							"            error.oid = asn1.derToOid(capture.certId);\r",
							"            throw error;\r",
							"          }\r",
							"\r",
							"          // true=produce cert hash\r",
							"          var certAsn1 = asn1.fromDer(capture.cert, strict);\r",
							"          try {\r",
							"            bag.cert = pki.certificateFromAsn1(certAsn1, true);\r",
							"          } catch(e) {\r",
							"            // ignore unknown cert type, pass asn1 value\r",
							"            bag.cert = null;\r",
							"            bag.asn1 = certAsn1;\r",
							"          }\r",
							"        };\r",
							"        break;\r",
							"\r",
							"      default:\r",
							"        var error = new Error('Unsupported PKCS#12 SafeBag type.');\r",
							"        error.oid = bag.type;\r",
							"        throw error;\r",
							"    }\r",
							"\r",
							"    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\r",
							"    if(validator !== undefined &&\r",
							"       !asn1.validate(bagAsn1, validator, capture, errors)) {\r",
							"      var error = new Error('Cannot read PKCS#12 ' + validator.name);\r",
							"      error.errors = errors;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    /* Call decoder function from above to store the results. */\r",
							"    decoder();\r",
							"  }\r",
							"\r",
							"  return res;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\r",
							" *\r",
							" * @param attributes SET OF PKCS12Attribute (ASN.1 object).\r",
							" *\r",
							" * @return the decoded attributes.\r",
							" */\r",
							"function _decodeBagAttributes(attributes) {\r",
							"  var decodedAttrs = {};\r",
							"\r",
							"  if(attributes !== undefined) {\r",
							"    for(var i = 0; i < attributes.length; ++i) {\r",
							"      var capture = {};\r",
							"      var errors = [];\r",
							"      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\r",
							"        var error = new Error('Cannot read PKCS#12 BagAttribute.');\r",
							"        error.errors = errors;\r",
							"        throw error;\r",
							"      }\r",
							"\r",
							"      var oid = asn1.derToOid(capture.oid);\r",
							"      if(pki.oids[oid] === undefined) {\r",
							"        // unsupported attribute type, ignore.\r",
							"        continue;\r",
							"      }\r",
							"\r",
							"      decodedAttrs[pki.oids[oid]] = [];\r",
							"      for(var j = 0; j < capture.values.length; ++j) {\r",
							"        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return decodedAttrs;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\r",
							" * password is provided then the private key will be encrypted.\r",
							" *\r",
							" * An entire certificate chain may also be included. To do this, pass\r",
							" * an array for the \"cert\" parameter where the first certificate is\r",
							" * the one that is paired with the private key and each subsequent one\r",
							" * verifies the previous one. The certificates may be in PEM format or\r",
							" * have been already parsed by Forge.\r",
							" *\r",
							" * @todo implement password-based-encryption for the whole package\r",
							" *\r",
							" * @param key the private key.\r",
							" * @param cert the certificate (may be an array of certificates in order\r",
							" *          to specify a certificate chain).\r",
							" * @param password the password to use, null for none.\r",
							" * @param options:\r",
							" *          algorithm the encryption algorithm to use\r",
							" *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r",
							" *          count the iteration count to use.\r",
							" *          saltSize the salt size to use.\r",
							" *          useMac true to include a MAC, false not to, defaults to true.\r",
							" *          localKeyId the local key ID to use, in hex.\r",
							" *          friendlyName the friendly name to use.\r",
							" *          generateLocalKeyId true to generate a random local key ID,\r",
							" *            false not to, defaults to true.\r",
							" *\r",
							" * @return the PKCS#12 PFX ASN.1 object.\r",
							" */\r",
							"p12.toPkcs12Asn1 = function(key, cert, password, options) {\r",
							"  // set default options\r",
							"  options = options || {};\r",
							"  options.saltSize = options.saltSize || 8;\r",
							"  options.count = options.count || 2048;\r",
							"  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\r",
							"  if(!('useMac' in options)) {\r",
							"    options.useMac = true;\r",
							"  }\r",
							"  if(!('localKeyId' in options)) {\r",
							"    options.localKeyId = null;\r",
							"  }\r",
							"  if(!('generateLocalKeyId' in options)) {\r",
							"    options.generateLocalKeyId = true;\r",
							"  }\r",
							"\r",
							"  var localKeyId = options.localKeyId;\r",
							"  var bagAttrs;\r",
							"  if(localKeyId !== null) {\r",
							"    localKeyId = forge.util.hexToBytes(localKeyId);\r",
							"  } else if(options.generateLocalKeyId) {\r",
							"    // use SHA-1 of paired cert, if available\r",
							"    if(cert) {\r",
							"      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\r",
							"      if(typeof pairedCert === 'string') {\r",
							"        pairedCert = pki.certificateFromPem(pairedCert);\r",
							"      }\r",
							"      var sha1 = forge.md.sha1.create();\r",
							"      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\r",
							"      localKeyId = sha1.digest().getBytes();\r",
							"    } else {\r",
							"      // FIXME: consider using SHA-1 of public key (which can be generated\r",
							"      // from private key components), see: cert.generateSubjectKeyIdentifier\r",
							"      // generate random bytes\r",
							"      localKeyId = forge.random.getBytes(20);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  var attrs = [];\r",
							"  if(localKeyId !== null) {\r",
							"    attrs.push(\r",
							"      // localKeyID\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // attrId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.localKeyId).getBytes()),\r",
							"        // attrValues\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"            localKeyId)\r",
							"        ])\r",
							"      ]));\r",
							"  }\r",
							"  if('friendlyName' in options) {\r",
							"    attrs.push(\r",
							"      // friendlyName\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // attrId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.friendlyName).getBytes()),\r",
							"        // attrValues\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,\r",
							"            options.friendlyName)\r",
							"        ])\r",
							"      ]));\r",
							"  }\r",
							"\r",
							"  if(attrs.length > 0) {\r",
							"    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\r",
							"  }\r",
							"\r",
							"  // collect contents for AuthenticatedSafe\r",
							"  var contents = [];\r",
							"\r",
							"  // create safe bag(s) for certificate chain\r",
							"  var chain = [];\r",
							"  if(cert !== null) {\r",
							"    if(forge.util.isArray(cert)) {\r",
							"      chain = cert;\r",
							"    } else {\r",
							"      chain = [cert];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  var certSafeBags = [];\r",
							"  for(var i = 0; i < chain.length; ++i) {\r",
							"    // convert cert from PEM as necessary\r",
							"    cert = chain[i];\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = pki.certificateFromPem(cert);\r",
							"    }\r",
							"\r",
							"    // SafeBag\r",
							"    var certBagAttrs = (i === 0) ? bagAttrs : undefined;\r",
							"    var certAsn1 = pki.certificateToAsn1(cert);\r",
							"    var certSafeBag =\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // bagId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.certBag).getBytes()),\r",
							"        // bagValue\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          // CertBag\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            // certId\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\r",
							"            // certValue (x509Certificate)\r",
							"            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"              asn1.create(\r",
							"                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"                asn1.toDer(certAsn1).getBytes())\r",
							"            ])])]),\r",
							"        // bagAttributes (OPTIONAL)\r",
							"        certBagAttrs\r",
							"      ]);\r",
							"    certSafeBags.push(certSafeBag);\r",
							"  }\r",
							"\r",
							"  if(certSafeBags.length > 0) {\r",
							"    // SafeContents\r",
							"    var certSafeContents = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\r",
							"\r",
							"    // ContentInfo\r",
							"    var certCI =\r",
							"      // PKCS#7 ContentInfo\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // contentType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          // OID for the content type is 'data'\r",
							"          asn1.oidToDer(pki.oids.data).getBytes()),\r",
							"        // content\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"            asn1.toDer(certSafeContents).getBytes())\r",
							"        ])\r",
							"      ]);\r",
							"    contents.push(certCI);\r",
							"  }\r",
							"\r",
							"  // create safe contents for private key\r",
							"  var keyBag = null;\r",
							"  if(key !== null) {\r",
							"    // SafeBag\r",
							"    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\r",
							"    if(password === null) {\r",
							"      // no encryption\r",
							"      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // bagId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.keyBag).getBytes()),\r",
							"        // bagValue\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          // PrivateKeyInfo\r",
							"          pkAsn1\r",
							"        ]),\r",
							"        // bagAttributes (OPTIONAL)\r",
							"        bagAttrs\r",
							"      ]);\r",
							"    } else {\r",
							"      // encrypted PrivateKeyInfo\r",
							"      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // bagId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\r",
							"        // bagValue\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          // EncryptedPrivateKeyInfo\r",
							"          pki.encryptPrivateKeyInfo(pkAsn1, password, options)\r",
							"        ]),\r",
							"        // bagAttributes (OPTIONAL)\r",
							"        bagAttrs\r",
							"      ]);\r",
							"    }\r",
							"\r",
							"    // SafeContents\r",
							"    var keySafeContents =\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\r",
							"\r",
							"    // ContentInfo\r",
							"    var keyCI =\r",
							"      // PKCS#7 ContentInfo\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // contentType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          // OID for the content type is 'data'\r",
							"          asn1.oidToDer(pki.oids.data).getBytes()),\r",
							"        // content\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"            asn1.toDer(keySafeContents).getBytes())\r",
							"        ])\r",
							"      ]);\r",
							"    contents.push(keyCI);\r",
							"  }\r",
							"\r",
							"  // create AuthenticatedSafe by stringing together the contents\r",
							"  var safe = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\r",
							"\r",
							"  var macData;\r",
							"  if(options.useMac) {\r",
							"    // MacData\r",
							"    var sha1 = forge.md.sha1.create();\r",
							"    var macSalt = new forge.util.ByteBuffer(\r",
							"      forge.random.getBytes(options.saltSize));\r",
							"    var count = options.count;\r",
							"    // 160-bit key\r",
							"    var key = p12.generateKey(password, macSalt, 3, count, 20);\r",
							"    var mac = forge.hmac.create();\r",
							"    mac.start(sha1, key);\r",
							"    mac.update(asn1.toDer(safe).getBytes());\r",
							"    var macValue = mac.getMac();\r",
							"    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // mac DigestInfo\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // digestAlgorithm\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // algorithm = SHA-1\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(pki.oids.sha1).getBytes()),\r",
							"          // parameters = Null\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"        ]),\r",
							"        // digest\r",
							"        asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\r",
							"          false, macValue.getBytes())\r",
							"      ]),\r",
							"      // macSalt OCTET STRING\r",
							"      asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\r",
							"      // iterations INTEGER (XXX: Only support count < 65536)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        asn1.integerToDer(count).getBytes()\r",
							"      )\r",
							"    ]);\r",
							"  }\r",
							"\r",
							"  // PFX\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version (3)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(3).getBytes()),\r",
							"    // PKCS#7 ContentInfo\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // contentType\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        // OID for the content type is 'data'\r",
							"        asn1.oidToDer(pki.oids.data).getBytes()),\r",
							"      // content\r",
							"      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"        asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"          asn1.toDer(safe).getBytes())\r",
							"      ])\r",
							"    ]),\r",
							"    macData\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Derives a PKCS#12 key.\r",
							" *\r",
							" * @param password the password to derive the key material from, null or\r",
							" *          undefined for none.\r",
							" * @param salt the salt, as a ByteBuffer, to use.\r",
							" * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r",
							" * @param iter the iteration count.\r",
							" * @param n the number of bytes to derive from the password.\r",
							" * @param md the message digest to use, defaults to SHA-1.\r",
							" *\r",
							" * @return a ByteBuffer with the bytes derived from the password.\r",
							" */\r",
							"p12.generateKey = forge.pbe.generatePkcs12Key;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 29 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright (c) 2012-2015 Digital Bazaar, Inc.\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * The ASN.1 representation of PKCS#7 is as follows\r",
							" * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):\r",
							" *\r",
							" * A PKCS#7 message consists of a ContentInfo on root level, which may\r",
							" * contain any number of further ContentInfo nested into it.\r",
							" *\r",
							" * ContentInfo ::= SEQUENCE {\r",
							" *   contentType                ContentType,\r",
							" *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL\r",
							" * }\r",
							" *\r",
							" * ContentType ::= OBJECT IDENTIFIER\r",
							" *\r",
							" * EnvelopedData ::= SEQUENCE {\r",
							" *   version                    Version,\r",
							" *   recipientInfos             RecipientInfos,\r",
							" *   encryptedContentInfo       EncryptedContentInfo\r",
							" * }\r",
							" *\r",
							" * EncryptedData ::= SEQUENCE {\r",
							" *   version                    Version,\r",
							" *   encryptedContentInfo       EncryptedContentInfo\r",
							" * }\r",
							" *\r",
							" * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)\r",
							" *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }\r",
							" *\r",
							" * SignedData ::= SEQUENCE {\r",
							" *   version           INTEGER,\r",
							" *   digestAlgorithms  DigestAlgorithmIdentifiers,\r",
							" *   contentInfo       ContentInfo,\r",
							" *   certificates      [0] IMPLICIT Certificates OPTIONAL,\r",
							" *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,\r",
							" *   signerInfos       SignerInfos\r",
							" * }\r",
							" *\r",
							" * SignerInfos ::= SET OF SignerInfo\r",
							" *\r",
							" * SignerInfo ::= SEQUENCE {\r",
							" *   version                    Version,\r",
							" *   issuerAndSerialNumber      IssuerAndSerialNumber,\r",
							" *   digestAlgorithm            DigestAlgorithmIdentifier,\r",
							" *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,\r",
							" *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,\r",
							" *   encryptedDigest            EncryptedDigest,\r",
							" *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL\r",
							" * }\r",
							" *\r",
							" * EncryptedDigest ::= OCTET STRING\r",
							" *\r",
							" * Attributes ::= SET OF Attribute\r",
							" *\r",
							" * Attribute ::= SEQUENCE {\r",
							" *   attrType    OBJECT IDENTIFIER,\r",
							" *   attrValues  SET OF AttributeValue\r",
							" * }\r",
							" *\r",
							" * AttributeValue ::= ANY\r",
							" *\r",
							" * Version ::= INTEGER\r",
							" *\r",
							" * RecipientInfos ::= SET OF RecipientInfo\r",
							" *\r",
							" * EncryptedContentInfo ::= SEQUENCE {\r",
							" *   contentType                 ContentType,\r",
							" *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,\r",
							" *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL\r",
							" * }\r",
							" *\r",
							" * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r",
							" * for the algorithm, if any. In the case of AES and DES3, there is only one,\r",
							" * the IV.\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *    algorithm OBJECT IDENTIFIER,\r",
							" *    parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * EncryptedContent ::= OCTET STRING\r",
							" *\r",
							" * RecipientInfo ::= SEQUENCE {\r",
							" *   version                     Version,\r",
							" *   issuerAndSerialNumber       IssuerAndSerialNumber,\r",
							" *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,\r",
							" *   encryptedKey                EncryptedKey\r",
							" * }\r",
							" *\r",
							" * IssuerAndSerialNumber ::= SEQUENCE {\r",
							" *   issuer                      Name,\r",
							" *   serialNumber                CertificateSerialNumber\r",
							" * }\r",
							" *\r",
							" * CertificateSerialNumber ::= INTEGER\r",
							" *\r",
							" * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * EncryptedKey ::= OCTET STRING\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for ASN.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"// shortcut for PKCS#7 API\r",
							"var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};\r",
							"forge.pkcs7 = forge.pkcs7 || {};\r",
							"forge.pkcs7.asn1 = p7v;\r",
							"\r",
							"var contentInfoValidator = {\r",
							"  name: 'ContentInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'ContentInfo.ContentType',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'contentType'\r",
							"  }, {\r",
							"    name: 'ContentInfo.content',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    captureAsn1: 'content'\r",
							"  }]\r",
							"};\r",
							"p7v.contentInfoValidator = contentInfoValidator;\r",
							"\r",
							"var encryptedContentInfoValidator = {\r",
							"  name: 'EncryptedContentInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EncryptedContentInfo.contentType',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'contentType'\r",
							"  }, {\r",
							"    name: 'EncryptedContentInfo.contentEncryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encAlgorithm'\r",
							"    }, {\r",
							"      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      captureAsn1: 'encParameter'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'EncryptedContentInfo.encryptedContent',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    /* The PKCS#7 structure output by OpenSSL somewhat differs from what\r",
							"     * other implementations do generate.\r",
							"     *\r",
							"     * OpenSSL generates a structure like this:\r",
							"     * SEQUENCE {\r",
							"     *    ...\r",
							"     *    [0]\r",
							"     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\r",
							"     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\r",
							"     *       ...\r",
							"     * }\r",
							"     *\r",
							"     * Whereas other implementations (and this PKCS#7 module) generate:\r",
							"     * SEQUENCE {\r",
							"     *    ...\r",
							"     *    [0] {\r",
							"     *       OCTET STRING\r",
							"     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\r",
							"     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\r",
							"     *          ...\r",
							"     *    }\r",
							"     * }\r",
							"     *\r",
							"     * In order to support both, we just capture the context specific\r",
							"     * field here.  The OCTET STRING bit is removed below.\r",
							"     */\r",
							"    capture: 'encryptedContent',\r",
							"    captureAsn1: 'encryptedContentAsn1'\r",
							"  }]\r",
							"};\r",
							"\r",
							"p7v.envelopedDataValidator = {\r",
							"  name: 'EnvelopedData',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EnvelopedData.Version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }, {\r",
							"    name: 'EnvelopedData.RecipientInfos',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'recipientInfos'\r",
							"  }].concat(encryptedContentInfoValidator)\r",
							"};\r",
							"\r",
							"p7v.encryptedDataValidator = {\r",
							"  name: 'EncryptedData',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EncryptedData.Version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }].concat(encryptedContentInfoValidator)\r",
							"};\r",
							"\r",
							"var signerValidator = {\r",
							"  name: 'SignerInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'SignerInfo.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false\r",
							"  }, {\r",
							"    name: 'SignerInfo.issuerAndSerialNumber',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'SignerInfo.issuerAndSerialNumber.issuer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'issuer'\r",
							"    }, {\r",
							"      name: 'SignerInfo.issuerAndSerialNumber.serialNumber',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'serial'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'SignerInfo.digestAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'SignerInfo.digestAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'digestAlgorithm'\r",
							"    }, {\r",
							"      name: 'SignerInfo.digestAlgorithm.parameter',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      constructed: false,\r",
							"      captureAsn1: 'digestParameter',\r",
							"      optional: true\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'SignerInfo.authenticatedAttributes',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'authenticatedAttributes'\r",
							"  }, {\r",
							"    name: 'SignerInfo.digestEncryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    capture: 'signatureAlgorithm'\r",
							"  }, {\r",
							"    name: 'SignerInfo.encryptedDigest',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'signature'\r",
							"  }, {\r",
							"    name: 'SignerInfo.unauthenticatedAttributes',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 1,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'unauthenticatedAttributes'\r",
							"  }]\r",
							"};\r",
							"\r",
							"p7v.signedDataValidator = {\r",
							"  name: 'SignedData',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'SignedData.Version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }, {\r",
							"    name: 'SignedData.DigestAlgorithms',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'digestAlgorithms'\r",
							"  },\r",
							"  contentInfoValidator,\r",
							"  {\r",
							"    name: 'SignedData.Certificates',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    optional: true,\r",
							"    captureAsn1: 'certificates'\r",
							"  }, {\r",
							"    name: 'SignedData.CertificateRevocationLists',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 1,\r",
							"    optional: true,\r",
							"    captureAsn1: 'crls'\r",
							"  }, {\r",
							"    name: 'SignedData.SignerInfos',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    capture: 'signerInfos',\r",
							"    optional: true,\r",
							"    value: [signerValidator]\r",
							"  }]\r",
							"};\r",
							"\r",
							"p7v.recipientInfoValidator = {\r",
							"  name: 'RecipientInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'RecipientInfo.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }, {\r",
							"    name: 'RecipientInfo.issuerAndSerial',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'RecipientInfo.issuerAndSerial.issuer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'issuer'\r",
							"    }, {\r",
							"      name: 'RecipientInfo.issuerAndSerial.serialNumber',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'serial'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'RecipientInfo.keyEncryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encAlgorithm'\r",
							"    }, {\r",
							"      name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      constructed: false,\r",
							"      captureAsn1: 'encParameter'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'RecipientInfo.encryptedKey',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'encKey'\r",
							"  }]\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 30 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of mask generation function MGF1.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" * Copyright (c) 2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"forge.mgf = forge.mgf || {};\r",
							"var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\r",
							"\r",
							"/**\r",
							" * Creates a MGF1 mask generation function object.\r",
							" *\r",
							" * @param md the message digest API to use (eg: forge.md.sha1.create()).\r",
							" *\r",
							" * @return a mask generation function object.\r",
							" */\r",
							"mgf1.create = function(md) {\r",
							"  var mgf = {\r",
							"    /**\r",
							"     * Generate mask of specified length.\r",
							"     *\r",
							"     * @param {String} seed The seed for mask generation.\r",
							"     * @param maskLen Number of bytes to generate.\r",
							"     * @return {String} The generated mask.\r",
							"     */\r",
							"    generate: function(seed, maskLen) {\r",
							"      /* 2. Let T be the empty octet string. */\r",
							"      var t = new forge.util.ByteBuffer();\r",
							"\r",
							"      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */\r",
							"      var len = Math.ceil(maskLen / md.digestLength);\r",
							"      for(var i = 0; i < len; i++) {\r",
							"        /* a. Convert counter to an octet string C of length 4 octets */\r",
							"        var c = new forge.util.ByteBuffer();\r",
							"        c.putInt32(i);\r",
							"\r",
							"        /* b. Concatenate the hash of the seed mgfSeed and C to the octet\r",
							"         * string T: */\r",
							"        md.start();\r",
							"        md.update(seed + c.getBytes());\r",
							"        t.putBuffer(md.digest());\r",
							"      }\r",
							"\r",
							"      /* Output the leading maskLen octets of T as the octet string mask. */\r",
							"      t.truncate(t.length() - maskLen);\r",
							"      return t.getBytes();\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return mgf;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 31 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Debugging support for web applications.\r",
							" *\r",
							" * @author David I. Lehn <dlehn@digitalbazaar.com>\r",
							" *\r",
							" * Copyright 2008-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"/* DEBUG API */\r",
							"module.exports = forge.debug = forge.debug || {};\r",
							"\r",
							"// Private storage for debugging.\r",
							"// Useful to expose data that is otherwise unviewable behind closures.\r",
							"// NOTE: remember that this can hold references to data and cause leaks!\r",
							"// format is \"forge._debug.<modulename>.<dataname> = data\"\r",
							"// Example:\r",
							"// (function() {\r",
							"//   var cat = 'forge.test.Test'; // debugging category\r",
							"//   var sState = {...}; // local state\r",
							"//   forge.debug.set(cat, 'sState', sState);\r",
							"// })();\r",
							"forge.debug.storage = {};\r",
							"\r",
							"/**\r",
							" * Gets debug data. Omit name for all cat data  Omit name and cat for\r",
							" * all data.\r",
							" *\r",
							" * @param cat name of debugging category.\r",
							" * @param name name of data to get (optional).\r",
							" * @return object with requested debug data or undefined.\r",
							" */\r",
							"forge.debug.get = function(cat, name) {\r",
							"  var rval;\r",
							"  if(typeof(cat) === 'undefined') {\r",
							"    rval = forge.debug.storage;\r",
							"  } else if(cat in forge.debug.storage) {\r",
							"    if(typeof(name) === 'undefined') {\r",
							"      rval = forge.debug.storage[cat];\r",
							"    } else {\r",
							"      rval = forge.debug.storage[cat][name];\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets debug data.\r",
							" *\r",
							" * @param cat name of debugging category.\r",
							" * @param name name of data to set.\r",
							" * @param data data to set.\r",
							" */\r",
							"forge.debug.set = function(cat, name, data) {\r",
							"  if(!(cat in forge.debug.storage)) {\r",
							"    forge.debug.storage[cat] = {};\r",
							"  }\r",
							"  forge.debug.storage[cat][name] = data;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears debug data. Omit name for all cat data. Omit name and cat for\r",
							" * all data.\r",
							" *\r",
							" * @param cat name of debugging category.\r",
							" * @param name name of data to clear or omit to clear entire category.\r",
							" */\r",
							"forge.debug.clear = function(cat, name) {\r",
							"  if(typeof(cat) === 'undefined') {\r",
							"    forge.debug.storage = {};\r",
							"  } else if(cat in forge.debug.storage) {\r",
							"    if(typeof(name) === 'undefined') {\r",
							"      delete forge.debug.storage[cat];\r",
							"    } else {\r",
							"      delete forge.debug.storage[cat][name];\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 32 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Secure Hash Algorithm with a 1024-bit block size implementation.\r",
							" *\r",
							" * This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For\r",
							" * SHA-256 (block size 512 bits), see sha256.js.\r",
							" *\r",
							" * See FIPS 180-4 for details.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2014-2015 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var sha512 = module.exports = forge.sha512 = forge.sha512 || {};\r",
							"\r",
							"// SHA-512\r",
							"forge.md.sha512 = forge.md.algorithms.sha512 = sha512;\r",
							"\r",
							"// SHA-384\r",
							"var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};\r",
							"sha384.create = function() {\r",
							"  return sha512.create('SHA-384');\r",
							"};\r",
							"forge.md.sha384 = forge.md.algorithms.sha384 = sha384;\r",
							"\r",
							"// SHA-512/256\r",
							"forge.sha512.sha256 = forge.sha512.sha256 || {\r",
							"  create: function() {\r",
							"    return sha512.create('SHA-512/256');\r",
							"  }\r",
							"};\r",
							"forge.md['sha512/256'] = forge.md.algorithms['sha512/256'] =\r",
							"  forge.sha512.sha256;\r",
							"\r",
							"// SHA-512/224\r",
							"forge.sha512.sha224 = forge.sha512.sha224 || {\r",
							"  create: function() {\r",
							"    return sha512.create('SHA-512/224');\r",
							"  }\r",
							"};\r",
							"forge.md['sha512/224'] = forge.md.algorithms['sha512/224'] =\r",
							"  forge.sha512.sha224;\r",
							"\r",
							"/**\r",
							" * Creates a SHA-2 message digest object.\r",
							" *\r",
							" * @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,\r",
							" *          SHA-512/256).\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"sha512.create = function(algorithm) {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  if(typeof algorithm === 'undefined') {\r",
							"    algorithm = 'SHA-512';\r",
							"  }\r",
							"\r",
							"  if(!(algorithm in _states)) {\r",
							"    throw new Error('Invalid SHA-512 algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  // SHA-512 state contains eight 64-bit integers (each as two 32-bit ints)\r",
							"  var _state = _states[algorithm];\r",
							"  var _h = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for 64-bit word storage\r",
							"  var _w = new Array(80);\r",
							"  for(var wi = 0; wi < 80; ++wi) {\r",
							"    _w[wi] = new Array(2);\r",
							"  }\r",
							"\r",
							"  // determine digest length by algorithm name (default)\r",
							"  var digestLength = 64;\r",
							"  switch (algorithm) {\r",
							"    case 'SHA-384':\r",
							"      digestLength = 48;\r",
							"      break;\r",
							"    case 'SHA-512/256':\r",
							"      digestLength = 32;\r",
							"      break;\r",
							"    case 'SHA-512/224':\r",
							"      digestLength = 28;\r",
							"      break;\r",
							"  }\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    // SHA-512 => sha512\r",
							"    algorithm: algorithm.replace('-', '').toLowerCase(),\r",
							"    blockLength: 128,\r",
							"    digestLength: digestLength,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 16\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength128 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength128 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _h = new Array(_state.length);\r",
							"    for(var i = 0; i < _state.length; ++i) {\r",
							"      _h[i] = _state[i].slice(0);\r",
							"    }\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = ((len[1] / 0x100000000) >>> 0);\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_h, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the digest.\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate SHA-512 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 896 mod 1024. In other words,\r",
							"    the data to be digested must be a multiple of 1024 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 16 bytes (128\r",
							"    bits), that means that the last segment of the data must have 112 bytes\r",
							"    (896 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 896 mod 1024 because\r",
							"    1024 - 128 = 896.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 896 mod 1024, then 1024 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in big-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry from next int\r",
							"    var next, carry;\r",
							"    var bits = md.fullMessageLength[0] * 8;\r",
							"    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\r",
							"      next = md.fullMessageLength[i + 1] * 8;\r",
							"      carry = (next / 0x100000000) >>> 0;\r",
							"      bits += carry;\r",
							"      finalBlock.putInt32(bits >>> 0);\r",
							"      bits = next >>> 0;\r",
							"    }\r",
							"    finalBlock.putInt32(bits);\r",
							"\r",
							"    var h = new Array(_h.length);\r",
							"    for(var i = 0; i < _h.length; ++i) {\r",
							"      h[i] = _h[i].slice(0);\r",
							"    }\r",
							"    _update(h, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    var hlen;\r",
							"    if(algorithm === 'SHA-512') {\r",
							"      hlen = h.length;\r",
							"    } else if(algorithm === 'SHA-384') {\r",
							"      hlen = h.length - 2;\r",
							"    } else {\r",
							"      hlen = h.length - 4;\r",
							"    }\r",
							"    for(var i = 0; i < hlen; ++i) {\r",
							"      rval.putInt32(h[i][0]);\r",
							"      if(i !== hlen - 1 || algorithm !== 'SHA-512/224') {\r",
							"        rval.putInt32(h[i][1]);\r",
							"      }\r",
							"    }\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// sha-512 padding bytes not initialized yet\r",
							"var _padding = null;\r",
							"var _initialized = false;\r",
							"\r",
							"// table of constants\r",
							"var _k = null;\r",
							"\r",
							"// initial hash states\r",
							"var _states = null;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 128);\r",
							"\r",
							"  // create K table for SHA-512\r",
							"  _k = [\r",
							"    [0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd],\r",
							"    [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc],\r",
							"    [0x3956c25b, 0xf348b538], [0x59f111f1, 0xb605d019],\r",
							"    [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118],\r",
							"    [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe],\r",
							"    [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2],\r",
							"    [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1],\r",
							"    [0x9bdc06a7, 0x25c71235], [0xc19bf174, 0xcf692694],\r",
							"    [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3],\r",
							"    [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65],\r",
							"    [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483],\r",
							"    [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5],\r",
							"    [0x983e5152, 0xee66dfab], [0xa831c66d, 0x2db43210],\r",
							"    [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4],\r",
							"    [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725],\r",
							"    [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70],\r",
							"    [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926],\r",
							"    [0x4d2c6dfc, 0x5ac42aed], [0x53380d13, 0x9d95b3df],\r",
							"    [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8],\r",
							"    [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b],\r",
							"    [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001],\r",
							"    [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30],\r",
							"    [0xd192e819, 0xd6ef5218], [0xd6990624, 0x5565a910],\r",
							"    [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8],\r",
							"    [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53],\r",
							"    [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8],\r",
							"    [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb],\r",
							"    [0x5b9cca4f, 0x7763e373], [0x682e6ff3, 0xd6b2b8a3],\r",
							"    [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60],\r",
							"    [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec],\r",
							"    [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9],\r",
							"    [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b],\r",
							"    [0xca273ece, 0xea26619c], [0xd186b8c7, 0x21c0c207],\r",
							"    [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178],\r",
							"    [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6],\r",
							"    [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b],\r",
							"    [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493],\r",
							"    [0x3c9ebe0a, 0x15c9bebc], [0x431d67c4, 0x9c100d4c],\r",
							"    [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a],\r",
							"    [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]\r",
							"  ];\r",
							"\r",
							"  // initial hash states\r",
							"  _states = {};\r",
							"  _states['SHA-512'] = [\r",
							"    [0x6a09e667, 0xf3bcc908],\r",
							"    [0xbb67ae85, 0x84caa73b],\r",
							"    [0x3c6ef372, 0xfe94f82b],\r",
							"    [0xa54ff53a, 0x5f1d36f1],\r",
							"    [0x510e527f, 0xade682d1],\r",
							"    [0x9b05688c, 0x2b3e6c1f],\r",
							"    [0x1f83d9ab, 0xfb41bd6b],\r",
							"    [0x5be0cd19, 0x137e2179]\r",
							"  ];\r",
							"  _states['SHA-384'] = [\r",
							"    [0xcbbb9d5d, 0xc1059ed8],\r",
							"    [0x629a292a, 0x367cd507],\r",
							"    [0x9159015a, 0x3070dd17],\r",
							"    [0x152fecd8, 0xf70e5939],\r",
							"    [0x67332667, 0xffc00b31],\r",
							"    [0x8eb44a87, 0x68581511],\r",
							"    [0xdb0c2e0d, 0x64f98fa7],\r",
							"    [0x47b5481d, 0xbefa4fa4]\r",
							"  ];\r",
							"  _states['SHA-512/256'] = [\r",
							"    [0x22312194, 0xFC2BF72C],\r",
							"    [0x9F555FA3, 0xC84C64C2],\r",
							"    [0x2393B86B, 0x6F53B151],\r",
							"    [0x96387719, 0x5940EABD],\r",
							"    [0x96283EE2, 0xA88EFFE3],\r",
							"    [0xBE5E1E25, 0x53863992],\r",
							"    [0x2B0199FC, 0x2C85B8AA],\r",
							"    [0x0EB72DDC, 0x81C52CA2]\r",
							"  ];\r",
							"  _states['SHA-512/224'] = [\r",
							"    [0x8C3D37C8, 0x19544DA2],\r",
							"    [0x73E19966, 0x89DCD4D6],\r",
							"    [0x1DFAB7AE, 0x32FF9C82],\r",
							"    [0x679DD514, 0x582F9FCF],\r",
							"    [0x0F6D2B69, 0x7BD44DA8],\r",
							"    [0x77E36F73, 0x04C48942],\r",
							"    [0x3F9D85A8, 0x6A1D36C8],\r",
							"    [0x1112E6AD, 0x91D692A1]\r",
							"  ];\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a SHA-512 state with the given byte buffer.\r",
							" *\r",
							" * @param s the SHA-512 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (128 byte) chunks\r",
							"  var t1_hi, t1_lo;\r",
							"  var t2_hi, t2_lo;\r",
							"  var s0_hi, s0_lo;\r",
							"  var s1_hi, s1_lo;\r",
							"  var ch_hi, ch_lo;\r",
							"  var maj_hi, maj_lo;\r",
							"  var a_hi, a_lo;\r",
							"  var b_hi, b_lo;\r",
							"  var c_hi, c_lo;\r",
							"  var d_hi, d_lo;\r",
							"  var e_hi, e_lo;\r",
							"  var f_hi, f_lo;\r",
							"  var g_hi, g_lo;\r",
							"  var h_hi, h_lo;\r",
							"  var i, hi, lo, w2, w7, w15, w16;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 128) {\r",
							"    // the w array will be populated with sixteen 64-bit big-endian words\r",
							"    // and then extended into 64 64-bit words according to SHA-512\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      w[i][0] = bytes.getInt32() >>> 0;\r",
							"      w[i][1] = bytes.getInt32() >>> 0;\r",
							"    }\r",
							"    for(; i < 80; ++i) {\r",
							"      // for word 2 words ago: ROTR 19(x) ^ ROTR 61(x) ^ SHR 6(x)\r",
							"      w2 = w[i - 2];\r",
							"      hi = w2[0];\r",
							"      lo = w2[1];\r",
							"\r",
							"      // high bits\r",
							"      t1_hi = (\r",
							"        ((hi >>> 19) | (lo << 13)) ^ // ROTR 19\r",
							"        ((lo >>> 29) | (hi << 3)) ^ // ROTR 61/(swap + ROTR 29)\r",
							"        (hi >>> 6)) >>> 0; // SHR 6\r",
							"      // low bits\r",
							"      t1_lo = (\r",
							"        ((hi << 13) | (lo >>> 19)) ^ // ROTR 19\r",
							"        ((lo << 3) | (hi >>> 29)) ^ // ROTR 61/(swap + ROTR 29)\r",
							"        ((hi << 26) | (lo >>> 6))) >>> 0; // SHR 6\r",
							"\r",
							"      // for word 15 words ago: ROTR 1(x) ^ ROTR 8(x) ^ SHR 7(x)\r",
							"      w15 = w[i - 15];\r",
							"      hi = w15[0];\r",
							"      lo = w15[1];\r",
							"\r",
							"      // high bits\r",
							"      t2_hi = (\r",
							"        ((hi >>> 1) | (lo << 31)) ^ // ROTR 1\r",
							"        ((hi >>> 8) | (lo << 24)) ^ // ROTR 8\r",
							"        (hi >>> 7)) >>> 0; // SHR 7\r",
							"      // low bits\r",
							"      t2_lo = (\r",
							"        ((hi << 31) | (lo >>> 1)) ^ // ROTR 1\r",
							"        ((hi << 24) | (lo >>> 8)) ^ // ROTR 8\r",
							"        ((hi << 25) | (lo >>> 7))) >>> 0; // SHR 7\r",
							"\r",
							"      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^64 (carry lo overflow)\r",
							"      w7 = w[i - 7];\r",
							"      w16 = w[i - 16];\r",
							"      lo = (t1_lo + w7[1] + t2_lo + w16[1]);\r",
							"      w[i][0] = (t1_hi + w7[0] + t2_hi + w16[0] +\r",
							"        ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      w[i][1] = lo >>> 0;\r",
							"    }\r",
							"\r",
							"    // initialize hash value for this chunk\r",
							"    a_hi = s[0][0];\r",
							"    a_lo = s[0][1];\r",
							"    b_hi = s[1][0];\r",
							"    b_lo = s[1][1];\r",
							"    c_hi = s[2][0];\r",
							"    c_lo = s[2][1];\r",
							"    d_hi = s[3][0];\r",
							"    d_lo = s[3][1];\r",
							"    e_hi = s[4][0];\r",
							"    e_lo = s[4][1];\r",
							"    f_hi = s[5][0];\r",
							"    f_lo = s[5][1];\r",
							"    g_hi = s[6][0];\r",
							"    g_lo = s[6][1];\r",
							"    h_hi = s[7][0];\r",
							"    h_lo = s[7][1];\r",
							"\r",
							"    // round function\r",
							"    for(i = 0; i < 80; ++i) {\r",
							"      // Sum1(e) = ROTR 14(e) ^ ROTR 18(e) ^ ROTR 41(e)\r",
							"      s1_hi = (\r",
							"        ((e_hi >>> 14) | (e_lo << 18)) ^ // ROTR 14\r",
							"        ((e_hi >>> 18) | (e_lo << 14)) ^ // ROTR 18\r",
							"        ((e_lo >>> 9) | (e_hi << 23))) >>> 0; // ROTR 41/(swap + ROTR 9)\r",
							"      s1_lo = (\r",
							"        ((e_hi << 18) | (e_lo >>> 14)) ^ // ROTR 14\r",
							"        ((e_hi << 14) | (e_lo >>> 18)) ^ // ROTR 18\r",
							"        ((e_lo << 23) | (e_hi >>> 9))) >>> 0; // ROTR 41/(swap + ROTR 9)\r",
							"\r",
							"      // Ch(e, f, g) (optimized the same way as SHA-1)\r",
							"      ch_hi = (g_hi ^ (e_hi & (f_hi ^ g_hi))) >>> 0;\r",
							"      ch_lo = (g_lo ^ (e_lo & (f_lo ^ g_lo))) >>> 0;\r",
							"\r",
							"      // Sum0(a) = ROTR 28(a) ^ ROTR 34(a) ^ ROTR 39(a)\r",
							"      s0_hi = (\r",
							"        ((a_hi >>> 28) | (a_lo << 4)) ^ // ROTR 28\r",
							"        ((a_lo >>> 2) | (a_hi << 30)) ^ // ROTR 34/(swap + ROTR 2)\r",
							"        ((a_lo >>> 7) | (a_hi << 25))) >>> 0; // ROTR 39/(swap + ROTR 7)\r",
							"      s0_lo = (\r",
							"        ((a_hi << 4) | (a_lo >>> 28)) ^ // ROTR 28\r",
							"        ((a_lo << 30) | (a_hi >>> 2)) ^ // ROTR 34/(swap + ROTR 2)\r",
							"        ((a_lo << 25) | (a_hi >>> 7))) >>> 0; // ROTR 39/(swap + ROTR 7)\r",
							"\r",
							"      // Maj(a, b, c) (optimized the same way as SHA-1)\r",
							"      maj_hi = ((a_hi & b_hi) | (c_hi & (a_hi ^ b_hi))) >>> 0;\r",
							"      maj_lo = ((a_lo & b_lo) | (c_lo & (a_lo ^ b_lo))) >>> 0;\r",
							"\r",
							"      // main algorithm\r",
							"      // t1 = (h + s1 + ch + _k[i] + _w[i]) modulo 2^64 (carry lo overflow)\r",
							"      lo = (h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1]);\r",
							"      t1_hi = (h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] +\r",
							"        ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      t1_lo = lo >>> 0;\r",
							"\r",
							"      // t2 = s0 + maj modulo 2^64 (carry lo overflow)\r",
							"      lo = s0_lo + maj_lo;\r",
							"      t2_hi = (s0_hi + maj_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      t2_lo = lo >>> 0;\r",
							"\r",
							"      h_hi = g_hi;\r",
							"      h_lo = g_lo;\r",
							"\r",
							"      g_hi = f_hi;\r",
							"      g_lo = f_lo;\r",
							"\r",
							"      f_hi = e_hi;\r",
							"      f_lo = e_lo;\r",
							"\r",
							"      // e = (d + t1) modulo 2^64 (carry lo overflow)\r",
							"      lo = d_lo + t1_lo;\r",
							"      e_hi = (d_hi + t1_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      e_lo = lo >>> 0;\r",
							"\r",
							"      d_hi = c_hi;\r",
							"      d_lo = c_lo;\r",
							"\r",
							"      c_hi = b_hi;\r",
							"      c_lo = b_lo;\r",
							"\r",
							"      b_hi = a_hi;\r",
							"      b_lo = a_lo;\r",
							"\r",
							"      // a = (t1 + t2) modulo 2^64 (carry lo overflow)\r",
							"      lo = t1_lo + t2_lo;\r",
							"      a_hi = (t1_hi + t2_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      a_lo = lo >>> 0;\r",
							"    }\r",
							"\r",
							"    // update hash state (additional modulo 2^64)\r",
							"    lo = s[0][1] + a_lo;\r",
							"    s[0][0] = (s[0][0] + a_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[0][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[1][1] + b_lo;\r",
							"    s[1][0] = (s[1][0] + b_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[1][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[2][1] + c_lo;\r",
							"    s[2][0] = (s[2][0] + c_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[2][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[3][1] + d_lo;\r",
							"    s[3][0] = (s[3][0] + d_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[3][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[4][1] + e_lo;\r",
							"    s[4][0] = (s[4][0] + e_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[4][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[5][1] + f_lo;\r",
							"    s[5][0] = (s[5][0] + f_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[5][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[6][1] + g_lo;\r",
							"    s[6][0] = (s[6][0] + g_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[6][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[7][1] + h_lo;\r",
							"    s[7][0] = (s[7][0] + h_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[7][1] = lo >>> 0;\r",
							"\r",
							"    len -= 128;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 33 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Cross-browser support for logging in a web application.\r",
							" *\r",
							" * @author David I. Lehn <dlehn@digitalbazaar.com>\r",
							" *\r",
							" * Copyright (c) 2008-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* LOG API */\r",
							"module.exports = forge.log = forge.log || {};\r",
							"\r",
							"/**\r",
							" * Application logging system.\r",
							" *\r",
							" * Each logger level available as it's own function of the form:\r",
							" *   forge.log.level(category, args...)\r",
							" * The category is an arbitrary string, and the args are the same as\r",
							" * Firebug's console.log API. By default the call will be output as:\r",
							" *   'LEVEL [category] <args[0]>, args[1], ...'\r",
							" * This enables proper % formatting via the first argument.\r",
							" * Each category is enabled by default but can be enabled or disabled with\r",
							" * the setCategoryEnabled() function.\r",
							" */\r",
							"// list of known levels\r",
							"forge.log.levels = [\r",
							"  'none', 'error', 'warning', 'info', 'debug', 'verbose', 'max'];\r",
							"// info on the levels indexed by name:\r",
							"//   index: level index\r",
							"//   name: uppercased display name\r",
							"var sLevelInfo = {};\r",
							"// list of loggers\r",
							"var sLoggers = [];\r",
							"/**\r",
							" * Standard console logger. If no console support is enabled this will\r",
							" * remain null. Check before using.\r",
							" */\r",
							"var sConsoleLogger = null;\r",
							"\r",
							"// logger flags\r",
							"/**\r",
							" * Lock the level at the current value. Used in cases where user config may\r",
							" * set the level such that only critical messages are seen but more verbose\r",
							" * messages are needed for debugging or other purposes.\r",
							" */\r",
							"forge.log.LEVEL_LOCKED = (1 << 1);\r",
							"/**\r",
							" * Always call log function. By default, the logging system will check the\r",
							" * message level against logger.level before calling the log function. This\r",
							" * flag allows the function to do its own check.\r",
							" */\r",
							"forge.log.NO_LEVEL_CHECK = (1 << 2);\r",
							"/**\r",
							" * Perform message interpolation with the passed arguments. \"%\" style\r",
							" * fields in log messages will be replaced by arguments as needed. Some\r",
							" * loggers, such as Firebug, may do this automatically. The original log\r",
							" * message will be available as 'message' and the interpolated version will\r",
							" * be available as 'fullMessage'.\r",
							" */\r",
							"forge.log.INTERPOLATE = (1 << 3);\r",
							"\r",
							"// setup each log level\r",
							"for(var i = 0; i < forge.log.levels.length; ++i) {\r",
							"  var level = forge.log.levels[i];\r",
							"  sLevelInfo[level] = {\r",
							"    index: i,\r",
							"    name: level.toUpperCase()\r",
							"  };\r",
							"}\r",
							"\r",
							"/**\r",
							" * Message logger. Will dispatch a message to registered loggers as needed.\r",
							" *\r",
							" * @param message message object\r",
							" */\r",
							"forge.log.logMessage = function(message) {\r",
							"  var messageLevelIndex = sLevelInfo[message.level].index;\r",
							"  for(var i = 0; i < sLoggers.length; ++i) {\r",
							"    var logger = sLoggers[i];\r",
							"    if(logger.flags & forge.log.NO_LEVEL_CHECK) {\r",
							"      logger.f(message);\r",
							"    } else {\r",
							"      // get logger level\r",
							"      var loggerLevelIndex = sLevelInfo[logger.level].index;\r",
							"      // check level\r",
							"      if(messageLevelIndex <= loggerLevelIndex) {\r",
							"        // message critical enough, call logger\r",
							"        logger.f(logger, message);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets the 'standard' key on a message object to:\r",
							" * \"LEVEL [category] \" + message\r",
							" *\r",
							" * @param message a message log object\r",
							" */\r",
							"forge.log.prepareStandard = function(message) {\r",
							"  if(!('standard' in message)) {\r",
							"    message.standard =\r",
							"      sLevelInfo[message.level].name +\r",
							"      //' ' + +message.timestamp +\r",
							"      ' [' + message.category + '] ' +\r",
							"      message.message;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets the 'full' key on a message object to the original message\r",
							" * interpolated via % formatting with the message arguments.\r",
							" *\r",
							" * @param message a message log object.\r",
							" */\r",
							"forge.log.prepareFull = function(message) {\r",
							"  if(!('full' in message)) {\r",
							"    // copy args and insert message at the front\r",
							"    var args = [message.message];\r",
							"    args = args.concat([] || message['arguments']);\r",
							"    // format the message\r",
							"    message.full = forge.util.format.apply(this, args);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Applies both preparseStandard() and prepareFull() to a message object and\r",
							" * store result in 'standardFull'.\r",
							" *\r",
							" * @param message a message log object.\r",
							" */\r",
							"forge.log.prepareStandardFull = function(message) {\r",
							"  if(!('standardFull' in message)) {\r",
							"    // FIXME implement 'standardFull' logging\r",
							"    forge.log.prepareStandard(message);\r",
							"    message.standardFull = message.standard;\r",
							"  }\r",
							"};\r",
							"\r",
							"// create log level functions\r",
							"if(true) {\r",
							"  // levels for which we want functions\r",
							"  var levels = ['error', 'warning', 'info', 'debug', 'verbose'];\r",
							"  for(var i = 0; i < levels.length; ++i) {\r",
							"    // wrap in a function to ensure proper level var is passed\r",
							"    (function(level) {\r",
							"      // create function for this level\r",
							"      forge.log[level] = function(category, message/*, args...*/) {\r",
							"        // convert arguments to real array, remove category and message\r",
							"        var args = Array.prototype.slice.call(arguments).slice(2);\r",
							"        // create message object\r",
							"        // Note: interpolation and standard formatting is done lazily\r",
							"        var msg = {\r",
							"          timestamp: new Date(),\r",
							"          level: level,\r",
							"          category: category,\r",
							"          message: message,\r",
							"          'arguments': args\r",
							"          /*standard*/\r",
							"          /*full*/\r",
							"          /*fullMessage*/\r",
							"        };\r",
							"        // process this message\r",
							"        forge.log.logMessage(msg);\r",
							"      };\r",
							"    })(levels[i]);\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Creates a new logger with specified custom logging function.\r",
							" *\r",
							" * The logging function has a signature of:\r",
							" *   function(logger, message)\r",
							" * logger: current logger\r",
							" * message: object:\r",
							" *   level: level id\r",
							" *   category: category\r",
							" *   message: string message\r",
							" *   arguments: Array of extra arguments\r",
							" *   fullMessage: interpolated message and arguments if INTERPOLATE flag set\r",
							" *\r",
							" * @param logFunction a logging function which takes a log message object\r",
							" *          as a parameter.\r",
							" *\r",
							" * @return a logger object.\r",
							" */\r",
							"forge.log.makeLogger = function(logFunction) {\r",
							"  var logger = {\r",
							"    flags: 0,\r",
							"    f: logFunction\r",
							"  };\r",
							"  forge.log.setLevel(logger, 'none');\r",
							"  return logger;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets the current log level on a logger.\r",
							" *\r",
							" * @param logger the target logger.\r",
							" * @param level the new maximum log level as a string.\r",
							" *\r",
							" * @return true if set, false if not.\r",
							" */\r",
							"forge.log.setLevel = function(logger, level) {\r",
							"  var rval = false;\r",
							"  if(logger && !(logger.flags & forge.log.LEVEL_LOCKED)) {\r",
							"    for(var i = 0; i < forge.log.levels.length; ++i) {\r",
							"      var aValidLevel = forge.log.levels[i];\r",
							"      if(level == aValidLevel) {\r",
							"        // set level\r",
							"        logger.level = level;\r",
							"        rval = true;\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Locks the log level at its current value.\r",
							" *\r",
							" * @param logger the target logger.\r",
							" * @param lock boolean lock value, default to true.\r",
							" */\r",
							"forge.log.lock = function(logger, lock) {\r",
							"  if(typeof lock === 'undefined' || lock) {\r",
							"    logger.flags |= forge.log.LEVEL_LOCKED;\r",
							"  } else {\r",
							"    logger.flags &= ~forge.log.LEVEL_LOCKED;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds a logger.\r",
							" *\r",
							" * @param logger the logger object.\r",
							" */\r",
							"forge.log.addLogger = function(logger) {\r",
							"  sLoggers.push(logger);\r",
							"};\r",
							"\r",
							"// setup the console logger if possible, else create fake console.log\r",
							"if(typeof(console) !== 'undefined' && 'log' in console) {\r",
							"  var logger;\r",
							"  if(console.error && console.warn && console.info && console.debug) {\r",
							"    // looks like Firebug-style logging is available\r",
							"    // level handlers map\r",
							"    var levelHandlers = {\r",
							"      error: console.error,\r",
							"      warning: console.warn,\r",
							"      info: console.info,\r",
							"      debug: console.debug,\r",
							"      verbose: console.debug\r",
							"    };\r",
							"    var f = function(logger, message) {\r",
							"      forge.log.prepareStandard(message);\r",
							"      var handler = levelHandlers[message.level];\r",
							"      // prepend standard message and concat args\r",
							"      var args = [message.standard];\r",
							"      args = args.concat(message['arguments'].slice());\r",
							"      // apply to low-level console function\r",
							"      handler.apply(console, args);\r",
							"    };\r",
							"    logger = forge.log.makeLogger(f);\r",
							"  } else {\r",
							"    // only appear to have basic console.log\r",
							"    var f = function(logger, message) {\r",
							"      forge.log.prepareStandardFull(message);\r",
							"      console.log(message.standardFull);\r",
							"    };\r",
							"    logger = forge.log.makeLogger(f);\r",
							"  }\r",
							"  forge.log.setLevel(logger, 'debug');\r",
							"  forge.log.addLogger(logger);\r",
							"  sConsoleLogger = logger;\r",
							"} else {\r",
							"  // define fake console.log to avoid potential script errors on\r",
							"  // browsers that do not have console logging\r",
							"  console = {\r",
							"    log: function() {}\r",
							"  };\r",
							"}\r",
							"\r",
							"/*\r",
							" * Check for logging control query vars.\r",
							" *\r",
							" * console.level=<level-name>\r",
							" * Set's the console log level by name.  Useful to override defaults and\r",
							" * allow more verbose logging before a user config is loaded.\r",
							" *\r",
							" * console.lock=<true|false>\r",
							" * Lock the console log level at whatever level it is set at.  This is run\r",
							" * after console.level is processed.  Useful to force a level of verbosity\r",
							" * that could otherwise be limited by a user config.\r",
							" */\r",
							"if(sConsoleLogger !== null) {\r",
							"  var query = forge.util.getQueryVariables();\r",
							"  if('console.level' in query) {\r",
							"    // set with last value\r",
							"    forge.log.setLevel(\r",
							"      sConsoleLogger, query['console.level'].slice(-1)[0]);\r",
							"  }\r",
							"  if('console.lock' in query) {\r",
							"    // set with last value\r",
							"    var lock = query['console.lock'].slice(-1)[0];\r",
							"    if(lock == 'true') {\r",
							"      forge.log.lock(sConsoleLogger);\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"// provide public access to console logger\r",
							"forge.log.consoleLogger = sConsoleLogger;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 34 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"module.exports = __webpack_require__(35);\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 35 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2016 Digital Bazaar, Inc.\r",
							" */\r",
							"module.exports = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(37);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(13);\r",
							"__webpack_require__(31);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(39);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(40);\r",
							"__webpack_require__(33);\r",
							"__webpack_require__(41);\r",
							"__webpack_require__(30);\r",
							"__webpack_require__(15);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(26);\r",
							"__webpack_require__(28);\r",
							"__webpack_require__(42);\r",
							"__webpack_require__(20);\r",
							"__webpack_require__(27);\r",
							"__webpack_require__(24);\r",
							"__webpack_require__(17);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(25);\r",
							"__webpack_require__(43);\r",
							"__webpack_require__(44);\r",
							"__webpack_require__(19);\r",
							"__webpack_require__(1);\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 36 */\r",
							"/***/ (function(module, exports) {\r",
							"\r",
							"/**\r",
							" * Base-N/Base-X encoding/decoding functions.\r",
							" *\r",
							" * Original implementation from base-x:\r",
							" * https://github.com/cryptocoinjs/base-x\r",
							" *\r",
							" * Which is MIT licensed:\r",
							" *\r",
							" * The MIT License (MIT)\r",
							" *\r",
							" * Copyright base-x contributors (c) 2016\r",
							" *\r",
							" * Permission is hereby granted, free of charge, to any person obtaining a copy\r",
							" * of this software and associated documentation files (the \"Software\"), to deal\r",
							" * in the Software without restriction, including without limitation the rights\r",
							" * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r",
							" * copies of the Software, and to permit persons to whom the Software is\r",
							" * furnished to do so, subject to the following conditions:\r",
							" *\r",
							" * The above copyright notice and this permission notice shall be included in\r",
							" * all copies or substantial portions of the Software.\r",
							" *\r",
							" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r",
							" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r",
							" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r",
							" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r",
							" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r",
							" * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r",
							" * DEALINGS IN THE SOFTWARE.\r",
							" */\r",
							"var api = {};\r",
							"module.exports = api;\r",
							"\r",
							"// baseN alphabet indexes\r",
							"var _reverseAlphabets = {};\r",
							"\r",
							"/**\r",
							" * BaseN-encodes a Uint8Array using the given alphabet.\r",
							" *\r",
							" * @param input the Uint8Array to encode.\r",
							" * @param maxline the maximum number of encoded characters per line to use,\r",
							" *          defaults to none.\r",
							" *\r",
							" * @return the baseN-encoded output string.\r",
							" */\r",
							"api.encode = function(input, alphabet, maxline) {\r",
							"  if(typeof alphabet !== 'string') {\r",
							"    throw new TypeError('\"alphabet\" must be a string.');\r",
							"  }\r",
							"  if(maxline !== undefined && typeof maxline !== 'number') {\r",
							"    throw new TypeError('\"maxline\" must be a number.');\r",
							"  }\r",
							"\r",
							"  var output = '';\r",
							"\r",
							"  if(!(input instanceof Uint8Array)) {\r",
							"    // assume forge byte buffer\r",
							"    output = _encodeWithByteBuffer(input, alphabet);\r",
							"  } else {\r",
							"    var i = 0;\r",
							"    var base = alphabet.length;\r",
							"    var first = alphabet.charAt(0);\r",
							"    var digits = [0];\r",
							"    for(i = 0; i < input.length; ++i) {\r",
							"      for(var j = 0, carry = input[i]; j < digits.length; ++j) {\r",
							"        carry += digits[j] << 8;\r",
							"        digits[j] = carry % base;\r",
							"        carry = (carry / base) | 0;\r",
							"      }\r",
							"\r",
							"      while(carry > 0) {\r",
							"        digits.push(carry % base);\r",
							"        carry = (carry / base) | 0;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // deal with leading zeros\r",
							"    for(i = 0; input[i] === 0 && i < input.length - 1; ++i) {\r",
							"      output += first;\r",
							"    }\r",
							"    // convert digits to a string\r",
							"    for(i = digits.length - 1; i >= 0; --i) {\r",
							"      output += alphabet[digits[i]];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(maxline) {\r",
							"    var regex = new RegExp('.{1,' + maxline + '}', 'g');\r",
							"    output = output.match(regex).join('\\r\\n');\r",
							"  }\r",
							"\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a baseN-encoded (using the given alphabet) string to a\r",
							" * Uint8Array.\r",
							" *\r",
							" * @param input the baseN-encoded input string.\r",
							" *\r",
							" * @return the Uint8Array.\r",
							" */\r",
							"api.decode = function(input, alphabet) {\r",
							"  if(typeof input !== 'string') {\r",
							"    throw new TypeError('\"input\" must be a string.');\r",
							"  }\r",
							"  if(typeof alphabet !== 'string') {\r",
							"    throw new TypeError('\"alphabet\" must be a string.');\r",
							"  }\r",
							"\r",
							"  var table = _reverseAlphabets[alphabet];\r",
							"  if(!table) {\r",
							"    // compute reverse alphabet\r",
							"    table = _reverseAlphabets[alphabet] = [];\r",
							"    for(var i = 0; i < alphabet.length; ++i) {\r",
							"      table[alphabet.charCodeAt(i)] = i;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // remove whitespace characters\r",
							"  input = input.replace(/\\s/g, '');\r",
							"\r",
							"  var base = alphabet.length;\r",
							"  var first = alphabet.charAt(0);\r",
							"  var bytes = [0];\r",
							"  for(var i = 0; i < input.length; i++) {\r",
							"    var value = table[input.charCodeAt(i)];\r",
							"    if(value === undefined) {\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    for(var j = 0, carry = value; j < bytes.length; ++j) {\r",
							"      carry += bytes[j] * base;\r",
							"      bytes[j] = carry & 0xff;\r",
							"      carry >>= 8;\r",
							"    }\r",
							"\r",
							"    while(carry > 0) {\r",
							"      bytes.push(carry & 0xff);\r",
							"      carry >>= 8;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // deal with leading zeros\r",
							"  for(var k = 0; input[k] === first && k < input.length - 1; ++k) {\r",
							"    bytes.push(0);\r",
							"  }\r",
							"\r",
							"  if(typeof Buffer !== 'undefined') {\r",
							"    return Buffer.from(bytes.reverse());\r",
							"  }\r",
							"\r",
							"  return new Uint8Array(bytes.reverse());\r",
							"};\r",
							"\r",
							"function _encodeWithByteBuffer(input, alphabet) {\r",
							"  var i = 0;\r",
							"  var base = alphabet.length;\r",
							"  var first = alphabet.charAt(0);\r",
							"  var digits = [0];\r",
							"  for(i = 0; i < input.length(); ++i) {\r",
							"    for(var j = 0, carry = input.at(i); j < digits.length; ++j) {\r",
							"      carry += digits[j] << 8;\r",
							"      digits[j] = carry % base;\r",
							"      carry = (carry / base) | 0;\r",
							"    }\r",
							"\r",
							"    while(carry > 0) {\r",
							"      digits.push(carry % base);\r",
							"      carry = (carry / base) | 0;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  var output = '';\r",
							"\r",
							"  // deal with leading zeros\r",
							"  for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {\r",
							"    output += first;\r",
							"  }\r",
							"  // convert digits to a string\r",
							"  for(i = digits.length - 1; i >= 0; --i) {\r",
							"    output += alphabet[digits[i]];\r",
							"  }\r",
							"\r",
							"  return output;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 37 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * A Javascript implementation of AES Cipher Suites for TLS.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2009-2015 Digital Bazaar, Inc.\r",
							" *\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(19);\r",
							"\r",
							"var tls = module.exports = forge.tls;\r",
							"\r",
							"/**\r",
							" * Supported cipher suites.\r",
							" */\r",
							"tls.CipherSuites['TLS_RSA_WITH_AES_128_CBC_SHA'] = {\r",
							"  id: [0x00,0x2f],\r",
							"  name: 'TLS_RSA_WITH_AES_128_CBC_SHA',\r",
							"  initSecurityParameters: function(sp) {\r",
							"    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\r",
							"    sp.cipher_type = tls.CipherType.block;\r",
							"    sp.enc_key_length = 16;\r",
							"    sp.block_length = 16;\r",
							"    sp.fixed_iv_length = 16;\r",
							"    sp.record_iv_length = 16;\r",
							"    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\r",
							"    sp.mac_length = 20;\r",
							"    sp.mac_key_length = 20;\r",
							"  },\r",
							"  initConnectionState: initConnectionState\r",
							"};\r",
							"tls.CipherSuites['TLS_RSA_WITH_AES_256_CBC_SHA'] = {\r",
							"  id: [0x00,0x35],\r",
							"  name: 'TLS_RSA_WITH_AES_256_CBC_SHA',\r",
							"  initSecurityParameters: function(sp) {\r",
							"    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\r",
							"    sp.cipher_type = tls.CipherType.block;\r",
							"    sp.enc_key_length = 32;\r",
							"    sp.block_length = 16;\r",
							"    sp.fixed_iv_length = 16;\r",
							"    sp.record_iv_length = 16;\r",
							"    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\r",
							"    sp.mac_length = 20;\r",
							"    sp.mac_key_length = 20;\r",
							"  },\r",
							"  initConnectionState: initConnectionState\r",
							"};\r",
							"\r",
							"function initConnectionState(state, c, sp) {\r",
							"  var client = (c.entity === forge.tls.ConnectionEnd.client);\r",
							"\r",
							"  // cipher setup\r",
							"  state.read.cipherState = {\r",
							"    init: false,\r",
							"    cipher: forge.cipher.createDecipher('AES-CBC', client ?\r",
							"      sp.keys.server_write_key : sp.keys.client_write_key),\r",
							"    iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV\r",
							"  };\r",
							"  state.write.cipherState = {\r",
							"    init: false,\r",
							"    cipher: forge.cipher.createCipher('AES-CBC', client ?\r",
							"      sp.keys.client_write_key : sp.keys.server_write_key),\r",
							"    iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV\r",
							"  };\r",
							"  state.read.cipherFunction = decrypt_aes_cbc_sha1;\r",
							"  state.write.cipherFunction = encrypt_aes_cbc_sha1;\r",
							"\r",
							"  // MAC setup\r",
							"  state.read.macLength = state.write.macLength = sp.mac_length;\r",
							"  state.read.macFunction = state.write.macFunction = tls.hmac_sha1;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Encrypts the TLSCompressed record into a TLSCipherText record using AES\r",
							" * in CBC mode.\r",
							" *\r",
							" * @param record the TLSCompressed record to encrypt.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"function encrypt_aes_cbc_sha1(record, s) {\r",
							"  var rval = false;\r",
							"\r",
							"  // append MAC to fragment, update sequence number\r",
							"  var mac = s.macFunction(s.macKey, s.sequenceNumber, record);\r",
							"  record.fragment.putBytes(mac);\r",
							"  s.updateSequenceNumber();\r",
							"\r",
							"  // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\r",
							"  var iv;\r",
							"  if(record.version.minor === tls.Versions.TLS_1_0.minor) {\r",
							"    // use the pre-generated IV when initializing for TLS 1.0, otherwise use\r",
							"    // the residue from the previous encryption\r",
							"    iv = s.cipherState.init ? null : s.cipherState.iv;\r",
							"  } else {\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"  }\r",
							"\r",
							"  s.cipherState.init = true;\r",
							"\r",
							"  // start cipher\r",
							"  var cipher = s.cipherState.cipher;\r",
							"  cipher.start({iv: iv});\r",
							"\r",
							"  // TLS 1.1+ write IV into output\r",
							"  if(record.version.minor >= tls.Versions.TLS_1_1.minor) {\r",
							"    cipher.output.putBytes(iv);\r",
							"  }\r",
							"\r",
							"  // do encryption (default padding is appropriate)\r",
							"  cipher.update(record.fragment);\r",
							"  if(cipher.finish(encrypt_aes_cbc_sha1_padding)) {\r",
							"    // set record fragment to encrypted output\r",
							"    record.fragment = cipher.output;\r",
							"    record.length = record.fragment.length();\r",
							"    rval = true;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Handles padding for aes_cbc_sha1 in encrypt mode.\r",
							" *\r",
							" * @param blockSize the block size.\r",
							" * @param input the input buffer.\r",
							" * @param decrypt true in decrypt mode, false in encrypt mode.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {\r",
							"  /* The encrypted data length (TLSCiphertext.length) is one more than the sum\r",
							"   of SecurityParameters.block_length, TLSCompressed.length,\r",
							"   SecurityParameters.mac_length, and padding_length.\r",
							"\r",
							"   The padding may be any length up to 255 bytes long, as long as it results in\r",
							"   the TLSCiphertext.length being an integral multiple of the block length.\r",
							"   Lengths longer than necessary might be desirable to frustrate attacks on a\r",
							"   protocol based on analysis of the lengths of exchanged messages. Each uint8\r",
							"   in the padding data vector must be filled with the padding length value.\r",
							"\r",
							"   The padding length should be such that the total size of the\r",
							"   GenericBlockCipher structure is a multiple of the cipher's block length.\r",
							"   Legal values range from zero to 255, inclusive. This length specifies the\r",
							"   length of the padding field exclusive of the padding_length field itself.\r",
							"\r",
							"   This is slightly different from PKCS#7 because the padding value is 1\r",
							"   less than the actual number of padding bytes if you include the\r",
							"   padding_length uint8 itself as a padding byte. */\r",
							"  if(!decrypt) {\r",
							"    // get the number of padding bytes required to reach the blockSize and\r",
							"    // subtract 1 for the padding value (to make room for the padding_length\r",
							"    // uint8)\r",
							"    var padding = blockSize - (input.length() % blockSize);\r",
							"    input.fillWithByte(padding - 1, padding);\r",
							"  }\r",
							"  return true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Handles padding for aes_cbc_sha1 in decrypt mode.\r",
							" *\r",
							" * @param blockSize the block size.\r",
							" * @param output the output buffer.\r",
							" * @param decrypt true in decrypt mode, false in encrypt mode.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {\r",
							"  var rval = true;\r",
							"  if(decrypt) {\r",
							"    /* The last byte in the output specifies the number of padding bytes not\r",
							"      including itself. Each of the padding bytes has the same value as that\r",
							"      last byte (known as the padding_length). Here we check all padding\r",
							"      bytes to ensure they have the value of padding_length even if one of\r",
							"      them is bad in order to ward-off timing attacks. */\r",
							"    var len = output.length();\r",
							"    var paddingLength = output.last();\r",
							"    for(var i = len - 1 - paddingLength; i < len - 1; ++i) {\r",
							"      rval = rval && (output.at(i) == paddingLength);\r",
							"    }\r",
							"    if(rval) {\r",
							"      // trim off padding bytes and last padding length byte\r",
							"      output.truncate(paddingLength + 1);\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decrypts a TLSCipherText record into a TLSCompressed record using\r",
							" * AES in CBC mode.\r",
							" *\r",
							" * @param record the TLSCipherText record to decrypt.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"var count = 0;\r",
							"function decrypt_aes_cbc_sha1(record, s) {\r",
							"  var rval = false;\r",
							"  ++count;\r",
							"\r",
							"  var iv;\r",
							"  if(record.version.minor === tls.Versions.TLS_1_0.minor) {\r",
							"    // use pre-generated IV when initializing for TLS 1.0, otherwise use the\r",
							"    // residue from the previous decryption\r",
							"    iv = s.cipherState.init ? null : s.cipherState.iv;\r",
							"  } else {\r",
							"    // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\r",
							"    // that is appended to the record fragment\r",
							"    iv = record.fragment.getBytes(16);\r",
							"  }\r",
							"\r",
							"  s.cipherState.init = true;\r",
							"\r",
							"  // start cipher\r",
							"  var cipher = s.cipherState.cipher;\r",
							"  cipher.start({iv: iv});\r",
							"\r",
							"  // do decryption\r",
							"  cipher.update(record.fragment);\r",
							"  rval = cipher.finish(decrypt_aes_cbc_sha1_padding);\r",
							"\r",
							"  // even if decryption fails, keep going to minimize timing attacks\r",
							"\r",
							"  // decrypted data:\r",
							"  // first (len - 20) bytes = application data\r",
							"  // last 20 bytes          = MAC\r",
							"  var macLen = s.macLength;\r",
							"\r",
							"  // create a random MAC to check against should the mac length check fail\r",
							"  // Note: do this regardless of the failure to keep timing consistent\r",
							"  var mac = forge.random.getBytesSync(macLen);\r",
							"\r",
							"  // get fragment and mac\r",
							"  var len = cipher.output.length();\r",
							"  if(len >= macLen) {\r",
							"    record.fragment = cipher.output.getBytes(len - macLen);\r",
							"    mac = cipher.output.getBytes(macLen);\r",
							"  } else {\r",
							"    // bad data, but get bytes anyway to try to keep timing consistent\r",
							"    record.fragment = cipher.output.getBytes();\r",
							"  }\r",
							"  record.fragment = forge.util.createBuffer(record.fragment);\r",
							"  record.length = record.fragment.length();\r",
							"\r",
							"  // see if data integrity checks out, update sequence number\r",
							"  var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);\r",
							"  s.updateSequenceNumber();\r",
							"  rval = compareMacs(s.macKey, mac, mac2) && rval;\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Safely compare two MACs. This function will compare two MACs in a way\r",
							" * that protects against timing attacks.\r",
							" *\r",
							" * TODO: Expose elsewhere as a utility API.\r",
							" *\r",
							" * See: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/\r",
							" *\r",
							" * @param key the MAC key to use.\r",
							" * @param mac1 as a binary-encoded string of bytes.\r",
							" * @param mac2 as a binary-encoded string of bytes.\r",
							" *\r",
							" * @return true if the MACs are the same, false if not.\r",
							" */\r",
							"function compareMacs(key, mac1, mac2) {\r",
							"  var hmac = forge.hmac.create();\r",
							"\r",
							"  hmac.start('SHA1', key);\r",
							"  hmac.update(mac1);\r",
							"  mac1 = hmac.digest().getBytes();\r",
							"\r",
							"  hmac.start(null, null);\r",
							"  hmac.update(mac2);\r",
							"  mac2 = hmac.digest().getBytes();\r",
							"\r",
							"  return mac1 === mac2;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 38 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge mask generation functions.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(30);\r",
							"\r",
							"module.exports = forge.mgf = forge.mgf || {};\r",
							"forge.mgf.mgf1 = forge.mgf1;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 39 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * JavaScript implementation of Ed25519.\r",
							" *\r",
							" * Copyright (c) 2017-2018 Digital Bazaar, Inc.\r",
							" *\r",
							" * This implementation is based on the most excellent TweetNaCl which is\r",
							" * in the public domain. Many thanks to its contributors:\r",
							" *\r",
							" * https://github.com/dchest/tweetnacl-js\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(12);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(32);\r",
							"__webpack_require__(1);\r",
							"\r",
							"if(typeof BigInteger === 'undefined') {\r",
							"  var BigInteger = forge.jsbn.BigInteger;\r",
							"}\r",
							"\r",
							"var ByteBuffer = forge.util.ByteBuffer;\r",
							"var NativeBuffer = typeof Buffer === 'undefined' ? Uint8Array : Buffer;\r",
							"\r",
							"/*\r",
							" * Ed25519 algorithms, see RFC 8032:\r",
							" * https://tools.ietf.org/html/rfc8032\r",
							" */\r",
							"forge.pki = forge.pki || {};\r",
							"module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};\r",
							"var ed25519 = forge.ed25519;\r",
							"\r",
							"ed25519.constants = {};\r",
							"ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;\r",
							"ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;\r",
							"ed25519.constants.SEED_BYTE_LENGTH = 32;\r",
							"ed25519.constants.SIGN_BYTE_LENGTH = 64;\r",
							"ed25519.constants.HASH_BYTE_LENGTH = 64;\r",
							"\r",
							"ed25519.generateKeyPair = function(options) {\r",
							"  options = options || {};\r",
							"  var seed = options.seed;\r",
							"  if(seed === undefined) {\r",
							"    // generate seed\r",
							"    seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);\r",
							"  } else if(typeof seed === 'string') {\r",
							"    if(seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {\r",
							"      throw new TypeError(\r",
							"        '\"seed\" must be ' + ed25519.constants.SEED_BYTE_LENGTH +\r",
							"        ' bytes in length.');\r",
							"    }\r",
							"  } else if(!(seed instanceof Uint8Array)) {\r",
							"    throw new TypeError(\r",
							"      '\"seed\" must be a node.js Buffer, Uint8Array, or a binary string.');\r",
							"  }\r",
							"\r",
							"  seed = messageToNativeBuffer({message: seed, encoding: 'binary'});\r",
							"\r",
							"  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\r",
							"  var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\r",
							"  for(var i = 0; i < 32; ++i) {\r",
							"    sk[i] = seed[i];\r",
							"  }\r",
							"  crypto_sign_keypair(pk, sk);\r",
							"  return {publicKey: pk, privateKey: sk};\r",
							"};\r",
							"\r",
							"ed25519.publicKeyFromPrivateKey = function(options) {\r",
							"  options = options || {};\r",
							"  var privateKey = messageToNativeBuffer({\r",
							"    message: options.privateKey, encoding: 'binary'\r",
							"  });\r",
							"  if(privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.privateKey\" must have a byte length of ' +\r",
							"      ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\r",
							"  }\r",
							"\r",
							"  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\r",
							"  for(var i = 0; i < pk.length; ++i) {\r",
							"    pk[i] = privateKey[32 + i];\r",
							"  }\r",
							"  return pk;\r",
							"};\r",
							"\r",
							"ed25519.sign = function(options) {\r",
							"  options = options || {};\r",
							"  var msg = messageToNativeBuffer(options);\r",
							"  var privateKey = messageToNativeBuffer({\r",
							"    message: options.privateKey,\r",
							"    encoding: 'binary'\r",
							"  });\r",
							"  if(privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.privateKey\" must have a byte length of ' +\r",
							"      ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\r",
							"  }\r",
							"\r",
							"  var signedMsg = new NativeBuffer(\r",
							"    ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\r",
							"  crypto_sign(signedMsg, msg, msg.length, privateKey);\r",
							"\r",
							"  var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);\r",
							"  for(var i = 0; i < sig.length; ++i) {\r",
							"    sig[i] = signedMsg[i];\r",
							"  }\r",
							"  return sig;\r",
							"};\r",
							"\r",
							"ed25519.verify = function(options) {\r",
							"  options = options || {};\r",
							"  var msg = messageToNativeBuffer(options);\r",
							"  if(options.signature === undefined) {\r",
							"    throw new TypeError(\r",
							"      '\"options.signature\" must be a node.js Buffer, a Uint8Array, a forge ' +\r",
							"      'ByteBuffer, or a binary string.');\r",
							"  }\r",
							"  var sig = messageToNativeBuffer({\r",
							"    message: options.signature,\r",
							"    encoding: 'binary'\r",
							"  });\r",
							"  if(sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.signature\" must have a byte length of ' +\r",
							"      ed25519.constants.SIGN_BYTE_LENGTH);\r",
							"  }\r",
							"  var publicKey = messageToNativeBuffer({\r",
							"    message: options.publicKey,\r",
							"    encoding: 'binary'\r",
							"  });\r",
							"  if(publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.publicKey\" must have a byte length of ' +\r",
							"      ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\r",
							"  }\r",
							"\r",
							"  var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\r",
							"  var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\r",
							"  var i;\r",
							"  for(i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {\r",
							"    sm[i] = sig[i];\r",
							"  }\r",
							"  for(i = 0; i < msg.length; ++i) {\r",
							"    sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];\r",
							"  }\r",
							"  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\r",
							"};\r",
							"\r",
							"function messageToNativeBuffer(options) {\r",
							"  var message = options.message;\r",
							"  if(message instanceof Uint8Array) {\r",
							"    return message;\r",
							"  }\r",
							"\r",
							"  var encoding = options.encoding;\r",
							"  if(message === undefined) {\r",
							"    if(options.md) {\r",
							"      // TODO: more rigorous validation that `md` is a MessageDigest\r",
							"      message = options.md.digest().getBytes();\r",
							"      encoding = 'binary';\r",
							"    } else {\r",
							"      throw new TypeError('\"options.message\" or \"options.md\" not specified.');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(typeof message === 'string' && !encoding) {\r",
							"    throw new TypeError('\"options.encoding\" must be \"binary\" or \"utf8\".');\r",
							"  }\r",
							"\r",
							"  if(typeof message === 'string') {\r",
							"    if(typeof Buffer !== 'undefined') {\r",
							"      return new Buffer(message, encoding);\r",
							"    }\r",
							"    message = new ByteBuffer(message, encoding);\r",
							"  } else if(!(message instanceof ByteBuffer)) {\r",
							"    throw new TypeError(\r",
							"      '\"options.message\" must be a node.js Buffer, a Uint8Array, a forge ' +\r",
							"      'ByteBuffer, or a string with \"options.encoding\" specifying its ' +\r",
							"      'encoding.');\r",
							"  }\r",
							"\r",
							"  // convert to native buffer\r",
							"  var buffer = new NativeBuffer(message.length());\r",
							"  for(var i = 0; i < buffer.length; ++i) {\r",
							"    buffer[i] = message.at(i);\r",
							"  }\r",
							"  return buffer;\r",
							"}\r",
							"\r",
							"var gf0 = gf();\r",
							"var gf1 = gf([1]);\r",
							"var D = gf([\r",
							"  0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,\r",
							"  0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]);\r",
							"var D2 = gf([\r",
							"  0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,\r",
							"  0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]);\r",
							"var X = gf([\r",
							"  0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,\r",
							"  0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]);\r",
							"var Y = gf([\r",
							"  0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,\r",
							"  0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]);\r",
							"var L = new Float64Array([\r",
							"  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\r",
							"  0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\r",
							"  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\r",
							"var I = gf([\r",
							"  0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,\r",
							"  0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\r",
							"\r",
							"// TODO: update forge buffer implementation to use `Buffer` or `Uint8Array`,\r",
							"// whichever is available, to improve performance\r",
							"function sha512(msg, msgLen) {\r",
							"  // Note: `out` and `msg` are NativeBuffer\r",
							"  var md = forge.md.sha512.create();\r",
							"  var buffer = new ByteBuffer(msg);\r",
							"  md.update(buffer.getBytes(msgLen), 'binary');\r",
							"  var hash = md.digest().getBytes();\r",
							"  if(typeof Buffer !== 'undefined') {\r",
							"    return new Buffer(hash, 'binary');\r",
							"  }\r",
							"  var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);\r",
							"  for(var i = 0; i < 64; ++i) {\r",
							"    out[i] = hash.charCodeAt(i);\r",
							"  }\r",
							"  return out;\r",
							"}\r",
							"\r",
							"function crypto_sign_keypair(pk, sk) {\r",
							"  var p = [gf(), gf(), gf(), gf()];\r",
							"  var i;\r",
							"\r",
							"  var d = sha512(sk, 32);\r",
							"  d[0] &= 248;\r",
							"  d[31] &= 127;\r",
							"  d[31] |= 64;\r",
							"\r",
							"  scalarbase(p, d);\r",
							"  pack(pk, p);\r",
							"\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    sk[i + 32] = pk[i];\r",
							"  }\r",
							"  return 0;\r",
							"}\r",
							"\r",
							"// Note: difference from C - smlen returned, not passed as argument.\r",
							"function crypto_sign(sm, m, n, sk) {\r",
							"  var i, j, x = new Float64Array(64);\r",
							"  var p = [gf(), gf(), gf(), gf()];\r",
							"\r",
							"  var d = sha512(sk, 32);\r",
							"  d[0] &= 248;\r",
							"  d[31] &= 127;\r",
							"  d[31] |= 64;\r",
							"\r",
							"  var smlen = n + 64;\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    sm[64 + i] = m[i];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    sm[32 + i] = d[32 + i];\r",
							"  }\r",
							"\r",
							"  var r = sha512(sm.subarray(32), n + 32);\r",
							"  reduce(r);\r",
							"  scalarbase(p, r);\r",
							"  pack(sm, p);\r",
							"\r",
							"  for(i = 32; i < 64; ++i) {\r",
							"    sm[i] = sk[i];\r",
							"  }\r",
							"  var h = sha512(sm, n + 64);\r",
							"  reduce(h);\r",
							"\r",
							"  for(i = 32; i < 64; ++i) {\r",
							"    x[i] = 0;\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    x[i] = r[i];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    for(j = 0; j < 32; j++) {\r",
							"      x[i + j] += h[i] * d[j];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  modL(sm.subarray(32), x);\r",
							"  return smlen;\r",
							"}\r",
							"\r",
							"function crypto_sign_open(m, sm, n, pk) {\r",
							"  var i, mlen;\r",
							"  var t = new NativeBuffer(32);\r",
							"  var p = [gf(), gf(), gf(), gf()],\r",
							"      q = [gf(), gf(), gf(), gf()];\r",
							"\r",
							"  mlen = -1;\r",
							"  if(n < 64) {\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  if(unpackneg(q, pk)) {\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    m[i] = sm[i];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    m[i + 32] = pk[i];\r",
							"  }\r",
							"  var h = sha512(m, n);\r",
							"  reduce(h);\r",
							"  scalarmult(p, q, h);\r",
							"\r",
							"  scalarbase(q, sm.subarray(32));\r",
							"  add(p, q);\r",
							"  pack(t, p);\r",
							"\r",
							"  n -= 64;\r",
							"  if(crypto_verify_32(sm, 0, t, 0)) {\r",
							"    for(i = 0; i < n; ++i) {\r",
							"      m[i] = 0;\r",
							"    }\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    m[i] = sm[i + 64];\r",
							"  }\r",
							"  mlen = n;\r",
							"  return mlen;\r",
							"}\r",
							"\r",
							"function modL(r, x) {\r",
							"  var carry, i, j, k;\r",
							"  for(i = 63; i >= 32; --i) {\r",
							"    carry = 0;\r",
							"    for(j = i - 32, k = i - 12; j < k; ++j) {\r",
							"      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\r",
							"      carry = (x[j] + 128) >> 8;\r",
							"      x[j] -= carry * 256;\r",
							"    }\r",
							"    x[j] += carry;\r",
							"    x[i] = 0;\r",
							"  }\r",
							"  carry = 0;\r",
							"  for(j = 0; j < 32; ++j) {\r",
							"    x[j] += carry - (x[31] >> 4) * L[j];\r",
							"    carry = x[j] >> 8;\r",
							"    x[j] &= 255;\r",
							"  }\r",
							"  for(j = 0; j < 32; ++j) {\r",
							"    x[j] -= carry * L[j];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    x[i + 1] += x[i] >> 8;\r",
							"    r[i] = x[i] & 255;\r",
							"  }\r",
							"}\r",
							"\r",
							"function reduce(r) {\r",
							"  var x = new Float64Array(64);\r",
							"  for(var i = 0; i < 64; ++i) {\r",
							"    x[i] = r[i];\r",
							"    r[i] = 0;\r",
							"  }\r",
							"  modL(r, x);\r",
							"}\r",
							"\r",
							"function add(p, q) {\r",
							"  var a = gf(), b = gf(), c = gf(),\r",
							"      d = gf(), e = gf(), f = gf(),\r",
							"      g = gf(), h = gf(), t = gf();\r",
							"\r",
							"  Z(a, p[1], p[0]);\r",
							"  Z(t, q[1], q[0]);\r",
							"  M(a, a, t);\r",
							"  A(b, p[0], p[1]);\r",
							"  A(t, q[0], q[1]);\r",
							"  M(b, b, t);\r",
							"  M(c, p[3], q[3]);\r",
							"  M(c, c, D2);\r",
							"  M(d, p[2], q[2]);\r",
							"  A(d, d, d);\r",
							"  Z(e, b, a);\r",
							"  Z(f, d, c);\r",
							"  A(g, d, c);\r",
							"  A(h, b, a);\r",
							"\r",
							"  M(p[0], e, f);\r",
							"  M(p[1], h, g);\r",
							"  M(p[2], g, f);\r",
							"  M(p[3], e, h);\r",
							"}\r",
							"\r",
							"function cswap(p, q, b) {\r",
							"  for(var i = 0; i < 4; ++i) {\r",
							"    sel25519(p[i], q[i], b);\r",
							"  }\r",
							"}\r",
							"\r",
							"function pack(r, p) {\r",
							"  var tx = gf(), ty = gf(), zi = gf();\r",
							"  inv25519(zi, p[2]);\r",
							"  M(tx, p[0], zi);\r",
							"  M(ty, p[1], zi);\r",
							"  pack25519(r, ty);\r",
							"  r[31] ^= par25519(tx) << 7;\r",
							"}\r",
							"\r",
							"function pack25519(o, n) {\r",
							"  var i, j, b;\r",
							"  var m = gf(), t = gf();\r",
							"  for(i = 0; i < 16; ++i) {\r",
							"    t[i] = n[i];\r",
							"  }\r",
							"  car25519(t);\r",
							"  car25519(t);\r",
							"  car25519(t);\r",
							"  for(j = 0; j < 2; ++j) {\r",
							"    m[0] = t[0] - 0xffed;\r",
							"    for(i = 1; i < 15; ++i) {\r",
							"      m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);\r",
							"      m[i-1] &= 0xffff;\r",
							"    }\r",
							"    m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);\r",
							"    b = (m[15] >> 16) & 1;\r",
							"    m[14] &= 0xffff;\r",
							"    sel25519(t, m, 1 - b);\r",
							"  }\r",
							"  for (i = 0; i < 16; i++) {\r",
							"    o[2 * i] = t[i] & 0xff;\r",
							"    o[2 * i + 1] = t[i] >> 8;\r",
							"  }\r",
							"}\r",
							"\r",
							"function unpackneg(r, p) {\r",
							"  var t = gf(), chk = gf(), num = gf(),\r",
							"      den = gf(), den2 = gf(), den4 = gf(),\r",
							"      den6 = gf();\r",
							"\r",
							"  set25519(r[2], gf1);\r",
							"  unpack25519(r[1], p);\r",
							"  S(num, r[1]);\r",
							"  M(den, num, D);\r",
							"  Z(num, num, r[2]);\r",
							"  A(den, r[2], den);\r",
							"\r",
							"  S(den2, den);\r",
							"  S(den4, den2);\r",
							"  M(den6, den4, den2);\r",
							"  M(t, den6, num);\r",
							"  M(t, t, den);\r",
							"\r",
							"  pow2523(t, t);\r",
							"  M(t, t, num);\r",
							"  M(t, t, den);\r",
							"  M(t, t, den);\r",
							"  M(r[0], t, den);\r",
							"\r",
							"  S(chk, r[0]);\r",
							"  M(chk, chk, den);\r",
							"  if(neq25519(chk, num)) {\r",
							"    M(r[0], r[0], I);\r",
							"  }\r",
							"\r",
							"  S(chk, r[0]);\r",
							"  M(chk, chk, den);\r",
							"  if(neq25519(chk, num)) {\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  if(par25519(r[0]) === (p[31] >> 7)) {\r",
							"    Z(r[0], gf0, r[0]);\r",
							"  }\r",
							"\r",
							"  M(r[3], r[0], r[1]);\r",
							"  return 0;\r",
							"}\r",
							"\r",
							"function unpack25519(o, n) {\r",
							"  var i;\r",
							"  for(i = 0; i < 16; ++i) {\r",
							"    o[i] = n[2 * i] + (n[2 * i + 1] << 8);\r",
							"  }\r",
							"  o[15] &= 0x7fff;\r",
							"}\r",
							"\r",
							"function pow2523(o, i) {\r",
							"  var c = gf();\r",
							"  var a;\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    c[a] = i[a];\r",
							"  }\r",
							"  for(a = 250; a >= 0; --a) {\r",
							"    S(c, c);\r",
							"    if(a !== 1) {\r",
							"      M(c, c, i);\r",
							"    }\r",
							"  }\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    o[a] = c[a];\r",
							"  }\r",
							"}\r",
							"\r",
							"function neq25519(a, b) {\r",
							"  var c = new NativeBuffer(32);\r",
							"  var d = new NativeBuffer(32);\r",
							"  pack25519(c, a);\r",
							"  pack25519(d, b);\r",
							"  return crypto_verify_32(c, 0, d, 0);\r",
							"}\r",
							"\r",
							"function crypto_verify_32(x, xi, y, yi) {\r",
							"  return vn(x, xi, y, yi, 32);\r",
							"}\r",
							"\r",
							"function vn(x, xi, y, yi, n) {\r",
							"  var i, d = 0;\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    d |= x[xi + i] ^ y[yi + i];\r",
							"  }\r",
							"  return (1 & ((d - 1) >>> 8)) - 1;\r",
							"}\r",
							"\r",
							"function par25519(a) {\r",
							"  var d = new NativeBuffer(32);\r",
							"  pack25519(d, a);\r",
							"  return d[0] & 1;\r",
							"}\r",
							"\r",
							"function scalarmult(p, q, s) {\r",
							"  var b, i;\r",
							"  set25519(p[0], gf0);\r",
							"  set25519(p[1], gf1);\r",
							"  set25519(p[2], gf1);\r",
							"  set25519(p[3], gf0);\r",
							"  for(i = 255; i >= 0; --i) {\r",
							"    b = (s[(i / 8)|0] >> (i & 7)) & 1;\r",
							"    cswap(p, q, b);\r",
							"    add(q, p);\r",
							"    add(p, p);\r",
							"    cswap(p, q, b);\r",
							"  }\r",
							"}\r",
							"\r",
							"function scalarbase(p, s) {\r",
							"  var q = [gf(), gf(), gf(), gf()];\r",
							"  set25519(q[0], X);\r",
							"  set25519(q[1], Y);\r",
							"  set25519(q[2], gf1);\r",
							"  M(q[3], X, Y);\r",
							"  scalarmult(p, q, s);\r",
							"}\r",
							"\r",
							"function set25519(r, a) {\r",
							"  var i;\r",
							"  for(i = 0; i < 16; i++) {\r",
							"    r[i] = a[i] | 0;\r",
							"  }\r",
							"}\r",
							"\r",
							"function inv25519(o, i) {\r",
							"  var c = gf();\r",
							"  var a;\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    c[a] = i[a];\r",
							"  }\r",
							"  for(a = 253; a >= 0; --a) {\r",
							"    S(c, c);\r",
							"    if(a !== 2 && a !== 4) {\r",
							"      M(c, c, i);\r",
							"    }\r",
							"  }\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    o[a] = c[a];\r",
							"  }\r",
							"}\r",
							"\r",
							"function car25519(o) {\r",
							"  var i, v, c = 1;\r",
							"  for(i = 0; i < 16; ++i) {\r",
							"    v = o[i] + c + 65535;\r",
							"    c = Math.floor(v / 65536);\r",
							"    o[i] = v - c * 65536;\r",
							"  }\r",
							"  o[0] += c - 1 + 37 * (c - 1);\r",
							"}\r",
							"\r",
							"function sel25519(p, q, b) {\r",
							"  var t, c = ~(b - 1);\r",
							"  for(var i = 0; i < 16; ++i) {\r",
							"    t = c & (p[i] ^ q[i]);\r",
							"    p[i] ^= t;\r",
							"    q[i] ^= t;\r",
							"  }\r",
							"}\r",
							"\r",
							"function gf(init) {\r",
							"  var i, r = new Float64Array(16);\r",
							"  if(init) {\r",
							"    for(i = 0; i < init.length; ++i) {\r",
							"      r[i] = init[i];\r",
							"    }\r",
							"  }\r",
							"  return r;\r",
							"}\r",
							"\r",
							"function A(o, a, b) {\r",
							"  for(var i = 0; i < 16; ++i) {\r",
							"    o[i] = a[i] + b[i];\r",
							"  }\r",
							"}\r",
							"\r",
							"function Z(o, a, b) {\r",
							"  for(var i = 0; i < 16; ++i) {\r",
							"    o[i] = a[i] - b[i];\r",
							"  }\r",
							"}\r",
							"\r",
							"function S(o, a) {\r",
							"  M(o, a, a);\r",
							"}\r",
							"\r",
							"function M(o, a, b) {\r",
							"  var v, c,\r",
							"     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\r",
							"     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\r",
							"    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\r",
							"    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\r",
							"    b0 = b[0],\r",
							"    b1 = b[1],\r",
							"    b2 = b[2],\r",
							"    b3 = b[3],\r",
							"    b4 = b[4],\r",
							"    b5 = b[5],\r",
							"    b6 = b[6],\r",
							"    b7 = b[7],\r",
							"    b8 = b[8],\r",
							"    b9 = b[9],\r",
							"    b10 = b[10],\r",
							"    b11 = b[11],\r",
							"    b12 = b[12],\r",
							"    b13 = b[13],\r",
							"    b14 = b[14],\r",
							"    b15 = b[15];\r",
							"\r",
							"  v = a[0];\r",
							"  t0 += v * b0;\r",
							"  t1 += v * b1;\r",
							"  t2 += v * b2;\r",
							"  t3 += v * b3;\r",
							"  t4 += v * b4;\r",
							"  t5 += v * b5;\r",
							"  t6 += v * b6;\r",
							"  t7 += v * b7;\r",
							"  t8 += v * b8;\r",
							"  t9 += v * b9;\r",
							"  t10 += v * b10;\r",
							"  t11 += v * b11;\r",
							"  t12 += v * b12;\r",
							"  t13 += v * b13;\r",
							"  t14 += v * b14;\r",
							"  t15 += v * b15;\r",
							"  v = a[1];\r",
							"  t1 += v * b0;\r",
							"  t2 += v * b1;\r",
							"  t3 += v * b2;\r",
							"  t4 += v * b3;\r",
							"  t5 += v * b4;\r",
							"  t6 += v * b5;\r",
							"  t7 += v * b6;\r",
							"  t8 += v * b7;\r",
							"  t9 += v * b8;\r",
							"  t10 += v * b9;\r",
							"  t11 += v * b10;\r",
							"  t12 += v * b11;\r",
							"  t13 += v * b12;\r",
							"  t14 += v * b13;\r",
							"  t15 += v * b14;\r",
							"  t16 += v * b15;\r",
							"  v = a[2];\r",
							"  t2 += v * b0;\r",
							"  t3 += v * b1;\r",
							"  t4 += v * b2;\r",
							"  t5 += v * b3;\r",
							"  t6 += v * b4;\r",
							"  t7 += v * b5;\r",
							"  t8 += v * b6;\r",
							"  t9 += v * b7;\r",
							"  t10 += v * b8;\r",
							"  t11 += v * b9;\r",
							"  t12 += v * b10;\r",
							"  t13 += v * b11;\r",
							"  t14 += v * b12;\r",
							"  t15 += v * b13;\r",
							"  t16 += v * b14;\r",
							"  t17 += v * b15;\r",
							"  v = a[3];\r",
							"  t3 += v * b0;\r",
							"  t4 += v * b1;\r",
							"  t5 += v * b2;\r",
							"  t6 += v * b3;\r",
							"  t7 += v * b4;\r",
							"  t8 += v * b5;\r",
							"  t9 += v * b6;\r",
							"  t10 += v * b7;\r",
							"  t11 += v * b8;\r",
							"  t12 += v * b9;\r",
							"  t13 += v * b10;\r",
							"  t14 += v * b11;\r",
							"  t15 += v * b12;\r",
							"  t16 += v * b13;\r",
							"  t17 += v * b14;\r",
							"  t18 += v * b15;\r",
							"  v = a[4];\r",
							"  t4 += v * b0;\r",
							"  t5 += v * b1;\r",
							"  t6 += v * b2;\r",
							"  t7 += v * b3;\r",
							"  t8 += v * b4;\r",
							"  t9 += v * b5;\r",
							"  t10 += v * b6;\r",
							"  t11 += v * b7;\r",
							"  t12 += v * b8;\r",
							"  t13 += v * b9;\r",
							"  t14 += v * b10;\r",
							"  t15 += v * b11;\r",
							"  t16 += v * b12;\r",
							"  t17 += v * b13;\r",
							"  t18 += v * b14;\r",
							"  t19 += v * b15;\r",
							"  v = a[5];\r",
							"  t5 += v * b0;\r",
							"  t6 += v * b1;\r",
							"  t7 += v * b2;\r",
							"  t8 += v * b3;\r",
							"  t9 += v * b4;\r",
							"  t10 += v * b5;\r",
							"  t11 += v * b6;\r",
							"  t12 += v * b7;\r",
							"  t13 += v * b8;\r",
							"  t14 += v * b9;\r",
							"  t15 += v * b10;\r",
							"  t16 += v * b11;\r",
							"  t17 += v * b12;\r",
							"  t18 += v * b13;\r",
							"  t19 += v * b14;\r",
							"  t20 += v * b15;\r",
							"  v = a[6];\r",
							"  t6 += v * b0;\r",
							"  t7 += v * b1;\r",
							"  t8 += v * b2;\r",
							"  t9 += v * b3;\r",
							"  t10 += v * b4;\r",
							"  t11 += v * b5;\r",
							"  t12 += v * b6;\r",
							"  t13 += v * b7;\r",
							"  t14 += v * b8;\r",
							"  t15 += v * b9;\r",
							"  t16 += v * b10;\r",
							"  t17 += v * b11;\r",
							"  t18 += v * b12;\r",
							"  t19 += v * b13;\r",
							"  t20 += v * b14;\r",
							"  t21 += v * b15;\r",
							"  v = a[7];\r",
							"  t7 += v * b0;\r",
							"  t8 += v * b1;\r",
							"  t9 += v * b2;\r",
							"  t10 += v * b3;\r",
							"  t11 += v * b4;\r",
							"  t12 += v * b5;\r",
							"  t13 += v * b6;\r",
							"  t14 += v * b7;\r",
							"  t15 += v * b8;\r",
							"  t16 += v * b9;\r",
							"  t17 += v * b10;\r",
							"  t18 += v * b11;\r",
							"  t19 += v * b12;\r",
							"  t20 += v * b13;\r",
							"  t21 += v * b14;\r",
							"  t22 += v * b15;\r",
							"  v = a[8];\r",
							"  t8 += v * b0;\r",
							"  t9 += v * b1;\r",
							"  t10 += v * b2;\r",
							"  t11 += v * b3;\r",
							"  t12 += v * b4;\r",
							"  t13 += v * b5;\r",
							"  t14 += v * b6;\r",
							"  t15 += v * b7;\r",
							"  t16 += v * b8;\r",
							"  t17 += v * b9;\r",
							"  t18 += v * b10;\r",
							"  t19 += v * b11;\r",
							"  t20 += v * b12;\r",
							"  t21 += v * b13;\r",
							"  t22 += v * b14;\r",
							"  t23 += v * b15;\r",
							"  v = a[9];\r",
							"  t9 += v * b0;\r",
							"  t10 += v * b1;\r",
							"  t11 += v * b2;\r",
							"  t12 += v * b3;\r",
							"  t13 += v * b4;\r",
							"  t14 += v * b5;\r",
							"  t15 += v * b6;\r",
							"  t16 += v * b7;\r",
							"  t17 += v * b8;\r",
							"  t18 += v * b9;\r",
							"  t19 += v * b10;\r",
							"  t20 += v * b11;\r",
							"  t21 += v * b12;\r",
							"  t22 += v * b13;\r",
							"  t23 += v * b14;\r",
							"  t24 += v * b15;\r",
							"  v = a[10];\r",
							"  t10 += v * b0;\r",
							"  t11 += v * b1;\r",
							"  t12 += v * b2;\r",
							"  t13 += v * b3;\r",
							"  t14 += v * b4;\r",
							"  t15 += v * b5;\r",
							"  t16 += v * b6;\r",
							"  t17 += v * b7;\r",
							"  t18 += v * b8;\r",
							"  t19 += v * b9;\r",
							"  t20 += v * b10;\r",
							"  t21 += v * b11;\r",
							"  t22 += v * b12;\r",
							"  t23 += v * b13;\r",
							"  t24 += v * b14;\r",
							"  t25 += v * b15;\r",
							"  v = a[11];\r",
							"  t11 += v * b0;\r",
							"  t12 += v * b1;\r",
							"  t13 += v * b2;\r",
							"  t14 += v * b3;\r",
							"  t15 += v * b4;\r",
							"  t16 += v * b5;\r",
							"  t17 += v * b6;\r",
							"  t18 += v * b7;\r",
							"  t19 += v * b8;\r",
							"  t20 += v * b9;\r",
							"  t21 += v * b10;\r",
							"  t22 += v * b11;\r",
							"  t23 += v * b12;\r",
							"  t24 += v * b13;\r",
							"  t25 += v * b14;\r",
							"  t26 += v * b15;\r",
							"  v = a[12];\r",
							"  t12 += v * b0;\r",
							"  t13 += v * b1;\r",
							"  t14 += v * b2;\r",
							"  t15 += v * b3;\r",
							"  t16 += v * b4;\r",
							"  t17 += v * b5;\r",
							"  t18 += v * b6;\r",
							"  t19 += v * b7;\r",
							"  t20 += v * b8;\r",
							"  t21 += v * b9;\r",
							"  t22 += v * b10;\r",
							"  t23 += v * b11;\r",
							"  t24 += v * b12;\r",
							"  t25 += v * b13;\r",
							"  t26 += v * b14;\r",
							"  t27 += v * b15;\r",
							"  v = a[13];\r",
							"  t13 += v * b0;\r",
							"  t14 += v * b1;\r",
							"  t15 += v * b2;\r",
							"  t16 += v * b3;\r",
							"  t17 += v * b4;\r",
							"  t18 += v * b5;\r",
							"  t19 += v * b6;\r",
							"  t20 += v * b7;\r",
							"  t21 += v * b8;\r",
							"  t22 += v * b9;\r",
							"  t23 += v * b10;\r",
							"  t24 += v * b11;\r",
							"  t25 += v * b12;\r",
							"  t26 += v * b13;\r",
							"  t27 += v * b14;\r",
							"  t28 += v * b15;\r",
							"  v = a[14];\r",
							"  t14 += v * b0;\r",
							"  t15 += v * b1;\r",
							"  t16 += v * b2;\r",
							"  t17 += v * b3;\r",
							"  t18 += v * b4;\r",
							"  t19 += v * b5;\r",
							"  t20 += v * b6;\r",
							"  t21 += v * b7;\r",
							"  t22 += v * b8;\r",
							"  t23 += v * b9;\r",
							"  t24 += v * b10;\r",
							"  t25 += v * b11;\r",
							"  t26 += v * b12;\r",
							"  t27 += v * b13;\r",
							"  t28 += v * b14;\r",
							"  t29 += v * b15;\r",
							"  v = a[15];\r",
							"  t15 += v * b0;\r",
							"  t16 += v * b1;\r",
							"  t17 += v * b2;\r",
							"  t18 += v * b3;\r",
							"  t19 += v * b4;\r",
							"  t20 += v * b5;\r",
							"  t21 += v * b6;\r",
							"  t22 += v * b7;\r",
							"  t23 += v * b8;\r",
							"  t24 += v * b9;\r",
							"  t25 += v * b10;\r",
							"  t26 += v * b11;\r",
							"  t27 += v * b12;\r",
							"  t28 += v * b13;\r",
							"  t29 += v * b14;\r",
							"  t30 += v * b15;\r",
							"\r",
							"  t0  += 38 * t16;\r",
							"  t1  += 38 * t17;\r",
							"  t2  += 38 * t18;\r",
							"  t3  += 38 * t19;\r",
							"  t4  += 38 * t20;\r",
							"  t5  += 38 * t21;\r",
							"  t6  += 38 * t22;\r",
							"  t7  += 38 * t23;\r",
							"  t8  += 38 * t24;\r",
							"  t9  += 38 * t25;\r",
							"  t10 += 38 * t26;\r",
							"  t11 += 38 * t27;\r",
							"  t12 += 38 * t28;\r",
							"  t13 += 38 * t29;\r",
							"  t14 += 38 * t30;\r",
							"  // t15 left as is\r",
							"\r",
							"  // first car\r",
							"  c = 1;\r",
							"  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\r",
							"  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\r",
							"  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\r",
							"  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\r",
							"  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\r",
							"  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\r",
							"  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\r",
							"  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\r",
							"  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\r",
							"  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\r",
							"  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\r",
							"  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\r",
							"  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\r",
							"  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\r",
							"  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\r",
							"  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\r",
							"  t0 += c-1 + 37 * (c-1);\r",
							"\r",
							"  // second car\r",
							"  c = 1;\r",
							"  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\r",
							"  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\r",
							"  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\r",
							"  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\r",
							"  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\r",
							"  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\r",
							"  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\r",
							"  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\r",
							"  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\r",
							"  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\r",
							"  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\r",
							"  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\r",
							"  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\r",
							"  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\r",
							"  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\r",
							"  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\r",
							"  t0 += c-1 + 37 * (c-1);\r",
							"\r",
							"  o[ 0] = t0;\r",
							"  o[ 1] = t1;\r",
							"  o[ 2] = t2;\r",
							"  o[ 3] = t3;\r",
							"  o[ 4] = t4;\r",
							"  o[ 5] = t5;\r",
							"  o[ 6] = t6;\r",
							"  o[ 7] = t7;\r",
							"  o[ 8] = t8;\r",
							"  o[ 9] = t9;\r",
							"  o[10] = t10;\r",
							"  o[11] = t11;\r",
							"  o[12] = t12;\r",
							"  o[13] = t13;\r",
							"  o[14] = t14;\r",
							"  o[15] = t15;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 40 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of RSA-KEM.\r",
							" *\r",
							" * @author Lautaro Cozzani Rodriguez\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\r",
							" * Copyright (c) 2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(12);\r",
							"\r",
							"module.exports = forge.kem = forge.kem || {};\r",
							"\r",
							"var BigInteger = forge.jsbn.BigInteger;\r",
							"\r",
							"/**\r",
							" * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\r",
							" */\r",
							"forge.kem.rsa = {};\r",
							"\r",
							"/**\r",
							" * Creates an RSA KEM API object for generating a secret asymmetric key.\r",
							" *\r",
							" * The symmetric key may be generated via a call to 'encrypt', which will\r",
							" * produce a ciphertext to be transmitted to the recipient and a key to be\r",
							" * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\r",
							" * will produce the same secret key for the recipient to use to decrypt a\r",
							" * message that was encrypted with the secret key.\r",
							" *\r",
							" * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\r",
							" * @param options the options to use.\r",
							" *          [prng] a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" */\r",
							"forge.kem.rsa.create = function(kdf, options) {\r",
							"  options = options || {};\r",
							"  var prng = options.prng || forge.random;\r",
							"\r",
							"  var kem = {};\r",
							"\r",
							"  /**\r",
							"   * Generates a secret key and its encapsulation.\r",
							"   *\r",
							"   * @param publicKey the RSA public key to encrypt with.\r",
							"   * @param keyLength the length, in bytes, of the secret key to generate.\r",
							"   *\r",
							"   * @return an object with:\r",
							"   *   encapsulation: the ciphertext for generating the secret key, as a\r",
							"   *     binary-encoded string of bytes.\r",
							"   *   key: the secret key to use for encrypting a message.\r",
							"   */\r",
							"  kem.encrypt = function(publicKey, keyLength) {\r",
							"    // generate a random r where 1 > r > n\r",
							"    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\r",
							"    var r;\r",
							"    do {\r",
							"      r = new BigInteger(\r",
							"        forge.util.bytesToHex(prng.getBytesSync(byteLength)),\r",
							"        16).mod(publicKey.n);\r",
							"    } while(r.equals(BigInteger.ZERO));\r",
							"\r",
							"    // prepend r with zeros\r",
							"    r = forge.util.hexToBytes(r.toString(16));\r",
							"    var zeros = byteLength - r.length;\r",
							"    if(zeros > 0) {\r",
							"      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\r",
							"    }\r",
							"\r",
							"    // encrypt the random\r",
							"    var encapsulation = publicKey.encrypt(r, 'NONE');\r",
							"\r",
							"    // generate the secret key\r",
							"    var key = kdf.generate(r, keyLength);\r",
							"\r",
							"    return {encapsulation: encapsulation, key: key};\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Decrypts an encapsulated secret key.\r",
							"   *\r",
							"   * @param privateKey the RSA private key to decrypt with.\r",
							"   * @param encapsulation the ciphertext for generating the secret key, as\r",
							"   *          a binary-encoded string of bytes.\r",
							"   * @param keyLength the length, in bytes, of the secret key to generate.\r",
							"   *\r",
							"   * @return the secret key as a binary-encoded string of bytes.\r",
							"   */\r",
							"  kem.decrypt = function(privateKey, encapsulation, keyLength) {\r",
							"    // decrypt the encapsulation and generate the secret key\r",
							"    var r = privateKey.decrypt(encapsulation, 'NONE');\r",
							"    return kdf.generate(r, keyLength);\r",
							"  };\r",
							"\r",
							"  return kem;\r",
							"};\r",
							"\r",
							"// TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\r",
							"\r",
							"/**\r",
							" * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\r",
							" *\r",
							" * @param md the hash API to use.\r",
							" * @param [digestLength] an optional digest length that must be positive and\r",
							" *          less than or equal to md.digestLength.\r",
							" *\r",
							" * @return a KDF1 API object.\r",
							" */\r",
							"forge.kem.kdf1 = function(md, digestLength) {\r",
							"  _createKDF(this, md, 0, digestLength || md.digestLength);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\r",
							" *\r",
							" * @param md the hash API to use.\r",
							" * @param [digestLength] an optional digest length that must be positive and\r",
							" *          less than or equal to md.digestLength.\r",
							" *\r",
							" * @return a KDF2 API object.\r",
							" */\r",
							"forge.kem.kdf2 = function(md, digestLength) {\r",
							"  _createKDF(this, md, 1, digestLength || md.digestLength);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a KDF1 or KDF2 API object.\r",
							" *\r",
							" * @param md the hash API to use.\r",
							" * @param counterStart the starting index for the counter.\r",
							" * @param digestLength the digest length to use.\r",
							" *\r",
							" * @return the KDF API object.\r",
							" */\r",
							"function _createKDF(kdf, md, counterStart, digestLength) {\r",
							"  /**\r",
							"   * Generate a key of the specified length.\r",
							"   *\r",
							"   * @param x the binary-encoded byte string to generate a key from.\r",
							"   * @param length the number of bytes to generate (the size of the key).\r",
							"   *\r",
							"   * @return the key as a binary-encoded string.\r",
							"   */\r",
							"  kdf.generate = function(x, length) {\r",
							"    var key = new forge.util.ByteBuffer();\r",
							"\r",
							"    // run counter from counterStart to ceil(length / Hash.len)\r",
							"    var k = Math.ceil(length / digestLength) + counterStart;\r",
							"\r",
							"    var c = new forge.util.ByteBuffer();\r",
							"    for(var i = counterStart; i < k; ++i) {\r",
							"      // I2OSP(i, 4): convert counter to an octet string of 4 octets\r",
							"      c.putInt32(i);\r",
							"\r",
							"      // digest 'x' and the counter and add the result to the key\r",
							"      md.start();\r",
							"      md.update(x + c.getBytes());\r",
							"      var hash = md.digest();\r",
							"      key.putBytes(hash.getBytes(digestLength));\r",
							"    }\r",
							"\r",
							"    // truncate to the correct key length\r",
							"    key.truncate(key.length() - length);\r",
							"    return key.getBytes();\r",
							"  };\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 41 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for all known Forge message digests.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2017 Digital Bazaar, Inc.\r",
							" */\r",
							"module.exports = __webpack_require__(4);\r",
							"\r",
							"__webpack_require__(14);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(23);\r",
							"__webpack_require__(32);\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 42 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of PKCS#7 v1.5.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" * Copyright (c) 2012-2015 Digital Bazaar, Inc.\r",
							" *\r",
							" * Currently this implementation only supports ContentType of EnvelopedData,\r",
							" * EncryptedData, or SignedData at the root level. The top level elements may\r",
							" * contain only a ContentInfo of ContentType Data, i.e. plain data. Further\r",
							" * nesting is not (yet) supported.\r",
							" *\r",
							" * The Forge validators for PKCS #7's ASN.1 structures are available from\r",
							" * a separate file pkcs7asn1.js, since those are referenced from other\r",
							" * PKCS standards like PKCS #12.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(29);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(16);\r",
							"\r",
							"// shortcut for ASN.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"// shortcut for PKCS#7 API\r",
							"var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#7 message from PEM format.\r",
							" *\r",
							" * @param pem the PEM-formatted PKCS#7 message.\r",
							" *\r",
							" * @return the PKCS#7 message.\r",
							" */\r",
							"p7.messageFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'PKCS7') {\r",
							"    var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' +\r",
							"      'header type is not \"PKCS#7\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body);\r",
							"\r",
							"  return p7.messageFromAsn1(obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#7 message to PEM format.\r",
							" *\r",
							" * @param msg The PKCS#7 message object\r",
							" * @param maxline The maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return The PEM-formatted PKCS#7 message.\r",
							" */\r",
							"p7.messageToPem = function(msg, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var pemObj = {\r",
							"    type: 'PKCS7',\r",
							"    body: asn1.toDer(msg.toAsn1()).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(pemObj, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#7 message from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 representation of a ContentInfo.\r",
							" *\r",
							" * @return the PKCS#7 message.\r",
							" */\r",
							"p7.messageFromAsn1 = function(obj) {\r",
							"  // validate root level ContentInfo and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 message. ' +\r",
							"      'ASN.1 object is not an PKCS#7 ContentInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var contentType = asn1.derToOid(capture.contentType);\r",
							"  var msg;\r",
							"\r",
							"  switch(contentType) {\r",
							"    case forge.pki.oids.envelopedData:\r",
							"      msg = p7.createEnvelopedData();\r",
							"      break;\r",
							"\r",
							"    case forge.pki.oids.encryptedData:\r",
							"      msg = p7.createEncryptedData();\r",
							"      break;\r",
							"\r",
							"    case forge.pki.oids.signedData:\r",
							"      msg = p7.createSignedData();\r",
							"      break;\r",
							"\r",
							"    default:\r",
							"      throw new Error('Cannot read PKCS#7 message. ContentType with OID ' +\r",
							"        contentType + ' is not (yet) supported.');\r",
							"  }\r",
							"\r",
							"  msg.fromAsn1(capture.content.value[0]);\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"p7.createSignedData = function() {\r",
							"  var msg = null;\r",
							"  msg = {\r",
							"    type: forge.pki.oids.signedData,\r",
							"    version: 1,\r",
							"    certificates: [],\r",
							"    crls: [],\r",
							"    // TODO: add json-formatted signer stuff here?\r",
							"    signers: [],\r",
							"    // populated during sign()\r",
							"    digestAlgorithmIdentifiers: [],\r",
							"    contentInfo: null,\r",
							"    signerInfos: [],\r",
							"\r",
							"    fromAsn1: function(obj) {\r",
							"      // validate SignedData content block and capture data.\r",
							"      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);\r",
							"      msg.certificates = [];\r",
							"      msg.crls = [];\r",
							"      msg.digestAlgorithmIdentifiers = [];\r",
							"      msg.contentInfo = null;\r",
							"      msg.signerInfos = [];\r",
							"\r",
							"      if(msg.rawCapture.certificates) {\r",
							"        var certs = msg.rawCapture.certificates.value;\r",
							"        for(var i = 0; i < certs.length; ++i) {\r",
							"          msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // TODO: parse crls\r",
							"    },\r",
							"\r",
							"    toAsn1: function() {\r",
							"      // degenerate case with no content\r",
							"      if(!msg.contentInfo) {\r",
							"        msg.sign();\r",
							"      }\r",
							"\r",
							"      var certs = [];\r",
							"      for(var i = 0; i < msg.certificates.length; ++i) {\r",
							"        certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));\r",
							"      }\r",
							"\r",
							"      var crls = [];\r",
							"      // TODO: implement CRLs\r",
							"\r",
							"      // [0] SignedData\r",
							"      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // Version\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"            asn1.integerToDer(msg.version).getBytes()),\r",
							"          // DigestAlgorithmIdentifiers\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.SET, true,\r",
							"            msg.digestAlgorithmIdentifiers),\r",
							"          // ContentInfo\r",
							"          msg.contentInfo\r",
							"        ])\r",
							"      ]);\r",
							"      if(certs.length > 0) {\r",
							"        // [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL\r",
							"        signedData.value[0].value.push(\r",
							"          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));\r",
							"      }\r",
							"      if(crls.length > 0) {\r",
							"        // [1] IMPLICIT CertificateRevocationLists OPTIONAL\r",
							"        signedData.value[0].value.push(\r",
							"          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));\r",
							"      }\r",
							"      // SignerInfos\r",
							"      signedData.value[0].value.push(\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,\r",
							"          msg.signerInfos));\r",
							"\r",
							"      // ContentInfo\r",
							"      return asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // ContentType\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(msg.type).getBytes()),\r",
							"          // [0] SignedData\r",
							"          signedData\r",
							"        ]);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add (another) entity to list of signers.\r",
							"     *\r",
							"     * Note: If authenticatedAttributes are provided, then, per RFC 2315,\r",
							"     * they must include at least two attributes: content type and\r",
							"     * message digest. The message digest attribute value will be\r",
							"     * auto-calculated during signing and will be ignored if provided.\r",
							"     *\r",
							"     * Here's an example of providing these two attributes:\r",
							"     *\r",
							"     * forge.pkcs7.createSignedData();\r",
							"     * p7.addSigner({\r",
							"     *   issuer: cert.issuer.attributes,\r",
							"     *   serialNumber: cert.serialNumber,\r",
							"     *   key: privateKey,\r",
							"     *   digestAlgorithm: forge.pki.oids.sha1,\r",
							"     *   authenticatedAttributes: [{\r",
							"     *     type: forge.pki.oids.contentType,\r",
							"     *     value: forge.pki.oids.data\r",
							"     *   }, {\r",
							"     *     type: forge.pki.oids.messageDigest\r",
							"     *   }]\r",
							"     * });\r",
							"     *\r",
							"     * TODO: Support [subjectKeyIdentifier] as signer's ID.\r",
							"     *\r",
							"     * @param signer the signer information:\r",
							"     *          key the signer's private key.\r",
							"     *          [certificate] a certificate containing the public key\r",
							"     *            associated with the signer's private key; use this option as\r",
							"     *            an alternative to specifying signer.issuer and\r",
							"     *            signer.serialNumber.\r",
							"     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).\r",
							"     *          [serialNumber] the signer's certificate's serial number in\r",
							"     *           hexadecimal (eg: cert.serialNumber).\r",
							"     *          [digestAlgorithm] the message digest OID, as a string, to use\r",
							"     *            (eg: forge.pki.oids.sha1).\r",
							"     *          [authenticatedAttributes] an optional array of attributes\r",
							"     *            to also sign along with the content.\r",
							"     */\r",
							"    addSigner: function(signer) {\r",
							"      var issuer = signer.issuer;\r",
							"      var serialNumber = signer.serialNumber;\r",
							"      if(signer.certificate) {\r",
							"        var cert = signer.certificate;\r",
							"        if(typeof cert === 'string') {\r",
							"          cert = forge.pki.certificateFromPem(cert);\r",
							"        }\r",
							"        issuer = cert.issuer.attributes;\r",
							"        serialNumber = cert.serialNumber;\r",
							"      }\r",
							"      var key = signer.key;\r",
							"      if(!key) {\r",
							"        throw new Error(\r",
							"          'Could not add PKCS#7 signer; no private key specified.');\r",
							"      }\r",
							"      if(typeof key === 'string') {\r",
							"        key = forge.pki.privateKeyFromPem(key);\r",
							"      }\r",
							"\r",
							"      // ensure OID known for digest algorithm\r",
							"      var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;\r",
							"      switch(digestAlgorithm) {\r",
							"      case forge.pki.oids.sha1:\r",
							"      case forge.pki.oids.sha256:\r",
							"      case forge.pki.oids.sha384:\r",
							"      case forge.pki.oids.sha512:\r",
							"      case forge.pki.oids.md5:\r",
							"        break;\r",
							"      default:\r",
							"        throw new Error(\r",
							"          'Could not add PKCS#7 signer; unknown message digest algorithm: ' +\r",
							"          digestAlgorithm);\r",
							"      }\r",
							"\r",
							"      // if authenticatedAttributes is present, then the attributes\r",
							"      // must contain at least PKCS #9 content-type and message-digest\r",
							"      var authenticatedAttributes = signer.authenticatedAttributes || [];\r",
							"      if(authenticatedAttributes.length > 0) {\r",
							"        var contentType = false;\r",
							"        var messageDigest = false;\r",
							"        for(var i = 0; i < authenticatedAttributes.length; ++i) {\r",
							"          var attr = authenticatedAttributes[i];\r",
							"          if(!contentType && attr.type === forge.pki.oids.contentType) {\r",
							"            contentType = true;\r",
							"            if(messageDigest) {\r",
							"              break;\r",
							"            }\r",
							"            continue;\r",
							"          }\r",
							"          if(!messageDigest && attr.type === forge.pki.oids.messageDigest) {\r",
							"            messageDigest = true;\r",
							"            if(contentType) {\r",
							"              break;\r",
							"            }\r",
							"            continue;\r",
							"          }\r",
							"        }\r",
							"\r",
							"        if(!contentType || !messageDigest) {\r",
							"          throw new Error('Invalid signer.authenticatedAttributes. If ' +\r",
							"            'signer.authenticatedAttributes is specified, then it must ' +\r",
							"            'contain at least two attributes, PKCS #9 content-type and ' +\r",
							"            'PKCS #9 message-digest.');\r",
							"        }\r",
							"      }\r",
							"\r",
							"      msg.signers.push({\r",
							"        key: key,\r",
							"        version: 1,\r",
							"        issuer: issuer,\r",
							"        serialNumber: serialNumber,\r",
							"        digestAlgorithm: digestAlgorithm,\r",
							"        signatureAlgorithm: forge.pki.oids.rsaEncryption,\r",
							"        signature: null,\r",
							"        authenticatedAttributes: authenticatedAttributes,\r",
							"        unauthenticatedAttributes: []\r",
							"      });\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Signs the content.\r",
							"     */\r",
							"    sign: function() {\r",
							"      // auto-generate content info\r",
							"      if(typeof msg.content !== 'object' || msg.contentInfo === null) {\r",
							"        // use Data ContentInfo\r",
							"        msg.contentInfo = asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            // ContentType\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"              asn1.oidToDer(forge.pki.oids.data).getBytes())\r",
							"          ]);\r",
							"\r",
							"        // add actual content, if present\r",
							"        if('content' in msg) {\r",
							"          var content;\r",
							"          if(msg.content instanceof forge.util.ByteBuffer) {\r",
							"            content = msg.content.bytes();\r",
							"          } else if(typeof msg.content === 'string') {\r",
							"            content = forge.util.encodeUtf8(msg.content);\r",
							"          }\r",
							"\r",
							"          msg.contentInfo.value.push(\r",
							"            // [0] EXPLICIT content\r",
							"            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"                content)\r",
							"            ]));\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // no signers, return early (degenerate case for certificate container)\r",
							"      if(msg.signers.length === 0) {\r",
							"        return;\r",
							"      }\r",
							"\r",
							"      // generate digest algorithm identifiers\r",
							"      var mds = addDigestAlgorithmIds();\r",
							"\r",
							"      // generate signerInfos\r",
							"      addSignerInfos(mds);\r",
							"    },\r",
							"\r",
							"    verify: function() {\r",
							"      throw new Error('PKCS#7 signature verification not yet implemented.');\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add a certificate.\r",
							"     *\r",
							"     * @param cert the certificate to add.\r",
							"     */\r",
							"    addCertificate: function(cert) {\r",
							"      // convert from PEM\r",
							"      if(typeof cert === 'string') {\r",
							"        cert = forge.pki.certificateFromPem(cert);\r",
							"      }\r",
							"      msg.certificates.push(cert);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add a certificate revokation list.\r",
							"     *\r",
							"     * @param crl the certificate revokation list to add.\r",
							"     */\r",
							"    addCertificateRevokationList: function(crl) {\r",
							"      throw new Error('PKCS#7 CRL support not yet implemented.');\r",
							"    }\r",
							"  };\r",
							"  return msg;\r",
							"\r",
							"  function addDigestAlgorithmIds() {\r",
							"    var mds = {};\r",
							"\r",
							"    for(var i = 0; i < msg.signers.length; ++i) {\r",
							"      var signer = msg.signers[i];\r",
							"      var oid = signer.digestAlgorithm;\r",
							"      if(!(oid in mds)) {\r",
							"        // content digest\r",
							"        mds[oid] = forge.md[forge.pki.oids[oid]].create();\r",
							"      }\r",
							"      if(signer.authenticatedAttributes.length === 0) {\r",
							"        // no custom attributes to digest; use content message digest\r",
							"        signer.md = mds[oid];\r",
							"      } else {\r",
							"        // custom attributes to be digested; use own message digest\r",
							"        // TODO: optimize to just copy message digest state if that\r",
							"        // feature is ever supported with message digests\r",
							"        signer.md = forge.md[forge.pki.oids[oid]].create();\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // add unique digest algorithm identifiers\r",
							"    msg.digestAlgorithmIdentifiers = [];\r",
							"    for(var oid in mds) {\r",
							"      msg.digestAlgorithmIdentifiers.push(\r",
							"        // AlgorithmIdentifier\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // algorithm\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(oid).getBytes()),\r",
							"          // parameters (null)\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"        ]));\r",
							"    }\r",
							"\r",
							"    return mds;\r",
							"  }\r",
							"\r",
							"  function addSignerInfos(mds) {\r",
							"    // Note: ContentInfo is a SEQUENCE with 2 values, second value is\r",
							"    // the content field and is optional for a ContentInfo but required here\r",
							"    // since signers are present\r",
							"    if(msg.contentInfo.value.length < 2) {\r",
							"      throw new Error(\r",
							"        'Could not sign PKCS#7 message; there is no content to sign.');\r",
							"    }\r",
							"\r",
							"    // get ContentInfo content type\r",
							"    var contentType = asn1.derToOid(msg.contentInfo.value[0].value);\r",
							"\r",
							"    // get ContentInfo content\r",
							"    var content = msg.contentInfo.value[1];\r",
							"    // skip [0] EXPLICIT content wrapper\r",
							"    content = content.value[0];\r",
							"\r",
							"    // serialize content\r",
							"    var bytes = asn1.toDer(content);\r",
							"\r",
							"    // skip identifier and length per RFC 2315 9.3\r",
							"    // skip identifier (1 byte)\r",
							"    bytes.getByte();\r",
							"    // read and discard length bytes\r",
							"    asn1.getBerValueLength(bytes);\r",
							"    bytes = bytes.getBytes();\r",
							"\r",
							"    // digest content DER value bytes\r",
							"    for(var oid in mds) {\r",
							"      mds[oid].start().update(bytes);\r",
							"    }\r",
							"\r",
							"    // sign content\r",
							"    var signingTime = new Date();\r",
							"    for(var i = 0; i < msg.signers.length; ++i) {\r",
							"      var signer = msg.signers[i];\r",
							"\r",
							"      if(signer.authenticatedAttributes.length === 0) {\r",
							"        // if ContentInfo content type is not \"Data\", then\r",
							"        // authenticatedAttributes must be present per RFC 2315\r",
							"        if(contentType !== forge.pki.oids.data) {\r",
							"          throw new Error(\r",
							"            'Invalid signer; authenticatedAttributes must be present ' +\r",
							"            'when the ContentInfo content type is not PKCS#7 Data.');\r",
							"        }\r",
							"      } else {\r",
							"        // process authenticated attributes\r",
							"        // [0] IMPLICIT\r",
							"        signer.authenticatedAttributesAsn1 = asn1.create(\r",
							"          asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\r",
							"\r",
							"        // per RFC 2315, attributes are to be digested using a SET container\r",
							"        // not the above [0] IMPLICIT container\r",
							"        var attrsAsn1 = asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);\r",
							"\r",
							"        for(var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {\r",
							"          var attr = signer.authenticatedAttributes[ai];\r",
							"          if(attr.type === forge.pki.oids.messageDigest) {\r",
							"            // use content message digest as value\r",
							"            attr.value = mds[signer.digestAlgorithm].digest();\r",
							"          } else if(attr.type === forge.pki.oids.signingTime) {\r",
							"            // auto-populate signing time if not already set\r",
							"            if(!attr.value) {\r",
							"              attr.value = signingTime;\r",
							"            }\r",
							"          }\r",
							"\r",
							"          // convert to ASN.1 and push onto Attributes SET (for signing) and\r",
							"          // onto authenticatedAttributesAsn1 to complete SignedData ASN.1\r",
							"          // TODO: optimize away duplication\r",
							"          attrsAsn1.value.push(_attributeToAsn1(attr));\r",
							"          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));\r",
							"        }\r",
							"\r",
							"        // DER-serialize and digest SET OF attributes only\r",
							"        bytes = asn1.toDer(attrsAsn1).getBytes();\r",
							"        signer.md.start().update(bytes);\r",
							"      }\r",
							"\r",
							"      // sign digest\r",
							"      signer.signature = signer.key.sign(signer.md, 'RSASSA-PKCS1-V1_5');\r",
							"    }\r",
							"\r",
							"    // add signer info\r",
							"    msg.signerInfos = _signersToAsn1(msg.signers);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty PKCS#7 message of type EncryptedData.\r",
							" *\r",
							" * @return the message.\r",
							" */\r",
							"p7.createEncryptedData = function() {\r",
							"  var msg = null;\r",
							"  msg = {\r",
							"    type: forge.pki.oids.encryptedData,\r",
							"    version: 0,\r",
							"    encryptedContent: {\r",
							"      algorithm: forge.pki.oids['aes256-CBC']\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Reads an EncryptedData content block (in ASN.1 format)\r",
							"     *\r",
							"     * @param obj The ASN.1 representation of the EncryptedData content block\r",
							"     */\r",
							"    fromAsn1: function(obj) {\r",
							"      // Validate EncryptedData content block and capture data.\r",
							"      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Decrypt encrypted content\r",
							"     *\r",
							"     * @param key The (symmetric) key as a byte buffer\r",
							"     */\r",
							"    decrypt: function(key) {\r",
							"      if(key !== undefined) {\r",
							"        msg.encryptedContent.key = key;\r",
							"      }\r",
							"      _decryptContent(msg);\r",
							"    }\r",
							"  };\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty PKCS#7 message of type EnvelopedData.\r",
							" *\r",
							" * @return the message.\r",
							" */\r",
							"p7.createEnvelopedData = function() {\r",
							"  var msg = null;\r",
							"  msg = {\r",
							"    type: forge.pki.oids.envelopedData,\r",
							"    version: 0,\r",
							"    recipients: [],\r",
							"    encryptedContent: {\r",
							"      algorithm: forge.pki.oids['aes256-CBC']\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Reads an EnvelopedData content block (in ASN.1 format)\r",
							"     *\r",
							"     * @param obj the ASN.1 representation of the EnvelopedData content block.\r",
							"     */\r",
							"    fromAsn1: function(obj) {\r",
							"      // validate EnvelopedData content block and capture data\r",
							"      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);\r",
							"      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);\r",
							"    },\r",
							"\r",
							"    toAsn1: function() {\r",
							"      // ContentInfo\r",
							"      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // ContentType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(msg.type).getBytes()),\r",
							"        // [0] EnvelopedData\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            // Version\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"              asn1.integerToDer(msg.version).getBytes()),\r",
							"            // RecipientInfos\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,\r",
							"              _recipientsToAsn1(msg.recipients)),\r",
							"            // EncryptedContentInfo\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true,\r",
							"              _encryptedContentToAsn1(msg.encryptedContent))\r",
							"          ])\r",
							"        ])\r",
							"      ]);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Find recipient by X.509 certificate's issuer.\r",
							"     *\r",
							"     * @param cert the certificate with the issuer to look for.\r",
							"     *\r",
							"     * @return the recipient object.\r",
							"     */\r",
							"    findRecipient: function(cert) {\r",
							"      var sAttr = cert.issuer.attributes;\r",
							"\r",
							"      for(var i = 0; i < msg.recipients.length; ++i) {\r",
							"        var r = msg.recipients[i];\r",
							"        var rAttr = r.issuer;\r",
							"\r",
							"        if(r.serialNumber !== cert.serialNumber) {\r",
							"          continue;\r",
							"        }\r",
							"\r",
							"        if(rAttr.length !== sAttr.length) {\r",
							"          continue;\r",
							"        }\r",
							"\r",
							"        var match = true;\r",
							"        for(var j = 0; j < sAttr.length; ++j) {\r",
							"          if(rAttr[j].type !== sAttr[j].type ||\r",
							"            rAttr[j].value !== sAttr[j].value) {\r",
							"            match = false;\r",
							"            break;\r",
							"          }\r",
							"        }\r",
							"\r",
							"        if(match) {\r",
							"          return r;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      return null;\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Decrypt enveloped content\r",
							"     *\r",
							"     * @param recipient The recipient object related to the private key\r",
							"     * @param privKey The (RSA) private key object\r",
							"     */\r",
							"    decrypt: function(recipient, privKey) {\r",
							"      if(msg.encryptedContent.key === undefined && recipient !== undefined &&\r",
							"        privKey !== undefined) {\r",
							"        switch(recipient.encryptedContent.algorithm) {\r",
							"          case forge.pki.oids.rsaEncryption:\r",
							"          case forge.pki.oids.desCBC:\r",
							"            var key = privKey.decrypt(recipient.encryptedContent.content);\r",
							"            msg.encryptedContent.key = forge.util.createBuffer(key);\r",
							"            break;\r",
							"\r",
							"          default:\r",
							"            throw new Error('Unsupported asymmetric cipher, ' +\r",
							"              'OID ' + recipient.encryptedContent.algorithm);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      _decryptContent(msg);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add (another) entity to list of recipients.\r",
							"     *\r",
							"     * @param cert The certificate of the entity to add.\r",
							"     */\r",
							"    addRecipient: function(cert) {\r",
							"      msg.recipients.push({\r",
							"        version: 0,\r",
							"        issuer: cert.issuer.attributes,\r",
							"        serialNumber: cert.serialNumber,\r",
							"        encryptedContent: {\r",
							"          // We simply assume rsaEncryption here, since forge.pki only\r",
							"          // supports RSA so far.  If the PKI module supports other\r",
							"          // ciphers one day, we need to modify this one as well.\r",
							"          algorithm: forge.pki.oids.rsaEncryption,\r",
							"          key: cert.publicKey\r",
							"        }\r",
							"      });\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Encrypt enveloped content.\r",
							"     *\r",
							"     * This function supports two optional arguments, cipher and key, which\r",
							"     * can be used to influence symmetric encryption.  Unless cipher is\r",
							"     * provided, the cipher specified in encryptedContent.algorithm is used\r",
							"     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key\r",
							"     * is (re-)used.  If that one's not set, a random key will be generated\r",
							"     * automatically.\r",
							"     *\r",
							"     * @param [key] The key to be used for symmetric encryption.\r",
							"     * @param [cipher] The OID of the symmetric cipher to use.\r",
							"     */\r",
							"    encrypt: function(key, cipher) {\r",
							"      // Part 1: Symmetric encryption\r",
							"      if(msg.encryptedContent.content === undefined) {\r",
							"        cipher = cipher || msg.encryptedContent.algorithm;\r",
							"        key = key || msg.encryptedContent.key;\r",
							"\r",
							"        var keyLen, ivLen, ciphFn;\r",
							"        switch(cipher) {\r",
							"          case forge.pki.oids['aes128-CBC']:\r",
							"            keyLen = 16;\r",
							"            ivLen = 16;\r",
							"            ciphFn = forge.aes.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          case forge.pki.oids['aes192-CBC']:\r",
							"            keyLen = 24;\r",
							"            ivLen = 16;\r",
							"            ciphFn = forge.aes.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          case forge.pki.oids['aes256-CBC']:\r",
							"            keyLen = 32;\r",
							"            ivLen = 16;\r",
							"            ciphFn = forge.aes.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          case forge.pki.oids['des-EDE3-CBC']:\r",
							"            keyLen = 24;\r",
							"            ivLen = 8;\r",
							"            ciphFn = forge.des.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          default:\r",
							"            throw new Error('Unsupported symmetric cipher, OID ' + cipher);\r",
							"        }\r",
							"\r",
							"        if(key === undefined) {\r",
							"          key = forge.util.createBuffer(forge.random.getBytes(keyLen));\r",
							"        } else if(key.length() != keyLen) {\r",
							"          throw new Error('Symmetric key has wrong length; ' +\r",
							"            'got ' + key.length() + ' bytes, expected ' + keyLen + '.');\r",
							"        }\r",
							"\r",
							"        // Keep a copy of the key & IV in the object, so the caller can\r",
							"        // use it for whatever reason.\r",
							"        msg.encryptedContent.algorithm = cipher;\r",
							"        msg.encryptedContent.key = key;\r",
							"        msg.encryptedContent.parameter = forge.util.createBuffer(\r",
							"          forge.random.getBytes(ivLen));\r",
							"\r",
							"        var ciph = ciphFn(key);\r",
							"        ciph.start(msg.encryptedContent.parameter.copy());\r",
							"        ciph.update(msg.content);\r",
							"\r",
							"        // The finish function does PKCS#7 padding by default, therefore\r",
							"        // no action required by us.\r",
							"        if(!ciph.finish()) {\r",
							"          throw new Error('Symmetric encryption failed.');\r",
							"        }\r",
							"\r",
							"        msg.encryptedContent.content = ciph.output;\r",
							"      }\r",
							"\r",
							"      // Part 2: asymmetric encryption for each recipient\r",
							"      for(var i = 0; i < msg.recipients.length; ++i) {\r",
							"        var recipient = msg.recipients[i];\r",
							"\r",
							"        // Nothing to do, encryption already done.\r",
							"        if(recipient.encryptedContent.content !== undefined) {\r",
							"          continue;\r",
							"        }\r",
							"\r",
							"        switch(recipient.encryptedContent.algorithm) {\r",
							"          case forge.pki.oids.rsaEncryption:\r",
							"            recipient.encryptedContent.content =\r",
							"              recipient.encryptedContent.key.encrypt(\r",
							"                msg.encryptedContent.key.data);\r",
							"            break;\r",
							"\r",
							"          default:\r",
							"            throw new Error('Unsupported asymmetric cipher, OID ' +\r",
							"              recipient.encryptedContent.algorithm);\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a single recipient from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 RecipientInfo.\r",
							" *\r",
							" * @return the recipient object.\r",
							" */\r",
							"function _recipientFromAsn1(obj) {\r",
							"  // validate EnvelopedData content block and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 RecipientInfo. ' +\r",
							"      'ASN.1 object is not an PKCS#7 RecipientInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  return {\r",
							"    version: capture.version.charCodeAt(0),\r",
							"    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\r",
							"    serialNumber: forge.util.createBuffer(capture.serial).toHex(),\r",
							"    encryptedContent: {\r",
							"      algorithm: asn1.derToOid(capture.encAlgorithm),\r",
							"      parameter: capture.encParameter.value,\r",
							"      content: capture.encKey\r",
							"    }\r",
							"  };\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a single recipient object to an ASN.1 object.\r",
							" *\r",
							" * @param obj the recipient object.\r",
							" *\r",
							" * @return the ASN.1 RecipientInfo.\r",
							" */\r",
							"function _recipientToAsn1(obj) {\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // Version\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(obj.version).getBytes()),\r",
							"    // IssuerAndSerialNumber\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // Name\r",
							"      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),\r",
							"      // Serial\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        forge.util.hexToBytes(obj.serialNumber))\r",
							"    ]),\r",
							"    // KeyEncryptionAlgorithmIdentifier\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // Algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),\r",
							"      // Parameter, force NULL, only RSA supported for now.\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ]),\r",
							"    // EncryptedKey\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"      obj.encryptedContent.content)\r",
							"  ]);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map a set of RecipientInfo ASN.1 objects to recipient objects.\r",
							" *\r",
							" * @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).\r",
							" *\r",
							" * @return an array of recipient objects.\r",
							" */\r",
							"function _recipientsFromAsn1(infos) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < infos.length; ++i) {\r",
							"    ret.push(_recipientFromAsn1(infos[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map an array of recipient objects to ASN.1 RecipientInfo objects.\r",
							" *\r",
							" * @param recipients an array of recipientInfo objects.\r",
							" *\r",
							" * @return an array of ASN.1 RecipientInfos.\r",
							" */\r",
							"function _recipientsToAsn1(recipients) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < recipients.length; ++i) {\r",
							"    ret.push(_recipientToAsn1(recipients[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a single signer from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 representation of a SignerInfo.\r",
							" *\r",
							" * @return the signer object.\r",
							" */\r",
							"function _signerFromAsn1(obj) {\r",
							"  // validate EnvelopedData content block and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 SignerInfo. ' +\r",
							"      'ASN.1 object is not an PKCS#7 SignerInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var rval = {\r",
							"    version: capture.version.charCodeAt(0),\r",
							"    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\r",
							"    serialNumber: forge.util.createBuffer(capture.serial).toHex(),\r",
							"    digestAlgorithm: asn1.derToOid(capture.digestAlgorithm),\r",
							"    signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm),\r",
							"    signature: capture.signature,\r",
							"    authenticatedAttributes: [],\r",
							"    unauthenticatedAttributes: []\r",
							"  };\r",
							"\r",
							"  // TODO: convert attributes\r",
							"  var authenticatedAttributes = capture.authenticatedAttributes || [];\r",
							"  var unauthenticatedAttributes = capture.unauthenticatedAttributes || [];\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a single signerInfo object to an ASN.1 object.\r",
							" *\r",
							" * @param obj the signerInfo object.\r",
							" *\r",
							" * @return the ASN.1 representation of a SignerInfo.\r",
							" */\r",
							"function _signerToAsn1(obj) {\r",
							"  // SignerInfo\r",
							"  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(obj.version).getBytes()),\r",
							"    // issuerAndSerialNumber\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // name\r",
							"      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),\r",
							"      // serial\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        forge.util.hexToBytes(obj.serialNumber))\r",
							"    ]),\r",
							"    // digestAlgorithm\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(obj.digestAlgorithm).getBytes()),\r",
							"      // parameters (null)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ])\r",
							"  ]);\r",
							"\r",
							"  // authenticatedAttributes (OPTIONAL)\r",
							"  if(obj.authenticatedAttributesAsn1) {\r",
							"    // add ASN.1 previously generated during signing\r",
							"    rval.value.push(obj.authenticatedAttributesAsn1);\r",
							"  }\r",
							"\r",
							"  // digestEncryptionAlgorithm\r",
							"  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // algorithm\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(obj.signatureAlgorithm).getBytes()),\r",
							"    // parameters (null)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"  ]));\r",
							"\r",
							"  // encryptedDigest\r",
							"  rval.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));\r",
							"\r",
							"  // unauthenticatedAttributes (OPTIONAL)\r",
							"  if(obj.unauthenticatedAttributes.length > 0) {\r",
							"    // [1] IMPLICIT\r",
							"    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);\r",
							"    for(var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {\r",
							"      var attr = obj.unauthenticatedAttributes[i];\r",
							"      attrsAsn1.values.push(_attributeToAsn1(attr));\r",
							"    }\r",
							"    rval.value.push(attrsAsn1);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map a set of SignerInfo ASN.1 objects to an array of signer objects.\r",
							" *\r",
							" * @param signerInfoAsn1s an array of ASN.1 SignerInfos (i.e. SET OF).\r",
							" *\r",
							" * @return an array of signers objects.\r",
							" */\r",
							"function _signersFromAsn1(signerInfoAsn1s) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < signerInfoAsn1s.length; ++i) {\r",
							"    ret.push(_signerFromAsn1(signerInfoAsn1s[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map an array of signer objects to ASN.1 objects.\r",
							" *\r",
							" * @param signers an array of signer objects.\r",
							" *\r",
							" * @return an array of ASN.1 SignerInfos.\r",
							" */\r",
							"function _signersToAsn1(signers) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < signers.length; ++i) {\r",
							"    ret.push(_signerToAsn1(signers[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Convert an attribute object to an ASN.1 Attribute.\r",
							" *\r",
							" * @param attr the attribute object.\r",
							" *\r",
							" * @return the ASN.1 Attribute.\r",
							" */\r",
							"function _attributeToAsn1(attr) {\r",
							"  var value;\r",
							"\r",
							"  // TODO: generalize to support more attributes\r",
							"  if(attr.type === forge.pki.oids.contentType) {\r",
							"    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(attr.value).getBytes());\r",
							"  } else if(attr.type === forge.pki.oids.messageDigest) {\r",
							"    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"      attr.value.bytes());\r",
							"  } else if(attr.type === forge.pki.oids.signingTime) {\r",
							"    /* Note per RFC 2985: Dates between 1 January 1950 and 31 December 2049\r",
							"      (inclusive) MUST be encoded as UTCTime. Any dates with year values\r",
							"      before 1950 or after 2049 MUST be encoded as GeneralizedTime. [Further,]\r",
							"      UTCTime values MUST be expressed in Greenwich Mean Time (Zulu) and MUST\r",
							"      include seconds (i.e., times are YYMMDDHHMMSSZ), even where the\r",
							"      number of seconds is zero.  Midnight (GMT) must be represented as\r",
							"      \"YYMMDD000000Z\". */\r",
							"    // TODO: make these module-level constants\r",
							"    var jan_1_1950 = new Date('1950-01-01T00:00:00Z');\r",
							"    var jan_1_2050 = new Date('2050-01-01T00:00:00Z');\r",
							"    var date = attr.value;\r",
							"    if(typeof date === 'string') {\r",
							"      // try to parse date\r",
							"      var timestamp = Date.parse(date);\r",
							"      if(!isNaN(timestamp)) {\r",
							"        date = new Date(timestamp);\r",
							"      } else if(date.length === 13) {\r",
							"        // YYMMDDHHMMSSZ (13 chars for UTCTime)\r",
							"        date = asn1.utcTimeToDate(date);\r",
							"      } else {\r",
							"        // assume generalized time\r",
							"        date = asn1.generalizedTimeToDate(date);\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(date >= jan_1_1950 && date < jan_1_2050) {\r",
							"      value = asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\r",
							"        asn1.dateToUtcTime(date));\r",
							"    } else {\r",
							"      value = asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,\r",
							"        asn1.dateToGeneralizedTime(date));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // TODO: expose as common API call\r",
							"  // create a RelativeDistinguishedName set\r",
							"  // each value in the set is an AttributeTypeAndValue first\r",
							"  // containing the type (an OID) and second the value\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // AttributeType\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(attr.type).getBytes()),\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"      // AttributeValue\r",
							"      value\r",
							"    ])\r",
							"  ]);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map messages encrypted content to ASN.1 objects.\r",
							" *\r",
							" * @param ec The encryptedContent object of the message.\r",
							" *\r",
							" * @return ASN.1 representation of the encryptedContent object (SEQUENCE).\r",
							" */\r",
							"function _encryptedContentToAsn1(ec) {\r",
							"  return [\r",
							"    // ContentType, always Data for the moment\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(forge.pki.oids.data).getBytes()),\r",
							"    // ContentEncryptionAlgorithmIdentifier\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // Algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(ec.algorithm).getBytes()),\r",
							"      // Parameters (IV)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"        ec.parameter.getBytes())\r",
							"    ]),\r",
							"    // [0] EncryptedContent\r",
							"    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"        ec.content.getBytes())\r",
							"    ])\r",
							"  ];\r",
							"}\r",
							"\r",
							"/**\r",
							" * Reads the \"common part\" of an PKCS#7 content block (in ASN.1 format)\r",
							" *\r",
							" * This function reads the \"common part\" of the PKCS#7 content blocks\r",
							" * EncryptedData and EnvelopedData, i.e. version number and symmetrically\r",
							" * encrypted content block.\r",
							" *\r",
							" * The result of the ASN.1 validate and capture process is returned\r",
							" * to allow the caller to extract further data, e.g. the list of recipients\r",
							" * in case of a EnvelopedData object.\r",
							" *\r",
							" * @param msg the PKCS#7 object to read the data to.\r",
							" * @param obj the ASN.1 representation of the content block.\r",
							" * @param validator the ASN.1 structure validator object to use.\r",
							" *\r",
							" * @return the value map captured by validator object.\r",
							" */\r",
							"function _fromAsn1(msg, obj, validator) {\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, validator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 message. ' +\r",
							"      'ASN.1 object is not a supported PKCS#7 message.');\r",
							"    error.errors = error;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // Check contentType, so far we only support (raw) Data.\r",
							"  var contentType = asn1.derToOid(capture.contentType);\r",
							"  if(contentType !== forge.pki.oids.data) {\r",
							"    throw new Error('Unsupported PKCS#7 message. ' +\r",
							"      'Only wrapped ContentType Data supported.');\r",
							"  }\r",
							"\r",
							"  if(capture.encryptedContent) {\r",
							"    var content = '';\r",
							"    if(forge.util.isArray(capture.encryptedContent)) {\r",
							"      for(var i = 0; i < capture.encryptedContent.length; ++i) {\r",
							"        if(capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {\r",
							"          throw new Error('Malformed PKCS#7 message, expecting encrypted ' +\r",
							"            'content constructed of only OCTET STRING objects.');\r",
							"        }\r",
							"        content += capture.encryptedContent[i].value;\r",
							"      }\r",
							"    } else {\r",
							"      content = capture.encryptedContent;\r",
							"    }\r",
							"    msg.encryptedContent = {\r",
							"      algorithm: asn1.derToOid(capture.encAlgorithm),\r",
							"      parameter: forge.util.createBuffer(capture.encParameter.value),\r",
							"      content: forge.util.createBuffer(content)\r",
							"    };\r",
							"  }\r",
							"\r",
							"  if(capture.content) {\r",
							"    var content = '';\r",
							"    if(forge.util.isArray(capture.content)) {\r",
							"      for(var i = 0; i < capture.content.length; ++i) {\r",
							"        if(capture.content[i].type !== asn1.Type.OCTETSTRING) {\r",
							"          throw new Error('Malformed PKCS#7 message, expecting ' +\r",
							"            'content constructed of only OCTET STRING objects.');\r",
							"        }\r",
							"        content += capture.content[i].value;\r",
							"      }\r",
							"    } else {\r",
							"      content = capture.content;\r",
							"    }\r",
							"    msg.content = forge.util.createBuffer(content);\r",
							"  }\r",
							"\r",
							"  msg.version = capture.version.charCodeAt(0);\r",
							"  msg.rawCapture = capture;\r",
							"\r",
							"  return capture;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decrypt the symmetrically encrypted content block of the PKCS#7 message.\r",
							" *\r",
							" * Decryption is skipped in case the PKCS#7 message object already has a\r",
							" * (decrypted) content attribute.  The algorithm, key and cipher parameters\r",
							" * (probably the iv) are taken from the encryptedContent attribute of the\r",
							" * message object.\r",
							" *\r",
							" * @param The PKCS#7 message object.\r",
							" */\r",
							"function _decryptContent(msg) {\r",
							"  if(msg.encryptedContent.key === undefined) {\r",
							"    throw new Error('Symmetric key not available.');\r",
							"  }\r",
							"\r",
							"  if(msg.content === undefined) {\r",
							"    var ciph;\r",
							"\r",
							"    switch(msg.encryptedContent.algorithm) {\r",
							"      case forge.pki.oids['aes128-CBC']:\r",
							"      case forge.pki.oids['aes192-CBC']:\r",
							"      case forge.pki.oids['aes256-CBC']:\r",
							"        ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);\r",
							"        break;\r",
							"\r",
							"      case forge.pki.oids['desCBC']:\r",
							"      case forge.pki.oids['des-EDE3-CBC']:\r",
							"        ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);\r",
							"        break;\r",
							"\r",
							"      default:\r",
							"        throw new Error('Unsupported symmetric cipher, OID ' +\r",
							"          msg.encryptedContent.algorithm);\r",
							"    }\r",
							"    ciph.start(msg.encryptedContent.parameter);\r",
							"    ciph.update(msg.encryptedContent.content);\r",
							"\r",
							"    if(!ciph.finish()) {\r",
							"      throw new Error('Symmetric decryption failed.');\r",
							"    }\r",
							"\r",
							"    msg.content = ciph.output;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 43 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Functions to output keys in SSH-friendly formats.\r",
							" *\r",
							" * This is part of the Forge project which may be used under the terms of\r",
							" * either the BSD License or the GNU General Public License (GPL) Version 2.\r",
							" *\r",
							" * See: https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE\r",
							" *\r",
							" * @author https://github.com/shellac\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(14);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var ssh = module.exports = forge.ssh = forge.ssh || {};\r",
							"\r",
							"/**\r",
							" * Encodes (and optionally encrypts) a private RSA key as a Putty PPK file.\r",
							" *\r",
							" * @param privateKey the key.\r",
							" * @param passphrase a passphrase to protect the key (falsy for no encryption).\r",
							" * @param comment a comment to include in the key file.\r",
							" *\r",
							" * @return the PPK file as a string.\r",
							" */\r",
							"ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {\r",
							"  comment = comment || '';\r",
							"  passphrase = passphrase || '';\r",
							"  var algorithm = 'ssh-rsa';\r",
							"  var encryptionAlgorithm = (passphrase === '') ? 'none' : 'aes256-cbc';\r",
							"\r",
							"  var ppk = 'PuTTY-User-Key-File-2: ' + algorithm + '\\r\\n';\r",
							"  ppk += 'Encryption: ' + encryptionAlgorithm + '\\r\\n';\r",
							"  ppk += 'Comment: ' + comment + '\\r\\n';\r",
							"\r",
							"  // public key into buffer for ppk\r",
							"  var pubbuffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(pubbuffer, algorithm);\r",
							"  _addBigIntegerToBuffer(pubbuffer, privateKey.e);\r",
							"  _addBigIntegerToBuffer(pubbuffer, privateKey.n);\r",
							"\r",
							"  // write public key\r",
							"  var pub = forge.util.encode64(pubbuffer.bytes(), 64);\r",
							"  var length = Math.floor(pub.length / 66) + 1; // 66 = 64 + \\r\\n\r",
							"  ppk += 'Public-Lines: ' + length + '\\r\\n';\r",
							"  ppk += pub;\r",
							"\r",
							"  // private key into a buffer\r",
							"  var privbuffer = forge.util.createBuffer();\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.d);\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.p);\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.q);\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.qInv);\r",
							"\r",
							"  // optionally encrypt the private key\r",
							"  var priv;\r",
							"  if(!passphrase) {\r",
							"    // use the unencrypted buffer\r",
							"    priv = forge.util.encode64(privbuffer.bytes(), 64);\r",
							"  } else {\r",
							"    // encrypt RSA key using passphrase\r",
							"    var encLen = privbuffer.length() + 16 - 1;\r",
							"    encLen -= encLen % 16;\r",
							"\r",
							"    // pad private key with sha1-d data -- needs to be a multiple of 16\r",
							"    var padding = _sha1(privbuffer.bytes());\r",
							"\r",
							"    padding.truncate(padding.length() - encLen + privbuffer.length());\r",
							"    privbuffer.putBuffer(padding);\r",
							"\r",
							"    var aeskey = forge.util.createBuffer();\r",
							"    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x00', passphrase));\r",
							"    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x01', passphrase));\r",
							"\r",
							"    // encrypt some bytes using CBC mode\r",
							"    // key is 40 bytes, so truncate *by* 8 bytes\r",
							"    var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), 'CBC');\r",
							"    cipher.start(forge.util.createBuffer().fillWithByte(0, 16));\r",
							"    cipher.update(privbuffer.copy());\r",
							"    cipher.finish();\r",
							"    var encrypted = cipher.output;\r",
							"\r",
							"    // Note: this appears to differ from Putty -- is forge wrong, or putty?\r",
							"    // due to padding we finish as an exact multiple of 16\r",
							"    encrypted.truncate(16); // all padding\r",
							"\r",
							"    priv = forge.util.encode64(encrypted.bytes(), 64);\r",
							"  }\r",
							"\r",
							"  // output private key\r",
							"  length = Math.floor(priv.length / 66) + 1; // 64 + \\r\\n\r",
							"  ppk += '\\r\\nPrivate-Lines: ' + length + '\\r\\n';\r",
							"  ppk += priv;\r",
							"\r",
							"  // MAC\r",
							"  var mackey = _sha1('putty-private-key-file-mac-key', passphrase);\r",
							"\r",
							"  var macbuffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(macbuffer, algorithm);\r",
							"  _addStringToBuffer(macbuffer, encryptionAlgorithm);\r",
							"  _addStringToBuffer(macbuffer, comment);\r",
							"  macbuffer.putInt32(pubbuffer.length());\r",
							"  macbuffer.putBuffer(pubbuffer);\r",
							"  macbuffer.putInt32(privbuffer.length());\r",
							"  macbuffer.putBuffer(privbuffer);\r",
							"\r",
							"  var hmac = forge.hmac.create();\r",
							"  hmac.start('sha1', mackey);\r",
							"  hmac.update(macbuffer.bytes());\r",
							"\r",
							"  ppk += '\\r\\nPrivate-MAC: ' + hmac.digest().toHex() + '\\r\\n';\r",
							"\r",
							"  return ppk;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a public RSA key as an OpenSSH file.\r",
							" *\r",
							" * @param key the key.\r",
							" * @param comment a comment.\r",
							" *\r",
							" * @return the public key in OpenSSH format.\r",
							" */\r",
							"ssh.publicKeyToOpenSSH = function(key, comment) {\r",
							"  var type = 'ssh-rsa';\r",
							"  comment = comment || '';\r",
							"\r",
							"  var buffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(buffer, type);\r",
							"  _addBigIntegerToBuffer(buffer, key.e);\r",
							"  _addBigIntegerToBuffer(buffer, key.n);\r",
							"\r",
							"  return type + ' ' + forge.util.encode64(buffer.bytes()) + ' ' + comment;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a private RSA key as an OpenSSH file.\r",
							" *\r",
							" * @param key the key.\r",
							" * @param passphrase a passphrase to protect the key (falsy for no encryption).\r",
							" *\r",
							" * @return the public key in OpenSSH format.\r",
							" */\r",
							"ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {\r",
							"  if(!passphrase) {\r",
							"    return forge.pki.privateKeyToPem(privateKey);\r",
							"  }\r",
							"  // OpenSSH private key is just a legacy format, it seems\r",
							"  return forge.pki.encryptRsaPrivateKey(privateKey, passphrase,\r",
							"    {legacy: true, algorithm: 'aes128'});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the SSH fingerprint for the given public key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          [md] the message digest object to use (defaults to forge.md.md5).\r",
							" *          [encoding] an alternative output encoding, such as 'hex'\r",
							" *            (defaults to none, outputs a byte buffer).\r",
							" *          [delimiter] the delimiter to use between bytes for 'hex' encoded\r",
							" *            output, eg: ':' (defaults to none).\r",
							" *\r",
							" * @return the fingerprint as a byte buffer or other encoding based on options.\r",
							" */\r",
							"ssh.getPublicKeyFingerprint = function(key, options) {\r",
							"  options = options || {};\r",
							"  var md = options.md || forge.md.md5.create();\r",
							"\r",
							"  var type = 'ssh-rsa';\r",
							"  var buffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(buffer, type);\r",
							"  _addBigIntegerToBuffer(buffer, key.e);\r",
							"  _addBigIntegerToBuffer(buffer, key.n);\r",
							"\r",
							"  // hash public key bytes\r",
							"  md.start();\r",
							"  md.update(buffer.getBytes());\r",
							"  var digest = md.digest();\r",
							"  if(options.encoding === 'hex') {\r",
							"    var hex = digest.toHex();\r",
							"    if(options.delimiter) {\r",
							"      return hex.match(/.{2}/g).join(options.delimiter);\r",
							"    }\r",
							"    return hex;\r",
							"  } else if(options.encoding === 'binary') {\r",
							"    return digest.getBytes();\r",
							"  } else if(options.encoding) {\r",
							"    throw new Error('Unknown encoding \"' + options.encoding + '\".');\r",
							"  }\r",
							"  return digest;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds len(val) then val to a buffer.\r",
							" *\r",
							" * @param buffer the buffer to add to.\r",
							" * @param val a big integer.\r",
							" */\r",
							"function _addBigIntegerToBuffer(buffer, val) {\r",
							"  var hexVal = val.toString(16);\r",
							"  // ensure 2s complement +ve\r",
							"  if(hexVal[0] >= '8') {\r",
							"    hexVal = '00' + hexVal;\r",
							"  }\r",
							"  var bytes = forge.util.hexToBytes(hexVal);\r",
							"  buffer.putInt32(bytes.length);\r",
							"  buffer.putBytes(bytes);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Adds len(val) then val to a buffer.\r",
							" *\r",
							" * @param buffer the buffer to add to.\r",
							" * @param val a string.\r",
							" */\r",
							"function _addStringToBuffer(buffer, val) {\r",
							"  buffer.putInt32(val.length);\r",
							"  buffer.putString(val);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Hashes the arguments into one value using SHA-1.\r",
							" *\r",
							" * @return the sha1 hash of the provided arguments.\r",
							" */\r",
							"function _sha1() {\r",
							"  var sha = forge.md.sha1.create();\r",
							"  var num = arguments.length;\r",
							"  for (var i = 0; i < num; ++i) {\r",
							"    sha.update(arguments[i]);\r",
							"  }\r",
							"  return sha.digest();\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 44 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Support for concurrent task management and synchronization in web\r",
							" * applications.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author David I. Lehn <dlehn@digitalbazaar.com>\r",
							" *\r",
							" * Copyright (c) 2009-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(31);\r",
							"__webpack_require__(33);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// logging category\r",
							"var cat = 'forge.task';\r",
							"\r",
							"// verbose level\r",
							"// 0: off, 1: a little, 2: a whole lot\r",
							"// Verbose debug logging is surrounded by a level check to avoid the\r",
							"// performance issues with even calling the logging code regardless if it\r",
							"// is actually logged.  For performance reasons this should not be set to 2\r",
							"// for production use.\r",
							"// ex: if(sVL >= 2) forge.log.verbose(....)\r",
							"var sVL = 0;\r",
							"\r",
							"// track tasks for debugging\r",
							"var sTasks = {};\r",
							"var sNextTaskId = 0;\r",
							"// debug access\r",
							"forge.debug.set(cat, 'tasks', sTasks);\r",
							"\r",
							"// a map of task type to task queue\r",
							"var sTaskQueues = {};\r",
							"// debug access\r",
							"forge.debug.set(cat, 'queues', sTaskQueues);\r",
							"\r",
							"// name for unnamed tasks\r",
							"var sNoTaskName = '?';\r",
							"\r",
							"// maximum number of doNext() recursions before a context swap occurs\r",
							"// FIXME: might need to tweak this based on the browser\r",
							"var sMaxRecursions = 30;\r",
							"\r",
							"// time slice for doing tasks before a context swap occurs\r",
							"// FIXME: might need to tweak this based on the browser\r",
							"var sTimeSlice = 20;\r",
							"\r",
							"/**\r",
							" * Task states.\r",
							" *\r",
							" * READY: ready to start processing\r",
							" * RUNNING: task or a subtask is running\r",
							" * BLOCKED: task is waiting to acquire N permits to continue\r",
							" * SLEEPING: task is sleeping for a period of time\r",
							" * DONE: task is done\r",
							" * ERROR: task has an error\r",
							" */\r",
							"var READY = 'ready';\r",
							"var RUNNING = 'running';\r",
							"var BLOCKED = 'blocked';\r",
							"var SLEEPING = 'sleeping';\r",
							"var DONE = 'done';\r",
							"var ERROR = 'error';\r",
							"\r",
							"/**\r",
							" * Task actions.  Used to control state transitions.\r",
							" *\r",
							" * STOP: stop processing\r",
							" * START: start processing tasks\r",
							" * BLOCK: block task from continuing until 1 or more permits are released\r",
							" * UNBLOCK: release one or more permits\r",
							" * SLEEP: sleep for a period of time\r",
							" * WAKEUP: wakeup early from SLEEPING state\r",
							" * CANCEL: cancel further tasks\r",
							" * FAIL: a failure occured\r",
							" */\r",
							"var STOP = 'stop';\r",
							"var START = 'start';\r",
							"var BLOCK = 'block';\r",
							"var UNBLOCK = 'unblock';\r",
							"var SLEEP = 'sleep';\r",
							"var WAKEUP = 'wakeup';\r",
							"var CANCEL = 'cancel';\r",
							"var FAIL = 'fail';\r",
							"\r",
							"/**\r",
							" * State transition table.\r",
							" *\r",
							" * nextState = sStateTable[currentState][action]\r",
							" */\r",
							"var sStateTable = {};\r",
							"\r",
							"sStateTable[READY] = {};\r",
							"sStateTable[READY][STOP] = READY;\r",
							"sStateTable[READY][START] = RUNNING;\r",
							"sStateTable[READY][CANCEL] = DONE;\r",
							"sStateTable[READY][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[RUNNING] = {};\r",
							"sStateTable[RUNNING][STOP] = READY;\r",
							"sStateTable[RUNNING][START] = RUNNING;\r",
							"sStateTable[RUNNING][BLOCK] = BLOCKED;\r",
							"sStateTable[RUNNING][UNBLOCK] = RUNNING;\r",
							"sStateTable[RUNNING][SLEEP] = SLEEPING;\r",
							"sStateTable[RUNNING][WAKEUP] = RUNNING;\r",
							"sStateTable[RUNNING][CANCEL] = DONE;\r",
							"sStateTable[RUNNING][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[BLOCKED] = {};\r",
							"sStateTable[BLOCKED][STOP] = BLOCKED;\r",
							"sStateTable[BLOCKED][START] = BLOCKED;\r",
							"sStateTable[BLOCKED][BLOCK] = BLOCKED;\r",
							"sStateTable[BLOCKED][UNBLOCK] = BLOCKED;\r",
							"sStateTable[BLOCKED][SLEEP] = BLOCKED;\r",
							"sStateTable[BLOCKED][WAKEUP] = BLOCKED;\r",
							"sStateTable[BLOCKED][CANCEL] = DONE;\r",
							"sStateTable[BLOCKED][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[SLEEPING] = {};\r",
							"sStateTable[SLEEPING][STOP] = SLEEPING;\r",
							"sStateTable[SLEEPING][START] = SLEEPING;\r",
							"sStateTable[SLEEPING][BLOCK] = SLEEPING;\r",
							"sStateTable[SLEEPING][UNBLOCK] = SLEEPING;\r",
							"sStateTable[SLEEPING][SLEEP] = SLEEPING;\r",
							"sStateTable[SLEEPING][WAKEUP] = SLEEPING;\r",
							"sStateTable[SLEEPING][CANCEL] = DONE;\r",
							"sStateTable[SLEEPING][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[DONE] = {};\r",
							"sStateTable[DONE][STOP] = DONE;\r",
							"sStateTable[DONE][START] = DONE;\r",
							"sStateTable[DONE][BLOCK] = DONE;\r",
							"sStateTable[DONE][UNBLOCK] = DONE;\r",
							"sStateTable[DONE][SLEEP] = DONE;\r",
							"sStateTable[DONE][WAKEUP] = DONE;\r",
							"sStateTable[DONE][CANCEL] = DONE;\r",
							"sStateTable[DONE][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[ERROR] = {};\r",
							"sStateTable[ERROR][STOP] = ERROR;\r",
							"sStateTable[ERROR][START] = ERROR;\r",
							"sStateTable[ERROR][BLOCK] = ERROR;\r",
							"sStateTable[ERROR][UNBLOCK] = ERROR;\r",
							"sStateTable[ERROR][SLEEP] = ERROR;\r",
							"sStateTable[ERROR][WAKEUP] = ERROR;\r",
							"sStateTable[ERROR][CANCEL] = ERROR;\r",
							"sStateTable[ERROR][FAIL] = ERROR;\r",
							"\r",
							"/**\r",
							" * Creates a new task.\r",
							" *\r",
							" * @param options options for this task\r",
							" *   run: the run function for the task (required)\r",
							" *   name: the run function for the task (optional)\r",
							" *   parent: parent of this task (optional)\r",
							" *\r",
							" * @return the empty task.\r",
							" */\r",
							"var Task = function(options) {\r",
							"  // task id\r",
							"  this.id = -1;\r",
							"\r",
							"  // task name\r",
							"  this.name = options.name || sNoTaskName;\r",
							"\r",
							"  // task has no parent\r",
							"  this.parent = options.parent || null;\r",
							"\r",
							"  // save run function\r",
							"  this.run = options.run;\r",
							"\r",
							"  // create a queue of subtasks to run\r",
							"  this.subtasks = [];\r",
							"\r",
							"  // error flag\r",
							"  this.error = false;\r",
							"\r",
							"  // state of the task\r",
							"  this.state = READY;\r",
							"\r",
							"  // number of times the task has been blocked (also the number\r",
							"  // of permits needed to be released to continue running)\r",
							"  this.blocks = 0;\r",
							"\r",
							"  // timeout id when sleeping\r",
							"  this.timeoutId = null;\r",
							"\r",
							"  // no swap time yet\r",
							"  this.swapTime = null;\r",
							"\r",
							"  // no user data\r",
							"  this.userData = null;\r",
							"\r",
							"  // initialize task\r",
							"  // FIXME: deal with overflow\r",
							"  this.id = sNextTaskId++;\r",
							"  sTasks[this.id] = this;\r",
							"  if(sVL >= 1) {\r",
							"    forge.log.verbose(cat, '[%s][%s] init', this.id, this.name, this);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Logs debug information on this task and the system state.\r",
							" */\r",
							"Task.prototype.debug = function(msg) {\r",
							"  msg = msg || '';\r",
							"  forge.log.debug(cat, msg,\r",
							"    '[%s][%s] task:', this.id, this.name, this,\r",
							"    'subtasks:', this.subtasks.length,\r",
							"    'queue:', sTaskQueues);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds a subtask to run after task.doNext() or task.fail() is called.\r",
							" *\r",
							" * @param name human readable name for this task (optional).\r",
							" * @param subrun a function to run that takes the current task as\r",
							" *          its first parameter.\r",
							" *\r",
							" * @return the current task (useful for chaining next() calls).\r",
							" */\r",
							"Task.prototype.next = function(name, subrun) {\r",
							"  // juggle parameters if it looks like no name is given\r",
							"  if(typeof(name) === 'function') {\r",
							"    subrun = name;\r",
							"\r",
							"    // inherit parent's name\r",
							"    name = this.name;\r",
							"  }\r",
							"  // create subtask, set parent to this task, propagate callbacks\r",
							"  var subtask = new Task({\r",
							"    run: subrun,\r",
							"    name: name,\r",
							"    parent: this\r",
							"  });\r",
							"  // start subtasks running\r",
							"  subtask.state = RUNNING;\r",
							"  subtask.type = this.type;\r",
							"  subtask.successCallback = this.successCallback || null;\r",
							"  subtask.failureCallback = this.failureCallback || null;\r",
							"\r",
							"  // queue a new subtask\r",
							"  this.subtasks.push(subtask);\r",
							"\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds subtasks to run in parallel after task.doNext() or task.fail()\r",
							" * is called.\r",
							" *\r",
							" * @param name human readable name for this task (optional).\r",
							" * @param subrun functions to run that take the current task as\r",
							" *          their first parameter.\r",
							" *\r",
							" * @return the current task (useful for chaining next() calls).\r",
							" */\r",
							"Task.prototype.parallel = function(name, subrun) {\r",
							"  // juggle parameters if it looks like no name is given\r",
							"  if(forge.util.isArray(name)) {\r",
							"    subrun = name;\r",
							"\r",
							"    // inherit parent's name\r",
							"    name = this.name;\r",
							"  }\r",
							"  // Wrap parallel tasks in a regular task so they are started at the\r",
							"  // proper time.\r",
							"  return this.next(name, function(task) {\r",
							"    // block waiting for subtasks\r",
							"    var ptask = task;\r",
							"    ptask.block(subrun.length);\r",
							"\r",
							"    // we pass the iterator from the loop below as a parameter\r",
							"    // to a function because it is otherwise included in the\r",
							"    // closure and changes as the loop changes -- causing i\r",
							"    // to always be set to its highest value\r",
							"    var startParallelTask = function(pname, pi) {\r",
							"      forge.task.start({\r",
							"        type: pname,\r",
							"        run: function(task) {\r",
							"           subrun[pi](task);\r",
							"        },\r",
							"        success: function(task) {\r",
							"           ptask.unblock();\r",
							"        },\r",
							"        failure: function(task) {\r",
							"           ptask.unblock();\r",
							"        }\r",
							"      });\r",
							"    };\r",
							"\r",
							"    for(var i = 0; i < subrun.length; i++) {\r",
							"      // Type must be unique so task starts in parallel:\r",
							"      //    name + private string + task id + sub-task index\r",
							"      // start tasks in parallel and unblock when the finish\r",
							"      var pname = name + '__parallel-' + task.id + '-' + i;\r",
							"      var pi = i;\r",
							"      startParallelTask(pname, pi);\r",
							"    }\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Stops a running task.\r",
							" */\r",
							"Task.prototype.stop = function() {\r",
							"  this.state = sStateTable[this.state][STOP];\r",
							"};\r",
							"\r",
							"/**\r",
							" * Starts running a task.\r",
							" */\r",
							"Task.prototype.start = function() {\r",
							"  this.error = false;\r",
							"  this.state = sStateTable[this.state][START];\r",
							"\r",
							"  // try to restart\r",
							"  if(this.state === RUNNING) {\r",
							"    this.start = new Date();\r",
							"    this.run(this);\r",
							"    runNext(this, 0);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Blocks a task until it one or more permits have been released. The\r",
							" * task will not resume until the requested number of permits have\r",
							" * been released with call(s) to unblock().\r",
							" *\r",
							" * @param n number of permits to wait for(default: 1).\r",
							" */\r",
							"Task.prototype.block = function(n) {\r",
							"  n = typeof(n) === 'undefined' ? 1 : n;\r",
							"  this.blocks += n;\r",
							"  if(this.blocks > 0) {\r",
							"    this.state = sStateTable[this.state][BLOCK];\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Releases a permit to unblock a task. If a task was blocked by\r",
							" * requesting N permits via block(), then it will only continue\r",
							" * running once enough permits have been released via unblock() calls.\r",
							" *\r",
							" * If multiple processes need to synchronize with a single task then\r",
							" * use a condition variable (see forge.task.createCondition). It is\r",
							" * an error to unblock a task more times than it has been blocked.\r",
							" *\r",
							" * @param n number of permits to release (default: 1).\r",
							" *\r",
							" * @return the current block count (task is unblocked when count is 0)\r",
							" */\r",
							"Task.prototype.unblock = function(n) {\r",
							"  n = typeof(n) === 'undefined' ? 1 : n;\r",
							"  this.blocks -= n;\r",
							"  if(this.blocks === 0 && this.state !== DONE) {\r",
							"    this.state = RUNNING;\r",
							"    runNext(this, 0);\r",
							"  }\r",
							"  return this.blocks;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sleep for a period of time before resuming tasks.\r",
							" *\r",
							" * @param n number of milliseconds to sleep (default: 0).\r",
							" */\r",
							"Task.prototype.sleep = function(n) {\r",
							"  n = typeof(n) === 'undefined' ? 0 : n;\r",
							"  this.state = sStateTable[this.state][SLEEP];\r",
							"  var self = this;\r",
							"  this.timeoutId = setTimeout(function() {\r",
							"    self.timeoutId = null;\r",
							"    self.state = RUNNING;\r",
							"    runNext(self, 0);\r",
							"  }, n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Waits on a condition variable until notified. The next task will\r",
							" * not be scheduled until notification. A condition variable can be\r",
							" * created with forge.task.createCondition().\r",
							" *\r",
							" * Once cond.notify() is called, the task will continue.\r",
							" *\r",
							" * @param cond the condition variable to wait on.\r",
							" */\r",
							"Task.prototype.wait = function(cond) {\r",
							"  cond.wait(this);\r",
							"};\r",
							"\r",
							"/**\r",
							" * If sleeping, wakeup and continue running tasks.\r",
							" */\r",
							"Task.prototype.wakeup = function() {\r",
							"  if(this.state === SLEEPING) {\r",
							"    cancelTimeout(this.timeoutId);\r",
							"    this.timeoutId = null;\r",
							"    this.state = RUNNING;\r",
							"    runNext(this, 0);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Cancel all remaining subtasks of this task.\r",
							" */\r",
							"Task.prototype.cancel = function() {\r",
							"  this.state = sStateTable[this.state][CANCEL];\r",
							"  // remove permits needed\r",
							"  this.permitsNeeded = 0;\r",
							"  // cancel timeouts\r",
							"  if(this.timeoutId !== null) {\r",
							"    cancelTimeout(this.timeoutId);\r",
							"    this.timeoutId = null;\r",
							"  }\r",
							"  // remove subtasks\r",
							"  this.subtasks = [];\r",
							"};\r",
							"\r",
							"/**\r",
							" * Finishes this task with failure and sets error flag. The entire\r",
							" * task will be aborted unless the next task that should execute\r",
							" * is passed as a parameter. This allows levels of subtasks to be\r",
							" * skipped. For instance, to abort only this tasks's subtasks, then\r",
							" * call fail(task.parent). To abort this task's subtasks and its\r",
							" * parent's subtasks, call fail(task.parent.parent). To abort\r",
							" * all tasks and simply call the task callback, call fail() or\r",
							" * fail(null).\r",
							" *\r",
							" * The task callback (success or failure) will always, eventually, be\r",
							" * called.\r",
							" *\r",
							" * @param next the task to continue at, or null to abort entirely.\r",
							" */\r",
							"Task.prototype.fail = function(next) {\r",
							"  // set error flag\r",
							"  this.error = true;\r",
							"\r",
							"  // finish task\r",
							"  finish(this, true);\r",
							"\r",
							"  if(next) {\r",
							"    // propagate task info\r",
							"    next.error = this.error;\r",
							"    next.swapTime = this.swapTime;\r",
							"    next.userData = this.userData;\r",
							"\r",
							"    // do next task as specified\r",
							"    runNext(next, 0);\r",
							"  } else {\r",
							"    if(this.parent !== null) {\r",
							"      // finish root task (ensures it is removed from task queue)\r",
							"      var parent = this.parent;\r",
							"      while(parent.parent !== null) {\r",
							"        // propagate task info\r",
							"        parent.error = this.error;\r",
							"        parent.swapTime = this.swapTime;\r",
							"        parent.userData = this.userData;\r",
							"        parent = parent.parent;\r",
							"      }\r",
							"      finish(parent, true);\r",
							"    }\r",
							"\r",
							"    // call failure callback if one exists\r",
							"    if(this.failureCallback) {\r",
							"      this.failureCallback(this);\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Asynchronously start a task.\r",
							" *\r",
							" * @param task the task to start.\r",
							" */\r",
							"var start = function(task) {\r",
							"  task.error = false;\r",
							"  task.state = sStateTable[task.state][START];\r",
							"  setTimeout(function() {\r",
							"    if(task.state === RUNNING) {\r",
							"      task.swapTime = +new Date();\r",
							"      task.run(task);\r",
							"      runNext(task, 0);\r",
							"    }\r",
							"  }, 0);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Run the next subtask or finish this task.\r",
							" *\r",
							" * @param task the task to process.\r",
							" * @param recurse the recursion count.\r",
							" */\r",
							"var runNext = function(task, recurse) {\r",
							"  // get time since last context swap (ms), if enough time has passed set\r",
							"  // swap to true to indicate that doNext was performed asynchronously\r",
							"  // also, if recurse is too high do asynchronously\r",
							"  var swap =\r",
							"    (recurse > sMaxRecursions) ||\r",
							"    (+new Date() - task.swapTime) > sTimeSlice;\r",
							"\r",
							"  var doNext = function(recurse) {\r",
							"    recurse++;\r",
							"    if(task.state === RUNNING) {\r",
							"      if(swap) {\r",
							"        // update swap time\r",
							"        task.swapTime = +new Date();\r",
							"      }\r",
							"\r",
							"      if(task.subtasks.length > 0) {\r",
							"        // run next subtask\r",
							"        var subtask = task.subtasks.shift();\r",
							"        subtask.error = task.error;\r",
							"        subtask.swapTime = task.swapTime;\r",
							"        subtask.userData = task.userData;\r",
							"        subtask.run(subtask);\r",
							"        if(!subtask.error) {\r",
							"           runNext(subtask, recurse);\r",
							"        }\r",
							"      } else {\r",
							"        finish(task);\r",
							"\r",
							"        if(!task.error) {\r",
							"          // chain back up and run parent\r",
							"          if(task.parent !== null) {\r",
							"            // propagate task info\r",
							"            task.parent.error = task.error;\r",
							"            task.parent.swapTime = task.swapTime;\r",
							"            task.parent.userData = task.userData;\r",
							"\r",
							"            // no subtasks left, call run next subtask on parent\r",
							"            runNext(task.parent, recurse);\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  if(swap) {\r",
							"    // we're swapping, so run asynchronously\r",
							"    setTimeout(doNext, 0);\r",
							"  } else {\r",
							"    // not swapping, so run synchronously\r",
							"    doNext(recurse);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Finishes a task and looks for the next task in the queue to start.\r",
							" *\r",
							" * @param task the task to finish.\r",
							" * @param suppressCallbacks true to suppress callbacks.\r",
							" */\r",
							"var finish = function(task, suppressCallbacks) {\r",
							"  // subtask is now done\r",
							"  task.state = DONE;\r",
							"\r",
							"  delete sTasks[task.id];\r",
							"  if(sVL >= 1) {\r",
							"    forge.log.verbose(cat, '[%s][%s] finish',\r",
							"      task.id, task.name, task);\r",
							"  }\r",
							"\r",
							"  // only do queue processing for root tasks\r",
							"  if(task.parent === null) {\r",
							"    // report error if queue is missing\r",
							"    if(!(task.type in sTaskQueues)) {\r",
							"      forge.log.error(cat,\r",
							"        '[%s][%s] task queue missing [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    } else if(sTaskQueues[task.type].length === 0) {\r",
							"      // report error if queue is empty\r",
							"      forge.log.error(cat,\r",
							"        '[%s][%s] task queue empty [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    } else if(sTaskQueues[task.type][0] !== task) {\r",
							"      // report error if this task isn't the first in the queue\r",
							"      forge.log.error(cat,\r",
							"        '[%s][%s] task not first in queue [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    } else {\r",
							"      // remove ourselves from the queue\r",
							"      sTaskQueues[task.type].shift();\r",
							"      // clean up queue if it is empty\r",
							"      if(sTaskQueues[task.type].length === 0) {\r",
							"        if(sVL >= 1) {\r",
							"          forge.log.verbose(cat, '[%s][%s] delete queue [%s]',\r",
							"            task.id, task.name, task.type);\r",
							"        }\r",
							"        /* Note: Only a task can delete a queue of its own type. This\r",
							"         is used as a way to synchronize tasks. If a queue for a certain\r",
							"         task type exists, then a task of that type is running.\r",
							"         */\r",
							"        delete sTaskQueues[task.type];\r",
							"      } else {\r",
							"        // dequeue the next task and start it\r",
							"        if(sVL >= 1) {\r",
							"          forge.log.verbose(cat,\r",
							"            '[%s][%s] queue start next [%s] remain:%s',\r",
							"            task.id, task.name, task.type,\r",
							"            sTaskQueues[task.type].length);\r",
							"        }\r",
							"        sTaskQueues[task.type][0].start();\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(!suppressCallbacks) {\r",
							"      // call final callback if one exists\r",
							"      if(task.error && task.failureCallback) {\r",
							"        task.failureCallback(task);\r",
							"      } else if(!task.error && task.successCallback) {\r",
							"        task.successCallback(task);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/* Tasks API */\r",
							"module.exports = forge.task = forge.task || {};\r",
							"\r",
							"/**\r",
							" * Starts a new task that will run the passed function asynchronously.\r",
							" *\r",
							" * In order to finish the task, either task.doNext() or task.fail()\r",
							" * *must* be called.\r",
							" *\r",
							" * The task must have a type (a string identifier) that can be used to\r",
							" * synchronize it with other tasks of the same type. That type can also\r",
							" * be used to cancel tasks that haven't started yet.\r",
							" *\r",
							" * To start a task, the following object must be provided as a parameter\r",
							" * (each function takes a task object as its first parameter):\r",
							" *\r",
							" * {\r",
							" *   type: the type of task.\r",
							" *   run: the function to run to execute the task.\r",
							" *   success: a callback to call when the task succeeds (optional).\r",
							" *   failure: a callback to call when the task fails (optional).\r",
							" * }\r",
							" *\r",
							" * @param options the object as described above.\r",
							" */\r",
							"forge.task.start = function(options) {\r",
							"  // create a new task\r",
							"  var task = new Task({\r",
							"    run: options.run,\r",
							"    name: options.name || sNoTaskName\r",
							"  });\r",
							"  task.type = options.type;\r",
							"  task.successCallback = options.success || null;\r",
							"  task.failureCallback = options.failure || null;\r",
							"\r",
							"  // append the task onto the appropriate queue\r",
							"  if(!(task.type in sTaskQueues)) {\r",
							"    if(sVL >= 1) {\r",
							"      forge.log.verbose(cat, '[%s][%s] create queue [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    }\r",
							"    // create the queue with the new task\r",
							"    sTaskQueues[task.type] = [task];\r",
							"    start(task);\r",
							"  } else {\r",
							"    // push the task onto the queue, it will be run after a task\r",
							"    // with the same type completes\r",
							"    sTaskQueues[options.type].push(task);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Cancels all tasks of the given type that haven't started yet.\r",
							" *\r",
							" * @param type the type of task to cancel.\r",
							" */\r",
							"forge.task.cancel = function(type) {\r",
							"  // find the task queue\r",
							"  if(type in sTaskQueues) {\r",
							"    // empty all but the current task from the queue\r",
							"    sTaskQueues[type] = [sTaskQueues[type][0]];\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a condition variable to synchronize tasks. To make a task wait\r",
							" * on the condition variable, call task.wait(condition). To notify all\r",
							" * tasks that are waiting, call condition.notify().\r",
							" *\r",
							" * @return the condition variable.\r",
							" */\r",
							"forge.task.createCondition = function() {\r",
							"  var cond = {\r",
							"    // all tasks that are blocked\r",
							"    tasks: {}\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Causes the given task to block until notify is called. If the task\r",
							"   * is already waiting on this condition then this is a no-op.\r",
							"   *\r",
							"   * @param task the task to cause to wait.\r",
							"   */\r",
							"  cond.wait = function(task) {\r",
							"    // only block once\r",
							"    if(!(task.id in cond.tasks)) {\r",
							"       task.block();\r",
							"       cond.tasks[task.id] = task;\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Notifies all waiting tasks to wake up.\r",
							"   */\r",
							"  cond.notify = function() {\r",
							"    // since unblock() will run the next task from here, make sure to\r",
							"    // clear the condition's blocked task list before unblocking\r",
							"    var tmp = cond.tasks;\r",
							"    cond.tasks = {};\r",
							"    for(var id in tmp) {\r",
							"      tmp[id].unblock();\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return cond;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ })\r",
							"/******/ ]); \r",
							" \r",
							" \r",
							" \r",
							"// Signature generation section bellow\r",
							" \r",
							" // Common\r",
							"function getHeaderValue(headerName) {\r",
							"    const headerValue = request.headers[headerName];\r",
							"    if (headerValue === undefined) {\r",
							"        throw new Error(`Required header: ${headerName} is not defined`);\r",
							"    }\r",
							"    //return resolveVariables(headerValue);\r",
							"    return headerValue;\r",
							"}\r",
							"  \r",
							"function resolveVariables(textWithPossibleVariables) {\r",
							"    return textWithPossibleVariables.replace  (/{{(\\w*)}}/,g, (str, key) => {\r",
							"        const value = environment[key];\r",
							"        return value === null ? \"\" : value;\r",
							"    });\r",
							"}\r",
							"  \r",
							" // Digest Calculation\r",
							"function resolveRequestBody() {\r",
							"    const contentType = getHeaderValue(\"content-type\");\r",
							"      \r",
							"    if (contentType === \"application/x-www-form-urlencoded\") {\r",
							"        const data = Object.keys(request.data)\r",
							"            .sort((a, b) => {\r",
							"                if(a < b) { return -1; }\r",
							"                if(a > b) { return 1; }\r",
							"                return 0;\r",
							"            })\r",
							"            .map(key => key + \"=\" + request.data[key])\r",
							"            .join('&');\r",
							"        return resolveVariables(data);\r",
							"    } else if (Object.entries(request.data).length === 0 && request.data.constructor === Object) {\r",
							"        return \"\";\r",
							"    }\r",
							"  \r",
							"    //return resolveVariables(request.data.toString());\r",
							"    return (request.data.toString());\r",
							"}\r",
							"  \r",
							"function calculateDigest() {\r",
							"    const requestData = resolveRequestBody();\r",
							"    const sha256digest = CryptoJS.SHA256(requestData);\r",
							"    const base64sha256 = CryptoJS.enc.Base64.stringify(sha256digest);\r",
							"    const calculatedDigest = 'sha-256=' + base64sha256;\r",
							"    pm.environment.set(\"Digest\", calculatedDigest);\r",
							"    return calculatedDigest;\r",
							"}\r",
							"  \r",
							"  // Signature Calculation\r",
							"  \r",
							"const sdk = require(\"postman-collection\");\r",
							"const moment = require(\"moment\");\r",
							"  \r",
							"const requestWithoutContentHeaders = \"(request-target) x-nordea-originating-host x-nordea-originating-date\";\r",
							"const requestWithContentHeaders = \"(request-target) x-nordea-originating-host x-nordea-originating-date content-type digest\";\r",
							"  \r",
							"function getSignatureBaseOnRequest() {\r",
							"    const url = new sdk.Url(request.url);\r",
							"    const host = url.getHost().toLowerCase();\r",
							"    const basicPath = url.getPathWithQuery().toLowerCase();\r",
							"    const refund_id = pm.environment.get(\"payment_id\");\r",
							"    const path = basicPath.substring(0,basicPath.length-14).concat(refund_id);\r",
							"    const method = request.method.toLowerCase();\r",
							"    const date = moment().utc().format(\"ddd, DD MMM YYYY HH:mm:ss\") + \" GMT\";\r",
							"  \r",
							"    let headers = requestWithoutContentHeaders;\r",
							"  \r",
							"    let normalizedString =\r",
							"        `(request-target): ${method} ${path}\\n` +\r",
							"        `x-nordea-originating-host: ${host}\\n` +\r",
							"        `x-nordea-originating-date: ${date}`;\r",
							"  \r",
							"    if (method === \"post\" || method === \"put\" || method === \"patch\") {\r",
							"        const contentType = getHeaderValue(\"content-type\");\r",
							"        const digest = calculateDigest();\r",
							"        normalizedString += `\\ncontent-type: ${contentType}\\ndigest: ${digest}`\r",
							"  \r",
							"        headers = requestWithContentHeaders;\r",
							"    }\r",
							"    return {host, path, method, date, headers, normalizedString};\r",
							"}\r",
							"\r",
							"function encryptSignature(normalizedSignatureString) {\r",
							"    const messageDigest = forge.md.sha256.create();\r",
							"    messageDigest.update(normalizedSignatureString,\"utf-8\");\r",
							"    return forge.util.encode64(getPrivateKey().sign(messageDigest));           \r",
							"}\r",
							"  \r",
							"function getPrivateKey() {\r",
							"    let eidasPrivateKey = pm.environment.get(\"eidasPrivateKey\");\r",
							"     \r",
							"    if (!eidasPrivateKey.includes('PRIVATE KEY')) {\r",
							"        eidasPrivateKey = \"-----BEGIN RSA PRIVATE KEY-----\\n\" + eidasPrivateKey + \"\\n\" + \"-----END RSA PRIVATE KEY-----\";\r",
							"    }\r",
							"    return forge.pki.privateKeyFromPem(eidasPrivateKey);\r",
							"}\r",
							"const clientId = getHeaderValue(\"x-ibm-client-id\");\r",
							"const signature = getSignatureBaseOnRequest();\r",
							"const encryptedSignature = encryptSignature(signature.normalizedString);\r",
							"const signatureHeader = `keyId=\"${clientId}\",algorithm=\"rsa-sha256\",headers=\"${signature.headers}\",signature=\"${encryptedSignature}\"`;\r",
							"  \r",
							"pm.environment.set(\"Signature\", signatureHeader);\r",
							"pm.environment.set(\"X-Nordea-Originating-Host\", signature.host);\r",
							"pm.environment.set(\"X-Nordea-Originating-Date\", signature.date);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "GET",
				"header": [
					{
						"key": "Signature",
						"value": "{{Signature}}",
						"type": "text"
					},
					{
						"key": "Technical-user-id",
						"value": "1234567",
						"type": "text"
					},
					{
						"key": "X-IBM-Client-Secret",
						"value": "{{X-IBM-Client-Secret}}",
						"type": "text"
					},
					{
						"key": "X-Nordea-Originating-Date",
						"value": "{{X-Nordea-Originating-Date}}",
						"type": "text"
					},
					{
						"key": "X-Nordea-Originating-Host",
						"value": "{{X-Nordea-Originating-Host}}",
						"type": "text"
					},
					{
						"key": "X-IBM-Client-Id",
						"value": "{{X-IBM-Client-Id}}",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://api.nordeaopenbanking.com/corporate/payment-refunds/v1/refunds/{{payment_id}}",
					"protocol": "https",
					"host": [
						"api",
						"nordeaopenbanking",
						"com"
					],
					"path": [
						"corporate",
						"payment-refunds",
						"v1",
						"refunds",
						"{{payment_id}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Create payment refund",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"var forge =\r",
							"/******/ (function(modules) { // webpackBootstrap\r",
							"/******/ \t// The module cache\r",
							"/******/ \tvar installedModules = {};\r",
							"/******/\r",
							"/******/ \t// The require function\r",
							"/******/ \tfunction __webpack_require__(moduleId) {\r",
							"/******/\r",
							"/******/ \t\t// Check if module is in cache\r",
							"/******/ \t\tif(installedModules[moduleId]) {\r",
							"/******/ \t\t\treturn installedModules[moduleId].exports;\r",
							"/******/ \t\t}\r",
							"/******/ \t\t// Create a new module (and put it into the cache)\r",
							"/******/ \t\tvar module = installedModules[moduleId] = {\r",
							"/******/ \t\t\ti: moduleId,\r",
							"/******/ \t\t\tl: false,\r",
							"/******/ \t\t\texports: {}\r",
							"/******/ \t\t};\r",
							"/******/\r",
							"/******/ \t\t// Execute the module function\r",
							"/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r",
							"/******/\r",
							"/******/ \t\t// Flag the module as loaded\r",
							"/******/ \t\tmodule.l = true;\r",
							"/******/\r",
							"/******/ \t\t// Return the exports of the module\r",
							"/******/ \t\treturn module.exports;\r",
							"/******/ \t}\r",
							"/******/\r",
							"/******/\r",
							"/******/ \t// expose the modules object (__webpack_modules__)\r",
							"/******/ \t__webpack_require__.m = modules;\r",
							"/******/\r",
							"/******/ \t// expose the module cache\r",
							"/******/ \t__webpack_require__.c = installedModules;\r",
							"/******/\r",
							"/******/ \t// define getter function for harmony exports\r",
							"/******/ \t__webpack_require__.d = function(exports, name, getter) {\r",
							"/******/ \t\tif(!__webpack_require__.o(exports, name)) {\r",
							"/******/ \t\t\tObject.defineProperty(exports, name, {\r",
							"/******/ \t\t\t\tconfigurable: false,\r",
							"/******/ \t\t\t\tenumerable: true,\r",
							"/******/ \t\t\t\tget: getter\r",
							"/******/ \t\t\t});\r",
							"/******/ \t\t}\r",
							"/******/ \t};\r",
							"/******/\r",
							"/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r",
							"/******/ \t__webpack_require__.n = function(module) {\r",
							"/******/ \t\tvar getter = module && module.__esModule ?\r",
							"/******/ \t\t\tfunction getDefault() { return module['default']; } :\r",
							"/******/ \t\t\tfunction getModuleExports() { return module; };\r",
							"/******/ \t\t__webpack_require__.d(getter, 'a', getter);\r",
							"/******/ \t\treturn getter;\r",
							"/******/ \t};\r",
							"/******/\r",
							"/******/ \t// Object.prototype.hasOwnProperty.call\r",
							"/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r",
							"/******/\r",
							"/******/ \t// __webpack_public_path__\r",
							"/******/ \t__webpack_require__.p = \"\";\r",
							"/******/\r",
							"/******/ \t// Load entry module and return exports\r",
							"/******/ \treturn __webpack_require__(__webpack_require__.s = 34);\r",
							"/******/ })\r",
							"/************************************************************************/\r",
							"/******/ ([\r",
							"/* 0 */\r",
							"/***/ (function(module, exports) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2016 Digital Bazaar, Inc.\r",
							" */\r",
							"module.exports = {\r",
							"  // default options\r",
							"  options: {\r",
							"    usePureJavaScript: false\r",
							"  }\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 1 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Utility functions for web applications.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2018 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"var baseN = __webpack_require__(36);\r",
							"\r",
							"/* Utilities API */\r",
							"var util = module.exports = forge.util = forge.util || {};\r",
							"\r",
							"// define setImmediate and nextTick\r",
							"(function() {\r",
							"  // use native nextTick\r",
							"  if(typeof process !== 'undefined' && process.nextTick) {\r",
							"    util.nextTick = process.nextTick;\r",
							"    if(typeof setImmediate === 'function') {\r",
							"      util.setImmediate = setImmediate;\r",
							"    } else {\r",
							"      // polyfill setImmediate with nextTick, older versions of node\r",
							"      // (those w/o setImmediate) won't totally starve IO\r",
							"      util.setImmediate = util.nextTick;\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // polyfill nextTick with native setImmediate\r",
							"  if(typeof setImmediate === 'function') {\r",
							"    util.setImmediate = function() { return setImmediate.apply(undefined, arguments); };\r",
							"    util.nextTick = function(callback) {\r",
							"      return setImmediate(callback);\r",
							"    };\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  /* Note: A polyfill upgrade pattern is used here to allow combining\r",
							"  polyfills. For example, MutationObserver is fast, but blocks UI updates,\r",
							"  so it needs to allow UI updates periodically, so it falls back on\r",
							"  postMessage or setTimeout. */\r",
							"\r",
							"  // polyfill with setTimeout\r",
							"  util.setImmediate = function(callback) {\r",
							"    setTimeout(callback, 0);\r",
							"  };\r",
							"\r",
							"  // upgrade polyfill to use postMessage\r",
							"  if(typeof window !== 'undefined' &&\r",
							"    typeof window.postMessage === 'function') {\r",
							"    var msg = 'forge.setImmediate';\r",
							"    var callbacks = [];\r",
							"    util.setImmediate = function(callback) {\r",
							"      callbacks.push(callback);\r",
							"      // only send message when one hasn't been sent in\r",
							"      // the current turn of the event loop\r",
							"      if(callbacks.length === 1) {\r",
							"        window.postMessage(msg, '*');\r",
							"      }\r",
							"    };\r",
							"    function handler(event) {\r",
							"      if(event.source === window && event.data === msg) {\r",
							"        event.stopPropagation();\r",
							"        var copy = callbacks.slice();\r",
							"        callbacks.length = 0;\r",
							"        copy.forEach(function(callback) {\r",
							"          callback();\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"    window.addEventListener('message', handler, true);\r",
							"  }\r",
							"\r",
							"  // upgrade polyfill to use MutationObserver\r",
							"  if(typeof MutationObserver !== 'undefined') {\r",
							"    // polyfill with MutationObserver\r",
							"    var now = Date.now();\r",
							"    var attr = true;\r",
							"    var div = document.createElement('div');\r",
							"    var callbacks = [];\r",
							"    new MutationObserver(function() {\r",
							"      var copy = callbacks.slice();\r",
							"      callbacks.length = 0;\r",
							"      copy.forEach(function(callback) {\r",
							"        callback();\r",
							"      });\r",
							"    }).observe(div, {attributes: true});\r",
							"    var oldSetImmediate = util.setImmediate;\r",
							"    util.setImmediate = function(callback) {\r",
							"      if(Date.now() - now > 15) {\r",
							"        now = Date.now();\r",
							"        oldSetImmediate(callback);\r",
							"      } else {\r",
							"        callbacks.push(callback);\r",
							"        // only trigger observer when it hasn't been triggered in\r",
							"        // the current turn of the event loop\r",
							"        if(callbacks.length === 1) {\r",
							"          div.setAttribute('a', attr = !attr);\r",
							"        }\r",
							"      }\r",
							"    };\r",
							"  }\r",
							"\r",
							"  util.nextTick = util.setImmediate;\r",
							"})();\r",
							"\r",
							"// check if running under Node.js\r",
							"util.isNodejs =\r",
							"  typeof process !== 'undefined' && process.versions && process.versions.node;\r",
							"\r",
							"// define isArray\r",
							"util.isArray = Array.isArray || function(x) {\r",
							"  return Object.prototype.toString.call(x) === '[object Array]';\r",
							"};\r",
							"\r",
							"// define isArrayBuffer\r",
							"util.isArrayBuffer = function(x) {\r",
							"  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;\r",
							"};\r",
							"\r",
							"// define isArrayBufferView\r",
							"util.isArrayBufferView = function(x) {\r",
							"  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for\r",
							" * algorithms where bit manipulation, JavaScript limitations, and/or algorithm\r",
							" * design only allow for byte operations of a limited size.\r",
							" *\r",
							" * @param n number of bits.\r",
							" *\r",
							" * Throw Error if n invalid.\r",
							" */\r",
							"function _checkBitsParam(n) {\r",
							"  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {\r",
							"    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);\r",
							"  }\r",
							"}\r",
							"\r",
							"// TODO: set ByteBuffer to best available backing\r",
							"util.ByteBuffer = ByteStringBuffer;\r",
							"\r",
							"/** Buffer w/BinaryString backing */\r",
							"\r",
							"/**\r",
							" * Constructor for a binary string backed byte buffer.\r",
							" *\r",
							" * @param [b] the bytes to wrap (either encoded as string, one byte per\r",
							" *          character, or as an ArrayBuffer or Typed Array).\r",
							" */\r",
							"function ByteStringBuffer(b) {\r",
							"  // TODO: update to match DataBuffer API\r",
							"\r",
							"  // the data in this buffer\r",
							"  this.data = '';\r",
							"  // the pointer for reading from this buffer\r",
							"  this.read = 0;\r",
							"\r",
							"  if(typeof b === 'string') {\r",
							"    this.data = b;\r",
							"  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\r",
							"    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {\r",
							"      this.data = b.toString('binary');\r",
							"    } else {\r",
							"      // convert native buffer to forge buffer\r",
							"      // FIXME: support native buffers internally instead\r",
							"      var arr = new Uint8Array(b);\r",
							"      try {\r",
							"        this.data = String.fromCharCode.apply(null, arr);\r",
							"      } catch(e) {\r",
							"        for(var i = 0; i < arr.length; ++i) {\r",
							"          this.putByte(arr[i]);\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"  } else if(b instanceof ByteStringBuffer ||\r",
							"    (typeof b === 'object' && typeof b.data === 'string' &&\r",
							"    typeof b.read === 'number')) {\r",
							"    // copy existing buffer\r",
							"    this.data = b.data;\r",
							"    this.read = b.read;\r",
							"  }\r",
							"\r",
							"  // used for v8 optimization\r",
							"  this._constructedStringLength = 0;\r",
							"}\r",
							"util.ByteStringBuffer = ByteStringBuffer;\r",
							"\r",
							"/* Note: This is an optimization for V8-based browsers. When V8 concatenates\r",
							"  a string, the strings are only joined logically using a \"cons string\" or\r",
							"  \"constructed/concatenated string\". These containers keep references to one\r",
							"  another and can result in very large memory usage. For example, if a 2MB\r",
							"  string is constructed by concatenating 4 bytes together at a time, the\r",
							"  memory usage will be ~44MB; so ~22x increase. The strings are only joined\r",
							"  together when an operation requiring their joining takes place, such as\r",
							"  substr(). This function is called when adding data to this buffer to ensure\r",
							"  these types of strings are periodically joined to reduce the memory\r",
							"  footprint. */\r",
							"var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\r",
							"util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\r",
							"  this._constructedStringLength += x;\r",
							"  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\r",
							"    // this substr() should cause the constructed string to join\r",
							"    this.data.substr(0, 1);\r",
							"    this._constructedStringLength = 0;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the number of bytes in this buffer.\r",
							" *\r",
							" * @return the number of bytes in this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.length = function() {\r",
							"  return this.data.length - this.read;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets whether or not this buffer is empty.\r",
							" *\r",
							" * @return true if this buffer is empty, false if not.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.isEmpty = function() {\r",
							"  return this.length() <= 0;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putByte = function(b) {\r",
							"  return this.putBytes(String.fromCharCode(b));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer N times.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" * @param n the number of bytes of value b to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\r",
							"  b = String.fromCharCode(b);\r",
							"  var d = this.data;\r",
							"  while(n > 0) {\r",
							"    if(n & 1) {\r",
							"      d += b;\r",
							"    }\r",
							"    n >>>= 1;\r",
							"    if(n > 0) {\r",
							"      b += b;\r",
							"    }\r",
							"  }\r",
							"  this.data = d;\r",
							"  this._optimizeConstructedString(n);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts bytes in this buffer.\r",
							" *\r",
							" * @param bytes the bytes (as a UTF-8 encoded string) to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putBytes = function(bytes) {\r",
							"  this.data += bytes;\r",
							"  this._optimizeConstructedString(bytes.length);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a UTF-16 encoded string into this buffer.\r",
							" *\r",
							" * @param str the string to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putString = function(str) {\r",
							"  return this.putBytes(util.encodeUtf8(str));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt16 = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt24 = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt32 = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i >> 24 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt16Le = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt24Le = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt32Le = function(i) {\r",
							"  return this.putBytes(\r",
							"    String.fromCharCode(i & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 24 & 0xFF));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts an n-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putInt = function(i, n) {\r",
							"  _checkBitsParam(n);\r",
							"  var bytes = '';\r",
							"  do {\r",
							"    n -= 8;\r",
							"    bytes += String.fromCharCode((i >> n) & 0xFF);\r",
							"  } while(n > 0);\r",
							"  return this.putBytes(bytes);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a signed n-bit integer in this buffer in big-endian order. Two's\r",
							" * complement representation is used.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\r",
							"  // putInt checks n\r",
							"  if(i < 0) {\r",
							"    i += 2 << (n - 1);\r",
							"  }\r",
							"  return this.putInt(i, n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts the given buffer into this buffer.\r",
							" *\r",
							" * @param buffer the buffer to put into this one.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.putBuffer = function(buffer) {\r",
							"  return this.putBytes(buffer.getBytes());\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte from this buffer and advances the read pointer by 1.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getByte = function() {\r",
							"  return this.data.charCodeAt(this.read++);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in big-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt16 = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 1));\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in big-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt24 = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) << 16 ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 2));\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in big-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt32 = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) << 24 ^\r",
							"    this.data.charCodeAt(this.read + 1) << 16 ^\r",
							"    this.data.charCodeAt(this.read + 2) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 3));\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in little-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt16Le = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8);\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in little-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt24Le = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 2) << 16);\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in little-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt32Le = function() {\r",
							"  var rval = (\r",
							"    this.data.charCodeAt(this.read) ^\r",
							"    this.data.charCodeAt(this.read + 1) << 8 ^\r",
							"    this.data.charCodeAt(this.read + 2) << 16 ^\r",
							"    this.data.charCodeAt(this.read + 3) << 24);\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an n-bit integer from this buffer in big-endian order and advances the\r",
							" * read pointer by ceil(n/8).\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getInt = function(n) {\r",
							"  _checkBitsParam(n);\r",
							"  var rval = 0;\r",
							"  do {\r",
							"    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\r",
							"    rval = (rval << 8) + this.data.charCodeAt(this.read++);\r",
							"    n -= 8;\r",
							"  } while(n > 0);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a signed n-bit integer from this buffer in big-endian order, using\r",
							" * two's complement, and advances the read pointer by n/8.\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getSignedInt = function(n) {\r",
							"  // getInt checks n\r",
							"  var x = this.getInt(n);\r",
							"  var max = 2 << (n - 2);\r",
							"  if(x >= max) {\r",
							"    x -= max << 1;\r",
							"  }\r",
							"  return x;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Reads bytes out into a UTF-8 string and clears them from the buffer.\r",
							" *\r",
							" * @param count the number of bytes to read, undefined or null for all.\r",
							" *\r",
							" * @return a UTF-8 string of bytes.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.getBytes = function(count) {\r",
							"  var rval;\r",
							"  if(count) {\r",
							"    // read count bytes\r",
							"    count = Math.min(this.length(), count);\r",
							"    rval = this.data.slice(this.read, this.read + count);\r",
							"    this.read += count;\r",
							"  } else if(count === 0) {\r",
							"    rval = '';\r",
							"  } else {\r",
							"    // read all bytes, optimize to only copy when needed\r",
							"    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\r",
							"    this.clear();\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a UTF-8 encoded string of the bytes from this buffer without modifying\r",
							" * the read pointer.\r",
							" *\r",
							" * @param count the number of bytes to get, omit to get all.\r",
							" *\r",
							" * @return a string full of UTF-8 encoded characters.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.bytes = function(count) {\r",
							"  return (typeof(count) === 'undefined' ?\r",
							"    this.data.slice(this.read) :\r",
							"    this.data.slice(this.read, this.read + count));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.at = function(i) {\r",
							"  return this.data.charCodeAt(this.read + i);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.setAt = function(i, b) {\r",
							"  this.data = this.data.substr(0, this.read + i) +\r",
							"    String.fromCharCode(b) +\r",
							"    this.data.substr(this.read + i + 1);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the last byte without modifying the read pointer.\r",
							" *\r",
							" * @return the last byte.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.last = function() {\r",
							"  return this.data.charCodeAt(this.data.length - 1);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a copy of this buffer.\r",
							" *\r",
							" * @return the copy.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.copy = function() {\r",
							"  var c = util.createBuffer(this.data);\r",
							"  c.read = this.read;\r",
							"  return c;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compacts this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.compact = function() {\r",
							"  if(this.read > 0) {\r",
							"    this.data = this.data.slice(this.read);\r",
							"    this.read = 0;\r",
							"  }\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.clear = function() {\r",
							"  this.data = '';\r",
							"  this.read = 0;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Shortens this buffer by triming bytes off of the end of this buffer.\r",
							" *\r",
							" * @param count the number of bytes to trim off.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.truncate = function(count) {\r",
							"  var len = Math.max(0, this.length() - count);\r",
							"  this.data = this.data.substr(this.read, len);\r",
							"  this.read = 0;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a hexadecimal string.\r",
							" *\r",
							" * @return a hexadecimal string.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.toHex = function() {\r",
							"  var rval = '';\r",
							"  for(var i = this.read; i < this.data.length; ++i) {\r",
							"    var b = this.data.charCodeAt(i);\r",
							"    if(b < 16) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += b.toString(16);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a UTF-16 string (standard JavaScript string).\r",
							" *\r",
							" * @return a UTF-16 string.\r",
							" */\r",
							"util.ByteStringBuffer.prototype.toString = function() {\r",
							"  return util.decodeUtf8(this.bytes());\r",
							"};\r",
							"\r",
							"/** End Buffer w/BinaryString backing */\r",
							"\r",
							"/** Buffer w/UInt8Array backing */\r",
							"\r",
							"/**\r",
							" * FIXME: Experimental. Do not use yet.\r",
							" *\r",
							" * Constructor for an ArrayBuffer-backed byte buffer.\r",
							" *\r",
							" * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a\r",
							" * TypedArray.\r",
							" *\r",
							" * If a string is given, its encoding should be provided as an option,\r",
							" * otherwise it will default to 'binary'. A 'binary' string is encoded such\r",
							" * that each character is one byte in length and size.\r",
							" *\r",
							" * If an ArrayBuffer, DataView, or TypedArray is given, it will be used\r",
							" * *directly* without any copying. Note that, if a write to the buffer requires\r",
							" * more space, the buffer will allocate a new backing ArrayBuffer to\r",
							" * accommodate. The starting read and write offsets for the buffer may be\r",
							" * given as options.\r",
							" *\r",
							" * @param [b] the initial bytes for this buffer.\r",
							" * @param options the options to use:\r",
							" *          [readOffset] the starting read offset to use (default: 0).\r",
							" *          [writeOffset] the starting write offset to use (default: the\r",
							" *            length of the first parameter).\r",
							" *          [growSize] the minimum amount, in bytes, to grow the buffer by to\r",
							" *            accommodate writes (default: 1024).\r",
							" *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the\r",
							" *            first parameter, if it is a string (default: 'binary').\r",
							" */\r",
							"function DataBuffer(b, options) {\r",
							"  // default options\r",
							"  options = options || {};\r",
							"\r",
							"  // pointers for read from/write to buffer\r",
							"  this.read = options.readOffset || 0;\r",
							"  this.growSize = options.growSize || 1024;\r",
							"\r",
							"  var isArrayBuffer = util.isArrayBuffer(b);\r",
							"  var isArrayBufferView = util.isArrayBufferView(b);\r",
							"  if(isArrayBuffer || isArrayBufferView) {\r",
							"    // use ArrayBuffer directly\r",
							"    if(isArrayBuffer) {\r",
							"      this.data = new DataView(b);\r",
							"    } else {\r",
							"      // TODO: adjust read/write offset based on the type of view\r",
							"      // or specify that this must be done in the options ... that the\r",
							"      // offsets are byte-based\r",
							"      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\r",
							"    }\r",
							"    this.write = ('writeOffset' in options ?\r",
							"      options.writeOffset : this.data.byteLength);\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // initialize to empty array buffer and add any given bytes using putBytes\r",
							"  this.data = new DataView(new ArrayBuffer(0));\r",
							"  this.write = 0;\r",
							"\r",
							"  if(b !== null && b !== undefined) {\r",
							"    this.putBytes(b);\r",
							"  }\r",
							"\r",
							"  if('writeOffset' in options) {\r",
							"    this.write = options.writeOffset;\r",
							"  }\r",
							"}\r",
							"util.DataBuffer = DataBuffer;\r",
							"\r",
							"/**\r",
							" * Gets the number of bytes in this buffer.\r",
							" *\r",
							" * @return the number of bytes in this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.length = function() {\r",
							"  return this.write - this.read;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets whether or not this buffer is empty.\r",
							" *\r",
							" * @return true if this buffer is empty, false if not.\r",
							" */\r",
							"util.DataBuffer.prototype.isEmpty = function() {\r",
							"  return this.length() <= 0;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Ensures this buffer has enough empty space to accommodate the given number\r",
							" * of bytes. An optional parameter may be given that indicates a minimum\r",
							" * amount to grow the buffer if necessary. If the parameter is not given,\r",
							" * the buffer will be grown by some previously-specified default amount\r",
							" * or heuristic.\r",
							" *\r",
							" * @param amount the number of bytes to accommodate.\r",
							" * @param [growSize] the minimum amount, in bytes, to grow the buffer by if\r",
							" *          necessary.\r",
							" */\r",
							"util.DataBuffer.prototype.accommodate = function(amount, growSize) {\r",
							"  if(this.length() >= amount) {\r",
							"    return this;\r",
							"  }\r",
							"  growSize = Math.max(growSize || this.growSize, amount);\r",
							"\r",
							"  // grow buffer\r",
							"  var src = new Uint8Array(\r",
							"    this.data.buffer, this.data.byteOffset, this.data.byteLength);\r",
							"  var dst = new Uint8Array(this.length() + growSize);\r",
							"  dst.set(src);\r",
							"  this.data = new DataView(dst.buffer);\r",
							"\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putByte = function(b) {\r",
							"  this.accommodate(1);\r",
							"  this.data.setUint8(this.write++, b);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte in this buffer N times.\r",
							" *\r",
							" * @param b the byte to put.\r",
							" * @param n the number of bytes of value b to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.fillWithByte = function(b, n) {\r",
							"  this.accommodate(n);\r",
							"  for(var i = 0; i < n; ++i) {\r",
							"    this.data.setUint8(b);\r",
							"  }\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts bytes in this buffer. The bytes may be given as a string, an\r",
							" * ArrayBuffer, a DataView, or a TypedArray.\r",
							" *\r",
							" * @param bytes the bytes to put.\r",
							" * @param [encoding] the encoding for the first parameter ('binary', 'utf8',\r",
							" *          'utf16', 'hex'), if it is a string (default: 'binary').\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putBytes = function(bytes, encoding) {\r",
							"  if(util.isArrayBufferView(bytes)) {\r",
							"    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\r",
							"    var len = src.byteLength - src.byteOffset;\r",
							"    this.accommodate(len);\r",
							"    var dst = new Uint8Array(this.data.buffer, this.write);\r",
							"    dst.set(src);\r",
							"    this.write += len;\r",
							"    return this;\r",
							"  }\r",
							"\r",
							"  if(util.isArrayBuffer(bytes)) {\r",
							"    var src = new Uint8Array(bytes);\r",
							"    this.accommodate(src.byteLength);\r",
							"    var dst = new Uint8Array(this.data.buffer);\r",
							"    dst.set(src, this.write);\r",
							"    this.write += src.byteLength;\r",
							"    return this;\r",
							"  }\r",
							"\r",
							"  // bytes is a util.DataBuffer or equivalent\r",
							"  if(bytes instanceof util.DataBuffer ||\r",
							"    (typeof bytes === 'object' &&\r",
							"    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&\r",
							"    util.isArrayBufferView(bytes.data))) {\r",
							"    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\r",
							"    this.accommodate(src.byteLength);\r",
							"    var dst = new Uint8Array(bytes.data.byteLength, this.write);\r",
							"    dst.set(src);\r",
							"    this.write += src.byteLength;\r",
							"    return this;\r",
							"  }\r",
							"\r",
							"  if(bytes instanceof util.ByteStringBuffer) {\r",
							"    // copy binary string and process as the same as a string parameter below\r",
							"    bytes = bytes.data;\r",
							"    encoding = 'binary';\r",
							"  }\r",
							"\r",
							"  // string conversion\r",
							"  encoding = encoding || 'binary';\r",
							"  if(typeof bytes === 'string') {\r",
							"    var view;\r",
							"\r",
							"    // decode from string\r",
							"    if(encoding === 'hex') {\r",
							"      this.accommodate(Math.ceil(bytes.length / 2));\r",
							"      view = new Uint8Array(this.data.buffer, this.write);\r",
							"      this.write += util.binary.hex.decode(bytes, view, this.write);\r",
							"      return this;\r",
							"    }\r",
							"    if(encoding === 'base64') {\r",
							"      this.accommodate(Math.ceil(bytes.length / 4) * 3);\r",
							"      view = new Uint8Array(this.data.buffer, this.write);\r",
							"      this.write += util.binary.base64.decode(bytes, view, this.write);\r",
							"      return this;\r",
							"    }\r",
							"\r",
							"    // encode text as UTF-8 bytes\r",
							"    if(encoding === 'utf8') {\r",
							"      // encode as UTF-8 then decode string as raw binary\r",
							"      bytes = util.encodeUtf8(bytes);\r",
							"      encoding = 'binary';\r",
							"    }\r",
							"\r",
							"    // decode string as raw binary\r",
							"    if(encoding === 'binary' || encoding === 'raw') {\r",
							"      // one byte per character\r",
							"      this.accommodate(bytes.length);\r",
							"      view = new Uint8Array(this.data.buffer, this.write);\r",
							"      this.write += util.binary.raw.decode(view);\r",
							"      return this;\r",
							"    }\r",
							"\r",
							"    // encode text as UTF-16 bytes\r",
							"    if(encoding === 'utf16') {\r",
							"      // two bytes per character\r",
							"      this.accommodate(bytes.length * 2);\r",
							"      view = new Uint16Array(this.data.buffer, this.write);\r",
							"      this.write += util.text.utf16.encode(view);\r",
							"      return this;\r",
							"    }\r",
							"\r",
							"    throw new Error('Invalid encoding: ' + encoding);\r",
							"  }\r",
							"\r",
							"  throw Error('Invalid parameter: ' + bytes);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts the given buffer into this buffer.\r",
							" *\r",
							" * @param buffer the buffer to put into this one.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putBuffer = function(buffer) {\r",
							"  this.putBytes(buffer);\r",
							"  buffer.clear();\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a string into this buffer.\r",
							" *\r",
							" * @param str the string to put.\r",
							" * @param [encoding] the encoding for the string (default: 'utf16').\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putString = function(str) {\r",
							"  return this.putBytes(str, 'utf16');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt16 = function(i) {\r",
							"  this.accommodate(2);\r",
							"  this.data.setInt16(this.write, i);\r",
							"  this.write += 2;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt24 = function(i) {\r",
							"  this.accommodate(3);\r",
							"  this.data.setInt16(this.write, i >> 8 & 0xFFFF);\r",
							"  this.data.setInt8(this.write, i >> 16 & 0xFF);\r",
							"  this.write += 3;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt32 = function(i) {\r",
							"  this.accommodate(4);\r",
							"  this.data.setInt32(this.write, i);\r",
							"  this.write += 4;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 16-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 16-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt16Le = function(i) {\r",
							"  this.accommodate(2);\r",
							"  this.data.setInt16(this.write, i, true);\r",
							"  this.write += 2;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 24-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 24-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt24Le = function(i) {\r",
							"  this.accommodate(3);\r",
							"  this.data.setInt8(this.write, i >> 16 & 0xFF);\r",
							"  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);\r",
							"  this.write += 3;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a 32-bit integer in this buffer in little-endian order.\r",
							" *\r",
							" * @param i the 32-bit integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt32Le = function(i) {\r",
							"  this.accommodate(4);\r",
							"  this.data.setInt32(this.write, i, true);\r",
							"  this.write += 4;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts an n-bit integer in this buffer in big-endian order.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putInt = function(i, n) {\r",
							"  _checkBitsParam(n);\r",
							"  this.accommodate(n / 8);\r",
							"  do {\r",
							"    n -= 8;\r",
							"    this.data.setInt8(this.write++, (i >> n) & 0xFF);\r",
							"  } while(n > 0);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a signed n-bit integer in this buffer in big-endian order. Two's\r",
							" * complement representation is used.\r",
							" *\r",
							" * @param i the n-bit integer.\r",
							" * @param n the number of bits in the integer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.putSignedInt = function(i, n) {\r",
							"  _checkBitsParam(n);\r",
							"  this.accommodate(n / 8);\r",
							"  if(i < 0) {\r",
							"    i += 2 << (n - 1);\r",
							"  }\r",
							"  return this.putInt(i, n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte from this buffer and advances the read pointer by 1.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.DataBuffer.prototype.getByte = function() {\r",
							"  return this.data.getInt8(this.read++);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in big-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt16 = function() {\r",
							"  var rval = this.data.getInt16(this.read);\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in big-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt24 = function() {\r",
							"  var rval = (\r",
							"    this.data.getInt16(this.read) << 8 ^\r",
							"    this.data.getInt8(this.read + 2));\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in big-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt32 = function() {\r",
							"  var rval = this.data.getInt32(this.read);\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint16 from this buffer in little-endian order and advances the read\r",
							" * pointer by 2.\r",
							" *\r",
							" * @return the uint16.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt16Le = function() {\r",
							"  var rval = this.data.getInt16(this.read, true);\r",
							"  this.read += 2;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint24 from this buffer in little-endian order and advances the read\r",
							" * pointer by 3.\r",
							" *\r",
							" * @return the uint24.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt24Le = function() {\r",
							"  var rval = (\r",
							"    this.data.getInt8(this.read) ^\r",
							"    this.data.getInt16(this.read + 1, true) << 8);\r",
							"  this.read += 3;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a uint32 from this buffer in little-endian order and advances the read\r",
							" * pointer by 4.\r",
							" *\r",
							" * @return the word.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt32Le = function() {\r",
							"  var rval = this.data.getInt32(this.read, true);\r",
							"  this.read += 4;\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an n-bit integer from this buffer in big-endian order and advances the\r",
							" * read pointer by n/8.\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.DataBuffer.prototype.getInt = function(n) {\r",
							"  _checkBitsParam(n);\r",
							"  var rval = 0;\r",
							"  do {\r",
							"    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\r",
							"    rval = (rval << 8) + this.data.getInt8(this.read++);\r",
							"    n -= 8;\r",
							"  } while(n > 0);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a signed n-bit integer from this buffer in big-endian order, using\r",
							" * two's complement, and advances the read pointer by n/8.\r",
							" *\r",
							" * @param n the number of bits in the integer (8, 16, 24, or 32).\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"util.DataBuffer.prototype.getSignedInt = function(n) {\r",
							"  // getInt checks n\r",
							"  var x = this.getInt(n);\r",
							"  var max = 2 << (n - 2);\r",
							"  if(x >= max) {\r",
							"    x -= max << 1;\r",
							"  }\r",
							"  return x;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Reads bytes out into a UTF-8 string and clears them from the buffer.\r",
							" *\r",
							" * @param count the number of bytes to read, undefined or null for all.\r",
							" *\r",
							" * @return a UTF-8 string of bytes.\r",
							" */\r",
							"util.DataBuffer.prototype.getBytes = function(count) {\r",
							"  // TODO: deprecate this method, it is poorly named and\r",
							"  // this.toString('binary') replaces it\r",
							"  // add a toTypedArray()/toArrayBuffer() function\r",
							"  var rval;\r",
							"  if(count) {\r",
							"    // read count bytes\r",
							"    count = Math.min(this.length(), count);\r",
							"    rval = this.data.slice(this.read, this.read + count);\r",
							"    this.read += count;\r",
							"  } else if(count === 0) {\r",
							"    rval = '';\r",
							"  } else {\r",
							"    // read all bytes, optimize to only copy when needed\r",
							"    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\r",
							"    this.clear();\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a UTF-8 encoded string of the bytes from this buffer without modifying\r",
							" * the read pointer.\r",
							" *\r",
							" * @param count the number of bytes to get, omit to get all.\r",
							" *\r",
							" * @return a string full of UTF-8 encoded characters.\r",
							" */\r",
							"util.DataBuffer.prototype.bytes = function(count) {\r",
							"  // TODO: deprecate this method, it is poorly named, add \"getString()\"\r",
							"  return (typeof(count) === 'undefined' ?\r",
							"    this.data.slice(this.read) :\r",
							"    this.data.slice(this.read, this.read + count));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" *\r",
							" * @return the byte.\r",
							" */\r",
							"util.DataBuffer.prototype.at = function(i) {\r",
							"  return this.data.getUint8(this.read + i);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Puts a byte at the given index without modifying the read pointer.\r",
							" *\r",
							" * @param i the byte index.\r",
							" * @param b the byte to put.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.setAt = function(i, b) {\r",
							"  this.data.setUint8(i, b);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the last byte without modifying the read pointer.\r",
							" *\r",
							" * @return the last byte.\r",
							" */\r",
							"util.DataBuffer.prototype.last = function() {\r",
							"  return this.data.getUint8(this.write - 1);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a copy of this buffer.\r",
							" *\r",
							" * @return the copy.\r",
							" */\r",
							"util.DataBuffer.prototype.copy = function() {\r",
							"  return new util.DataBuffer(this);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compacts this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.compact = function() {\r",
							"  if(this.read > 0) {\r",
							"    var src = new Uint8Array(this.data.buffer, this.read);\r",
							"    var dst = new Uint8Array(src.byteLength);\r",
							"    dst.set(src);\r",
							"    this.data = new DataView(dst);\r",
							"    this.write -= this.read;\r",
							"    this.read = 0;\r",
							"  }\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears this buffer.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.clear = function() {\r",
							"  this.data = new DataView(new ArrayBuffer(0));\r",
							"  this.read = this.write = 0;\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Shortens this buffer by triming bytes off of the end of this buffer.\r",
							" *\r",
							" * @param count the number of bytes to trim off.\r",
							" *\r",
							" * @return this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.truncate = function(count) {\r",
							"  this.write = Math.max(0, this.length() - count);\r",
							"  this.read = Math.min(this.read, this.write);\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a hexadecimal string.\r",
							" *\r",
							" * @return a hexadecimal string.\r",
							" */\r",
							"util.DataBuffer.prototype.toHex = function() {\r",
							"  var rval = '';\r",
							"  for(var i = this.read; i < this.data.byteLength; ++i) {\r",
							"    var b = this.data.getUint8(i);\r",
							"    if(b < 16) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += b.toString(16);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts this buffer to a string, using the given encoding. If no\r",
							" * encoding is given, 'utf8' (UTF-8) is used.\r",
							" *\r",
							" * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',\r",
							" *          'base64' (default: 'utf8').\r",
							" *\r",
							" * @return a string representation of the bytes in this buffer.\r",
							" */\r",
							"util.DataBuffer.prototype.toString = function(encoding) {\r",
							"  var view = new Uint8Array(this.data, this.read, this.length());\r",
							"  encoding = encoding || 'utf8';\r",
							"\r",
							"  // encode to string\r",
							"  if(encoding === 'binary' || encoding === 'raw') {\r",
							"    return util.binary.raw.encode(view);\r",
							"  }\r",
							"  if(encoding === 'hex') {\r",
							"    return util.binary.hex.encode(view);\r",
							"  }\r",
							"  if(encoding === 'base64') {\r",
							"    return util.binary.base64.encode(view);\r",
							"  }\r",
							"\r",
							"  // decode to text\r",
							"  if(encoding === 'utf8') {\r",
							"    return util.text.utf8.decode(view);\r",
							"  }\r",
							"  if(encoding === 'utf16') {\r",
							"    return util.text.utf16.decode(view);\r",
							"  }\r",
							"\r",
							"  throw new Error('Invalid encoding: ' + encoding);\r",
							"};\r",
							"\r",
							"/** End Buffer w/UInt8Array backing */\r",
							"\r",
							"/**\r",
							" * Creates a buffer that stores bytes. A value may be given to put into the\r",
							" * buffer that is either a string of bytes or a UTF-16 string that will\r",
							" * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).\r",
							" *\r",
							" * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode\r",
							" *          as UTF-8.\r",
							" * @param [encoding] (default: 'raw', other: 'utf8').\r",
							" */\r",
							"util.createBuffer = function(input, encoding) {\r",
							"  // TODO: deprecate, use new ByteBuffer() instead\r",
							"  encoding = encoding || 'raw';\r",
							"  if(input !== undefined && encoding === 'utf8') {\r",
							"    input = util.encodeUtf8(input);\r",
							"  }\r",
							"  return new util.ByteBuffer(input);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Fills a string with a particular value. If you want the string to be a byte\r",
							" * string, pass in String.fromCharCode(theByte).\r",
							" *\r",
							" * @param c the character to fill the string with, use String.fromCharCode\r",
							" *          to fill the string with a byte value.\r",
							" * @param n the number of characters of value c to fill with.\r",
							" *\r",
							" * @return the filled string.\r",
							" */\r",
							"util.fillString = function(c, n) {\r",
							"  var s = '';\r",
							"  while(n > 0) {\r",
							"    if(n & 1) {\r",
							"      s += c;\r",
							"    }\r",
							"    n >>>= 1;\r",
							"    if(n > 0) {\r",
							"      c += c;\r",
							"    }\r",
							"  }\r",
							"  return s;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Performs a per byte XOR between two byte strings and returns the result as a\r",
							" * string of bytes.\r",
							" *\r",
							" * @param s1 first string of bytes.\r",
							" * @param s2 second string of bytes.\r",
							" * @param n the number of bytes to XOR.\r",
							" *\r",
							" * @return the XOR'd result.\r",
							" */\r",
							"util.xorBytes = function(s1, s2, n) {\r",
							"  var s3 = '';\r",
							"  var b = '';\r",
							"  var t = '';\r",
							"  var i = 0;\r",
							"  var c = 0;\r",
							"  for(; n > 0; --n, ++i) {\r",
							"    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\r",
							"    if(c >= 10) {\r",
							"      s3 += t;\r",
							"      t = '';\r",
							"      c = 0;\r",
							"    }\r",
							"    t += String.fromCharCode(b);\r",
							"    ++c;\r",
							"  }\r",
							"  s3 += t;\r",
							"  return s3;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a hex string into a 'binary' encoded string of bytes.\r",
							" *\r",
							" * @param hex the hexadecimal string to convert.\r",
							" *\r",
							" * @return the binary-encoded string of bytes.\r",
							" */\r",
							"util.hexToBytes = function(hex) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.hex.decode instead.\"\r",
							"  var rval = '';\r",
							"  var i = 0;\r",
							"  if(hex.length & 1 == 1) {\r",
							"    // odd number of characters, convert first character alone\r",
							"    i = 1;\r",
							"    rval += String.fromCharCode(parseInt(hex[0], 16));\r",
							"  }\r",
							"  // convert 2 characters (1 byte) at a time\r",
							"  for(; i < hex.length; i += 2) {\r",
							"    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a 'binary' encoded string of bytes to hex.\r",
							" *\r",
							" * @param bytes the byte string to convert.\r",
							" *\r",
							" * @return the string of hexadecimal characters.\r",
							" */\r",
							"util.bytesToHex = function(bytes) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.hex.encode instead.\"\r",
							"  return util.createBuffer(bytes).toHex();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an 32-bit integer to 4-big-endian byte string.\r",
							" *\r",
							" * @param i the integer.\r",
							" *\r",
							" * @return the byte string.\r",
							" */\r",
							"util.int32ToBytes = function(i) {\r",
							"  return (\r",
							"    String.fromCharCode(i >> 24 & 0xFF) +\r",
							"    String.fromCharCode(i >> 16 & 0xFF) +\r",
							"    String.fromCharCode(i >> 8 & 0xFF) +\r",
							"    String.fromCharCode(i & 0xFF));\r",
							"};\r",
							"\r",
							"// base64 characters, reverse mapping\r",
							"var _base64 =\r",
							"  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r",
							"var _base64Idx = [\r",
							"/*43 -43 = 0*/\r",
							"/*'+',  1,  2,  3,'/' */\r",
							"   62, -1, -1, -1, 63,\r",
							"\r",
							"/*'0','1','2','3','4','5','6','7','8','9' */\r",
							"   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\r",
							"\r",
							"/*15, 16, 17,'=', 19, 20, 21 */\r",
							"  -1, -1, -1, 64, -1, -1, -1,\r",
							"\r",
							"/*65 - 43 = 22*/\r",
							"/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */\r",
							"   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,\r",
							"\r",
							"/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */\r",
							"   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\r",
							"\r",
							"/*91 - 43 = 48 */\r",
							"/*48, 49, 50, 51, 52, 53 */\r",
							"  -1, -1, -1, -1, -1, -1,\r",
							"\r",
							"/*97 - 43 = 54*/\r",
							"/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */\r",
							"   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\r",
							"\r",
							"/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */\r",
							"   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\r",
							"];\r",
							"\r",
							"// base58 characters (Bitcoin alphabet)\r",
							"var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\r",
							"\r",
							"/**\r",
							" * Base64 encodes a 'binary' encoded string of bytes.\r",
							" *\r",
							" * @param input the binary encoded string of bytes to base64-encode.\r",
							" * @param maxline the maximum number of encoded characters per line to use,\r",
							" *          defaults to none.\r",
							" *\r",
							" * @return the base64-encoded output.\r",
							" */\r",
							"util.encode64 = function(input, maxline) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.base64.encode instead.\"\r",
							"  var line = '';\r",
							"  var output = '';\r",
							"  var chr1, chr2, chr3;\r",
							"  var i = 0;\r",
							"  while(i < input.length) {\r",
							"    chr1 = input.charCodeAt(i++);\r",
							"    chr2 = input.charCodeAt(i++);\r",
							"    chr3 = input.charCodeAt(i++);\r",
							"\r",
							"    // encode 4 character group\r",
							"    line += _base64.charAt(chr1 >> 2);\r",
							"    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\r",
							"    if(isNaN(chr2)) {\r",
							"      line += '==';\r",
							"    } else {\r",
							"      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\r",
							"      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\r",
							"    }\r",
							"\r",
							"    if(maxline && line.length > maxline) {\r",
							"      output += line.substr(0, maxline) + '\\r\\n';\r",
							"      line = line.substr(maxline);\r",
							"    }\r",
							"  }\r",
							"  output += line;\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Base64 decodes a string into a 'binary' encoded string of bytes.\r",
							" *\r",
							" * @param input the base64-encoded input.\r",
							" *\r",
							" * @return the binary encoded string.\r",
							" */\r",
							"util.decode64 = function(input) {\r",
							"  // TODO: deprecate: \"Deprecated. Use util.binary.base64.decode instead.\"\r",
							"\r",
							"  // remove all non-base64 characters\r",
							"  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\r",
							"\r",
							"  var output = '';\r",
							"  var enc1, enc2, enc3, enc4;\r",
							"  var i = 0;\r",
							"\r",
							"  while(i < input.length) {\r",
							"    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"\r",
							"    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));\r",
							"    if(enc3 !== 64) {\r",
							"      // decoded at least 2 bytes\r",
							"      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));\r",
							"      if(enc4 !== 64) {\r",
							"        // decoded 3 bytes\r",
							"        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript\r",
							" * string). Non-ASCII characters will be encoded as multiple bytes according\r",
							" * to UTF-8.\r",
							" *\r",
							" * @param str the string to encode.\r",
							" *\r",
							" * @return the UTF-8 encoded string.\r",
							" */\r",
							"util.encodeUtf8 = function(str) {\r",
							"  return unescape(encodeURIComponent(str));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a UTF-8 encoded string into a UTF-16 string.\r",
							" *\r",
							" * @param str the string to decode.\r",
							" *\r",
							" * @return the UTF-16 encoded string (standard JavaScript string).\r",
							" */\r",
							"util.decodeUtf8 = function(str) {\r",
							"  return decodeURIComponent(escape(str));\r",
							"};\r",
							"\r",
							"// binary encoding/decoding tools\r",
							"// FIXME: Experimental. Do not use yet.\r",
							"util.binary = {\r",
							"  raw: {},\r",
							"  hex: {},\r",
							"  base64: {},\r",
							"  base58: {},\r",
							"  baseN : {\r",
							"    encode: baseN.encode,\r",
							"    decode: baseN.decode\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a Uint8Array as a binary-encoded string. This encoding uses\r",
							" * a value between 0 and 255 for each character.\r",
							" *\r",
							" * @param bytes the Uint8Array to encode.\r",
							" *\r",
							" * @return the binary-encoded string.\r",
							" */\r",
							"util.binary.raw.encode = function(bytes) {\r",
							"  return String.fromCharCode.apply(null, bytes);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a binary-encoded string to a Uint8Array. This encoding uses\r",
							" * a value between 0 and 255 for each character.\r",
							" *\r",
							" * @param str the binary-encoded string to decode.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.binary.raw.decode = function(str, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(str.length);\r",
							"  }\r",
							"  offset = offset || 0;\r",
							"  var j = offset;\r",
							"  for(var i = 0; i < str.length; ++i) {\r",
							"    out[j++] = str.charCodeAt(i);\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or\r",
							" * ByteBuffer as a string of hexadecimal characters.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the string of hexadecimal characters.\r",
							" */\r",
							"util.binary.hex.encode = util.bytesToHex;\r",
							"\r",
							"/**\r",
							" * Decodes a hex-encoded string to a Uint8Array.\r",
							" *\r",
							" * @param hex the hexadecimal string to convert.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.binary.hex.decode = function(hex, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(Math.ceil(hex.length / 2));\r",
							"  }\r",
							"  offset = offset || 0;\r",
							"  var i = 0, j = offset;\r",
							"  if(hex.length & 1) {\r",
							"    // odd number of characters, convert first character alone\r",
							"    i = 1;\r",
							"    out[j++] = parseInt(hex[0], 16);\r",
							"  }\r",
							"  // convert 2 characters (1 byte) at a time\r",
							"  for(; i < hex.length; i += 2) {\r",
							"    out[j++] = parseInt(hex.substr(i, 2), 16);\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Base64-encodes a Uint8Array.\r",
							" *\r",
							" * @param input the Uint8Array to encode.\r",
							" * @param maxline the maximum number of encoded characters per line to use,\r",
							" *          defaults to none.\r",
							" *\r",
							" * @return the base64-encoded output string.\r",
							" */\r",
							"util.binary.base64.encode = function(input, maxline) {\r",
							"  var line = '';\r",
							"  var output = '';\r",
							"  var chr1, chr2, chr3;\r",
							"  var i = 0;\r",
							"  while(i < input.byteLength) {\r",
							"    chr1 = input[i++];\r",
							"    chr2 = input[i++];\r",
							"    chr3 = input[i++];\r",
							"\r",
							"    // encode 4 character group\r",
							"    line += _base64.charAt(chr1 >> 2);\r",
							"    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\r",
							"    if(isNaN(chr2)) {\r",
							"      line += '==';\r",
							"    } else {\r",
							"      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\r",
							"      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\r",
							"    }\r",
							"\r",
							"    if(maxline && line.length > maxline) {\r",
							"      output += line.substr(0, maxline) + '\\r\\n';\r",
							"      line = line.substr(maxline);\r",
							"    }\r",
							"  }\r",
							"  output += line;\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a base64-encoded string to a Uint8Array.\r",
							" *\r",
							" * @param input the base64-encoded input string.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.binary.base64.decode = function(input, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(Math.ceil(input.length / 4) * 3);\r",
							"  }\r",
							"\r",
							"  // remove all non-base64 characters\r",
							"  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\r",
							"\r",
							"  offset = offset || 0;\r",
							"  var enc1, enc2, enc3, enc4;\r",
							"  var i = 0, j = offset;\r",
							"\r",
							"  while(i < input.length) {\r",
							"    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\r",
							"\r",
							"    out[j++] = (enc1 << 2) | (enc2 >> 4);\r",
							"    if(enc3 !== 64) {\r",
							"      // decoded at least 2 bytes\r",
							"      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);\r",
							"      if(enc4 !== 64) {\r",
							"        // decoded 3 bytes\r",
							"        out[j++] = ((enc3 & 3) << 6) | enc4;\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // make sure result is the exact decoded length\r",
							"  return output ? (j - offset) : out.subarray(0, j);\r",
							"};\r",
							"\r",
							"// add support for base58 encoding/decoding with Bitcoin alphabet\r",
							"util.binary.base58.encode = function(input, maxline) {\r",
							"  return util.binary.baseN.encode(input, _base58, maxline);\r",
							"};\r",
							"util.binary.base58.decode = function(input, maxline) {\r",
							"  return util.binary.baseN.decode(input, _base58, maxline);\r",
							"};\r",
							"\r",
							"// text encoding/decoding tools\r",
							"// FIXME: Experimental. Do not use yet.\r",
							"util.text = {\r",
							"  utf8: {},\r",
							"  utf16: {}\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes the given string as UTF-8 in a Uint8Array.\r",
							" *\r",
							" * @param str the string to encode.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.text.utf8.encode = function(str, output, offset) {\r",
							"  str = util.encodeUtf8(str);\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(str.length);\r",
							"  }\r",
							"  offset = offset || 0;\r",
							"  var j = offset;\r",
							"  for(var i = 0; i < str.length; ++i) {\r",
							"    out[j++] = str.charCodeAt(i);\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes the UTF-8 contents from a Uint8Array.\r",
							" *\r",
							" * @param bytes the Uint8Array to decode.\r",
							" *\r",
							" * @return the resulting string.\r",
							" */\r",
							"util.text.utf8.decode = function(bytes) {\r",
							"  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes the given string as UTF-16 in a Uint8Array.\r",
							" *\r",
							" * @param str the string to encode.\r",
							" * @param [output] an optional Uint8Array to write the output to; if it\r",
							" *          is too small, an exception will be thrown.\r",
							" * @param [offset] the start offset for writing to the output (default: 0).\r",
							" *\r",
							" * @return the Uint8Array or the number of bytes written if output was given.\r",
							" */\r",
							"util.text.utf16.encode = function(str, output, offset) {\r",
							"  var out = output;\r",
							"  if(!out) {\r",
							"    out = new Uint8Array(str.length * 2);\r",
							"  }\r",
							"  var view = new Uint16Array(out.buffer);\r",
							"  offset = offset || 0;\r",
							"  var j = offset;\r",
							"  var k = offset;\r",
							"  for(var i = 0; i < str.length; ++i) {\r",
							"    view[k++] = str.charCodeAt(i);\r",
							"    j += 2;\r",
							"  }\r",
							"  return output ? (j - offset) : out;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes the UTF-16 contents from a Uint8Array.\r",
							" *\r",
							" * @param bytes the Uint8Array to decode.\r",
							" *\r",
							" * @return the resulting string.\r",
							" */\r",
							"util.text.utf16.decode = function(bytes) {\r",
							"  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deflates the given data using a flash interface.\r",
							" *\r",
							" * @param api the flash interface.\r",
							" * @param bytes the data.\r",
							" * @param raw true to return only raw deflate data, false to include zlib\r",
							" *          header and trailer.\r",
							" *\r",
							" * @return the deflated data as a string.\r",
							" */\r",
							"util.deflate = function(api, bytes, raw) {\r",
							"  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\r",
							"\r",
							"  // strip zlib header and trailer if necessary\r",
							"  if(raw) {\r",
							"    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\r",
							"    // there is a 4-byte DICT (alder-32) block before the data if\r",
							"    // its 5th bit is set\r",
							"    var start = 2;\r",
							"    var flg = bytes.charCodeAt(1);\r",
							"    if(flg & 0x20) {\r",
							"      start = 6;\r",
							"    }\r",
							"    // zlib trailer is 4 bytes of adler-32\r",
							"    bytes = bytes.substring(start, bytes.length - 4);\r",
							"  }\r",
							"\r",
							"  return bytes;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Inflates the given data using a flash interface.\r",
							" *\r",
							" * @param api the flash interface.\r",
							" * @param bytes the data.\r",
							" * @param raw true if the incoming data has no zlib header or trailer and is\r",
							" *          raw DEFLATE data.\r",
							" *\r",
							" * @return the inflated data as a string, null on error.\r",
							" */\r",
							"util.inflate = function(api, bytes, raw) {\r",
							"  // TODO: add zlib header and trailer if necessary/possible\r",
							"  var rval = api.inflate(util.encode64(bytes)).rval;\r",
							"  return (rval === null) ? null : util.decode64(rval);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets a storage object.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param obj the storage object, null to remove.\r",
							" */\r",
							"var _setStorageObject = function(api, id, obj) {\r",
							"  if(!api) {\r",
							"    throw new Error('WebStorage not available.');\r",
							"  }\r",
							"\r",
							"  var rval;\r",
							"  if(obj === null) {\r",
							"    rval = api.removeItem(id);\r",
							"  } else {\r",
							"    // json-encode and base64-encode object\r",
							"    obj = util.encode64(JSON.stringify(obj));\r",
							"    rval = api.setItem(id, obj);\r",
							"  }\r",
							"\r",
							"  // handle potential flash error\r",
							"  if(typeof(rval) !== 'undefined' && rval.rval !== true) {\r",
							"    var error = new Error(rval.error.message);\r",
							"    error.id = rval.error.id;\r",
							"    error.name = rval.error.name;\r",
							"    throw error;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a storage object.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" *\r",
							" * @return the storage object entry or null if none exists.\r",
							" */\r",
							"var _getStorageObject = function(api, id) {\r",
							"  if(!api) {\r",
							"    throw new Error('WebStorage not available.');\r",
							"  }\r",
							"\r",
							"  // get the existing entry\r",
							"  var rval = api.getItem(id);\r",
							"\r",
							"  /* Note: We check api.init because we can't do (api == localStorage)\r",
							"    on IE because of \"Class doesn't support Automation\" exception. Only\r",
							"    the flash api has an init method so this works too, but we need a\r",
							"    better solution in the future. */\r",
							"\r",
							"  // flash returns item wrapped in an object, handle special case\r",
							"  if(api.init) {\r",
							"    if(rval.rval === null) {\r",
							"      if(rval.error) {\r",
							"        var error = new Error(rval.error.message);\r",
							"        error.id = rval.error.id;\r",
							"        error.name = rval.error.name;\r",
							"        throw error;\r",
							"      }\r",
							"      // no error, but also no item\r",
							"      rval = null;\r",
							"    } else {\r",
							"      rval = rval.rval;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // handle decoding\r",
							"  if(rval !== null) {\r",
							"    // base64-decode and json-decode data\r",
							"    rval = JSON.parse(util.decode64(rval));\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Stores an item in local storage.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param data the data for the item (any javascript object/primitive).\r",
							" */\r",
							"var _setItem = function(api, id, key, data) {\r",
							"  // get storage object\r",
							"  var obj = _getStorageObject(api, id);\r",
							"  if(obj === null) {\r",
							"    // create a new storage object\r",
							"    obj = {};\r",
							"  }\r",
							"  // update key\r",
							"  obj[key] = data;\r",
							"\r",
							"  // set storage object\r",
							"  _setStorageObject(api, id, obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an item from local storage.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" *\r",
							" * @return the item.\r",
							" */\r",
							"var _getItem = function(api, id, key) {\r",
							"  // get storage object\r",
							"  var rval = _getStorageObject(api, id);\r",
							"  if(rval !== null) {\r",
							"    // return data at key\r",
							"    rval = (key in rval) ? rval[key] : null;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Removes an item from local storage.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" */\r",
							"var _removeItem = function(api, id, key) {\r",
							"  // get storage object\r",
							"  var obj = _getStorageObject(api, id);\r",
							"  if(obj !== null && key in obj) {\r",
							"    // remove key\r",
							"    delete obj[key];\r",
							"\r",
							"    // see if entry has no keys remaining\r",
							"    var empty = true;\r",
							"    for(var prop in obj) {\r",
							"      empty = false;\r",
							"      break;\r",
							"    }\r",
							"    if(empty) {\r",
							"      // remove entry entirely if no keys are left\r",
							"      obj = null;\r",
							"    }\r",
							"\r",
							"    // set storage object\r",
							"    _setStorageObject(api, id, obj);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears the local disk storage identified by the given ID.\r",
							" *\r",
							" * @param api the storage interface.\r",
							" * @param id the storage ID to use.\r",
							" */\r",
							"var _clearItems = function(api, id) {\r",
							"  _setStorageObject(api, id, null);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Calls a storage function.\r",
							" *\r",
							" * @param func the function to call.\r",
							" * @param args the arguments for the function.\r",
							" * @param location the location argument.\r",
							" *\r",
							" * @return the return value from the function.\r",
							" */\r",
							"var _callStorageFunction = function(func, args, location) {\r",
							"  var rval = null;\r",
							"\r",
							"  // default storage types\r",
							"  if(typeof(location) === 'undefined') {\r",
							"    location = ['web', 'flash'];\r",
							"  }\r",
							"\r",
							"  // apply storage types in order of preference\r",
							"  var type;\r",
							"  var done = false;\r",
							"  var exception = null;\r",
							"  for(var idx in location) {\r",
							"    type = location[idx];\r",
							"    try {\r",
							"      if(type === 'flash' || type === 'both') {\r",
							"        if(args[0] === null) {\r",
							"          throw new Error('Flash local storage not available.');\r",
							"        }\r",
							"        rval = func.apply(this, args);\r",
							"        done = (type === 'flash');\r",
							"      }\r",
							"      if(type === 'web' || type === 'both') {\r",
							"        args[0] = localStorage;\r",
							"        rval = func.apply(this, args);\r",
							"        done = true;\r",
							"      }\r",
							"    } catch(ex) {\r",
							"      exception = ex;\r",
							"    }\r",
							"    if(done) {\r",
							"      break;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(!done) {\r",
							"    throw exception;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Stores an item on local disk.\r",
							" *\r",
							" * The available types of local storage include 'flash', 'web', and 'both'.\r",
							" *\r",
							" * The type 'flash' refers to flash local storage (SharedObject). In order\r",
							" * to use flash local storage, the 'api' parameter must be valid. The type\r",
							" * 'web' refers to WebStorage, if supported by the browser. The type 'both'\r",
							" * refers to storing using both 'flash' and 'web', not just one or the\r",
							" * other.\r",
							" *\r",
							" * The location array should list the storage types to use in order of\r",
							" * preference:\r",
							" *\r",
							" * ['flash']: flash only storage\r",
							" * ['web']: web only storage\r",
							" * ['both']: try to store in both\r",
							" * ['flash','web']: store in flash first, but if not available, 'web'\r",
							" * ['web','flash']: store in web first, but if not available, 'flash'\r",
							" *\r",
							" * The location array defaults to: ['web', 'flash']\r",
							" *\r",
							" * @param api the flash interface, null to use only WebStorage.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param data the data for the item (any javascript object/primitive).\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" */\r",
							"util.setItem = function(api, id, key, data, location) {\r",
							"  _callStorageFunction(_setItem, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an item on local disk.\r",
							" *\r",
							" * Set setItem() for details on storage types.\r",
							" *\r",
							" * @param api the flash interface, null to use only WebStorage.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" *\r",
							" * @return the item.\r",
							" */\r",
							"util.getItem = function(api, id, key, location) {\r",
							"  return _callStorageFunction(_getItem, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Removes an item on local disk.\r",
							" *\r",
							" * Set setItem() for details on storage types.\r",
							" *\r",
							" * @param api the flash interface.\r",
							" * @param id the storage ID to use.\r",
							" * @param key the key for the item.\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" */\r",
							"util.removeItem = function(api, id, key, location) {\r",
							"  _callStorageFunction(_removeItem, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears the local disk storage identified by the given ID.\r",
							" *\r",
							" * Set setItem() for details on storage types.\r",
							" *\r",
							" * @param api the flash interface if flash is available.\r",
							" * @param id the storage ID to use.\r",
							" * @param location an array with the preferred types of storage to use.\r",
							" */\r",
							"util.clearItems = function(api, id, location) {\r",
							"  _callStorageFunction(_clearItems, arguments, location);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses the scheme, host, and port from an http(s) url.\r",
							" *\r",
							" * @param str the url string.\r",
							" *\r",
							" * @return the parsed url object or null if the url is invalid.\r",
							" */\r",
							"util.parseUrl = function(str) {\r",
							"  // FIXME: this regex looks a bit broken\r",
							"  var regex = /^(https?):\\/\\/([^:&^\\/]*):?(\\d*)(.*)$/g;\r",
							"  regex.lastIndex = 0;\r",
							"  var m = regex.exec(str);\r",
							"  var url = (m === null) ? null : {\r",
							"    full: str,\r",
							"    scheme: m[1],\r",
							"    host: m[2],\r",
							"    port: m[3],\r",
							"    path: m[4]\r",
							"  };\r",
							"  if(url) {\r",
							"    url.fullHost = url.host;\r",
							"    if(url.port) {\r",
							"      if(url.port !== 80 && url.scheme === 'http') {\r",
							"        url.fullHost += ':' + url.port;\r",
							"      } else if(url.port !== 443 && url.scheme === 'https') {\r",
							"        url.fullHost += ':' + url.port;\r",
							"      }\r",
							"    } else if(url.scheme === 'http') {\r",
							"      url.port = 80;\r",
							"    } else if(url.scheme === 'https') {\r",
							"      url.port = 443;\r",
							"    }\r",
							"    url.full = url.scheme + '://' + url.fullHost;\r",
							"  }\r",
							"  return url;\r",
							"};\r",
							"\r",
							"/* Storage for query variables */\r",
							"var _queryVariables = null;\r",
							"\r",
							"/**\r",
							" * Returns the window location query variables. Query is parsed on the first\r",
							" * call and the same object is returned on subsequent calls. The mapping\r",
							" * is from keys to an array of values. Parameters without values will have\r",
							" * an object key set but no value added to the value array. Values are\r",
							" * unescaped.\r",
							" *\r",
							" * ...?k1=v1&k2=v2:\r",
							" * {\r",
							" *   \"k1\": [\"v1\"],\r",
							" *   \"k2\": [\"v2\"]\r",
							" * }\r",
							" *\r",
							" * ...?k1=v1&k1=v2:\r",
							" * {\r",
							" *   \"k1\": [\"v1\", \"v2\"]\r",
							" * }\r",
							" *\r",
							" * ...?k1=v1&k2:\r",
							" * {\r",
							" *   \"k1\": [\"v1\"],\r",
							" *   \"k2\": []\r",
							" * }\r",
							" *\r",
							" * ...?k1=v1&k1:\r",
							" * {\r",
							" *   \"k1\": [\"v1\"]\r",
							" * }\r",
							" *\r",
							" * ...?k1&k1:\r",
							" * {\r",
							" *   \"k1\": []\r",
							" * }\r",
							" *\r",
							" * @param query the query string to parse (optional, default to cached\r",
							" *          results from parsing window location search query).\r",
							" *\r",
							" * @return object mapping keys to variables.\r",
							" */\r",
							"util.getQueryVariables = function(query) {\r",
							"  var parse = function(q) {\r",
							"    var rval = {};\r",
							"    var kvpairs = q.split('&');\r",
							"    for(var i = 0; i < kvpairs.length; i++) {\r",
							"      var pos = kvpairs[i].indexOf('=');\r",
							"      var key;\r",
							"      var val;\r",
							"      if(pos > 0) {\r",
							"        key = kvpairs[i].substring(0, pos);\r",
							"        val = kvpairs[i].substring(pos + 1);\r",
							"      } else {\r",
							"        key = kvpairs[i];\r",
							"        val = null;\r",
							"      }\r",
							"      if(!(key in rval)) {\r",
							"        rval[key] = [];\r",
							"      }\r",
							"      // disallow overriding object prototype keys\r",
							"      if(!(key in Object.prototype) && val !== null) {\r",
							"        rval[key].push(unescape(val));\r",
							"      }\r",
							"    }\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"   var rval;\r",
							"   if(typeof(query) === 'undefined') {\r",
							"     // set cached variables if needed\r",
							"     if(_queryVariables === null) {\r",
							"       if(typeof(window) !== 'undefined' && window.location && window.location.search) {\r",
							"          // parse window search query\r",
							"          _queryVariables = parse(window.location.search.substring(1));\r",
							"       } else {\r",
							"          // no query variables available\r",
							"          _queryVariables = {};\r",
							"       }\r",
							"     }\r",
							"     rval = _queryVariables;\r",
							"   } else {\r",
							"     // parse given query\r",
							"     rval = parse(query);\r",
							"   }\r",
							"   return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses a fragment into a path and query. This method will take a URI\r",
							" * fragment and break it up as if it were the main URI. For example:\r",
							" *    /bar/baz?a=1&b=2\r",
							" * results in:\r",
							" *    {\r",
							" *       path: [\"bar\", \"baz\"],\r",
							" *       query: {\"k1\": [\"v1\"], \"k2\": [\"v2\"]}\r",
							" *    }\r",
							" *\r",
							" * @return object with a path array and query object.\r",
							" */\r",
							"util.parseFragment = function(fragment) {\r",
							"  // default to whole fragment\r",
							"  var fp = fragment;\r",
							"  var fq = '';\r",
							"  // split into path and query if possible at the first '?'\r",
							"  var pos = fragment.indexOf('?');\r",
							"  if(pos > 0) {\r",
							"    fp = fragment.substring(0, pos);\r",
							"    fq = fragment.substring(pos + 1);\r",
							"  }\r",
							"  // split path based on '/' and ignore first element if empty\r",
							"  var path = fp.split('/');\r",
							"  if(path.length > 0 && path[0] === '') {\r",
							"    path.shift();\r",
							"  }\r",
							"  // convert query into object\r",
							"  var query = (fq === '') ? {} : util.getQueryVariables(fq);\r",
							"\r",
							"  return {\r",
							"    pathString: fp,\r",
							"    queryString: fq,\r",
							"    path: path,\r",
							"    query: query\r",
							"  };\r",
							"};\r",
							"\r",
							"/**\r",
							" * Makes a request out of a URI-like request string. This is intended to\r",
							" * be used where a fragment id (after a URI '#') is parsed as a URI with\r",
							" * path and query parts. The string should have a path beginning and\r",
							" * delimited by '/' and optional query parameters following a '?'. The\r",
							" * query should be a standard URL set of key value pairs delimited by\r",
							" * '&'. For backwards compatibility the initial '/' on the path is not\r",
							" * required. The request object has the following API, (fully described\r",
							" * in the method code):\r",
							" *    {\r",
							" *       path: <the path string part>.\r",
							" *       query: <the query string part>,\r",
							" *       getPath(i): get part or all of the split path array,\r",
							" *       getQuery(k, i): get part or all of a query key array,\r",
							" *       getQueryLast(k, _default): get last element of a query key array.\r",
							" *    }\r",
							" *\r",
							" * @return object with request parameters.\r",
							" */\r",
							"util.makeRequest = function(reqString) {\r",
							"  var frag = util.parseFragment(reqString);\r",
							"  var req = {\r",
							"    // full path string\r",
							"    path: frag.pathString,\r",
							"    // full query string\r",
							"    query: frag.queryString,\r",
							"    /**\r",
							"     * Get path or element in path.\r",
							"     *\r",
							"     * @param i optional path index.\r",
							"     *\r",
							"     * @return path or part of path if i provided.\r",
							"     */\r",
							"    getPath: function(i) {\r",
							"      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];\r",
							"    },\r",
							"    /**\r",
							"     * Get query, values for a key, or value for a key index.\r",
							"     *\r",
							"     * @param k optional query key.\r",
							"     * @param i optional query key index.\r",
							"     *\r",
							"     * @return query, values for a key, or value for a key index.\r",
							"     */\r",
							"    getQuery: function(k, i) {\r",
							"      var rval;\r",
							"      if(typeof(k) === 'undefined') {\r",
							"        rval = frag.query;\r",
							"      } else {\r",
							"        rval = frag.query[k];\r",
							"        if(rval && typeof(i) !== 'undefined') {\r",
							"           rval = rval[i];\r",
							"        }\r",
							"      }\r",
							"      return rval;\r",
							"    },\r",
							"    getQueryLast: function(k, _default) {\r",
							"      var rval;\r",
							"      var vals = req.getQuery(k);\r",
							"      if(vals) {\r",
							"        rval = vals[vals.length - 1];\r",
							"      } else {\r",
							"        rval = _default;\r",
							"      }\r",
							"      return rval;\r",
							"    }\r",
							"  };\r",
							"  return req;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Makes a URI out of a path, an object with query parameters, and a\r",
							" * fragment. Uses jQuery.param() internally for query string creation.\r",
							" * If the path is an array, it will be joined with '/'.\r",
							" *\r",
							" * @param path string path or array of strings.\r",
							" * @param query object with query parameters. (optional)\r",
							" * @param fragment fragment string. (optional)\r",
							" *\r",
							" * @return string object with request parameters.\r",
							" */\r",
							"util.makeLink = function(path, query, fragment) {\r",
							"  // join path parts if needed\r",
							"  path = jQuery.isArray(path) ? path.join('/') : path;\r",
							"\r",
							"  var qstr = jQuery.param(query || {});\r",
							"  fragment = fragment || '';\r",
							"  return path +\r",
							"    ((qstr.length > 0) ? ('?' + qstr) : '') +\r",
							"    ((fragment.length > 0) ? ('#' + fragment) : '');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Follows a path of keys deep into an object hierarchy and set a value.\r",
							" * If a key does not exist or it's value is not an object, create an\r",
							" * object in it's place. This can be destructive to a object tree if\r",
							" * leaf nodes are given as non-final path keys.\r",
							" * Used to avoid exceptions from missing parts of the path.\r",
							" *\r",
							" * @param object the starting object.\r",
							" * @param keys an array of string keys.\r",
							" * @param value the value to set.\r",
							" */\r",
							"util.setPath = function(object, keys, value) {\r",
							"  // need to start at an object\r",
							"  if(typeof(object) === 'object' && object !== null) {\r",
							"    var i = 0;\r",
							"    var len = keys.length;\r",
							"    while(i < len) {\r",
							"      var next = keys[i++];\r",
							"      if(i == len) {\r",
							"        // last\r",
							"        object[next] = value;\r",
							"      } else {\r",
							"        // more\r",
							"        var hasNext = (next in object);\r",
							"        if(!hasNext ||\r",
							"          (hasNext && typeof(object[next]) !== 'object') ||\r",
							"          (hasNext && object[next] === null)) {\r",
							"          object[next] = {};\r",
							"        }\r",
							"        object = object[next];\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Follows a path of keys deep into an object hierarchy and return a value.\r",
							" * If a key does not exist, create an object in it's place.\r",
							" * Used to avoid exceptions from missing parts of the path.\r",
							" *\r",
							" * @param object the starting object.\r",
							" * @param keys an array of string keys.\r",
							" * @param _default value to return if path not found.\r",
							" *\r",
							" * @return the value at the path if found, else default if given, else\r",
							" *         undefined.\r",
							" */\r",
							"util.getPath = function(object, keys, _default) {\r",
							"  var i = 0;\r",
							"  var len = keys.length;\r",
							"  var hasNext = true;\r",
							"  while(hasNext && i < len &&\r",
							"    typeof(object) === 'object' && object !== null) {\r",
							"    var next = keys[i++];\r",
							"    hasNext = next in object;\r",
							"    if(hasNext) {\r",
							"      object = object[next];\r",
							"    }\r",
							"  }\r",
							"  return (hasNext ? object : _default);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Follow a path of keys deep into an object hierarchy and delete the\r",
							" * last one. If a key does not exist, do nothing.\r",
							" * Used to avoid exceptions from missing parts of the path.\r",
							" *\r",
							" * @param object the starting object.\r",
							" * @param keys an array of string keys.\r",
							" */\r",
							"util.deletePath = function(object, keys) {\r",
							"  // need to start at an object\r",
							"  if(typeof(object) === 'object' && object !== null) {\r",
							"    var i = 0;\r",
							"    var len = keys.length;\r",
							"    while(i < len) {\r",
							"      var next = keys[i++];\r",
							"      if(i == len) {\r",
							"        // last\r",
							"        delete object[next];\r",
							"      } else {\r",
							"        // more\r",
							"        if(!(next in object) ||\r",
							"          (typeof(object[next]) !== 'object') ||\r",
							"          (object[next] === null)) {\r",
							"           break;\r",
							"        }\r",
							"        object = object[next];\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Check if an object is empty.\r",
							" *\r",
							" * Taken from:\r",
							" * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\r",
							" *\r",
							" * @param object the object to check.\r",
							" */\r",
							"util.isEmpty = function(obj) {\r",
							"  for(var prop in obj) {\r",
							"    if(obj.hasOwnProperty(prop)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"  return true;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Format with simple printf-style interpolation.\r",
							" *\r",
							" * %%: literal '%'\r",
							" * %s,%o: convert next argument into a string.\r",
							" *\r",
							" * @param format the string to format.\r",
							" * @param ... arguments to interpolate into the format string.\r",
							" */\r",
							"util.format = function(format) {\r",
							"  var re = /%./g;\r",
							"  // current match\r",
							"  var match;\r",
							"  // current part\r",
							"  var part;\r",
							"  // current arg index\r",
							"  var argi = 0;\r",
							"  // collected parts to recombine later\r",
							"  var parts = [];\r",
							"  // last index found\r",
							"  var last = 0;\r",
							"  // loop while matches remain\r",
							"  while((match = re.exec(format))) {\r",
							"    part = format.substring(last, re.lastIndex - 2);\r",
							"    // don't add empty strings (ie, parts between %s%s)\r",
							"    if(part.length > 0) {\r",
							"      parts.push(part);\r",
							"    }\r",
							"    last = re.lastIndex;\r",
							"    // switch on % code\r",
							"    var code = match[0][1];\r",
							"    switch(code) {\r",
							"    case 's':\r",
							"    case 'o':\r",
							"      // check if enough arguments were given\r",
							"      if(argi < arguments.length) {\r",
							"        parts.push(arguments[argi++ + 1]);\r",
							"      } else {\r",
							"        parts.push('<?>');\r",
							"      }\r",
							"      break;\r",
							"    // FIXME: do proper formating for numbers, etc\r",
							"    //case 'f':\r",
							"    //case 'd':\r",
							"    case '%':\r",
							"      parts.push('%');\r",
							"      break;\r",
							"    default:\r",
							"      parts.push('<%' + code + '?>');\r",
							"    }\r",
							"  }\r",
							"  // add trailing part of format string\r",
							"  parts.push(format.substring(last));\r",
							"  return parts.join('');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Formats a number.\r",
							" *\r",
							" * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\r",
							" */\r",
							"util.formatNumber = function(number, decimals, dec_point, thousands_sep) {\r",
							"  // http://kevin.vanzonneveld.net\r",
							"  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r",
							"  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r",
							"  // +     bugfix by: Michael White (http://crestidg.com)\r",
							"  // +     bugfix by: Benjamin Lupton\r",
							"  // +     bugfix by: Allan Jensen (http://www.winternet.no)\r",
							"  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r",
							"  // *     example 1: number_format(1234.5678, 2, '.', '');\r",
							"  // *     returns 1: 1234.57\r",
							"\r",
							"  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\r",
							"  var d = dec_point === undefined ? ',' : dec_point;\r",
							"  var t = thousands_sep === undefined ?\r",
							"   '.' : thousands_sep, s = n < 0 ? '-' : '';\r",
							"  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';\r",
							"  var j = (i.length > 3) ? i.length % 3 : 0;\r",
							"  return s + (j ? i.substr(0, j) + t : '') +\r",
							"    i.substr(j).replace(/(\\d{3})(?=\\d)/g, '$1' + t) +\r",
							"    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Formats a byte size.\r",
							" *\r",
							" * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\r",
							" */\r",
							"util.formatSize = function(size) {\r",
							"  if(size >= 1073741824) {\r",
							"    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';\r",
							"  } else if(size >= 1048576) {\r",
							"    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';\r",
							"  } else if(size >= 1024) {\r",
							"    size = util.formatNumber(size / 1024, 0) + ' KiB';\r",
							"  } else {\r",
							"    size = util.formatNumber(size, 0) + ' bytes';\r",
							"  }\r",
							"  return size;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an IPv4 or IPv6 string representation into bytes (in network order).\r",
							" *\r",
							" * @param ip the IPv4 or IPv6 address to convert.\r",
							" *\r",
							" * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't\r",
							" *         be parsed.\r",
							" */\r",
							"util.bytesFromIP = function(ip) {\r",
							"  if(ip.indexOf('.') !== -1) {\r",
							"    return util.bytesFromIPv4(ip);\r",
							"  }\r",
							"  if(ip.indexOf(':') !== -1) {\r",
							"    return util.bytesFromIPv6(ip);\r",
							"  }\r",
							"  return null;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an IPv4 string representation into bytes (in network order).\r",
							" *\r",
							" * @param ip the IPv4 address to convert.\r",
							" *\r",
							" * @return the 4-byte address or null if the address can't be parsed.\r",
							" */\r",
							"util.bytesFromIPv4 = function(ip) {\r",
							"  ip = ip.split('.');\r",
							"  if(ip.length !== 4) {\r",
							"    return null;\r",
							"  }\r",
							"  var b = util.createBuffer();\r",
							"  for(var i = 0; i < ip.length; ++i) {\r",
							"    var num = parseInt(ip[i], 10);\r",
							"    if(isNaN(num)) {\r",
							"      return null;\r",
							"    }\r",
							"    b.putByte(num);\r",
							"  }\r",
							"  return b.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an IPv6 string representation into bytes (in network order).\r",
							" *\r",
							" * @param ip the IPv6 address to convert.\r",
							" *\r",
							" * @return the 16-byte address or null if the address can't be parsed.\r",
							" */\r",
							"util.bytesFromIPv6 = function(ip) {\r",
							"  var blanks = 0;\r",
							"  ip = ip.split(':').filter(function(e) {\r",
							"    if(e.length === 0) ++blanks;\r",
							"    return true;\r",
							"  });\r",
							"  var zeros = (8 - ip.length + blanks) * 2;\r",
							"  var b = util.createBuffer();\r",
							"  for(var i = 0; i < 8; ++i) {\r",
							"    if(!ip[i] || ip[i].length === 0) {\r",
							"      b.fillWithByte(0, zeros);\r",
							"      zeros = 0;\r",
							"      continue;\r",
							"    }\r",
							"    var bytes = util.hexToBytes(ip[i]);\r",
							"    if(bytes.length < 2) {\r",
							"      b.putByte(0);\r",
							"    }\r",
							"    b.putBytes(bytes);\r",
							"  }\r",
							"  return b.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts 4-bytes into an IPv4 string representation or 16-bytes into\r",
							" * an IPv6 string representation. The bytes must be in network order.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,\r",
							" *         respectively, are given, otherwise null.\r",
							" */\r",
							"util.bytesToIP = function(bytes) {\r",
							"  if(bytes.length === 4) {\r",
							"    return util.bytesToIPv4(bytes);\r",
							"  }\r",
							"  if(bytes.length === 16) {\r",
							"    return util.bytesToIPv6(bytes);\r",
							"  }\r",
							"  return null;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts 4-bytes into an IPv4 string representation. The bytes must be\r",
							" * in network order.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the IPv4 string representation or null for an invalid # of bytes.\r",
							" */\r",
							"util.bytesToIPv4 = function(bytes) {\r",
							"  if(bytes.length !== 4) {\r",
							"    return null;\r",
							"  }\r",
							"  var ip = [];\r",
							"  for(var i = 0; i < bytes.length; ++i) {\r",
							"    ip.push(bytes.charCodeAt(i));\r",
							"  }\r",
							"  return ip.join('.');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts 16-bytes into an IPv16 string representation. The bytes must be\r",
							" * in network order.\r",
							" *\r",
							" * @param bytes the bytes to convert.\r",
							" *\r",
							" * @return the IPv16 string representation or null for an invalid # of bytes.\r",
							" */\r",
							"util.bytesToIPv6 = function(bytes) {\r",
							"  if(bytes.length !== 16) {\r",
							"    return null;\r",
							"  }\r",
							"  var ip = [];\r",
							"  var zeroGroups = [];\r",
							"  var zeroMaxGroup = 0;\r",
							"  for(var i = 0; i < bytes.length; i += 2) {\r",
							"    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\r",
							"    // canonicalize zero representation\r",
							"    while(hex[0] === '0' && hex !== '0') {\r",
							"      hex = hex.substr(1);\r",
							"    }\r",
							"    if(hex === '0') {\r",
							"      var last = zeroGroups[zeroGroups.length - 1];\r",
							"      var idx = ip.length;\r",
							"      if(!last || idx !== last.end + 1) {\r",
							"        zeroGroups.push({start: idx, end: idx});\r",
							"      } else {\r",
							"        last.end = idx;\r",
							"        if((last.end - last.start) >\r",
							"          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {\r",
							"          zeroMaxGroup = zeroGroups.length - 1;\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    ip.push(hex);\r",
							"  }\r",
							"  if(zeroGroups.length > 0) {\r",
							"    var group = zeroGroups[zeroMaxGroup];\r",
							"    // only shorten group of length > 0\r",
							"    if(group.end - group.start > 0) {\r",
							"      ip.splice(group.start, group.end - group.start + 1, '');\r",
							"      if(group.start === 0) {\r",
							"        ip.unshift('');\r",
							"      }\r",
							"      if(group.end === 7) {\r",
							"        ip.push('');\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"  return ip.join(':');\r",
							"};\r",
							"\r",
							"/**\r",
							" * Estimates the number of processes that can be run concurrently. If\r",
							" * creating Web Workers, keep in mind that the main JavaScript process needs\r",
							" * its own core.\r",
							" *\r",
							" * @param options the options to use:\r",
							" *          update true to force an update (not use the cached value).\r",
							" * @param callback(err, max) called once the operation completes.\r",
							" */\r",
							"util.estimateCores = function(options, callback) {\r",
							"  if(typeof options === 'function') {\r",
							"    callback = options;\r",
							"    options = {};\r",
							"  }\r",
							"  options = options || {};\r",
							"  if('cores' in util && !options.update) {\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"  if(typeof navigator !== 'undefined' &&\r",
							"    'hardwareConcurrency' in navigator &&\r",
							"    navigator.hardwareConcurrency > 0) {\r",
							"    util.cores = navigator.hardwareConcurrency;\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"  if(typeof Worker === 'undefined') {\r",
							"    // workers not available\r",
							"    util.cores = 1;\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"  if(typeof Blob === 'undefined') {\r",
							"    // can't estimate, default to 2\r",
							"    util.cores = 2;\r",
							"    return callback(null, util.cores);\r",
							"  }\r",
							"\r",
							"  // create worker concurrency estimation code as blob\r",
							"  var blobUrl = URL.createObjectURL(new Blob(['(',\r",
							"    function() {\r",
							"      self.addEventListener('message', function(e) {\r",
							"        // run worker for 4 ms\r",
							"        var st = Date.now();\r",
							"        var et = st + 4;\r",
							"        while(Date.now() < et);\r",
							"        self.postMessage({st: st, et: et});\r",
							"      });\r",
							"    }.toString(),\r",
							"  ')()'], {type: 'application/javascript'}));\r",
							"\r",
							"  // take 5 samples using 16 workers\r",
							"  sample([], 5, 16);\r",
							"\r",
							"  function sample(max, samples, numWorkers) {\r",
							"    if(samples === 0) {\r",
							"      // get overlap average\r",
							"      var avg = Math.floor(max.reduce(function(avg, x) {\r",
							"        return avg + x;\r",
							"      }, 0) / max.length);\r",
							"      util.cores = Math.max(1, avg);\r",
							"      URL.revokeObjectURL(blobUrl);\r",
							"      return callback(null, util.cores);\r",
							"    }\r",
							"    map(numWorkers, function(err, results) {\r",
							"      max.push(reduce(numWorkers, results));\r",
							"      sample(max, samples - 1, numWorkers);\r",
							"    });\r",
							"  }\r",
							"\r",
							"  function map(numWorkers, callback) {\r",
							"    var workers = [];\r",
							"    var results = [];\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      var worker = new Worker(blobUrl);\r",
							"      worker.addEventListener('message', function(e) {\r",
							"        results.push(e.data);\r",
							"        if(results.length === numWorkers) {\r",
							"          for(var i = 0; i < numWorkers; ++i) {\r",
							"            workers[i].terminate();\r",
							"          }\r",
							"          callback(null, results);\r",
							"        }\r",
							"      });\r",
							"      workers.push(worker);\r",
							"    }\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      workers[i].postMessage(i);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  function reduce(numWorkers, results) {\r",
							"    // find overlapping time windows\r",
							"    var overlaps = [];\r",
							"    for(var n = 0; n < numWorkers; ++n) {\r",
							"      var r1 = results[n];\r",
							"      var overlap = overlaps[n] = [];\r",
							"      for(var i = 0; i < numWorkers; ++i) {\r",
							"        if(n === i) {\r",
							"          continue;\r",
							"        }\r",
							"        var r2 = results[i];\r",
							"        if((r1.st > r2.st && r1.st < r2.et) ||\r",
							"          (r2.st > r1.st && r2.st < r1.et)) {\r",
							"          overlap.push(i);\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    // get maximum overlaps ... don't include overlapping worker itself\r",
							"    // as the main JS process was also being scheduled during the work and\r",
							"    // would have to be subtracted from the estimate anyway\r",
							"    return overlaps.reduce(function(max, overlap) {\r",
							"      return Math.max(max, overlap.length);\r",
							"    }, 0);\r",
							"  }\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 2 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * An API for getting cryptographically-secure random bytes. The bytes are\r",
							" * generated using the Fortuna algorithm devised by Bruce Schneier and\r",
							" * Niels Ferguson.\r",
							" *\r",
							" * Getting strong random bytes is not yet easy to do in javascript. The only\r",
							" * truish random entropy that can be collected is from the mouse, keyboard, or\r",
							" * from timing with respect to page loads, etc. This generator makes a poor\r",
							" * attempt at providing random bytes when those sources haven't yet provided\r",
							" * enough entropy to initially seed or to reseed the PRNG.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2009-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(23);\r",
							"__webpack_require__(24);\r",
							"__webpack_require__(1);\r",
							"\r",
							"(function() {\r",
							"\r",
							"// forge.random already defined\r",
							"if(forge.random && forge.random.getBytes) {\r",
							"  module.exports = forge.random;\r",
							"  return;\r",
							"}\r",
							"\r",
							"(function(jQuery) {\r",
							"\r",
							"// the default prng plugin, uses AES-128\r",
							"var prng_aes = {};\r",
							"var _prng_aes_output = new Array(4);\r",
							"var _prng_aes_buffer = forge.util.createBuffer();\r",
							"prng_aes.formatKey = function(key) {\r",
							"  // convert the key into 32-bit integers\r",
							"  var tmp = forge.util.createBuffer(key);\r",
							"  key = new Array(4);\r",
							"  key[0] = tmp.getInt32();\r",
							"  key[1] = tmp.getInt32();\r",
							"  key[2] = tmp.getInt32();\r",
							"  key[3] = tmp.getInt32();\r",
							"\r",
							"  // return the expanded key\r",
							"  return forge.aes._expandKey(key, false);\r",
							"};\r",
							"prng_aes.formatSeed = function(seed) {\r",
							"  // convert seed into 32-bit integers\r",
							"  var tmp = forge.util.createBuffer(seed);\r",
							"  seed = new Array(4);\r",
							"  seed[0] = tmp.getInt32();\r",
							"  seed[1] = tmp.getInt32();\r",
							"  seed[2] = tmp.getInt32();\r",
							"  seed[3] = tmp.getInt32();\r",
							"  return seed;\r",
							"};\r",
							"prng_aes.cipher = function(key, seed) {\r",
							"  forge.aes._updateBlock(key, seed, _prng_aes_output, false);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[0]);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[1]);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[2]);\r",
							"  _prng_aes_buffer.putInt32(_prng_aes_output[3]);\r",
							"  return _prng_aes_buffer.getBytes();\r",
							"};\r",
							"prng_aes.increment = function(seed) {\r",
							"  // FIXME: do we care about carry or signed issues?\r",
							"  ++seed[3];\r",
							"  return seed;\r",
							"};\r",
							"prng_aes.md = forge.md.sha256;\r",
							"\r",
							"/**\r",
							" * Creates a new PRNG.\r",
							" */\r",
							"function spawnPrng() {\r",
							"  var ctx = forge.prng.create(prng_aes);\r",
							"\r",
							"  /**\r",
							"   * Gets random bytes. If a native secure crypto API is unavailable, this\r",
							"   * method tries to make the bytes more unpredictable by drawing from data that\r",
							"   * can be collected from the user of the browser, eg: mouse movement.\r",
							"   *\r",
							"   * If a callback is given, this method will be called asynchronously.\r",
							"   *\r",
							"   * @param count the number of random bytes to get.\r",
							"   * @param [callback(err, bytes)] called once the operation completes.\r",
							"   *\r",
							"   * @return the random bytes in a string.\r",
							"   */\r",
							"  ctx.getBytes = function(count, callback) {\r",
							"    return ctx.generate(count, callback);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Gets random bytes asynchronously. If a native secure crypto API is\r",
							"   * unavailable, this method tries to make the bytes more unpredictable by\r",
							"   * drawing from data that can be collected from the user of the browser,\r",
							"   * eg: mouse movement.\r",
							"   *\r",
							"   * @param count the number of random bytes to get.\r",
							"   *\r",
							"   * @return the random bytes in a string.\r",
							"   */\r",
							"  ctx.getBytesSync = function(count) {\r",
							"    return ctx.generate(count);\r",
							"  };\r",
							"\r",
							"  return ctx;\r",
							"}\r",
							"\r",
							"// create default prng context\r",
							"var _ctx = spawnPrng();\r",
							"\r",
							"// add other sources of entropy only if window.crypto.getRandomValues is not\r",
							"// available -- otherwise this source will be automatically used by the prng\r",
							"var getRandomValues = null;\r",
							"if(typeof window !== 'undefined') {\r",
							"  var _crypto = window.crypto || window.msCrypto;\r",
							"  if(_crypto && _crypto.getRandomValues) {\r",
							"    getRandomValues = function(arr) {\r",
							"      return _crypto.getRandomValues(arr);\r",
							"    };\r",
							"  }\r",
							"}\r",
							"if(forge.options.usePureJavaScript ||\r",
							"  (!forge.util.isNodejs && !getRandomValues)) {\r",
							"  // if this is a web worker, do not use weak entropy, instead register to\r",
							"  // receive strong entropy asynchronously from the main thread\r",
							"  if(typeof window === 'undefined' || window.document === undefined) {\r",
							"    // FIXME:\r",
							"  }\r",
							"\r",
							"  // get load time entropy\r",
							"  _ctx.collectInt(+new Date(), 32);\r",
							"\r",
							"  // add some entropy from navigator object\r",
							"  if(typeof(navigator) !== 'undefined') {\r",
							"    var _navBytes = '';\r",
							"    for(var key in navigator) {\r",
							"      try {\r",
							"        if(typeof(navigator[key]) == 'string') {\r",
							"          _navBytes += navigator[key];\r",
							"        }\r",
							"      } catch(e) {\r",
							"        /* Some navigator keys might not be accessible, e.g. the geolocation\r",
							"          attribute throws an exception if touched in Mozilla chrome://\r",
							"          context.\r",
							"\r",
							"          Silently ignore this and just don't use this as a source of\r",
							"          entropy. */\r",
							"      }\r",
							"    }\r",
							"    _ctx.collect(_navBytes);\r",
							"    _navBytes = null;\r",
							"  }\r",
							"\r",
							"  // add mouse and keyboard collectors if jquery is available\r",
							"  if(jQuery) {\r",
							"    // set up mouse entropy capture\r",
							"    jQuery().mousemove(function(e) {\r",
							"      // add mouse coords\r",
							"      _ctx.collectInt(e.clientX, 16);\r",
							"      _ctx.collectInt(e.clientY, 16);\r",
							"    });\r",
							"\r",
							"    // set up keyboard entropy capture\r",
							"    jQuery().keypress(function(e) {\r",
							"      _ctx.collectInt(e.charCode, 8);\r",
							"    });\r",
							"  }\r",
							"}\r",
							"\r",
							"/* Random API */\r",
							"if(!forge.random) {\r",
							"  forge.random = _ctx;\r",
							"} else {\r",
							"  // extend forge.random with _ctx\r",
							"  for(var key in _ctx) {\r",
							"    forge.random[key] = _ctx[key];\r",
							"  }\r",
							"}\r",
							"\r",
							"// expose spawn PRNG\r",
							"forge.random.createInstance = spawnPrng;\r",
							"\r",
							"module.exports = forge.random;\r",
							"\r",
							"})(typeof(jQuery) !== 'undefined' ? jQuery : null);\r",
							"\r",
							"})();\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 3 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of Abstract Syntax Notation Number One.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2015 Digital Bazaar, Inc.\r",
							" *\r",
							" * An API for storing data using the Abstract Syntax Notation Number One\r",
							" * format using DER (Distinguished Encoding Rules) encoding. This encoding is\r",
							" * commonly used to store data for PKI, i.e. X.509 Certificates, and this\r",
							" * implementation exists for that purpose.\r",
							" *\r",
							" * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract\r",
							" * syntax of information without restricting the way the information is encoded\r",
							" * for transmission. It provides a standard that allows for open systems\r",
							" * communication. ASN.1 defines the syntax of information data and a number of\r",
							" * simple data types as well as a notation for describing them and specifying\r",
							" * values for them.\r",
							" *\r",
							" * The RSA algorithm creates public and private keys that are often stored in\r",
							" * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This\r",
							" * class provides the most basic functionality required to store and load DSA\r",
							" * keys that are encoded according to ASN.1.\r",
							" *\r",
							" * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)\r",
							" * and DER (Distinguished Encoding Rules). DER is just a subset of BER that\r",
							" * has stricter requirements for how data must be encoded.\r",
							" *\r",
							" * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)\r",
							" * and a byte array for the value of this ASN1 structure which may be data or a\r",
							" * list of ASN.1 structures.\r",
							" *\r",
							" * Each ASN.1 structure using BER is (Tag-Length-Value):\r",
							" *\r",
							" * | byte 0 | bytes X | bytes Y |\r",
							" * |--------|---------|----------\r",
							" * |  tag   | length  |  value  |\r",
							" *\r",
							" * ASN.1 allows for tags to be of \"High-tag-number form\" which allows a tag to\r",
							" * be two or more octets, but that is not supported by this class. A tag is\r",
							" * only 1 byte. Bits 1-5 give the tag number (ie the data type within a\r",
							" * particular 'class'), 6 indicates whether or not the ASN.1 value is\r",
							" * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If\r",
							" * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,\r",
							" * then the class is APPLICATION. If only bit 8 is set, then the class is\r",
							" * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.\r",
							" * The tag numbers for the data types for the class UNIVERSAL are listed below:\r",
							" *\r",
							" * UNIVERSAL 0 Reserved for use by the encoding rules\r",
							" * UNIVERSAL 1 Boolean type\r",
							" * UNIVERSAL 2 Integer type\r",
							" * UNIVERSAL 3 Bitstring type\r",
							" * UNIVERSAL 4 Octetstring type\r",
							" * UNIVERSAL 5 Null type\r",
							" * UNIVERSAL 6 Object identifier type\r",
							" * UNIVERSAL 7 Object descriptor type\r",
							" * UNIVERSAL 8 External type and Instance-of type\r",
							" * UNIVERSAL 9 Real type\r",
							" * UNIVERSAL 10 Enumerated type\r",
							" * UNIVERSAL 11 Embedded-pdv type\r",
							" * UNIVERSAL 12 UTF8String type\r",
							" * UNIVERSAL 13 Relative object identifier type\r",
							" * UNIVERSAL 14-15 Reserved for future editions\r",
							" * UNIVERSAL 16 Sequence and Sequence-of types\r",
							" * UNIVERSAL 17 Set and Set-of types\r",
							" * UNIVERSAL 18-22, 25-30 Character string types\r",
							" * UNIVERSAL 23-24 Time types\r",
							" *\r",
							" * The length of an ASN.1 structure is specified after the tag identifier.\r",
							" * There is a definite form and an indefinite form. The indefinite form may\r",
							" * be used if the encoding is constructed and not all immediately available.\r",
							" * The indefinite form is encoded using a length byte with only the 8th bit\r",
							" * set. The end of the constructed object is marked using end-of-contents\r",
							" * octets (two zero bytes).\r",
							" *\r",
							" * The definite form looks like this:\r",
							" *\r",
							" * The length may take up 1 or more bytes, it depends on the length of the\r",
							" * value of the ASN.1 structure. DER encoding requires that if the ASN.1\r",
							" * structure has a value that has a length greater than 127, more than 1 byte\r",
							" * will be used to store its length, otherwise just one byte will be used.\r",
							" * This is strict.\r",
							" *\r",
							" * In the case that the length of the ASN.1 value is less than 127, 1 octet\r",
							" * (byte) is used to store the \"short form\" length. The 8th bit has a value of\r",
							" * 0 indicating the length is \"short form\" and not \"long form\" and bits 7-1\r",
							" * give the length of the data. (The 8th bit is the left-most, most significant\r",
							" * bit: also known as big endian or network format).\r",
							" *\r",
							" * In the case that the length of the ASN.1 value is greater than 127, 2 to\r",
							" * 127 octets (bytes) are used to store the \"long form\" length. The first\r",
							" * byte's 8th bit is set to 1 to indicate the length is \"long form.\" Bits 7-1\r",
							" * give the number of additional octets. All following octets are in base 256\r",
							" * with the most significant digit first (typical big-endian binary unsigned\r",
							" * integer storage). So, for instance, if the length of a value was 257, the\r",
							" * first byte would be set to:\r",
							" *\r",
							" * 10000010 = 130 = 0x82.\r",
							" *\r",
							" * This indicates there are 2 octets (base 256) for the length. The second and\r",
							" * third bytes (the octets just mentioned) would store the length in base 256:\r",
							" *\r",
							" * octet 2: 00000001 = 1 * 256^1 = 256\r",
							" * octet 3: 00000001 = 1 * 256^0 = 1\r",
							" * total = 257\r",
							" *\r",
							" * The algorithm for converting a js integer value of 257 to base-256 is:\r",
							" *\r",
							" * var value = 257;\r",
							" * var bytes = [];\r",
							" * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first\r",
							" * bytes[1] = value & 0xFF;        // least significant byte last\r",
							" *\r",
							" * On the ASN.1 UNIVERSAL Object Identifier (OID) type:\r",
							" *\r",
							" * An OID can be written like: \"value1.value2.value3...valueN\"\r",
							" *\r",
							" * The DER encoding rules:\r",
							" *\r",
							" * The first byte has the value 40 * value1 + value2.\r",
							" * The following bytes, if any, encode the remaining values. Each value is\r",
							" * encoded in base 128, most significant digit first (big endian), with as\r",
							" * few digits as possible, and the most significant bit of each byte set\r",
							" * to 1 except the last in each value's encoding. For example: Given the\r",
							" * OID \"1.2.840.113549\", its DER encoding is (remember each byte except the\r",
							" * last one in each encoding is OR'd with 0x80):\r",
							" *\r",
							" * byte 1: 40 * 1 + 2 = 42 = 0x2A.\r",
							" * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648\r",
							" * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D\r",
							" *\r",
							" * The final value is: 0x2A864886F70D.\r",
							" * The full OID (including ASN.1 tag and length of 6 bytes) is:\r",
							" * 0x06062A864886F70D\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(6);\r",
							"\r",
							"/* ASN.1 API */\r",
							"var asn1 = module.exports = forge.asn1 = forge.asn1 || {};\r",
							"\r",
							"/**\r",
							" * ASN.1 classes.\r",
							" */\r",
							"asn1.Class = {\r",
							"  UNIVERSAL:        0x00,\r",
							"  APPLICATION:      0x40,\r",
							"  CONTEXT_SPECIFIC: 0x80,\r",
							"  PRIVATE:          0xC0\r",
							"};\r",
							"\r",
							"/**\r",
							" * ASN.1 types. Not all types are supported by this implementation, only\r",
							" * those necessary to implement a simple PKI are implemented.\r",
							" */\r",
							"asn1.Type = {\r",
							"  NONE:             0,\r",
							"  BOOLEAN:          1,\r",
							"  INTEGER:          2,\r",
							"  BITSTRING:        3,\r",
							"  OCTETSTRING:      4,\r",
							"  NULL:             5,\r",
							"  OID:              6,\r",
							"  ODESC:            7,\r",
							"  EXTERNAL:         8,\r",
							"  REAL:             9,\r",
							"  ENUMERATED:      10,\r",
							"  EMBEDDED:        11,\r",
							"  UTF8:            12,\r",
							"  ROID:            13,\r",
							"  SEQUENCE:        16,\r",
							"  SET:             17,\r",
							"  PRINTABLESTRING: 19,\r",
							"  IA5STRING:       22,\r",
							"  UTCTIME:         23,\r",
							"  GENERALIZEDTIME: 24,\r",
							"  BMPSTRING:       30\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new asn1 object.\r",
							" *\r",
							" * @param tagClass the tag class for the object.\r",
							" * @param type the data type (tag number) for the object.\r",
							" * @param constructed true if the asn1 object is in constructed form.\r",
							" * @param value the value for the object, if it is not constructed.\r",
							" * @param [options] the options to use:\r",
							" *          [bitStringContents] the plain BIT STRING content including padding\r",
							" *            byte.\r",
							" *\r",
							" * @return the asn1 object.\r",
							" */\r",
							"asn1.create = function(tagClass, type, constructed, value, options) {\r",
							"  /* An asn1 object has a tagClass, a type, a constructed flag, and a\r",
							"    value. The value's type depends on the constructed flag. If\r",
							"    constructed, it will contain a list of other asn1 objects. If not,\r",
							"    it will contain the ASN.1 value as an array of bytes formatted\r",
							"    according to the ASN.1 data type. */\r",
							"\r",
							"  // remove undefined values\r",
							"  if(forge.util.isArray(value)) {\r",
							"    var tmp = [];\r",
							"    for(var i = 0; i < value.length; ++i) {\r",
							"      if(value[i] !== undefined) {\r",
							"        tmp.push(value[i]);\r",
							"      }\r",
							"    }\r",
							"    value = tmp;\r",
							"  }\r",
							"\r",
							"  var obj = {\r",
							"    tagClass: tagClass,\r",
							"    type: type,\r",
							"    constructed: constructed,\r",
							"    composed: constructed || forge.util.isArray(value),\r",
							"    value: value\r",
							"  };\r",
							"  if(options && 'bitStringContents' in options) {\r",
							"    // TODO: copy byte buffer if it's a buffer not a string\r",
							"    obj.bitStringContents = options.bitStringContents;\r",
							"    // TODO: add readonly flag to avoid this overhead\r",
							"    // save copy to detect changes\r",
							"    obj.original = asn1.copy(obj);\r",
							"  }\r",
							"  return obj;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Copies an asn1 object.\r",
							" *\r",
							" * @param obj the asn1 object.\r",
							" * @param [options] copy options:\r",
							" *          [excludeBitStringContents] true to not copy bitStringContents\r",
							" *\r",
							" * @return the a copy of the asn1 object.\r",
							" */\r",
							"asn1.copy = function(obj, options) {\r",
							"  var copy;\r",
							"\r",
							"  if(forge.util.isArray(obj)) {\r",
							"    copy = [];\r",
							"    for(var i = 0; i < obj.length; ++i) {\r",
							"      copy.push(asn1.copy(obj[i], options));\r",
							"    }\r",
							"    return copy;\r",
							"  }\r",
							"\r",
							"  if(typeof obj === 'string') {\r",
							"    // TODO: copy byte buffer if it's a buffer not a string\r",
							"    return obj;\r",
							"  }\r",
							"\r",
							"  copy = {\r",
							"    tagClass: obj.tagClass,\r",
							"    type: obj.type,\r",
							"    constructed: obj.constructed,\r",
							"    composed: obj.composed,\r",
							"    value: asn1.copy(obj.value, options)\r",
							"  };\r",
							"  if(options && !options.excludeBitStringContents) {\r",
							"    // TODO: copy byte buffer if it's a buffer not a string\r",
							"    copy.bitStringContents = obj.bitStringContents;\r",
							"  }\r",
							"  return copy;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compares asn1 objects for equality.\r",
							" *\r",
							" * Note this function does not run in constant time.\r",
							" *\r",
							" * @param obj1 the first asn1 object.\r",
							" * @param obj2 the second asn1 object.\r",
							" * @param [options] compare options:\r",
							" *          [includeBitStringContents] true to compare bitStringContents\r",
							" *\r",
							" * @return true if the asn1 objects are equal.\r",
							" */\r",
							"asn1.equals = function(obj1, obj2, options) {\r",
							"  if(forge.util.isArray(obj1)) {\r",
							"    if(!forge.util.isArray(obj2)) {\r",
							"      return false;\r",
							"    }\r",
							"    if(obj1.length !== obj2.length) {\r",
							"      return false;\r",
							"    }\r",
							"    for(var i = 0; i < obj1.length; ++i) {\r",
							"      if(!asn1.equals(obj1[i], obj2[i])) {\r",
							"        return false;\r",
							"      }\r",
							"    }\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  if(typeof obj1 !== typeof obj2) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  if(typeof obj1 === 'string') {\r",
							"    return obj1 === obj2;\r",
							"  }\r",
							"\r",
							"  var equal = obj1.tagClass === obj2.tagClass &&\r",
							"    obj1.type === obj2.type &&\r",
							"    obj1.constructed === obj2.constructed &&\r",
							"    obj1.composed === obj2.composed &&\r",
							"    asn1.equals(obj1.value, obj2.value);\r",
							"  if(options && options.includeBitStringContents) {\r",
							"    equal = equal && (obj1.bitStringContents === obj2.bitStringContents);\r",
							"  }\r",
							"\r",
							"  return equal;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the length of a BER-encoded ASN.1 value.\r",
							" *\r",
							" * In case the length is not specified, undefined is returned.\r",
							" *\r",
							" * @param b the BER-encoded ASN.1 byte buffer, starting with the first\r",
							" *          length byte.\r",
							" *\r",
							" * @return the length of the BER-encoded ASN.1 value or undefined.\r",
							" */\r",
							"asn1.getBerValueLength = function(b) {\r",
							"  // TODO: move this function and related DER/BER functions to a der.js\r",
							"  // file; better abstract ASN.1 away from der/ber.\r",
							"  var b2 = b.getByte();\r",
							"  if(b2 === 0x80) {\r",
							"    return undefined;\r",
							"  }\r",
							"\r",
							"  // see if the length is \"short form\" or \"long form\" (bit 8 set)\r",
							"  var length;\r",
							"  var longForm = b2 & 0x80;\r",
							"  if(!longForm) {\r",
							"    // length is just the first byte\r",
							"    length = b2;\r",
							"  } else {\r",
							"    // the number of bytes the length is specified in bits 7 through 1\r",
							"    // and each length byte is in big-endian base-256\r",
							"    length = b.getInt((b2 & 0x7F) << 3);\r",
							"  }\r",
							"  return length;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Check if the byte buffer has enough bytes. Throws an Error if not.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param remaining the bytes remaining in the current parsing state.\r",
							" * @param n the number of bytes the buffer must have.\r",
							" */\r",
							"function _checkBufferLength(bytes, remaining, n) {\r",
							"  if(n > remaining) {\r",
							"    var error = new Error('Too few bytes to parse DER.');\r",
							"    error.available = bytes.length();\r",
							"    error.remaining = remaining;\r",
							"    error.requested = n;\r",
							"    throw error;\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Gets the length of a BER-encoded ASN.1 value.\r",
							" *\r",
							" * In case the length is not specified, undefined is returned.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param remaining the bytes remaining in the current parsing state.\r",
							" *\r",
							" * @return the length of the BER-encoded ASN.1 value or undefined.\r",
							" */\r",
							"var _getValueLength = function(bytes, remaining) {\r",
							"  // TODO: move this function and related DER/BER functions to a der.js\r",
							"  // file; better abstract ASN.1 away from der/ber.\r",
							"  // fromDer already checked that this byte exists\r",
							"  var b2 = bytes.getByte();\r",
							"  remaining--;\r",
							"  if(b2 === 0x80) {\r",
							"    return undefined;\r",
							"  }\r",
							"\r",
							"  // see if the length is \"short form\" or \"long form\" (bit 8 set)\r",
							"  var length;\r",
							"  var longForm = b2 & 0x80;\r",
							"  if(!longForm) {\r",
							"    // length is just the first byte\r",
							"    length = b2;\r",
							"  } else {\r",
							"    // the number of bytes the length is specified in bits 7 through 1\r",
							"    // and each length byte is in big-endian base-256\r",
							"    var longFormBytes = b2 & 0x7F;\r",
							"    _checkBufferLength(bytes, remaining, longFormBytes);\r",
							"    length = bytes.getInt(longFormBytes << 3);\r",
							"  }\r",
							"  // FIXME: this will only happen for 32 bit getInt with high bit set\r",
							"  if(length < 0) {\r",
							"    throw new Error('Negative length: ' + length);\r",
							"  }\r",
							"  return length;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses an asn1 object from a byte buffer in DER format.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param [strict] true to be strict when checking value lengths, false to\r",
							" *          allow truncated values (default: true).\r",
							" * @param [options] object with options or boolean strict flag\r",
							" *          [strict] true to be strict when checking value lengths, false to\r",
							" *            allow truncated values (default: true).\r",
							" *          [decodeBitStrings] true to attempt to decode the content of\r",
							" *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that\r",
							" *            without schema support to understand the data context this can\r",
							" *            erroneously decode values that happen to be valid ASN.1. This\r",
							" *            flag will be deprecated or removed as soon as schema support is\r",
							" *            available. (default: true)\r",
							" *\r",
							" * @return the parsed asn1 object.\r",
							" */\r",
							"asn1.fromDer = function(bytes, options) {\r",
							"  if(options === undefined) {\r",
							"    options = {\r",
							"      strict: true,\r",
							"      decodeBitStrings: true\r",
							"    };\r",
							"  }\r",
							"  if(typeof options === 'boolean') {\r",
							"    options = {\r",
							"      strict: options,\r",
							"      decodeBitStrings: true\r",
							"    };\r",
							"  }\r",
							"  if(!('strict' in options)) {\r",
							"    options.strict = true;\r",
							"  }\r",
							"  if(!('decodeBitStrings' in options)) {\r",
							"    options.decodeBitStrings = true;\r",
							"  }\r",
							"\r",
							"  // wrap in buffer if needed\r",
							"  if(typeof bytes === 'string') {\r",
							"    bytes = forge.util.createBuffer(bytes);\r",
							"  }\r",
							"\r",
							"  return _fromDer(bytes, bytes.length(), 0, options);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Internal function to parse an asn1 object from a byte buffer in DER format.\r",
							" *\r",
							" * @param bytes the byte buffer to parse from.\r",
							" * @param remaining the number of bytes remaining for this chunk.\r",
							" * @param depth the current parsing depth.\r",
							" * @param options object with same options as fromDer().\r",
							" *\r",
							" * @return the parsed asn1 object.\r",
							" */\r",
							"function _fromDer(bytes, remaining, depth, options) {\r",
							"  // temporary storage for consumption calculations\r",
							"  var start;\r",
							"\r",
							"  // minimum length for ASN.1 DER structure is 2\r",
							"  _checkBufferLength(bytes, remaining, 2);\r",
							"\r",
							"  // get the first byte\r",
							"  var b1 = bytes.getByte();\r",
							"  // consumed one byte\r",
							"  remaining--;\r",
							"\r",
							"  // get the tag class\r",
							"  var tagClass = (b1 & 0xC0);\r",
							"\r",
							"  // get the type (bits 1-5)\r",
							"  var type = b1 & 0x1F;\r",
							"\r",
							"  // get the variable value length and adjust remaining bytes\r",
							"  start = bytes.length();\r",
							"  var length = _getValueLength(bytes, remaining);\r",
							"  remaining -= start - bytes.length();\r",
							"\r",
							"  // ensure there are enough bytes to get the value\r",
							"  if(length !== undefined && length > remaining) {\r",
							"    if(options.strict) {\r",
							"      var error = new Error('Too few bytes to read ASN.1 value.');\r",
							"      error.available = bytes.length();\r",
							"      error.remaining = remaining;\r",
							"      error.requested = length;\r",
							"      throw error;\r",
							"    }\r",
							"    // Note: be lenient with truncated values and use remaining state bytes\r",
							"    length = remaining;\r",
							"  }\r",
							"\r",
							"  // value storage\r",
							"  var value;\r",
							"  // possible BIT STRING contents storage\r",
							"  var bitStringContents;\r",
							"\r",
							"  // constructed flag is bit 6 (32 = 0x20) of the first byte\r",
							"  var constructed = ((b1 & 0x20) === 0x20);\r",
							"  if(constructed) {\r",
							"    // parse child asn1 objects from the value\r",
							"    value = [];\r",
							"    if(length === undefined) {\r",
							"      // asn1 object of indefinite length, read until end tag\r",
							"      for(;;) {\r",
							"        _checkBufferLength(bytes, remaining, 2);\r",
							"        if(bytes.bytes(2) === String.fromCharCode(0, 0)) {\r",
							"          bytes.getBytes(2);\r",
							"          remaining -= 2;\r",
							"          break;\r",
							"        }\r",
							"        start = bytes.length();\r",
							"        value.push(_fromDer(bytes, remaining, depth + 1, options));\r",
							"        remaining -= start - bytes.length();\r",
							"      }\r",
							"    } else {\r",
							"      // parsing asn1 object of definite length\r",
							"      while(length > 0) {\r",
							"        start = bytes.length();\r",
							"        value.push(_fromDer(bytes, length, depth + 1, options));\r",
							"        remaining -= start - bytes.length();\r",
							"        length -= start - bytes.length();\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // if a BIT STRING, save the contents including padding\r",
							"  if(value === undefined && tagClass === asn1.Class.UNIVERSAL &&\r",
							"    type === asn1.Type.BITSTRING) {\r",
							"    bitStringContents = bytes.bytes(length);\r",
							"  }\r",
							"\r",
							"  // determine if a non-constructed value should be decoded as a composed\r",
							"  // value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)\r",
							"  // can be used this way.\r",
							"  if(value === undefined && options.decodeBitStrings &&\r",
							"    tagClass === asn1.Class.UNIVERSAL &&\r",
							"    // FIXME: OCTET STRINGs not yet supported here\r",
							"    // .. other parts of forge expect to decode OCTET STRINGs manually\r",
							"    (type === asn1.Type.BITSTRING /*|| type === asn1.Type.OCTETSTRING*/) &&\r",
							"    length > 1) {\r",
							"    // save read position\r",
							"    var savedRead = bytes.read;\r",
							"    var savedRemaining = remaining;\r",
							"    var unused = 0;\r",
							"    if(type === asn1.Type.BITSTRING) {\r",
							"      /* The first octet gives the number of bits by which the length of the\r",
							"        bit string is less than the next multiple of eight (this is called\r",
							"        the \"number of unused bits\").\r",
							"\r",
							"        The second and following octets give the value of the bit string\r",
							"        converted to an octet string. */\r",
							"      _checkBufferLength(bytes, remaining, 1);\r",
							"      unused = bytes.getByte();\r",
							"      remaining--;\r",
							"    }\r",
							"    // if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs\r",
							"    if(unused === 0) {\r",
							"      try {\r",
							"        // attempt to parse child asn1 object from the value\r",
							"        // (stored in array to signal composed value)\r",
							"        start = bytes.length();\r",
							"        var subOptions = {\r",
							"          // enforce strict mode to avoid parsing ASN.1 from plain data\r",
							"          verbose: options.verbose,\r",
							"          strict: true,\r",
							"          decodeBitStrings: true\r",
							"        };\r",
							"        var composed = _fromDer(bytes, remaining, depth + 1, subOptions);\r",
							"        var used = start - bytes.length();\r",
							"        remaining -= used;\r",
							"        if(type == asn1.Type.BITSTRING) {\r",
							"          used++;\r",
							"        }\r",
							"\r",
							"        // if the data all decoded and the class indicates UNIVERSAL or\r",
							"        // CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object\r",
							"        var tc = composed.tagClass;\r",
							"        if(used === length &&\r",
							"          (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {\r",
							"          value = [composed];\r",
							"        }\r",
							"      } catch(ex) {\r",
							"      }\r",
							"    }\r",
							"    if(value === undefined) {\r",
							"      // restore read position\r",
							"      bytes.read = savedRead;\r",
							"      remaining = savedRemaining;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(value === undefined) {\r",
							"    // asn1 not constructed or composed, get raw value\r",
							"    // TODO: do DER to OID conversion and vice-versa in .toDer?\r",
							"\r",
							"    if(length === undefined) {\r",
							"      if(options.strict) {\r",
							"        throw new Error('Non-constructed ASN.1 object of indefinite length.');\r",
							"      }\r",
							"      // be lenient and use remaining state bytes\r",
							"      length = remaining;\r",
							"    }\r",
							"\r",
							"    if(type === asn1.Type.BMPSTRING) {\r",
							"      value = '';\r",
							"      for(; length > 0; length -= 2) {\r",
							"        _checkBufferLength(bytes, remaining, 2);\r",
							"        value += String.fromCharCode(bytes.getInt16());\r",
							"        remaining -= 2;\r",
							"      }\r",
							"    } else {\r",
							"      value = bytes.getBytes(length);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // add BIT STRING contents if available\r",
							"  var asn1Options = bitStringContents === undefined ?  null : {\r",
							"    bitStringContents: bitStringContents\r",
							"  };\r",
							"\r",
							"  // create and return asn1 object\r",
							"  return asn1.create(tagClass, type, constructed, value, asn1Options);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts the given asn1 object to a buffer of bytes in DER format.\r",
							" *\r",
							" * @param asn1 the asn1 object to convert to bytes.\r",
							" *\r",
							" * @return the buffer of bytes.\r",
							" */\r",
							"asn1.toDer = function(obj) {\r",
							"  var bytes = forge.util.createBuffer();\r",
							"\r",
							"  // build the first byte\r",
							"  var b1 = obj.tagClass | obj.type;\r",
							"\r",
							"  // for storing the ASN.1 value\r",
							"  var value = forge.util.createBuffer();\r",
							"\r",
							"  // use BIT STRING contents if available and data not changed\r",
							"  var useBitStringContents = false;\r",
							"  if('bitStringContents' in obj) {\r",
							"    useBitStringContents = true;\r",
							"    if(obj.original) {\r",
							"      useBitStringContents = asn1.equals(obj, obj.original);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(useBitStringContents) {\r",
							"    value.putBytes(obj.bitStringContents);\r",
							"  } else if(obj.composed) {\r",
							"    // if composed, use each child asn1 object's DER bytes as value\r",
							"    // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed\r",
							"    // from other asn1 objects\r",
							"    if(obj.constructed) {\r",
							"      b1 |= 0x20;\r",
							"    } else {\r",
							"      // type is a bit string, add unused bits of 0x00\r",
							"      value.putByte(0x00);\r",
							"    }\r",
							"\r",
							"    // add all of the child DER bytes together\r",
							"    for(var i = 0; i < obj.value.length; ++i) {\r",
							"      if(obj.value[i] !== undefined) {\r",
							"        value.putBuffer(asn1.toDer(obj.value[i]));\r",
							"      }\r",
							"    }\r",
							"  } else {\r",
							"    // use asn1.value directly\r",
							"    if(obj.type === asn1.Type.BMPSTRING) {\r",
							"      for(var i = 0; i < obj.value.length; ++i) {\r",
							"        value.putInt16(obj.value.charCodeAt(i));\r",
							"      }\r",
							"    } else {\r",
							"      // ensure integer is minimally-encoded\r",
							"      // TODO: should all leading bytes be stripped vs just one?\r",
							"      // .. ex '00 00 01' => '01'?\r",
							"      if(obj.type === asn1.Type.INTEGER &&\r",
							"        obj.value.length > 1 &&\r",
							"        // leading 0x00 for positive integer\r",
							"        ((obj.value.charCodeAt(0) === 0 &&\r",
							"        (obj.value.charCodeAt(1) & 0x80) === 0) ||\r",
							"        // leading 0xFF for negative integer\r",
							"        (obj.value.charCodeAt(0) === 0xFF &&\r",
							"        (obj.value.charCodeAt(1) & 0x80) === 0x80))) {\r",
							"        value.putBytes(obj.value.substr(1));\r",
							"      } else {\r",
							"        value.putBytes(obj.value);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // add tag byte\r",
							"  bytes.putByte(b1);\r",
							"\r",
							"  // use \"short form\" encoding\r",
							"  if(value.length() <= 127) {\r",
							"    // one byte describes the length\r",
							"    // bit 8 = 0 and bits 7-1 = length\r",
							"    bytes.putByte(value.length() & 0x7F);\r",
							"  } else {\r",
							"    // use \"long form\" encoding\r",
							"    // 2 to 127 bytes describe the length\r",
							"    // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes\r",
							"    // other bytes: length in base 256, big-endian\r",
							"    var len = value.length();\r",
							"    var lenBytes = '';\r",
							"    do {\r",
							"      lenBytes += String.fromCharCode(len & 0xFF);\r",
							"      len = len >>> 8;\r",
							"    } while(len > 0);\r",
							"\r",
							"    // set first byte to # bytes used to store the length and turn on\r",
							"    // bit 8 to indicate long-form length is used\r",
							"    bytes.putByte(lenBytes.length | 0x80);\r",
							"\r",
							"    // concatenate length bytes in reverse since they were generated\r",
							"    // little endian and we need big endian\r",
							"    for(var i = lenBytes.length - 1; i >= 0; --i) {\r",
							"      bytes.putByte(lenBytes.charCodeAt(i));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // concatenate value bytes\r",
							"  bytes.putBuffer(value);\r",
							"  return bytes;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an OID dot-separated string to a byte buffer. The byte buffer\r",
							" * contains only the DER-encoded value, not any tag or length bytes.\r",
							" *\r",
							" * @param oid the OID dot-separated string.\r",
							" *\r",
							" * @return the byte buffer.\r",
							" */\r",
							"asn1.oidToDer = function(oid) {\r",
							"  // split OID into individual values\r",
							"  var values = oid.split('.');\r",
							"  var bytes = forge.util.createBuffer();\r",
							"\r",
							"  // first byte is 40 * value1 + value2\r",
							"  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));\r",
							"  // other bytes are each value in base 128 with 8th bit set except for\r",
							"  // the last byte for each value\r",
							"  var last, valueBytes, value, b;\r",
							"  for(var i = 2; i < values.length; ++i) {\r",
							"    // produce value bytes in reverse because we don't know how many\r",
							"    // bytes it will take to store the value\r",
							"    last = true;\r",
							"    valueBytes = [];\r",
							"    value = parseInt(values[i], 10);\r",
							"    do {\r",
							"      b = value & 0x7F;\r",
							"      value = value >>> 7;\r",
							"      // if value is not last, then turn on 8th bit\r",
							"      if(!last) {\r",
							"        b |= 0x80;\r",
							"      }\r",
							"      valueBytes.push(b);\r",
							"      last = false;\r",
							"    } while(value > 0);\r",
							"\r",
							"    // add value bytes in reverse (needs to be in big endian)\r",
							"    for(var n = valueBytes.length - 1; n >= 0; --n) {\r",
							"      bytes.putByte(valueBytes[n]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return bytes;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a DER-encoded byte buffer to an OID dot-separated string. The\r",
							" * byte buffer should contain only the DER-encoded value, not any tag or\r",
							" * length bytes.\r",
							" *\r",
							" * @param bytes the byte buffer.\r",
							" *\r",
							" * @return the OID dot-separated string.\r",
							" */\r",
							"asn1.derToOid = function(bytes) {\r",
							"  var oid;\r",
							"\r",
							"  // wrap in buffer if needed\r",
							"  if(typeof bytes === 'string') {\r",
							"    bytes = forge.util.createBuffer(bytes);\r",
							"  }\r",
							"\r",
							"  // first byte is 40 * value1 + value2\r",
							"  var b = bytes.getByte();\r",
							"  oid = Math.floor(b / 40) + '.' + (b % 40);\r",
							"\r",
							"  // other bytes are each value in base 128 with 8th bit set except for\r",
							"  // the last byte for each value\r",
							"  var value = 0;\r",
							"  while(bytes.length() > 0) {\r",
							"    b = bytes.getByte();\r",
							"    value = value << 7;\r",
							"    // not the last byte for the value\r",
							"    if(b & 0x80) {\r",
							"      value += b & 0x7F;\r",
							"    } else {\r",
							"      // last byte\r",
							"      oid += '.' + (value + b);\r",
							"      value = 0;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return oid;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a UTCTime value to a date.\r",
							" *\r",
							" * Note: GeneralizedTime has 4 digits for the year and is used for X.509\r",
							" * dates past 2049. Parsing that structure hasn't been implemented yet.\r",
							" *\r",
							" * @param utc the UTCTime value to convert.\r",
							" *\r",
							" * @return the date.\r",
							" */\r",
							"asn1.utcTimeToDate = function(utc) {\r",
							"  /* The following formats can be used:\r",
							"\r",
							"    YYMMDDhhmmZ\r",
							"    YYMMDDhhmm+hh'mm'\r",
							"    YYMMDDhhmm-hh'mm'\r",
							"    YYMMDDhhmmssZ\r",
							"    YYMMDDhhmmss+hh'mm'\r",
							"    YYMMDDhhmmss-hh'mm'\r",
							"\r",
							"    Where:\r",
							"\r",
							"    YY is the least significant two digits of the year\r",
							"    MM is the month (01 to 12)\r",
							"    DD is the day (01 to 31)\r",
							"    hh is the hour (00 to 23)\r",
							"    mm are the minutes (00 to 59)\r",
							"    ss are the seconds (00 to 59)\r",
							"    Z indicates that local time is GMT, + indicates that local time is\r",
							"    later than GMT, and - indicates that local time is earlier than GMT\r",
							"    hh' is the absolute value of the offset from GMT in hours\r",
							"    mm' is the absolute value of the offset from GMT in minutes */\r",
							"  var date = new Date();\r",
							"\r",
							"  // if YY >= 50 use 19xx, if YY < 50 use 20xx\r",
							"  var year = parseInt(utc.substr(0, 2), 10);\r",
							"  year = (year >= 50) ? 1900 + year : 2000 + year;\r",
							"  var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month\r",
							"  var DD = parseInt(utc.substr(4, 2), 10);\r",
							"  var hh = parseInt(utc.substr(6, 2), 10);\r",
							"  var mm = parseInt(utc.substr(8, 2), 10);\r",
							"  var ss = 0;\r",
							"\r",
							"  // not just YYMMDDhhmmZ\r",
							"  if(utc.length > 11) {\r",
							"    // get character after minutes\r",
							"    var c = utc.charAt(10);\r",
							"    var end = 10;\r",
							"\r",
							"    // see if seconds are present\r",
							"    if(c !== '+' && c !== '-') {\r",
							"      // get seconds\r",
							"      ss = parseInt(utc.substr(10, 2), 10);\r",
							"      end += 2;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // update date\r",
							"  date.setUTCFullYear(year, MM, DD);\r",
							"  date.setUTCHours(hh, mm, ss, 0);\r",
							"\r",
							"  if(end) {\r",
							"    // get +/- after end of time\r",
							"    c = utc.charAt(end);\r",
							"    if(c === '+' || c === '-') {\r",
							"      // get hours+minutes offset\r",
							"      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);\r",
							"      var mmoffset = parseInt(utc.substr(end + 4, 2), 10);\r",
							"\r",
							"      // calculate offset in milliseconds\r",
							"      var offset = hhoffset * 60 + mmoffset;\r",
							"      offset *= 60000;\r",
							"\r",
							"      // apply offset\r",
							"      if(c === '+') {\r",
							"        date.setTime(+date - offset);\r",
							"      } else {\r",
							"        date.setTime(+date + offset);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return date;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a GeneralizedTime value to a date.\r",
							" *\r",
							" * @param gentime the GeneralizedTime value to convert.\r",
							" *\r",
							" * @return the date.\r",
							" */\r",
							"asn1.generalizedTimeToDate = function(gentime) {\r",
							"  /* The following formats can be used:\r",
							"\r",
							"    YYYYMMDDHHMMSS\r",
							"    YYYYMMDDHHMMSS.fff\r",
							"    YYYYMMDDHHMMSSZ\r",
							"    YYYYMMDDHHMMSS.fffZ\r",
							"    YYYYMMDDHHMMSS+hh'mm'\r",
							"    YYYYMMDDHHMMSS.fff+hh'mm'\r",
							"    YYYYMMDDHHMMSS-hh'mm'\r",
							"    YYYYMMDDHHMMSS.fff-hh'mm'\r",
							"\r",
							"    Where:\r",
							"\r",
							"    YYYY is the year\r",
							"    MM is the month (01 to 12)\r",
							"    DD is the day (01 to 31)\r",
							"    hh is the hour (00 to 23)\r",
							"    mm are the minutes (00 to 59)\r",
							"    ss are the seconds (00 to 59)\r",
							"    .fff is the second fraction, accurate to three decimal places\r",
							"    Z indicates that local time is GMT, + indicates that local time is\r",
							"    later than GMT, and - indicates that local time is earlier than GMT\r",
							"    hh' is the absolute value of the offset from GMT in hours\r",
							"    mm' is the absolute value of the offset from GMT in minutes */\r",
							"  var date = new Date();\r",
							"\r",
							"  var YYYY = parseInt(gentime.substr(0, 4), 10);\r",
							"  var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month\r",
							"  var DD = parseInt(gentime.substr(6, 2), 10);\r",
							"  var hh = parseInt(gentime.substr(8, 2), 10);\r",
							"  var mm = parseInt(gentime.substr(10, 2), 10);\r",
							"  var ss = parseInt(gentime.substr(12, 2), 10);\r",
							"  var fff = 0;\r",
							"  var offset = 0;\r",
							"  var isUTC = false;\r",
							"\r",
							"  if(gentime.charAt(gentime.length - 1) === 'Z') {\r",
							"    isUTC = true;\r",
							"  }\r",
							"\r",
							"  var end = gentime.length - 5, c = gentime.charAt(end);\r",
							"  if(c === '+' || c === '-') {\r",
							"    // get hours+minutes offset\r",
							"    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);\r",
							"    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);\r",
							"\r",
							"    // calculate offset in milliseconds\r",
							"    offset = hhoffset * 60 + mmoffset;\r",
							"    offset *= 60000;\r",
							"\r",
							"    // apply offset\r",
							"    if(c === '+') {\r",
							"      offset *= -1;\r",
							"    }\r",
							"\r",
							"    isUTC = true;\r",
							"  }\r",
							"\r",
							"  // check for second fraction\r",
							"  if(gentime.charAt(14) === '.') {\r",
							"    fff = parseFloat(gentime.substr(14), 10) * 1000;\r",
							"  }\r",
							"\r",
							"  if(isUTC) {\r",
							"    date.setUTCFullYear(YYYY, MM, DD);\r",
							"    date.setUTCHours(hh, mm, ss, fff);\r",
							"\r",
							"    // apply offset\r",
							"    date.setTime(+date + offset);\r",
							"  } else {\r",
							"    date.setFullYear(YYYY, MM, DD);\r",
							"    date.setHours(hh, mm, ss, fff);\r",
							"  }\r",
							"\r",
							"  return date;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a date to a UTCTime value.\r",
							" *\r",
							" * Note: GeneralizedTime has 4 digits for the year and is used for X.509\r",
							" * dates past 2049. Converting to a GeneralizedTime hasn't been\r",
							" * implemented yet.\r",
							" *\r",
							" * @param date the date to convert.\r",
							" *\r",
							" * @return the UTCTime value.\r",
							" */\r",
							"asn1.dateToUtcTime = function(date) {\r",
							"  // TODO: validate; currently assumes proper format\r",
							"  if(typeof date === 'string') {\r",
							"    return date;\r",
							"  }\r",
							"\r",
							"  var rval = '';\r",
							"\r",
							"  // create format YYMMDDhhmmssZ\r",
							"  var format = [];\r",
							"  format.push(('' + date.getUTCFullYear()).substr(2));\r",
							"  format.push('' + (date.getUTCMonth() + 1));\r",
							"  format.push('' + date.getUTCDate());\r",
							"  format.push('' + date.getUTCHours());\r",
							"  format.push('' + date.getUTCMinutes());\r",
							"  format.push('' + date.getUTCSeconds());\r",
							"\r",
							"  // ensure 2 digits are used for each format entry\r",
							"  for(var i = 0; i < format.length; ++i) {\r",
							"    if(format[i].length < 2) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += format[i];\r",
							"  }\r",
							"  rval += 'Z';\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a date to a GeneralizedTime value.\r",
							" *\r",
							" * @param date the date to convert.\r",
							" *\r",
							" * @return the GeneralizedTime value as a string.\r",
							" */\r",
							"asn1.dateToGeneralizedTime = function(date) {\r",
							"  // TODO: validate; currently assumes proper format\r",
							"  if(typeof date === 'string') {\r",
							"    return date;\r",
							"  }\r",
							"\r",
							"  var rval = '';\r",
							"\r",
							"  // create format YYYYMMDDHHMMSSZ\r",
							"  var format = [];\r",
							"  format.push('' + date.getUTCFullYear());\r",
							"  format.push('' + (date.getUTCMonth() + 1));\r",
							"  format.push('' + date.getUTCDate());\r",
							"  format.push('' + date.getUTCHours());\r",
							"  format.push('' + date.getUTCMinutes());\r",
							"  format.push('' + date.getUTCSeconds());\r",
							"\r",
							"  // ensure 2 digits are used for each format entry\r",
							"  for(var i = 0; i < format.length; ++i) {\r",
							"    if(format[i].length < 2) {\r",
							"      rval += '0';\r",
							"    }\r",
							"    rval += format[i];\r",
							"  }\r",
							"  rval += 'Z';\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a javascript integer to a DER-encoded byte buffer to be used\r",
							" * as the value for an INTEGER type.\r",
							" *\r",
							" * @param x the integer.\r",
							" *\r",
							" * @return the byte buffer.\r",
							" */\r",
							"asn1.integerToDer = function(x) {\r",
							"  var rval = forge.util.createBuffer();\r",
							"  if(x >= -0x80 && x < 0x80) {\r",
							"    return rval.putSignedInt(x, 8);\r",
							"  }\r",
							"  if(x >= -0x8000 && x < 0x8000) {\r",
							"    return rval.putSignedInt(x, 16);\r",
							"  }\r",
							"  if(x >= -0x800000 && x < 0x800000) {\r",
							"    return rval.putSignedInt(x, 24);\r",
							"  }\r",
							"  if(x >= -0x80000000 && x < 0x80000000) {\r",
							"    return rval.putSignedInt(x, 32);\r",
							"  }\r",
							"  var error = new Error('Integer too large; max is 32-bits.');\r",
							"  error.integer = x;\r",
							"  throw error;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a DER-encoded byte buffer to a javascript integer. This is\r",
							" * typically used to decode the value of an INTEGER type.\r",
							" *\r",
							" * @param bytes the byte buffer.\r",
							" *\r",
							" * @return the integer.\r",
							" */\r",
							"asn1.derToInteger = function(bytes) {\r",
							"  // wrap in buffer if needed\r",
							"  if(typeof bytes === 'string') {\r",
							"    bytes = forge.util.createBuffer(bytes);\r",
							"  }\r",
							"\r",
							"  var n = bytes.length() * 8;\r",
							"  if(n > 32) {\r",
							"    throw new Error('Integer too large; max is 32-bits.');\r",
							"  }\r",
							"  return bytes.getSignedInt(n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Validates that the given ASN.1 object is at least a super set of the\r",
							" * given ASN.1 structure. Only tag classes and types are checked. An\r",
							" * optional map may also be provided to capture ASN.1 values while the\r",
							" * structure is checked.\r",
							" *\r",
							" * To capture an ASN.1 value, set an object in the validator's 'capture'\r",
							" * parameter to the key to use in the capture map. To capture the full\r",
							" * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including\r",
							" * the leading unused bits counter byte, specify 'captureBitStringContents'.\r",
							" * To capture BIT STRING bytes, without the leading unused bits counter byte,\r",
							" * specify 'captureBitStringValue'.\r",
							" *\r",
							" * Objects in the validator may set a field 'optional' to true to indicate\r",
							" * that it isn't necessary to pass validation.\r",
							" *\r",
							" * @param obj the ASN.1 object to validate.\r",
							" * @param v the ASN.1 structure validator.\r",
							" * @param capture an optional map to capture values in.\r",
							" * @param errors an optional array for storing validation errors.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"asn1.validate = function(obj, v, capture, errors) {\r",
							"  var rval = false;\r",
							"\r",
							"  // ensure tag class and type are the same if specified\r",
							"  if((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') &&\r",
							"    (obj.type === v.type || typeof(v.type) === 'undefined')) {\r",
							"    // ensure constructed flag is the same if specified\r",
							"    if(obj.constructed === v.constructed ||\r",
							"      typeof(v.constructed) === 'undefined') {\r",
							"      rval = true;\r",
							"\r",
							"      // handle sub values\r",
							"      if(v.value && forge.util.isArray(v.value)) {\r",
							"        var j = 0;\r",
							"        for(var i = 0; rval && i < v.value.length; ++i) {\r",
							"          rval = v.value[i].optional || false;\r",
							"          if(obj.value[j]) {\r",
							"            rval = asn1.validate(obj.value[j], v.value[i], capture, errors);\r",
							"            if(rval) {\r",
							"              ++j;\r",
							"            } else if(v.value[i].optional) {\r",
							"              rval = true;\r",
							"            }\r",
							"          }\r",
							"          if(!rval && errors) {\r",
							"            errors.push(\r",
							"              '[' + v.name + '] ' +\r",
							"              'Tag class \"' + v.tagClass + '\", type \"' +\r",
							"              v.type + '\" expected value length \"' +\r",
							"              v.value.length + '\", got \"' +\r",
							"              obj.value.length + '\"');\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(rval && capture) {\r",
							"        if(v.capture) {\r",
							"          capture[v.capture] = obj.value;\r",
							"        }\r",
							"        if(v.captureAsn1) {\r",
							"          capture[v.captureAsn1] = obj;\r",
							"        }\r",
							"        if(v.captureBitStringContents && 'bitStringContents' in obj) {\r",
							"          capture[v.captureBitStringContents] = obj.bitStringContents;\r",
							"        }\r",
							"        if(v.captureBitStringValue && 'bitStringContents' in obj) {\r",
							"          var value;\r",
							"          if(obj.bitStringContents.length < 2) {\r",
							"            capture[v.captureBitStringValue] = '';\r",
							"          } else {\r",
							"            // FIXME: support unused bits with data shifting\r",
							"            var unused = obj.bitStringContents.charCodeAt(0);\r",
							"            if(unused !== 0) {\r",
							"              throw new Error(\r",
							"                'captureBitStringValue only supported for zero unused bits');\r",
							"            }\r",
							"            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    } else if(errors) {\r",
							"      errors.push(\r",
							"        '[' + v.name + '] ' +\r",
							"        'Expected constructed \"' + v.constructed + '\", got \"' +\r",
							"        obj.constructed + '\"');\r",
							"    }\r",
							"  } else if(errors) {\r",
							"    if(obj.tagClass !== v.tagClass) {\r",
							"      errors.push(\r",
							"        '[' + v.name + '] ' +\r",
							"        'Expected tag class \"' + v.tagClass + '\", got \"' +\r",
							"        obj.tagClass + '\"');\r",
							"    }\r",
							"    if(obj.type !== v.type) {\r",
							"      errors.push(\r",
							"        '[' + v.name + '] ' +\r",
							"        'Expected type \"' + v.type + '\", got \"' + obj.type + '\"');\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"// regex for testing for non-latin characters\r",
							"var _nonLatinRegex = /[^\\\\u0000-\\\\u00ff]/;\r",
							"\r",
							"/**\r",
							" * Pretty prints an ASN.1 object to a string.\r",
							" *\r",
							" * @param obj the object to write out.\r",
							" * @param level the level in the tree.\r",
							" * @param indentation the indentation to use.\r",
							" *\r",
							" * @return the string.\r",
							" */\r",
							"asn1.prettyPrint = function(obj, level, indentation) {\r",
							"  var rval = '';\r",
							"\r",
							"  // set default level and indentation\r",
							"  level = level || 0;\r",
							"  indentation = indentation || 2;\r",
							"\r",
							"  // start new line for deep levels\r",
							"  if(level > 0) {\r",
							"    rval += '\\n';\r",
							"  }\r",
							"\r",
							"  // create indent\r",
							"  var indent = '';\r",
							"  for(var i = 0; i < level * indentation; ++i) {\r",
							"    indent += ' ';\r",
							"  }\r",
							"\r",
							"  // print class:type\r",
							"  rval += indent + 'Tag: ';\r",
							"  switch(obj.tagClass) {\r",
							"  case asn1.Class.UNIVERSAL:\r",
							"    rval += 'Universal:';\r",
							"    break;\r",
							"  case asn1.Class.APPLICATION:\r",
							"    rval += 'Application:';\r",
							"    break;\r",
							"  case asn1.Class.CONTEXT_SPECIFIC:\r",
							"    rval += 'Context-Specific:';\r",
							"    break;\r",
							"  case asn1.Class.PRIVATE:\r",
							"    rval += 'Private:';\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  if(obj.tagClass === asn1.Class.UNIVERSAL) {\r",
							"    rval += obj.type;\r",
							"\r",
							"    // known types\r",
							"    switch(obj.type) {\r",
							"    case asn1.Type.NONE:\r",
							"      rval += ' (None)';\r",
							"      break;\r",
							"    case asn1.Type.BOOLEAN:\r",
							"      rval += ' (Boolean)';\r",
							"      break;\r",
							"    case asn1.Type.INTEGER:\r",
							"      rval += ' (Integer)';\r",
							"      break;\r",
							"    case asn1.Type.BITSTRING:\r",
							"      rval += ' (Bit string)';\r",
							"      break;\r",
							"    case asn1.Type.OCTETSTRING:\r",
							"      rval += ' (Octet string)';\r",
							"      break;\r",
							"    case asn1.Type.NULL:\r",
							"      rval += ' (Null)';\r",
							"      break;\r",
							"    case asn1.Type.OID:\r",
							"      rval += ' (Object Identifier)';\r",
							"      break;\r",
							"    case asn1.Type.ODESC:\r",
							"      rval += ' (Object Descriptor)';\r",
							"      break;\r",
							"    case asn1.Type.EXTERNAL:\r",
							"      rval += ' (External or Instance of)';\r",
							"      break;\r",
							"    case asn1.Type.REAL:\r",
							"      rval += ' (Real)';\r",
							"      break;\r",
							"    case asn1.Type.ENUMERATED:\r",
							"      rval += ' (Enumerated)';\r",
							"      break;\r",
							"    case asn1.Type.EMBEDDED:\r",
							"      rval += ' (Embedded PDV)';\r",
							"      break;\r",
							"    case asn1.Type.UTF8:\r",
							"      rval += ' (UTF8)';\r",
							"      break;\r",
							"    case asn1.Type.ROID:\r",
							"      rval += ' (Relative Object Identifier)';\r",
							"      break;\r",
							"    case asn1.Type.SEQUENCE:\r",
							"      rval += ' (Sequence)';\r",
							"      break;\r",
							"    case asn1.Type.SET:\r",
							"      rval += ' (Set)';\r",
							"      break;\r",
							"    case asn1.Type.PRINTABLESTRING:\r",
							"      rval += ' (Printable String)';\r",
							"      break;\r",
							"    case asn1.Type.IA5String:\r",
							"      rval += ' (IA5String (ASCII))';\r",
							"      break;\r",
							"    case asn1.Type.UTCTIME:\r",
							"      rval += ' (UTC time)';\r",
							"      break;\r",
							"    case asn1.Type.GENERALIZEDTIME:\r",
							"      rval += ' (Generalized time)';\r",
							"      break;\r",
							"    case asn1.Type.BMPSTRING:\r",
							"      rval += ' (BMP String)';\r",
							"      break;\r",
							"    }\r",
							"  } else {\r",
							"    rval += obj.type;\r",
							"  }\r",
							"\r",
							"  rval += '\\n';\r",
							"  rval += indent + 'Constructed: ' + obj.constructed + '\\n';\r",
							"\r",
							"  if(obj.composed) {\r",
							"    var subvalues = 0;\r",
							"    var sub = '';\r",
							"    for(var i = 0; i < obj.value.length; ++i) {\r",
							"      if(obj.value[i] !== undefined) {\r",
							"        subvalues += 1;\r",
							"        sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);\r",
							"        if((i + 1) < obj.value.length) {\r",
							"          sub += ',';\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    rval += indent + 'Sub values: ' + subvalues + sub;\r",
							"  } else {\r",
							"    rval += indent + 'Value: ';\r",
							"    if(obj.type === asn1.Type.OID) {\r",
							"      var oid = asn1.derToOid(obj.value);\r",
							"      rval += oid;\r",
							"      if(forge.pki && forge.pki.oids) {\r",
							"        if(oid in forge.pki.oids) {\r",
							"          rval += ' (' + forge.pki.oids[oid] + ') ';\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    if(obj.type === asn1.Type.INTEGER) {\r",
							"      try {\r",
							"        rval += asn1.derToInteger(obj.value);\r",
							"      } catch(ex) {\r",
							"        rval += '0x' + forge.util.bytesToHex(obj.value);\r",
							"      }\r",
							"    } else if(obj.type === asn1.Type.BITSTRING) {\r",
							"      // TODO: shift bits as needed to display without padding\r",
							"      if(obj.value.length > 1) {\r",
							"        // remove unused bits field\r",
							"        rval += '0x' + forge.util.bytesToHex(obj.value.slice(1));\r",
							"      } else {\r",
							"        rval += '(none)';\r",
							"      }\r",
							"      // show unused bit count\r",
							"      if(obj.value.length > 0) {\r",
							"        var unused = obj.value.charCodeAt(0);\r",
							"        if(unused == 1) {\r",
							"          rval += ' (1 unused bit shown)';\r",
							"        } else if(unused > 1) {\r",
							"          rval += ' (' + unused + ' unused bits shown)';\r",
							"        }\r",
							"      }\r",
							"    } else if(obj.type === asn1.Type.OCTETSTRING) {\r",
							"      if(!_nonLatinRegex.test(obj.value)) {\r",
							"        rval += '(' + obj.value + ') ';\r",
							"      }\r",
							"      rval += '0x' + forge.util.bytesToHex(obj.value);\r",
							"    } else if(obj.type === asn1.Type.UTF8) {\r",
							"      rval += forge.util.decodeUtf8(obj.value);\r",
							"    } else if(obj.type === asn1.Type.PRINTABLESTRING ||\r",
							"      obj.type === asn1.Type.IA5String) {\r",
							"      rval += obj.value;\r",
							"    } else if(_nonLatinRegex.test(obj.value)) {\r",
							"      rval += '0x' + forge.util.bytesToHex(obj.value);\r",
							"    } else if(obj.value.length === 0) {\r",
							"      rval += '[null]';\r",
							"    } else {\r",
							"      rval += obj.value;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 4 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge message digests.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2017 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"module.exports = forge.md = forge.md || {};\r",
							"forge.md.algorithms = forge.md.algorithms || {};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 5 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Advanced Encryption Standard (AES) implementation.\r",
							" *\r",
							" * This implementation is based on the public domain library 'jscrypto' which\r",
							" * was written by:\r",
							" *\r",
							" * Emily Stark (estark@stanford.edu)\r",
							" * Mike Hamburg (mhamburg@stanford.edu)\r",
							" * Dan Boneh (dabo@cs.stanford.edu)\r",
							" *\r",
							" * Parts of this code are based on the OpenSSL implementation of AES:\r",
							" * http://www.openssl.org\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(13);\r",
							"__webpack_require__(18);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* AES API */\r",
							"module.exports = forge.aes = forge.aes || {};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('AES-<mode>', key);\r",
							" * cipher.start({iv: iv});\r",
							" *\r",
							" * Creates an AES cipher object to encrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes, an array of bytes,\r",
							" * a byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.startEncrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: false,\r",
							"    mode: mode\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('AES-<mode>', key);\r",
							" *\r",
							" * Creates an AES cipher object to encrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes, an array of bytes, a\r",
							" * byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.createEncryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: false,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\r",
							" * decipher.start({iv: iv});\r",
							" *\r",
							" * Creates an AES cipher object to decrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes, an array of bytes,\r",
							" * a byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.startDecrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: true,\r",
							"    mode: mode\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\r",
							" *\r",
							" * Creates an AES cipher object to decrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes, an array of bytes, a\r",
							" * byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.aes.createDecryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: true,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new AES cipher algorithm object.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" * @param mode the mode factory function.\r",
							" *\r",
							" * @return the AES algorithm object.\r",
							" */\r",
							"forge.aes.Algorithm = function(name, mode) {\r",
							"  if(!init) {\r",
							"    initialize();\r",
							"  }\r",
							"  var self = this;\r",
							"  self.name = name;\r",
							"  self.mode = new mode({\r",
							"    blockSize: 16,\r",
							"    cipher: {\r",
							"      encrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._w, inBlock, outBlock, false);\r",
							"      },\r",
							"      decrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._w, inBlock, outBlock, true);\r",
							"      }\r",
							"    }\r",
							"  });\r",
							"  self._init = false;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Initializes this AES algorithm by expanding its key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the key to use with this algorithm.\r",
							" *          decrypt true if the algorithm should be initialized for decryption,\r",
							" *            false for encryption.\r",
							" */\r",
							"forge.aes.Algorithm.prototype.initialize = function(options) {\r",
							"  if(this._init) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  var key = options.key;\r",
							"  var tmp;\r",
							"\r",
							"  /* Note: The key may be a string of bytes, an array of bytes, a byte\r",
							"    buffer, or an array of 32-bit integers. If the key is in bytes, then\r",
							"    it must be 16, 24, or 32 bytes in length. If it is in 32-bit\r",
							"    integers, it must be 4, 6, or 8 integers long. */\r",
							"\r",
							"  if(typeof key === 'string' &&\r",
							"    (key.length === 16 || key.length === 24 || key.length === 32)) {\r",
							"    // convert key string into byte buffer\r",
							"    key = forge.util.createBuffer(key);\r",
							"  } else if(forge.util.isArray(key) &&\r",
							"    (key.length === 16 || key.length === 24 || key.length === 32)) {\r",
							"    // convert key integer array into byte buffer\r",
							"    tmp = key;\r",
							"    key = forge.util.createBuffer();\r",
							"    for(var i = 0; i < tmp.length; ++i) {\r",
							"      key.putByte(tmp[i]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // convert key byte buffer into 32-bit integer array\r",
							"  if(!forge.util.isArray(key)) {\r",
							"    tmp = key;\r",
							"    key = [];\r",
							"\r",
							"    // key lengths of 16, 24, 32 bytes allowed\r",
							"    var len = tmp.length();\r",
							"    if(len === 16 || len === 24 || len === 32) {\r",
							"      len = len >>> 2;\r",
							"      for(var i = 0; i < len; ++i) {\r",
							"        key.push(tmp.getInt32());\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // key must be an array of 32-bit integers by now\r",
							"  if(!forge.util.isArray(key) ||\r",
							"    !(key.length === 4 || key.length === 6 || key.length === 8)) {\r",
							"    throw new Error('Invalid key parameter.');\r",
							"  }\r",
							"\r",
							"  // encryption operation is always used for these modes\r",
							"  var mode = this.mode.name;\r",
							"  var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);\r",
							"\r",
							"  // do key expansion\r",
							"  this._w = _expandKey(key, options.decrypt && !encryptOp);\r",
							"  this._init = true;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Expands a key. Typically only used for testing.\r",
							" *\r",
							" * @param key the symmetric key to expand, as an array of 32-bit words.\r",
							" * @param decrypt true to expand for decryption, false for encryption.\r",
							" *\r",
							" * @return the expanded key.\r",
							" */\r",
							"forge.aes._expandKey = function(key, decrypt) {\r",
							"  if(!init) {\r",
							"    initialize();\r",
							"  }\r",
							"  return _expandKey(key, decrypt);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Updates a single block. Typically only used for testing.\r",
							" *\r",
							" * @param w the expanded key to use.\r",
							" * @param input an array of block-size 32-bit words.\r",
							" * @param output an array of block-size 32-bit words.\r",
							" * @param decrypt true to decrypt, false to encrypt.\r",
							" */\r",
							"forge.aes._updateBlock = _updateBlock;\r",
							"\r",
							"/** Register AES algorithms **/\r",
							"\r",
							"registerAlgorithm('AES-ECB', forge.cipher.modes.ecb);\r",
							"registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);\r",
							"registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);\r",
							"registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);\r",
							"registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);\r",
							"registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);\r",
							"\r",
							"function registerAlgorithm(name, mode) {\r",
							"  var factory = function() {\r",
							"    return new forge.aes.Algorithm(name, mode);\r",
							"  };\r",
							"  forge.cipher.registerAlgorithm(name, factory);\r",
							"}\r",
							"\r",
							"/** AES implementation **/\r",
							"\r",
							"var init = false; // not yet initialized\r",
							"var Nb = 4;       // number of words comprising the state (AES = 4)\r",
							"var sbox;         // non-linear substitution table used in key expansion\r",
							"var isbox;        // inversion of sbox\r",
							"var rcon;         // round constant word array\r",
							"var mix;          // mix-columns table\r",
							"var imix;         // inverse mix-columns table\r",
							"\r",
							"/**\r",
							" * Performs initialization, ie: precomputes tables to optimize for speed.\r",
							" *\r",
							" * One way to understand how AES works is to imagine that 'addition' and\r",
							" * 'multiplication' are interfaces that require certain mathematical\r",
							" * properties to hold true (ie: they are associative) but they might have\r",
							" * different implementations and produce different kinds of results ...\r",
							" * provided that their mathematical properties remain true. AES defines\r",
							" * its own methods of addition and multiplication but keeps some important\r",
							" * properties the same, ie: associativity and distributivity. The\r",
							" * explanation below tries to shed some light on how AES defines addition\r",
							" * and multiplication of bytes and 32-bit words in order to perform its\r",
							" * encryption and decryption algorithms.\r",
							" *\r",
							" * The basics:\r",
							" *\r",
							" * The AES algorithm views bytes as binary representations of polynomials\r",
							" * that have either 1 or 0 as the coefficients. It defines the addition\r",
							" * or subtraction of two bytes as the XOR operation. It also defines the\r",
							" * multiplication of two bytes as a finite field referred to as GF(2^8)\r",
							" * (Note: 'GF' means \"Galois Field\" which is a field that contains a finite\r",
							" * number of elements so GF(2^8) has 256 elements).\r",
							" *\r",
							" * This means that any two bytes can be represented as binary polynomials;\r",
							" * when they multiplied together and modularly reduced by an irreducible\r",
							" * polynomial of the 8th degree, the results are the field GF(2^8). The\r",
							" * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.\r",
							" * This multiplication is associative with 0x01 as the identity:\r",
							" *\r",
							" * (b * 0x01 = GF(b, 0x01) = b).\r",
							" *\r",
							" * The operation GF(b, 0x02) can be performed at the byte level by left\r",
							" * shifting b once and then XOR'ing it (to perform the modular reduction)\r",
							" * with 0x11b if b is >= 128. Repeated application of the multiplication\r",
							" * of 0x02 can be used to implement the multiplication of any two bytes.\r",
							" *\r",
							" * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can\r",
							" * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these\r",
							" * factors can each be multiplied by 0x57 and then added together. To do\r",
							" * the multiplication, values for 0x57 multiplied by each of these 3 factors\r",
							" * can be precomputed and stored in a table. To add them, the values from\r",
							" * the table are XOR'd together.\r",
							" *\r",
							" * AES also defines addition and multiplication of words, that is 4-byte\r",
							" * numbers represented as polynomials of 3 degrees where the coefficients\r",
							" * are the values of the bytes.\r",
							" *\r",
							" * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.\r",
							" *\r",
							" * Addition is performed by XOR'ing like powers of x. Multiplication\r",
							" * is performed in two steps, the first is an algebriac expansion as\r",
							" * you would do normally (where addition is XOR). But the result is\r",
							" * a polynomial larger than 3 degrees and thus it cannot fit in a word. So\r",
							" * next the result is modularly reduced by an AES-specific polynomial of\r",
							" * degree 4 which will always produce a polynomial of less than 4 degrees\r",
							" * such that it will fit in a word. In AES, this polynomial is x^4 + 1.\r",
							" *\r",
							" * The modular product of two polynomials 'a' and 'b' is thus:\r",
							" *\r",
							" * d(x) = d3x^3 + d2x^2 + d1x + d0\r",
							" * with\r",
							" * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)\r",
							" * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)\r",
							" * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)\r",
							" * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)\r",
							" *\r",
							" * As a matrix:\r",
							" *\r",
							" * [d0] = [a0 a3 a2 a1][b0]\r",
							" * [d1]   [a1 a0 a3 a2][b1]\r",
							" * [d2]   [a2 a1 a0 a3][b2]\r",
							" * [d3]   [a3 a2 a1 a0][b3]\r",
							" *\r",
							" * Special polynomials defined by AES (0x02 == {02}):\r",
							" * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}\r",
							" * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.\r",
							" *\r",
							" * These polynomials are used in the MixColumns() and InverseMixColumns()\r",
							" * operations, respectively, to cause each element in the state to affect\r",
							" * the output (referred to as diffusing).\r",
							" *\r",
							" * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the\r",
							" * polynomial x3.\r",
							" *\r",
							" * The ShiftRows() method modifies the last 3 rows in the state (where\r",
							" * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.\r",
							" * The 1st byte in the second row is moved to the end of the row. The 1st\r",
							" * and 2nd bytes in the third row are moved to the end of the row. The 1st,\r",
							" * 2nd, and 3rd bytes are moved in the fourth row.\r",
							" *\r",
							" * More details on how AES arithmetic works:\r",
							" *\r",
							" * In the polynomial representation of binary numbers, XOR performs addition\r",
							" * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)\r",
							" * corresponds with the multiplication of polynomials modulo an irreducible\r",
							" * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply\r",
							" * polynomial 'a' with polynomial 'b' and then do a modular reduction by\r",
							" * an AES-specific irreducible polynomial of degree 8.\r",
							" *\r",
							" * A polynomial is irreducible if its only divisors are one and itself. For\r",
							" * the AES algorithm, this irreducible polynomial is:\r",
							" *\r",
							" * m(x) = x^8 + x^4 + x^3 + x + 1,\r",
							" *\r",
							" * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:\r",
							" * 100011011 = 283 = 0x11b.\r",
							" *\r",
							" * For example, GF(0x57, 0x83) = 0xc1 because\r",
							" *\r",
							" * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1\r",
							" * 0x85 = 131 = 10000101 = x^7 + x + 1\r",
							" *\r",
							" * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)\r",
							" * =  x^13 + x^11 + x^9 + x^8 + x^7 +\r",
							" *    x^7 + x^5 + x^3 + x^2 + x +\r",
							" *    x^6 + x^4 + x^2 + x + 1\r",
							" * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y\r",
							" *    y modulo (x^8 + x^4 + x^3 + x + 1)\r",
							" * =  x^7 + x^6 + 1.\r",
							" *\r",
							" * The modular reduction by m(x) guarantees the result will be a binary\r",
							" * polynomial of less than degree 8, so that it can fit in a byte.\r",
							" *\r",
							" * The operation to multiply a binary polynomial b with x (the polynomial\r",
							" * x in binary representation is 00000010) is:\r",
							" *\r",
							" * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1\r",
							" *\r",
							" * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the\r",
							" * most significant bit is 0 in b) then the result is already reduced. If\r",
							" * it is 1, then we can reduce it by subtracting m(x) via an XOR.\r",
							" *\r",
							" * It follows that multiplication by x (00000010 or 0x02) can be implemented\r",
							" * by performing a left shift followed by a conditional bitwise XOR with\r",
							" * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by\r",
							" * higher powers of x can be implemented by repeated application of xtime().\r",
							" *\r",
							" * By adding intermediate results, multiplication by any constant can be\r",
							" * implemented. For instance:\r",
							" *\r",
							" * GF(0x57, 0x13) = 0xfe because:\r",
							" *\r",
							" * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)\r",
							" *\r",
							" * Note: We XOR with 0x11b instead of 0x1b because in javascript our\r",
							" * datatype for b can be larger than 1 byte, so a left shift will not\r",
							" * automatically eliminate bits that overflow a byte ... by XOR'ing the\r",
							" * overflow bit with 1 (the extra one from 0x11b) we zero it out.\r",
							" *\r",
							" * GF(0x57, 0x02) = xtime(0x57) = 0xae\r",
							" * GF(0x57, 0x04) = xtime(0xae) = 0x47\r",
							" * GF(0x57, 0x08) = xtime(0x47) = 0x8e\r",
							" * GF(0x57, 0x10) = xtime(0x8e) = 0x07\r",
							" *\r",
							" * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))\r",
							" *\r",
							" * And by the distributive property (since XOR is addition and GF() is\r",
							" * multiplication):\r",
							" *\r",
							" * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)\r",
							" * = 0x57 ^ 0xae ^ 0x07\r",
							" * = 0xfe.\r",
							" */\r",
							"function initialize() {\r",
							"  init = true;\r",
							"\r",
							"  /* Populate the Rcon table. These are the values given by\r",
							"    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)\r",
							"    in the field of GF(2^8), where i starts at 1.\r",
							"\r",
							"    rcon[0] = [0x00, 0x00, 0x00, 0x00]\r",
							"    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1\r",
							"    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2\r",
							"    ...\r",
							"    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B\r",
							"    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36\r",
							"\r",
							"    We only store the first byte because it is the only one used.\r",
							"  */\r",
							"  rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36];\r",
							"\r",
							"  // compute xtime table which maps i onto GF(i, 0x02)\r",
							"  var xtime = new Array(256);\r",
							"  for(var i = 0; i < 128; ++i) {\r",
							"    xtime[i] = i << 1;\r",
							"    xtime[i + 128] = (i + 128) << 1 ^ 0x11B;\r",
							"  }\r",
							"\r",
							"  // compute all other tables\r",
							"  sbox = new Array(256);\r",
							"  isbox = new Array(256);\r",
							"  mix = new Array(4);\r",
							"  imix = new Array(4);\r",
							"  for(var i = 0; i < 4; ++i) {\r",
							"    mix[i] = new Array(256);\r",
							"    imix[i] = new Array(256);\r",
							"  }\r",
							"  var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;\r",
							"  for(var i = 0; i < 256; ++i) {\r",
							"    /* We need to generate the SubBytes() sbox and isbox tables so that\r",
							"      we can perform byte substitutions. This requires us to traverse\r",
							"      all of the elements in GF, find their multiplicative inverses,\r",
							"      and apply to each the following affine transformation:\r",
							"\r",
							"      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^\r",
							"            b(i + 7) mod 8 ^ ci\r",
							"      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the\r",
							"      ith bit of a byte c with the value {63} or {01100011}.\r",
							"\r",
							"      It is possible to traverse every possible value in a Galois field\r",
							"      using what is referred to as a 'generator'. There are many\r",
							"      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully\r",
							"      traverse GF we iterate 255 times, multiplying by our generator\r",
							"      each time.\r",
							"\r",
							"      On each iteration we can determine the multiplicative inverse for\r",
							"      the current element.\r",
							"\r",
							"      Suppose there is an element in GF 'e'. For a given generator 'g',\r",
							"      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns\r",
							"      out that if use the inverse of a generator as another generator\r",
							"      it will produce all of the corresponding multiplicative inverses\r",
							"      at the same time. For this reason, we choose 5 as our inverse\r",
							"      generator because it only requires 2 multiplies and 1 add and its\r",
							"      inverse, 82, requires relatively few operations as well.\r",
							"\r",
							"      In order to apply the affine transformation, the multiplicative\r",
							"      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a\r",
							"      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and\r",
							"      'x'. Then 's' is left shifted and the high bit of 's' is made the\r",
							"      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd\r",
							"      with 's' and stored in 'x'. On each subsequent iteration the same\r",
							"      operation is performed. When 4 iterations are complete, 'x' is\r",
							"      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.\r",
							"      For example:\r",
							"\r",
							"      s = 01000001\r",
							"      x = 01000001\r",
							"\r",
							"      iteration 1: s = 10000010, x ^= s\r",
							"      iteration 2: s = 00000101, x ^= s\r",
							"      iteration 3: s = 00001010, x ^= s\r",
							"      iteration 4: s = 00010100, x ^= s\r",
							"      x ^= 0x63\r",
							"\r",
							"      This can be done with a loop where s = (s << 1) | (s >> 7). However,\r",
							"      it can also be done by using a single 16-bit (in this case 32-bit)\r",
							"      number 'sx'. Since XOR is an associative operation, we can set 'sx'\r",
							"      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.\r",
							"      The most significant bits will flow into the high 8 bit positions\r",
							"      and be correctly XOR'd with one another. All that remains will be\r",
							"      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits\r",
							"      afterwards.\r",
							"\r",
							"      At the same time we're populating sbox and isbox we can precompute\r",
							"      the multiplication we'll need to do to do MixColumns() later.\r",
							"    */\r",
							"\r",
							"    // apply affine transformation\r",
							"    sx = ei ^ (ei << 1) ^ (ei << 2) ^ (ei << 3) ^ (ei << 4);\r",
							"    sx = (sx >> 8) ^ (sx & 255) ^ 0x63;\r",
							"\r",
							"    // update tables\r",
							"    sbox[e] = sx;\r",
							"    isbox[sx] = e;\r",
							"\r",
							"    /* Mixing columns is done using matrix multiplication. The columns\r",
							"      that are to be mixed are each a single word in the current state.\r",
							"      The state has Nb columns (4 columns). Therefore each column is a\r",
							"      4 byte word. So to mix the columns in a single column 'c' where\r",
							"      its rows are r0, r1, r2, and r3, we use the following matrix\r",
							"      multiplication:\r",
							"\r",
							"      [2 3 1 1]*[r0,c]=[r'0,c]\r",
							"      [1 2 3 1] [r1,c] [r'1,c]\r",
							"      [1 1 2 3] [r2,c] [r'2,c]\r",
							"      [3 1 1 2] [r3,c] [r'3,c]\r",
							"\r",
							"      r0, r1, r2, and r3 are each 1 byte of one of the words in the\r",
							"      state (a column). To do matrix multiplication for each mixed\r",
							"      column c' we multiply the corresponding row from the left matrix\r",
							"      with the corresponding column from the right matrix. In total, we\r",
							"      get 4 equations:\r",
							"\r",
							"      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c\r",
							"      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c\r",
							"      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c\r",
							"      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c\r",
							"\r",
							"      As usual, the multiplication is as previously defined and the\r",
							"      addition is XOR. In order to optimize mixing columns we can store\r",
							"      the multiplication results in tables. If you think of the whole\r",
							"      column as a word (it might help to visualize by mentally rotating\r",
							"      the equations above by counterclockwise 90 degrees) then you can\r",
							"      see that it would be useful to map the multiplications performed on\r",
							"      each byte (r0, r1, r2, r3) onto a word as well. For instance, we\r",
							"      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the\r",
							"      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two\r",
							"      respectively in the middle). This means that a table can be\r",
							"      constructed that uses r0 as an index to the word. We can do the\r",
							"      same with r1, r2, and r3, creating a total of 4 tables.\r",
							"\r",
							"      To construct a full c', we can just look up each byte of c in\r",
							"      their respective tables and XOR the results together.\r",
							"\r",
							"      Also, to build each table we only have to calculate the word\r",
							"      for 2,1,1,3 for every byte ... which we can do on each iteration\r",
							"      of this loop since we will iterate over every byte. After we have\r",
							"      calculated 2,1,1,3 we can get the results for the other tables\r",
							"      by cycling the byte at the end to the beginning. For instance\r",
							"      we can take the result of table 2,1,1,3 and produce table 3,2,1,1\r",
							"      by moving the right most byte to the left most position just like\r",
							"      how you can imagine the 3 moved out of 2,1,1,3 and to the front\r",
							"      to produce 3,2,1,1.\r",
							"\r",
							"      There is another optimization in that the same multiples of\r",
							"      the current element we need in order to advance our generator\r",
							"      to the next iteration can be reused in performing the 2,1,1,3\r",
							"      calculation. We also calculate the inverse mix column tables,\r",
							"      with e,9,d,b being the inverse of 2,1,1,3.\r",
							"\r",
							"      When we're done, and we need to actually mix columns, the first\r",
							"      byte of each state word should be put through mix[0] (2,1,1,3),\r",
							"      the second through mix[1] (3,2,1,1) and so forth. Then they should\r",
							"      be XOR'd together to produce the fully mixed column.\r",
							"    */\r",
							"\r",
							"    // calculate mix and imix table values\r",
							"    sx2 = xtime[sx];\r",
							"    e2 = xtime[e];\r",
							"    e4 = xtime[e2];\r",
							"    e8 = xtime[e4];\r",
							"    me =\r",
							"      (sx2 << 24) ^  // 2\r",
							"      (sx << 16) ^   // 1\r",
							"      (sx << 8) ^    // 1\r",
							"      (sx ^ sx2);    // 3\r",
							"    ime =\r",
							"      (e2 ^ e4 ^ e8) << 24 ^  // E (14)\r",
							"      (e ^ e8) << 16 ^        // 9\r",
							"      (e ^ e4 ^ e8) << 8 ^    // D (13)\r",
							"      (e ^ e2 ^ e8);          // B (11)\r",
							"    // produce each of the mix tables by rotating the 2,1,1,3 value\r",
							"    for(var n = 0; n < 4; ++n) {\r",
							"      mix[n][e] = me;\r",
							"      imix[n][sx] = ime;\r",
							"      // cycle the right most byte to the left most position\r",
							"      // ie: 2,1,1,3 becomes 3,2,1,1\r",
							"      me = me << 24 | me >>> 8;\r",
							"      ime = ime << 24 | ime >>> 8;\r",
							"    }\r",
							"\r",
							"    // get next element and inverse\r",
							"    if(e === 0) {\r",
							"      // 1 is the inverse of 1\r",
							"      e = ei = 1;\r",
							"    } else {\r",
							"      // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)\r",
							"      // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)\r",
							"      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];\r",
							"      ei ^= xtime[xtime[ei]];\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Generates a key schedule using the AES key expansion algorithm.\r",
							" *\r",
							" * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion\r",
							" * routine to generate a key schedule. The Key Expansion generates a total\r",
							" * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,\r",
							" * and each of the Nr rounds requires Nb words of key data. The resulting\r",
							" * key schedule consists of a linear array of 4-byte words, denoted [wi ],\r",
							" * with i in the range 0  i < Nb(Nr + 1).\r",
							" *\r",
							" * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)\r",
							" * AES-128 (Nb=4, Nk=4, Nr=10)\r",
							" * AES-192 (Nb=4, Nk=6, Nr=12)\r",
							" * AES-256 (Nb=4, Nk=8, Nr=14)\r",
							" * Note: Nr=Nk+6.\r",
							" *\r",
							" * Nb is the number of columns (32-bit words) comprising the State (or\r",
							" * number of bytes in a block). For AES, Nb=4.\r",
							" *\r",
							" * @param key the key to schedule (as an array of 32-bit words).\r",
							" * @param decrypt true to modify the key schedule to decrypt, false not to.\r",
							" *\r",
							" * @return the generated key schedule.\r",
							" */\r",
							"function _expandKey(key, decrypt) {\r",
							"  // copy the key's words to initialize the key schedule\r",
							"  var w = key.slice(0);\r",
							"\r",
							"  /* RotWord() will rotate a word, moving the first byte to the last\r",
							"    byte's position (shifting the other bytes left).\r",
							"\r",
							"    We will be getting the value of Rcon at i / Nk. 'i' will iterate\r",
							"    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in\r",
							"    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from\r",
							"    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will\r",
							"    increase by 1. We use a counter iNk to keep track of this.\r",
							"   */\r",
							"\r",
							"  // go through the rounds expanding the key\r",
							"  var temp, iNk = 1;\r",
							"  var Nk = w.length;\r",
							"  var Nr1 = Nk + 6 + 1;\r",
							"  var end = Nb * Nr1;\r",
							"  for(var i = Nk; i < end; ++i) {\r",
							"    temp = w[i - 1];\r",
							"    if(i % Nk === 0) {\r",
							"      // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]\r",
							"      temp =\r",
							"        sbox[temp >>> 16 & 255] << 24 ^\r",
							"        sbox[temp >>> 8 & 255] << 16 ^\r",
							"        sbox[temp & 255] << 8 ^\r",
							"        sbox[temp >>> 24] ^ (rcon[iNk] << 24);\r",
							"      iNk++;\r",
							"    } else if(Nk > 6 && (i % Nk === 4)) {\r",
							"      // temp = SubWord(temp)\r",
							"      temp =\r",
							"        sbox[temp >>> 24] << 24 ^\r",
							"        sbox[temp >>> 16 & 255] << 16 ^\r",
							"        sbox[temp >>> 8 & 255] << 8 ^\r",
							"        sbox[temp & 255];\r",
							"    }\r",
							"    w[i] = w[i - Nk] ^ temp;\r",
							"  }\r",
							"\r",
							"   /* When we are updating a cipher block we always use the code path for\r",
							"     encryption whether we are decrypting or not (to shorten code and\r",
							"     simplify the generation of look up tables). However, because there\r",
							"     are differences in the decryption algorithm, other than just swapping\r",
							"     in different look up tables, we must transform our key schedule to\r",
							"     account for these changes:\r",
							"\r",
							"     1. The decryption algorithm gets its key rounds in reverse order.\r",
							"     2. The decryption algorithm adds the round key before mixing columns\r",
							"       instead of afterwards.\r",
							"\r",
							"     We don't need to modify our key schedule to handle the first case,\r",
							"     we can just traverse the key schedule in reverse order when decrypting.\r",
							"\r",
							"     The second case requires a little work.\r",
							"\r",
							"     The tables we built for performing rounds will take an input and then\r",
							"     perform SubBytes() and MixColumns() or, for the decrypt version,\r",
							"     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires\r",
							"     us to AddRoundKey() before InvMixColumns(). This means we'll need to\r",
							"     apply some transformations to the round key to inverse-mix its columns\r",
							"     so they'll be correct for moving AddRoundKey() to after the state has\r",
							"     had its columns inverse-mixed.\r",
							"\r",
							"     To inverse-mix the columns of the state when we're decrypting we use a\r",
							"     lookup table that will apply InvSubBytes() and InvMixColumns() at the\r",
							"     same time. However, the round key's bytes are not inverse-substituted\r",
							"     in the decryption algorithm. To get around this problem, we can first\r",
							"     substitute the bytes in the round key so that when we apply the\r",
							"     transformation via the InvSubBytes()+InvMixColumns() table, it will\r",
							"     undo our substitution leaving us with the original value that we\r",
							"     want -- and then inverse-mix that value.\r",
							"\r",
							"     This change will correctly alter our key schedule so that we can XOR\r",
							"     each round key with our already transformed decryption state. This\r",
							"     allows us to use the same code path as the encryption algorithm.\r",
							"\r",
							"     We make one more change to the decryption key. Since the decryption\r",
							"     algorithm runs in reverse from the encryption algorithm, we reverse\r",
							"     the order of the round keys to avoid having to iterate over the key\r",
							"     schedule backwards when running the encryption algorithm later in\r",
							"     decryption mode. In addition to reversing the order of the round keys,\r",
							"     we also swap each round key's 2nd and 4th rows. See the comments\r",
							"     section where rounds are performed for more details about why this is\r",
							"     done. These changes are done inline with the other substitution\r",
							"     described above.\r",
							"  */\r",
							"  if(decrypt) {\r",
							"    var tmp;\r",
							"    var m0 = imix[0];\r",
							"    var m1 = imix[1];\r",
							"    var m2 = imix[2];\r",
							"    var m3 = imix[3];\r",
							"    var wnew = w.slice(0);\r",
							"    end = w.length;\r",
							"    for(var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {\r",
							"      // do not sub the first or last round key (round keys are Nb\r",
							"      // words) as no column mixing is performed before they are added,\r",
							"      // but do change the key order\r",
							"      if(i === 0 || i === (end - Nb)) {\r",
							"        wnew[i] = w[wi];\r",
							"        wnew[i + 1] = w[wi + 3];\r",
							"        wnew[i + 2] = w[wi + 2];\r",
							"        wnew[i + 3] = w[wi + 1];\r",
							"      } else {\r",
							"        // substitute each round key byte because the inverse-mix\r",
							"        // table will inverse-substitute it (effectively cancel the\r",
							"        // substitution because round key bytes aren't sub'd in\r",
							"        // decryption mode) and swap indexes 3 and 1\r",
							"        for(var n = 0; n < Nb; ++n) {\r",
							"          tmp = w[wi + n];\r",
							"          wnew[i + (3&-n)] =\r",
							"            m0[sbox[tmp >>> 24]] ^\r",
							"            m1[sbox[tmp >>> 16 & 255]] ^\r",
							"            m2[sbox[tmp >>> 8 & 255]] ^\r",
							"            m3[sbox[tmp & 255]];\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"    w = wnew;\r",
							"  }\r",
							"\r",
							"  return w;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a single block (16 bytes) using AES. The update will either\r",
							" * encrypt or decrypt the block.\r",
							" *\r",
							" * @param w the key schedule.\r",
							" * @param input the input block (an array of 32-bit words).\r",
							" * @param output the updated output block.\r",
							" * @param decrypt true to decrypt the block, false to encrypt it.\r",
							" */\r",
							"function _updateBlock(w, input, output, decrypt) {\r",
							"  /*\r",
							"  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\r",
							"  begin\r",
							"    byte state[4,Nb]\r",
							"    state = in\r",
							"    AddRoundKey(state, w[0, Nb-1])\r",
							"    for round = 1 step 1 to Nr1\r",
							"      SubBytes(state)\r",
							"      ShiftRows(state)\r",
							"      MixColumns(state)\r",
							"      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r",
							"    end for\r",
							"    SubBytes(state)\r",
							"    ShiftRows(state)\r",
							"    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"    out = state\r",
							"  end\r",
							"\r",
							"  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\r",
							"  begin\r",
							"    byte state[4,Nb]\r",
							"    state = in\r",
							"    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"    for round = Nr-1 step -1 downto 1\r",
							"      InvShiftRows(state)\r",
							"      InvSubBytes(state)\r",
							"      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r",
							"      InvMixColumns(state)\r",
							"    end for\r",
							"    InvShiftRows(state)\r",
							"    InvSubBytes(state)\r",
							"    AddRoundKey(state, w[0, Nb-1])\r",
							"    out = state\r",
							"  end\r",
							"  */\r",
							"\r",
							"  // Encrypt: AddRoundKey(state, w[0, Nb-1])\r",
							"  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"  var Nr = w.length / 4 - 1;\r",
							"  var m0, m1, m2, m3, sub;\r",
							"  if(decrypt) {\r",
							"    m0 = imix[0];\r",
							"    m1 = imix[1];\r",
							"    m2 = imix[2];\r",
							"    m3 = imix[3];\r",
							"    sub = isbox;\r",
							"  } else {\r",
							"    m0 = mix[0];\r",
							"    m1 = mix[1];\r",
							"    m2 = mix[2];\r",
							"    m3 = mix[3];\r",
							"    sub = sbox;\r",
							"  }\r",
							"  var a, b, c, d, a2, b2, c2;\r",
							"  a = input[0] ^ w[0];\r",
							"  b = input[decrypt ? 3 : 1] ^ w[1];\r",
							"  c = input[2] ^ w[2];\r",
							"  d = input[decrypt ? 1 : 3] ^ w[3];\r",
							"  var i = 3;\r",
							"\r",
							"  /* In order to share code we follow the encryption algorithm when both\r",
							"    encrypting and decrypting. To account for the changes required in the\r",
							"    decryption algorithm, we use different lookup tables when decrypting\r",
							"    and use a modified key schedule to account for the difference in the\r",
							"    order of transformations applied when performing rounds. We also get\r",
							"    key rounds in reverse order (relative to encryption). */\r",
							"  for(var round = 1; round < Nr; ++round) {\r",
							"    /* As described above, we'll be using table lookups to perform the\r",
							"      column mixing. Each column is stored as a word in the state (the\r",
							"      array 'input' has one column as a word at each index). In order to\r",
							"      mix a column, we perform these transformations on each row in c,\r",
							"      which is 1 byte in each word. The new column for c0 is c'0:\r",
							"\r",
							"               m0      m1      m2      m3\r",
							"      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0\r",
							"      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0\r",
							"      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0\r",
							"      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0\r",
							"\r",
							"      So using mix tables where c0 is a word with r0 being its upper\r",
							"      8 bits and r3 being its lower 8 bits:\r",
							"\r",
							"      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]\r",
							"      ...\r",
							"      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]\r",
							"\r",
							"      Therefore to mix the columns in each word in the state we\r",
							"      do the following (& 255 omitted for brevity):\r",
							"      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r",
							"\r",
							"      However, before mixing, the algorithm requires us to perform\r",
							"      ShiftRows(). The ShiftRows() transformation cyclically shifts the\r",
							"      last 3 rows of the state over different offsets. The first row\r",
							"      (r = 0) is not shifted.\r",
							"\r",
							"      s'_r,c = s_r,(c + shift(r, Nb) mod Nb\r",
							"      for 0 < r < 4 and 0 <= c < Nb and\r",
							"      shift(1, 4) = 1\r",
							"      shift(2, 4) = 2\r",
							"      shift(3, 4) = 3.\r",
							"\r",
							"      This causes the first byte in r = 1 to be moved to the end of\r",
							"      the row, the first 2 bytes in r = 2 to be moved to the end of\r",
							"      the row, the first 3 bytes in r = 3 to be moved to the end of\r",
							"      the row:\r",
							"\r",
							"      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]\r",
							"      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]\r",
							"      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]\r",
							"\r",
							"      We can make these substitutions inline with our column mixing to\r",
							"      generate an updated set of equations to produce each word in the\r",
							"      state (note the columns have changed positions):\r",
							"\r",
							"      c0 c1 c2 c3 => c0 c1 c2 c3\r",
							"      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)\r",
							"      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)\r",
							"      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)\r",
							"\r",
							"      Therefore:\r",
							"\r",
							"      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3\r",
							"      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3\r",
							"      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3\r",
							"      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3\r",
							"\r",
							"      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0\r",
							"      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0\r",
							"      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0\r",
							"      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0\r",
							"\r",
							"      ... and so forth for c'2 and c'3. The important distinction is\r",
							"      that the columns are cycling, with c0 being used with the m0\r",
							"      map when calculating c0, but c1 being used with the m0 map when\r",
							"      calculating c1 ... and so forth.\r",
							"\r",
							"      When performing the inverse we transform the mirror image and\r",
							"      skip the bottom row, instead of the top one, and move upwards:\r",
							"\r",
							"      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption\r",
							"      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)\r",
							"      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption\r",
							"      c3 c2 c1 c0    c3 c2 c1 c0\r",
							"\r",
							"      If you compare the resulting matrices for ShiftRows()+MixColumns()\r",
							"      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are\r",
							"      different (in encrypt mode vs. decrypt mode). So in order to use\r",
							"      the same code to handle both encryption and decryption, we will\r",
							"      need to do some mapping.\r",
							"\r",
							"      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be\r",
							"      a row number in the state, then the resulting matrix in encryption\r",
							"      mode for applying the above transformations would be:\r",
							"\r",
							"      r1: a b c d\r",
							"      r2: b c d a\r",
							"      r3: c d a b\r",
							"      r4: d a b c\r",
							"\r",
							"      If we did the same in decryption mode we would get:\r",
							"\r",
							"      r1: a d c b\r",
							"      r2: b a d c\r",
							"      r3: c b a d\r",
							"      r4: d c b a\r",
							"\r",
							"      If instead we swap d and b (set b=c3 and d=c1), then we get:\r",
							"\r",
							"      r1: a b c d\r",
							"      r2: d a b c\r",
							"      r3: c d a b\r",
							"      r4: b c d a\r",
							"\r",
							"      Now the 1st and 3rd rows are the same as the encryption matrix. All\r",
							"      we need to do then to make the mapping exactly the same is to swap\r",
							"      the 2nd and 4th rows when in decryption mode. To do this without\r",
							"      having to do it on each iteration, we swapped the 2nd and 4th rows\r",
							"      in the decryption key schedule. We also have to do the swap above\r",
							"      when we first pull in the input and when we set the final output. */\r",
							"    a2 =\r",
							"      m0[a >>> 24] ^\r",
							"      m1[b >>> 16 & 255] ^\r",
							"      m2[c >>> 8 & 255] ^\r",
							"      m3[d & 255] ^ w[++i];\r",
							"    b2 =\r",
							"      m0[b >>> 24] ^\r",
							"      m1[c >>> 16 & 255] ^\r",
							"      m2[d >>> 8 & 255] ^\r",
							"      m3[a & 255] ^ w[++i];\r",
							"    c2 =\r",
							"      m0[c >>> 24] ^\r",
							"      m1[d >>> 16 & 255] ^\r",
							"      m2[a >>> 8 & 255] ^\r",
							"      m3[b & 255] ^ w[++i];\r",
							"    d =\r",
							"      m0[d >>> 24] ^\r",
							"      m1[a >>> 16 & 255] ^\r",
							"      m2[b >>> 8 & 255] ^\r",
							"      m3[c & 255] ^ w[++i];\r",
							"    a = a2;\r",
							"    b = b2;\r",
							"    c = c2;\r",
							"  }\r",
							"\r",
							"  /*\r",
							"    Encrypt:\r",
							"    SubBytes(state)\r",
							"    ShiftRows(state)\r",
							"    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r",
							"\r",
							"    Decrypt:\r",
							"    InvShiftRows(state)\r",
							"    InvSubBytes(state)\r",
							"    AddRoundKey(state, w[0, Nb-1])\r",
							"   */\r",
							"   // Note: rows are shifted inline\r",
							"  output[0] =\r",
							"    (sub[a >>> 24] << 24) ^\r",
							"    (sub[b >>> 16 & 255] << 16) ^\r",
							"    (sub[c >>> 8 & 255] << 8) ^\r",
							"    (sub[d & 255]) ^ w[++i];\r",
							"  output[decrypt ? 3 : 1] =\r",
							"    (sub[b >>> 24] << 24) ^\r",
							"    (sub[c >>> 16 & 255] << 16) ^\r",
							"    (sub[d >>> 8 & 255] << 8) ^\r",
							"    (sub[a & 255]) ^ w[++i];\r",
							"  output[2] =\r",
							"    (sub[c >>> 24] << 24) ^\r",
							"    (sub[d >>> 16 & 255] << 16) ^\r",
							"    (sub[a >>> 8 & 255] << 8) ^\r",
							"    (sub[b & 255]) ^ w[++i];\r",
							"  output[decrypt ? 1 : 3] =\r",
							"    (sub[d >>> 24] << 24) ^\r",
							"    (sub[a >>> 16 & 255] << 16) ^\r",
							"    (sub[b >>> 8 & 255] << 8) ^\r",
							"    (sub[c & 255]) ^ w[++i];\r",
							"}\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * forge.cipher.createCipher('AES-<mode>', key);\r",
							" * forge.cipher.createDecipher('AES-<mode>', key);\r",
							" *\r",
							" * Creates a deprecated AES cipher object. This object's mode will default to\r",
							" * CBC (cipher-block-chaining).\r",
							" *\r",
							" * The key and iv may be given as a string of bytes, an array of bytes, a\r",
							" * byte buffer, or an array of 32-bit words.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the symmetric key to use.\r",
							" *          output the buffer to write to.\r",
							" *          decrypt true for decryption, false for encryption.\r",
							" *          mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"function _createCipher(options) {\r",
							"  options = options || {};\r",
							"  var mode = (options.mode || 'CBC').toUpperCase();\r",
							"  var algorithm = 'AES-' + mode;\r",
							"\r",
							"  var cipher;\r",
							"  if(options.decrypt) {\r",
							"    cipher = forge.cipher.createDecipher(algorithm, options.key);\r",
							"  } else {\r",
							"    cipher = forge.cipher.createCipher(algorithm, options.key);\r",
							"  }\r",
							"\r",
							"  // backwards compatible start API\r",
							"  var start = cipher.start;\r",
							"  cipher.start = function(iv, options) {\r",
							"    // backwards compatibility: support second arg as output buffer\r",
							"    var output = null;\r",
							"    if(options instanceof forge.util.ByteBuffer) {\r",
							"      output = options;\r",
							"      options = {};\r",
							"    }\r",
							"    options = options || {};\r",
							"    options.output = output;\r",
							"    options.iv = iv;\r",
							"    start.call(cipher, options);\r",
							"  };\r",
							"\r",
							"  return cipher;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 6 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Object IDs for ASN.1.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"forge.pki = forge.pki || {};\r",
							"var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};\r",
							"\r",
							"// set id to name mapping and name to id mapping\r",
							"function _IN(id, name) {\r",
							"  oids[id] = name;\r",
							"  oids[name] = id;\r",
							"}\r",
							"// set id to name mapping only\r",
							"function _I_(id, name) {\r",
							"  oids[id] = name;\r",
							"}\r",
							"\r",
							"// algorithm OIDs\r",
							"_IN('1.2.840.113549.1.1.1', 'rsaEncryption');\r",
							"// Note: md2 & md4 not implemented\r",
							"//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');\r",
							"//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.4', 'md5WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.7', 'RSAES-OAEP');\r",
							"_IN('1.2.840.113549.1.1.8', 'mgf1');\r",
							"_IN('1.2.840.113549.1.1.9', 'pSpecified');\r",
							"_IN('1.2.840.113549.1.1.10', 'RSASSA-PSS');\r",
							"_IN('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption');\r",
							"_IN('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption');\r",
							"\r",
							"_IN('1.2.840.10040.4.3', 'dsa-with-sha1');\r",
							"\r",
							"_IN('1.3.14.3.2.7', 'desCBC');\r",
							"\r",
							"_IN('1.3.14.3.2.26', 'sha1');\r",
							"_IN('2.16.840.1.101.3.4.2.1', 'sha256');\r",
							"_IN('2.16.840.1.101.3.4.2.2', 'sha384');\r",
							"_IN('2.16.840.1.101.3.4.2.3', 'sha512');\r",
							"_IN('1.2.840.113549.2.5', 'md5');\r",
							"\r",
							"// pkcs#7 content types\r",
							"_IN('1.2.840.113549.1.7.1', 'data');\r",
							"_IN('1.2.840.113549.1.7.2', 'signedData');\r",
							"_IN('1.2.840.113549.1.7.3', 'envelopedData');\r",
							"_IN('1.2.840.113549.1.7.4', 'signedAndEnvelopedData');\r",
							"_IN('1.2.840.113549.1.7.5', 'digestedData');\r",
							"_IN('1.2.840.113549.1.7.6', 'encryptedData');\r",
							"\r",
							"// pkcs#9 oids\r",
							"_IN('1.2.840.113549.1.9.1', 'emailAddress');\r",
							"_IN('1.2.840.113549.1.9.2', 'unstructuredName');\r",
							"_IN('1.2.840.113549.1.9.3', 'contentType');\r",
							"_IN('1.2.840.113549.1.9.4', 'messageDigest');\r",
							"_IN('1.2.840.113549.1.9.5', 'signingTime');\r",
							"_IN('1.2.840.113549.1.9.6', 'counterSignature');\r",
							"_IN('1.2.840.113549.1.9.7', 'challengePassword');\r",
							"_IN('1.2.840.113549.1.9.8', 'unstructuredAddress');\r",
							"_IN('1.2.840.113549.1.9.14', 'extensionRequest');\r",
							"\r",
							"_IN('1.2.840.113549.1.9.20', 'friendlyName');\r",
							"_IN('1.2.840.113549.1.9.21', 'localKeyId');\r",
							"_IN('1.2.840.113549.1.9.22.1', 'x509Certificate');\r",
							"\r",
							"// pkcs#12 safe bags\r",
							"_IN('1.2.840.113549.1.12.10.1.1', 'keyBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.3', 'certBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.4', 'crlBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.5', 'secretBag');\r",
							"_IN('1.2.840.113549.1.12.10.1.6', 'safeContentsBag');\r",
							"\r",
							"// password-based-encryption for pkcs#12\r",
							"_IN('1.2.840.113549.1.5.13', 'pkcs5PBES2');\r",
							"_IN('1.2.840.113549.1.5.12', 'pkcs5PBKDF2');\r",
							"\r",
							"_IN('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4');\r",
							"_IN('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4');\r",
							"_IN('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC');\r",
							"_IN('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC');\r",
							"_IN('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC');\r",
							"_IN('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC');\r",
							"\r",
							"// hmac OIDs\r",
							"_IN('1.2.840.113549.2.7', 'hmacWithSHA1');\r",
							"_IN('1.2.840.113549.2.8', 'hmacWithSHA224');\r",
							"_IN('1.2.840.113549.2.9', 'hmacWithSHA256');\r",
							"_IN('1.2.840.113549.2.10', 'hmacWithSHA384');\r",
							"_IN('1.2.840.113549.2.11', 'hmacWithSHA512');\r",
							"\r",
							"// symmetric key algorithm oids\r",
							"_IN('1.2.840.113549.3.7', 'des-EDE3-CBC');\r",
							"_IN('2.16.840.1.101.3.4.1.2', 'aes128-CBC');\r",
							"_IN('2.16.840.1.101.3.4.1.22', 'aes192-CBC');\r",
							"_IN('2.16.840.1.101.3.4.1.42', 'aes256-CBC');\r",
							"\r",
							"// certificate issuer/subject OIDs\r",
							"_IN('2.5.4.3', 'commonName');\r",
							"_IN('2.5.4.5', 'serialName');\r",
							"_IN('2.5.4.6', 'countryName');\r",
							"_IN('2.5.4.7', 'localityName');\r",
							"_IN('2.5.4.8', 'stateOrProvinceName');\r",
							"_IN('2.5.4.10', 'organizationName');\r",
							"_IN('2.5.4.11', 'organizationalUnitName');\r",
							"\r",
							"// X.509 extension OIDs\r",
							"_IN('2.16.840.1.113730.1.1', 'nsCertType');\r",
							"_I_('2.5.29.1', 'authorityKeyIdentifier'); // deprecated, use .35\r",
							"_I_('2.5.29.2', 'keyAttributes'); // obsolete use .37 or .15\r",
							"_I_('2.5.29.3', 'certificatePolicies'); // deprecated, use .32\r",
							"_I_('2.5.29.4', 'keyUsageRestriction'); // obsolete use .37 or .15\r",
							"_I_('2.5.29.5', 'policyMapping'); // deprecated use .33\r",
							"_I_('2.5.29.6', 'subtreesConstraint'); // obsolete use .30\r",
							"_I_('2.5.29.7', 'subjectAltName'); // deprecated use .17\r",
							"_I_('2.5.29.8', 'issuerAltName'); // deprecated use .18\r",
							"_I_('2.5.29.9', 'subjectDirectoryAttributes');\r",
							"_I_('2.5.29.10', 'basicConstraints'); // deprecated use .19\r",
							"_I_('2.5.29.11', 'nameConstraints'); // deprecated use .30\r",
							"_I_('2.5.29.12', 'policyConstraints'); // deprecated use .36\r",
							"_I_('2.5.29.13', 'basicConstraints'); // deprecated use .19\r",
							"_IN('2.5.29.14', 'subjectKeyIdentifier');\r",
							"_IN('2.5.29.15', 'keyUsage');\r",
							"_I_('2.5.29.16', 'privateKeyUsagePeriod');\r",
							"_IN('2.5.29.17', 'subjectAltName');\r",
							"_IN('2.5.29.18', 'issuerAltName');\r",
							"_IN('2.5.29.19', 'basicConstraints');\r",
							"_I_('2.5.29.20', 'cRLNumber');\r",
							"_I_('2.5.29.21', 'cRLReason');\r",
							"_I_('2.5.29.22', 'expirationDate');\r",
							"_I_('2.5.29.23', 'instructionCode');\r",
							"_I_('2.5.29.24', 'invalidityDate');\r",
							"_I_('2.5.29.25', 'cRLDistributionPoints'); // deprecated use .31\r",
							"_I_('2.5.29.26', 'issuingDistributionPoint'); // deprecated use .28\r",
							"_I_('2.5.29.27', 'deltaCRLIndicator');\r",
							"_I_('2.5.29.28', 'issuingDistributionPoint');\r",
							"_I_('2.5.29.29', 'certificateIssuer');\r",
							"_I_('2.5.29.30', 'nameConstraints');\r",
							"_IN('2.5.29.31', 'cRLDistributionPoints');\r",
							"_IN('2.5.29.32', 'certificatePolicies');\r",
							"_I_('2.5.29.33', 'policyMappings');\r",
							"_I_('2.5.29.34', 'policyConstraints'); // deprecated use .36\r",
							"_IN('2.5.29.35', 'authorityKeyIdentifier');\r",
							"_I_('2.5.29.36', 'policyConstraints');\r",
							"_IN('2.5.29.37', 'extKeyUsage');\r",
							"_I_('2.5.29.46', 'freshestCRL');\r",
							"_I_('2.5.29.54', 'inhibitAnyPolicy');\r",
							"\r",
							"// extKeyUsage purposes\r",
							"_IN('1.3.6.1.4.1.11129.2.4.2', 'timestampList');\r",
							"_IN('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess');\r",
							"_IN('1.3.6.1.5.5.7.3.1', 'serverAuth');\r",
							"_IN('1.3.6.1.5.5.7.3.2', 'clientAuth');\r",
							"_IN('1.3.6.1.5.5.7.3.3', 'codeSigning');\r",
							"_IN('1.3.6.1.5.5.7.3.4', 'emailProtection');\r",
							"_IN('1.3.6.1.5.5.7.3.8', 'timeStamping');\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 7 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\r",
							" *\r",
							" * See: RFC 1421.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2013-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * A Forge PEM object has the following fields:\r",
							" *\r",
							" * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\r",
							" *\r",
							" * procType: identifies the type of processing performed on the message,\r",
							" *   it has two subfields: version and type, eg: 4,ENCRYPTED.\r",
							" *\r",
							" * contentDomain: identifies the type of content in the message, typically\r",
							" *   only uses the value: \"RFC822\".\r",
							" *\r",
							" * dekInfo: identifies the message encryption algorithm and mode and includes\r",
							" *   any parameters for the algorithm, it has two subfields: algorithm and\r",
							" *   parameters, eg: DES-CBC,F8143EDE5960C597.\r",
							" *\r",
							" * headers: contains all other PEM encapsulated headers -- where order is\r",
							" *   significant (for pairing data like recipient ID + key info).\r",
							" *\r",
							" * body: the binary-encoded body.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for pem API\r",
							"var pem = module.exports = forge.pem = forge.pem || {};\r",
							"\r",
							"/**\r",
							" * Encodes (serializes) the given PEM object.\r",
							" *\r",
							" * @param msg the PEM message object to encode.\r",
							" * @param options the options to use:\r",
							" *          maxline the maximum characters per line for the body, (default: 64).\r",
							" *\r",
							" * @return the PEM-formatted string.\r",
							" */\r",
							"pem.encode = function(msg, options) {\r",
							"  options = options || {};\r",
							"  var rval = '-----BEGIN ' + msg.type + '-----\\r\\n';\r",
							"\r",
							"  // encode special headers\r",
							"  var header;\r",
							"  if(msg.procType) {\r",
							"    header = {\r",
							"      name: 'Proc-Type',\r",
							"      values: [String(msg.procType.version), msg.procType.type]\r",
							"    };\r",
							"    rval += foldHeader(header);\r",
							"  }\r",
							"  if(msg.contentDomain) {\r",
							"    header = {name: 'Content-Domain', values: [msg.contentDomain]};\r",
							"    rval += foldHeader(header);\r",
							"  }\r",
							"  if(msg.dekInfo) {\r",
							"    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};\r",
							"    if(msg.dekInfo.parameters) {\r",
							"      header.values.push(msg.dekInfo.parameters);\r",
							"    }\r",
							"    rval += foldHeader(header);\r",
							"  }\r",
							"\r",
							"  if(msg.headers) {\r",
							"    // encode all other headers\r",
							"    for(var i = 0; i < msg.headers.length; ++i) {\r",
							"      rval += foldHeader(msg.headers[i]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // terminate header\r",
							"  if(msg.procType) {\r",
							"    rval += '\\r\\n';\r",
							"  }\r",
							"\r",
							"  // add body\r",
							"  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\\r\\n';\r",
							"\r",
							"  rval += '-----END ' + msg.type + '-----\\r\\n';\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes (deserializes) all PEM messages found in the given string.\r",
							" *\r",
							" * @param str the PEM-formatted string to decode.\r",
							" *\r",
							" * @return the PEM message objects in an array.\r",
							" */\r",
							"pem.decode = function(str) {\r",
							"  var rval = [];\r",
							"\r",
							"  // split string into PEM messages (be lenient w/EOF on BEGIN line)\r",
							"  var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\r",
							"  var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\r",
							"  var rCRLF = /\\r?\\n/;\r",
							"  var match;\r",
							"  while(true) {\r",
							"    match = rMessage.exec(str);\r",
							"    if(!match) {\r",
							"      break;\r",
							"    }\r",
							"\r",
							"    var msg = {\r",
							"      type: match[1],\r",
							"      procType: null,\r",
							"      contentDomain: null,\r",
							"      dekInfo: null,\r",
							"      headers: [],\r",
							"      body: forge.util.decode64(match[3])\r",
							"    };\r",
							"    rval.push(msg);\r",
							"\r",
							"    // no headers\r",
							"    if(!match[2]) {\r",
							"      continue;\r",
							"    }\r",
							"\r",
							"    // parse headers\r",
							"    var lines = match[2].split(rCRLF);\r",
							"    var li = 0;\r",
							"    while(match && li < lines.length) {\r",
							"      // get line, trim any rhs whitespace\r",
							"      var line = lines[li].replace(/\\s+$/, '');\r",
							"\r",
							"      // RFC2822 unfold any following folded lines\r",
							"      for(var nl = li + 1; nl < lines.length; ++nl) {\r",
							"        var next = lines[nl];\r",
							"        if(!/\\s/.test(next[0])) {\r",
							"          break;\r",
							"        }\r",
							"        line += next;\r",
							"        li = nl;\r",
							"      }\r",
							"\r",
							"      // parse header\r",
							"      match = line.match(rHeader);\r",
							"      if(match) {\r",
							"        var header = {name: match[1], values: []};\r",
							"        var values = match[2].split(',');\r",
							"        for(var vi = 0; vi < values.length; ++vi) {\r",
							"          header.values.push(ltrim(values[vi]));\r",
							"        }\r",
							"\r",
							"        // Proc-Type must be the first header\r",
							"        if(!msg.procType) {\r",
							"          if(header.name !== 'Proc-Type') {\r",
							"            throw new Error('Invalid PEM formatted message. The first ' +\r",
							"              'encapsulated header must be \"Proc-Type\".');\r",
							"          } else if(header.values.length !== 2) {\r",
							"            throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' +\r",
							"              'header must have two subfields.');\r",
							"          }\r",
							"          msg.procType = {version: values[0], type: values[1]};\r",
							"        } else if(!msg.contentDomain && header.name === 'Content-Domain') {\r",
							"          // special-case Content-Domain\r",
							"          msg.contentDomain = values[0] || '';\r",
							"        } else if(!msg.dekInfo && header.name === 'DEK-Info') {\r",
							"          // special-case DEK-Info\r",
							"          if(header.values.length === 0) {\r",
							"            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\r",
							"              'header must have at least one subfield.');\r",
							"          }\r",
							"          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};\r",
							"        } else {\r",
							"          msg.headers.push(header);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      ++li;\r",
							"    }\r",
							"\r",
							"    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {\r",
							"      throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\r",
							"        'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(rval.length === 0) {\r",
							"    throw new Error('Invalid PEM formatted message.');\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"function foldHeader(header) {\r",
							"  var rval = header.name + ': ';\r",
							"\r",
							"  // ensure values with CRLF are folded\r",
							"  var values = [];\r",
							"  var insertSpace = function(match, $1) {\r",
							"    return ' ' + $1;\r",
							"  };\r",
							"  for(var i = 0; i < header.values.length; ++i) {\r",
							"    values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\r",
							"  }\r",
							"  rval += values.join(',') + '\\r\\n';\r",
							"\r",
							"  // do folding\r",
							"  var length = 0;\r",
							"  var candidate = -1;\r",
							"  for(var i = 0; i < rval.length; ++i, ++length) {\r",
							"    if(length > 65 && candidate !== -1) {\r",
							"      var insert = rval[candidate];\r",
							"      if(insert === ',') {\r",
							"        ++candidate;\r",
							"        rval = rval.substr(0, candidate) + '\\r\\n ' + rval.substr(candidate);\r",
							"      } else {\r",
							"        rval = rval.substr(0, candidate) +\r",
							"          '\\r\\n' + insert + rval.substr(candidate + 1);\r",
							"      }\r",
							"      length = (i - candidate - 1);\r",
							"      candidate = -1;\r",
							"      ++i;\r",
							"    } else if(rval[i] === ' ' || rval[i] === '\\t' || rval[i] === ',') {\r",
							"      candidate = i;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"function ltrim(str) {\r",
							"  return str.replace(/^\\s+/, '');\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 8 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Hash-based Message Authentication Code implementation. Requires a message\r",
							" * digest object that can be obtained, for example, from forge.md.sha1 or\r",
							" * forge.md.md5.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* HMAC API */\r",
							"var hmac = module.exports = forge.hmac = forge.hmac || {};\r",
							"\r",
							"/**\r",
							" * Creates an HMAC object that uses the given message digest object.\r",
							" *\r",
							" * @return an HMAC object.\r",
							" */\r",
							"hmac.create = function() {\r",
							"  // the hmac key to use\r",
							"  var _key = null;\r",
							"\r",
							"  // the message digest to use\r",
							"  var _md = null;\r",
							"\r",
							"  // the inner padding\r",
							"  var _ipadding = null;\r",
							"\r",
							"  // the outer padding\r",
							"  var _opadding = null;\r",
							"\r",
							"  // hmac context\r",
							"  var ctx = {};\r",
							"\r",
							"  /**\r",
							"   * Starts or restarts the HMAC with the given key and message digest.\r",
							"   *\r",
							"   * @param md the message digest to use, null to reuse the previous one,\r",
							"   *           a string to use builtin 'sha1', 'md5', 'sha256'.\r",
							"   * @param key the key to use as a string, array of bytes, byte buffer,\r",
							"   *           or null to reuse the previous key.\r",
							"   */\r",
							"  ctx.start = function(md, key) {\r",
							"    if(md !== null) {\r",
							"      if(typeof md === 'string') {\r",
							"        // create builtin message digest\r",
							"        md = md.toLowerCase();\r",
							"        if(md in forge.md.algorithms) {\r",
							"          _md = forge.md.algorithms[md].create();\r",
							"        } else {\r",
							"          throw new Error('Unknown hash algorithm \"' + md + '\"');\r",
							"        }\r",
							"      } else {\r",
							"        // store message digest\r",
							"        _md = md;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(key === null) {\r",
							"      // reuse previous key\r",
							"      key = _key;\r",
							"    } else {\r",
							"      if(typeof key === 'string') {\r",
							"        // convert string into byte buffer\r",
							"        key = forge.util.createBuffer(key);\r",
							"      } else if(forge.util.isArray(key)) {\r",
							"        // convert byte array into byte buffer\r",
							"        var tmp = key;\r",
							"        key = forge.util.createBuffer();\r",
							"        for(var i = 0; i < tmp.length; ++i) {\r",
							"          key.putByte(tmp[i]);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // if key is longer than blocksize, hash it\r",
							"      var keylen = key.length();\r",
							"      if(keylen > _md.blockLength) {\r",
							"        _md.start();\r",
							"        _md.update(key.bytes());\r",
							"        key = _md.digest();\r",
							"      }\r",
							"\r",
							"      // mix key into inner and outer padding\r",
							"      // ipadding = [0x36 * blocksize] ^ key\r",
							"      // opadding = [0x5C * blocksize] ^ key\r",
							"      _ipadding = forge.util.createBuffer();\r",
							"      _opadding = forge.util.createBuffer();\r",
							"      keylen = key.length();\r",
							"      for(var i = 0; i < keylen; ++i) {\r",
							"        var tmp = key.at(i);\r",
							"        _ipadding.putByte(0x36 ^ tmp);\r",
							"        _opadding.putByte(0x5C ^ tmp);\r",
							"      }\r",
							"\r",
							"      // if key is shorter than blocksize, add additional padding\r",
							"      if(keylen < _md.blockLength) {\r",
							"        var tmp = _md.blockLength - keylen;\r",
							"        for(var i = 0; i < tmp; ++i) {\r",
							"          _ipadding.putByte(0x36);\r",
							"          _opadding.putByte(0x5C);\r",
							"        }\r",
							"      }\r",
							"      _key = key;\r",
							"      _ipadding = _ipadding.bytes();\r",
							"      _opadding = _opadding.bytes();\r",
							"    }\r",
							"\r",
							"    // digest is done like so: hash(opadding | hash(ipadding | message))\r",
							"\r",
							"    // prepare to do inner hash\r",
							"    // hash(ipadding | message)\r",
							"    _md.start();\r",
							"    _md.update(_ipadding);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Updates the HMAC with the given message bytes.\r",
							"   *\r",
							"   * @param bytes the bytes to update with.\r",
							"   */\r",
							"  ctx.update = function(bytes) {\r",
							"    _md.update(bytes);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the Message Authentication Code (MAC).\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  ctx.getMac = function() {\r",
							"    // digest is done like so: hash(opadding | hash(ipadding | message))\r",
							"    // here we do the outer hashing\r",
							"    var inner = _md.digest().bytes();\r",
							"    _md.start();\r",
							"    _md.update(_opadding);\r",
							"    _md.update(inner);\r",
							"    return _md.digest();\r",
							"  };\r",
							"  // alias for getMac\r",
							"  ctx.digest = ctx.getMac;\r",
							"\r",
							"  return ctx;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 9 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2015 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var sha1 = module.exports = forge.sha1 = forge.sha1 || {};\r",
							"forge.md.sha1 = forge.md.algorithms.sha1 = sha1;\r",
							"\r",
							"/**\r",
							" * Creates a SHA-1 message digest object.\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"sha1.create = function() {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  // SHA-1 state contains five 32-bit integers\r",
							"  var _state = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for word storage\r",
							"  var _w = new Array(80);\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    algorithm: 'sha1',\r",
							"    blockLength: 64,\r",
							"    digestLength: 20,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 8\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength64 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength64 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _state = {\r",
							"      h0: 0x67452301,\r",
							"      h1: 0xEFCDAB89,\r",
							"      h2: 0x98BADCFE,\r",
							"      h3: 0x10325476,\r",
							"      h4: 0xC3D2E1F0\r",
							"    };\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = ((len[1] / 0x100000000) >>> 0);\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_state, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"   /**\r",
							"    * Produces the digest.\r",
							"    *\r",
							"    * @return a byte buffer containing the digest value.\r",
							"    */\r",
							"   md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate SHA-1 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 448 mod 512. In other words,\r",
							"    the data to be digested must be a multiple of 512 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 8 bytes (64\r",
							"    bits), that means that the last segment of the data must have 56 bytes\r",
							"    (448 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 448 mod 512 because\r",
							"    512 - 128 = 448.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 448 mod 512, then 512 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in big-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry from next int\r",
							"    var next, carry;\r",
							"    var bits = md.fullMessageLength[0] * 8;\r",
							"    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\r",
							"      next = md.fullMessageLength[i + 1] * 8;\r",
							"      carry = (next / 0x100000000) >>> 0;\r",
							"      bits += carry;\r",
							"      finalBlock.putInt32(bits >>> 0);\r",
							"      bits = next >>> 0;\r",
							"    }\r",
							"    finalBlock.putInt32(bits);\r",
							"\r",
							"    var s2 = {\r",
							"      h0: _state.h0,\r",
							"      h1: _state.h1,\r",
							"      h2: _state.h2,\r",
							"      h3: _state.h3,\r",
							"      h4: _state.h4\r",
							"    };\r",
							"    _update(s2, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    rval.putInt32(s2.h0);\r",
							"    rval.putInt32(s2.h1);\r",
							"    rval.putInt32(s2.h2);\r",
							"    rval.putInt32(s2.h3);\r",
							"    rval.putInt32(s2.h4);\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// sha-1 padding bytes not initialized yet\r",
							"var _padding = null;\r",
							"var _initialized = false;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a SHA-1 state with the given byte buffer.\r",
							" *\r",
							" * @param s the SHA-1 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (64 byte) chunks\r",
							"  var t, a, b, c, d, e, f, i;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 64) {\r",
							"    // the w array will be populated with sixteen 32-bit big-endian words\r",
							"    // and then extended into 80 32-bit words according to SHA-1 algorithm\r",
							"    // and for 32-79 using Max Locktyukhin's optimization\r",
							"\r",
							"    // initialize hash value for this chunk\r",
							"    a = s.h0;\r",
							"    b = s.h1;\r",
							"    c = s.h2;\r",
							"    d = s.h3;\r",
							"    e = s.h4;\r",
							"\r",
							"    // round 1\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      t = bytes.getInt32();\r",
							"      w[i] = t;\r",
							"      f = d ^ (b & (c ^ d));\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    for(; i < 20; ++i) {\r",
							"      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);\r",
							"      t = (t << 1) | (t >>> 31);\r",
							"      w[i] = t;\r",
							"      f = d ^ (b & (c ^ d));\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    // round 2\r",
							"    for(; i < 32; ++i) {\r",
							"      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);\r",
							"      t = (t << 1) | (t >>> 31);\r",
							"      w[i] = t;\r",
							"      f = b ^ c ^ d;\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    for(; i < 40; ++i) {\r",
							"      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\r",
							"      t = (t << 2) | (t >>> 30);\r",
							"      w[i] = t;\r",
							"      f = b ^ c ^ d;\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    // round 3\r",
							"    for(; i < 60; ++i) {\r",
							"      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\r",
							"      t = (t << 2) | (t >>> 30);\r",
							"      w[i] = t;\r",
							"      f = (b & c) | (d & (b ^ c));\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"    // round 4\r",
							"    for(; i < 80; ++i) {\r",
							"      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\r",
							"      t = (t << 2) | (t >>> 30);\r",
							"      w[i] = t;\r",
							"      f = b ^ c ^ d;\r",
							"      t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;\r",
							"      e = d;\r",
							"      d = c;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      c = ((b << 30) | (b >>> 2)) >>> 0;\r",
							"      b = a;\r",
							"      a = t;\r",
							"    }\r",
							"\r",
							"    // update hash state\r",
							"    s.h0 = (s.h0 + a) | 0;\r",
							"    s.h1 = (s.h1 + b) | 0;\r",
							"    s.h2 = (s.h2 + c) | 0;\r",
							"    s.h3 = (s.h3 + d) | 0;\r",
							"    s.h4 = (s.h4 + e) | 0;\r",
							"\r",
							"    len -= 64;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 10 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * DES (Data Encryption Standard) implementation.\r",
							" *\r",
							" * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.\r",
							" * It is based on the BSD-licensed implementation by Paul Tero:\r",
							" *\r",
							" * Paul Tero, July 2001\r",
							" * http://www.tero.co.uk/des/\r",
							" *\r",
							" * Optimised for performance with large blocks by Michael Hayworth, November 2001\r",
							" * http://www.netdealing.com\r",
							" *\r",
							" * THIS SOFTWARE IS PROVIDED \"AS IS\" AND\r",
							" * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r",
							" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r",
							" * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\r",
							" * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r",
							" * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\r",
							" * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\r",
							" * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r",
							" * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r",
							" * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r",
							" * SUCH DAMAGE.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" * Copyright (c) 2012-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(13);\r",
							"__webpack_require__(18);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* DES API */\r",
							"module.exports = forge.des = forge.des || {};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('DES-<mode>', key);\r",
							" * cipher.start({iv: iv});\r",
							" *\r",
							" * Creates an DES cipher object to encrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as binary-encoded strings of bytes or\r",
							" * byte buffers.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC' if IV is\r",
							" *          given, 'ECB' if null).\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.startEncrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: false,\r",
							"    mode: mode || (iv === null ? 'ECB' : 'CBC')\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var cipher = forge.cipher.createCipher('DES-<mode>', key);\r",
							" *\r",
							" * Creates an DES cipher object to encrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a binary-encoded string of bytes or a byte buffer.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.createEncryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: false,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\r",
							" * decipher.start({iv: iv});\r",
							" *\r",
							" * Creates an DES cipher object to decrypt data using the given symmetric key.\r",
							" * The output will be stored in the 'output' member of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as binary-encoded strings of bytes or\r",
							" * byte buffers.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" * @param mode the cipher mode to use (default: 'CBC' if IV is\r",
							" *          given, 'ECB' if null).\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.startDecrypting = function(key, iv, output, mode) {\r",
							"  var cipher = _createCipher({\r",
							"    key: key,\r",
							"    output: output,\r",
							"    decrypt: true,\r",
							"    mode: mode || (iv === null ? 'ECB' : 'CBC')\r",
							"  });\r",
							"  cipher.start(iv);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\r",
							" *\r",
							" * Creates an DES cipher object to decrypt data using the given symmetric key.\r",
							" *\r",
							" * The key may be given as a binary-encoded string of bytes or a byte buffer.\r",
							" *\r",
							" * @param key the symmetric key to use (64 or 192 bits).\r",
							" * @param mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.des.createDecryptionCipher = function(key, mode) {\r",
							"  return _createCipher({\r",
							"    key: key,\r",
							"    output: null,\r",
							"    decrypt: true,\r",
							"    mode: mode\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new DES cipher algorithm object.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" * @param mode the mode factory function.\r",
							" *\r",
							" * @return the DES algorithm object.\r",
							" */\r",
							"forge.des.Algorithm = function(name, mode) {\r",
							"  var self = this;\r",
							"  self.name = name;\r",
							"  self.mode = new mode({\r",
							"    blockSize: 8,\r",
							"    cipher: {\r",
							"      encrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._keys, inBlock, outBlock, false);\r",
							"      },\r",
							"      decrypt: function(inBlock, outBlock) {\r",
							"        return _updateBlock(self._keys, inBlock, outBlock, true);\r",
							"      }\r",
							"    }\r",
							"  });\r",
							"  self._init = false;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Initializes this DES algorithm by expanding its key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the key to use with this algorithm.\r",
							" *          decrypt true if the algorithm should be initialized for decryption,\r",
							" *            false for encryption.\r",
							" */\r",
							"forge.des.Algorithm.prototype.initialize = function(options) {\r",
							"  if(this._init) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  var key = forge.util.createBuffer(options.key);\r",
							"  if(this.name.indexOf('3DES') === 0) {\r",
							"    if(key.length() !== 24) {\r",
							"      throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // do key expansion to 16 or 48 subkeys (single or triple DES)\r",
							"  this._keys = _createKeys(key);\r",
							"  this._init = true;\r",
							"};\r",
							"\r",
							"/** Register DES algorithms **/\r",
							"\r",
							"registerAlgorithm('DES-ECB', forge.cipher.modes.ecb);\r",
							"registerAlgorithm('DES-CBC', forge.cipher.modes.cbc);\r",
							"registerAlgorithm('DES-CFB', forge.cipher.modes.cfb);\r",
							"registerAlgorithm('DES-OFB', forge.cipher.modes.ofb);\r",
							"registerAlgorithm('DES-CTR', forge.cipher.modes.ctr);\r",
							"\r",
							"registerAlgorithm('3DES-ECB', forge.cipher.modes.ecb);\r",
							"registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);\r",
							"registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);\r",
							"registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);\r",
							"registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);\r",
							"\r",
							"function registerAlgorithm(name, mode) {\r",
							"  var factory = function() {\r",
							"    return new forge.des.Algorithm(name, mode);\r",
							"  };\r",
							"  forge.cipher.registerAlgorithm(name, factory);\r",
							"}\r",
							"\r",
							"/** DES implementation **/\r",
							"\r",
							"var spfunction1 = [0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];\r",
							"var spfunction2 = [-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];\r",
							"var spfunction3 = [0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];\r",
							"var spfunction4 = [0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];\r",
							"var spfunction5 = [0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];\r",
							"var spfunction6 = [0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];\r",
							"var spfunction7 = [0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];\r",
							"var spfunction8 = [0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];\r",
							"\r",
							"/**\r",
							" * Create necessary sub keys.\r",
							" *\r",
							" * @param key the 64-bit or 192-bit key.\r",
							" *\r",
							" * @return the expanded keys.\r",
							" */\r",
							"function _createKeys(key) {\r",
							"  var pc2bytes0  = [0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],\r",
							"      pc2bytes1  = [0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],\r",
							"      pc2bytes2  = [0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],\r",
							"      pc2bytes3  = [0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],\r",
							"      pc2bytes4  = [0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],\r",
							"      pc2bytes5  = [0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],\r",
							"      pc2bytes6  = [0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],\r",
							"      pc2bytes7  = [0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],\r",
							"      pc2bytes8  = [0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],\r",
							"      pc2bytes9  = [0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],\r",
							"      pc2bytes10 = [0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],\r",
							"      pc2bytes11 = [0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],\r",
							"      pc2bytes12 = [0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],\r",
							"      pc2bytes13 = [0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];\r",
							"\r",
							"  // how many iterations (1 for des, 3 for triple des)\r",
							"  // changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys\r",
							"  var iterations = key.length() > 8 ? 3 : 1;\r",
							"\r",
							"  // stores the return keys\r",
							"  var keys = [];\r",
							"\r",
							"  // now define the left shifts which need to be done\r",
							"  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];\r",
							"\r",
							"  var n = 0, tmp;\r",
							"  for(var j = 0; j < iterations; j++) {\r",
							"    var left = key.getInt32();\r",
							"    var right = key.getInt32();\r",
							"\r",
							"    tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 4);\r",
							"\r",
							"    tmp = ((right >>> -16) ^ left) & 0x0000ffff;\r",
							"    left ^= tmp;\r",
							"    right ^= (tmp << -16);\r",
							"\r",
							"    tmp = ((left >>> 2) ^ right) & 0x33333333;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 2);\r",
							"\r",
							"    tmp = ((right >>> -16) ^ left) & 0x0000ffff;\r",
							"    left ^= tmp;\r",
							"    right ^= (tmp << -16);\r",
							"\r",
							"    tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 1);\r",
							"\r",
							"    tmp = ((right >>> 8) ^ left) & 0x00ff00ff;\r",
							"    left ^= tmp;\r",
							"    right ^= (tmp << 8);\r",
							"\r",
							"    tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"    right ^= tmp;\r",
							"    left ^= (tmp << 1);\r",
							"\r",
							"    // right needs to be shifted and OR'd with last four bits of left\r",
							"    tmp = (left << 8) | ((right >>> 20) & 0x000000f0);\r",
							"\r",
							"    // left needs to be put upside down\r",
							"    left = ((right << 24) | ((right << 8) & 0xff0000) |\r",
							"      ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0));\r",
							"    right = tmp;\r",
							"\r",
							"    // now go through and perform these shifts on the left and right keys\r",
							"    for(var i = 0; i < shifts.length; ++i) {\r",
							"      //shift the keys either one or two bits to the left\r",
							"      if(shifts[i]) {\r",
							"        left = (left << 2) | (left >>> 26);\r",
							"        right = (right << 2) | (right >>> 26);\r",
							"      } else {\r",
							"        left = (left << 1) | (left >>> 27);\r",
							"        right = (right << 1) | (right >>> 27);\r",
							"      }\r",
							"      left &= -0xf;\r",
							"      right &= -0xf;\r",
							"\r",
							"      // now apply PC-2, in such a way that E is easier when encrypting or\r",
							"      // decrypting this conversion will look like PC-2 except only the last 6\r",
							"      // bits of each byte are used rather than 48 consecutive bits and the\r",
							"      // order of lines will be according to how the S selection functions will\r",
							"      // be applied: S2, S4, S6, S8, S1, S3, S5, S7\r",
							"      var lefttmp = (\r",
							"        pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf] |\r",
							"        pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf] |\r",
							"        pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf] |\r",
							"        pc2bytes6[(left >>> 4) & 0xf]);\r",
							"      var righttmp = (\r",
							"        pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf] |\r",
							"        pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf] |\r",
							"        pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf] |\r",
							"        pc2bytes13[(right >>> 4) & 0xf]);\r",
							"      tmp = ((righttmp >>> 16) ^ lefttmp) & 0x0000ffff;\r",
							"      keys[n++] = lefttmp ^ tmp;\r",
							"      keys[n++] = righttmp ^ (tmp << 16);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return keys;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a single block (1 byte) using DES. The update will either\r",
							" * encrypt or decrypt the block.\r",
							" *\r",
							" * @param keys the expanded keys.\r",
							" * @param input the input block (an array of 32-bit words).\r",
							" * @param output the updated output block.\r",
							" * @param decrypt true to decrypt the block, false to encrypt it.\r",
							" */\r",
							"function _updateBlock(keys, input, output, decrypt) {\r",
							"  // set up loops for single or triple DES\r",
							"  var iterations = keys.length === 32 ? 3 : 9;\r",
							"  var looping;\r",
							"  if(iterations === 3) {\r",
							"    looping = decrypt ? [30, -2, -2] : [0, 32, 2];\r",
							"  } else {\r",
							"    looping = (decrypt ?\r",
							"      [94, 62, -2, 32, 64, 2, 30, -2, -2] :\r",
							"      [0, 32, 2, 62, 30, -2, 64, 96, 2]);\r",
							"  }\r",
							"\r",
							"  var tmp;\r",
							"\r",
							"  var left = input[0];\r",
							"  var right = input[1];\r",
							"\r",
							"  // first each 64 bit chunk of the message must be permuted according to IP\r",
							"  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 4);\r",
							"\r",
							"  tmp = ((left >>> 16) ^ right) & 0x0000ffff;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 16);\r",
							"\r",
							"  tmp = ((right >>> 2) ^ left) & 0x33333333;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 2);\r",
							"\r",
							"  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 8);\r",
							"\r",
							"  tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 1);\r",
							"\r",
							"  // rotate left 1 bit\r",
							"  left = ((left << 1) | (left >>> 31));\r",
							"  right = ((right << 1) | (right >>> 31));\r",
							"\r",
							"  for(var j = 0; j < iterations; j += 3) {\r",
							"    var endloop = looping[j + 1];\r",
							"    var loopinc = looping[j + 2];\r",
							"\r",
							"    // now go through and perform the encryption or decryption\r",
							"    for(var i = looping[j]; i != endloop; i += loopinc) {\r",
							"      var right1 = right ^ keys[i];\r",
							"      var right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];\r",
							"\r",
							"      // passing these bytes through the S selection functions\r",
							"      tmp = left;\r",
							"      left = right;\r",
							"      right = tmp ^ (\r",
							"        spfunction2[(right1 >>> 24) & 0x3f] |\r",
							"        spfunction4[(right1 >>> 16) & 0x3f] |\r",
							"        spfunction6[(right1 >>>  8) & 0x3f] |\r",
							"        spfunction8[right1 & 0x3f] |\r",
							"        spfunction1[(right2 >>> 24) & 0x3f] |\r",
							"        spfunction3[(right2 >>> 16) & 0x3f] |\r",
							"        spfunction5[(right2 >>>  8) & 0x3f] |\r",
							"        spfunction7[right2 & 0x3f]);\r",
							"    }\r",
							"    // unreverse left and right\r",
							"    tmp = left;\r",
							"    left = right;\r",
							"    right = tmp;\r",
							"  }\r",
							"\r",
							"  // rotate right 1 bit\r",
							"  left = ((left >>> 1) | (left << 31));\r",
							"  right = ((right >>> 1) | (right << 31));\r",
							"\r",
							"  // now perform IP-1, which is IP in the opposite direction\r",
							"  tmp = ((left >>> 1) ^ right) & 0x55555555;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 1);\r",
							"\r",
							"  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 8);\r",
							"\r",
							"  tmp = ((right >>> 2) ^ left) & 0x33333333;\r",
							"  left ^= tmp;\r",
							"  right ^= (tmp << 2);\r",
							"\r",
							"  tmp = ((left >>> 16) ^ right) & 0x0000ffff;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 16);\r",
							"\r",
							"  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\r",
							"  right ^= tmp;\r",
							"  left ^= (tmp << 4);\r",
							"\r",
							"  output[0] = left;\r",
							"  output[1] = right;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Deprecated. Instead, use:\r",
							" *\r",
							" * forge.cipher.createCipher('DES-<mode>', key);\r",
							" * forge.cipher.createDecipher('DES-<mode>', key);\r",
							" *\r",
							" * Creates a deprecated DES cipher object. This object's mode will default to\r",
							" * CBC (cipher-block-chaining).\r",
							" *\r",
							" * The key may be given as a binary-encoded string of bytes or a byte buffer.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          key the symmetric key to use (64 or 192 bits).\r",
							" *          output the buffer to write to.\r",
							" *          decrypt true for decryption, false for encryption.\r",
							" *          mode the cipher mode to use (default: 'CBC').\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"function _createCipher(options) {\r",
							"  options = options || {};\r",
							"  var mode = (options.mode || 'CBC').toUpperCase();\r",
							"  var algorithm = 'DES-' + mode;\r",
							"\r",
							"  var cipher;\r",
							"  if(options.decrypt) {\r",
							"    cipher = forge.cipher.createDecipher(algorithm, options.key);\r",
							"  } else {\r",
							"    cipher = forge.cipher.createCipher(algorithm, options.key);\r",
							"  }\r",
							"\r",
							"  // backwards compatible start API\r",
							"  var start = cipher.start;\r",
							"  cipher.start = function(iv, options) {\r",
							"    // backwards compatibility: support second arg as output buffer\r",
							"    var output = null;\r",
							"    if(options instanceof forge.util.ByteBuffer) {\r",
							"      output = options;\r",
							"      options = {};\r",
							"    }\r",
							"    options = options || {};\r",
							"    options.output = output;\r",
							"    options.iv = iv;\r",
							"    start.call(cipher, options);\r",
							"  };\r",
							"\r",
							"  return cipher;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 11 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of basic RSA algorithms.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * The only algorithm currently supported for PKI is RSA.\r",
							" *\r",
							" * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo\r",
							" * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier\r",
							" * and a subjectPublicKey of type bit string.\r",
							" *\r",
							" * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r",
							" * for the algorithm, if any. In the case of RSA, there aren't any.\r",
							" *\r",
							" * SubjectPublicKeyInfo ::= SEQUENCE {\r",
							" *   algorithm AlgorithmIdentifier,\r",
							" *   subjectPublicKey BIT STRING\r",
							" * }\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *   algorithm OBJECT IDENTIFIER,\r",
							" *   parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * For an RSA public key, the subjectPublicKey is:\r",
							" *\r",
							" * RSAPublicKey ::= SEQUENCE {\r",
							" *   modulus            INTEGER,    -- n\r",
							" *   publicExponent     INTEGER     -- e\r",
							" * }\r",
							" *\r",
							" * PrivateKeyInfo ::= SEQUENCE {\r",
							" *   version                   Version,\r",
							" *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,\r",
							" *   privateKey                PrivateKey,\r",
							" *   attributes           [0]  IMPLICIT Attributes OPTIONAL\r",
							" * }\r",
							" *\r",
							" * Version ::= INTEGER\r",
							" * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" * PrivateKey ::= OCTET STRING\r",
							" * Attributes ::= SET OF Attribute\r",
							" *\r",
							" * An RSA private key as the following structure:\r",
							" *\r",
							" * RSAPrivateKey ::= SEQUENCE {\r",
							" *   version Version,\r",
							" *   modulus INTEGER, -- n\r",
							" *   publicExponent INTEGER, -- e\r",
							" *   privateExponent INTEGER, -- d\r",
							" *   prime1 INTEGER, -- p\r",
							" *   prime2 INTEGER, -- q\r",
							" *   exponent1 INTEGER, -- d mod (p-1)\r",
							" *   exponent2 INTEGER, -- d mod (q-1)\r",
							" *   coefficient INTEGER -- (inverse of q) mod p\r",
							" * }\r",
							" *\r",
							" * Version ::= INTEGER\r",
							" *\r",
							" * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(12);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(26);\r",
							"__webpack_require__(27);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(1);\r",
							"\r",
							"if(typeof BigInteger === 'undefined') {\r",
							"  var BigInteger = forge.jsbn.BigInteger;\r",
							"}\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/*\r",
							" * RSA encryption and decryption, see RFC 2313.\r",
							" */\r",
							"forge.pki = forge.pki || {};\r",
							"module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};\r",
							"var pki = forge.pki;\r",
							"\r",
							"// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\r",
							"var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\r",
							"\r",
							"// validator for a PrivateKeyInfo structure\r",
							"var privateKeyValidator = {\r",
							"  // PrivateKeyInfo\r",
							"  name: 'PrivateKeyInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    // Version (INTEGER)\r",
							"    name: 'PrivateKeyInfo.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyVersion'\r",
							"  }, {\r",
							"    // privateKeyAlgorithm\r",
							"    name: 'PrivateKeyInfo.privateKeyAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'AlgorithmIdentifier.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'privateKeyOid'\r",
							"    }]\r",
							"  }, {\r",
							"    // PrivateKey\r",
							"    name: 'PrivateKeyInfo',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'privateKey'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for an RSA private key\r",
							"var rsaPrivateKeyValidator = {\r",
							"  // RSAPrivateKey\r",
							"  name: 'RSAPrivateKey',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    // Version (INTEGER)\r",
							"    name: 'RSAPrivateKey.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyVersion'\r",
							"  }, {\r",
							"    // modulus (n)\r",
							"    name: 'RSAPrivateKey.modulus',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyModulus'\r",
							"  }, {\r",
							"    // publicExponent (e)\r",
							"    name: 'RSAPrivateKey.publicExponent',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPublicExponent'\r",
							"  }, {\r",
							"    // privateExponent (d)\r",
							"    name: 'RSAPrivateKey.privateExponent',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPrivateExponent'\r",
							"  }, {\r",
							"    // prime1 (p)\r",
							"    name: 'RSAPrivateKey.prime1',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPrime1'\r",
							"  }, {\r",
							"    // prime2 (q)\r",
							"    name: 'RSAPrivateKey.prime2',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyPrime2'\r",
							"  }, {\r",
							"    // exponent1 (d mod (p-1))\r",
							"    name: 'RSAPrivateKey.exponent1',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyExponent1'\r",
							"  }, {\r",
							"    // exponent2 (d mod (q-1))\r",
							"    name: 'RSAPrivateKey.exponent2',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyExponent2'\r",
							"  }, {\r",
							"    // coefficient ((inverse of q) mod p)\r",
							"    name: 'RSAPrivateKey.coefficient',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'privateKeyCoefficient'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for an RSA public key\r",
							"var rsaPublicKeyValidator = {\r",
							"  // RSAPublicKey\r",
							"  name: 'RSAPublicKey',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    // modulus (n)\r",
							"    name: 'RSAPublicKey.modulus',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'publicKeyModulus'\r",
							"  }, {\r",
							"    // publicExponent (e)\r",
							"    name: 'RSAPublicKey.exponent',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'publicKeyExponent'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for an SubjectPublicKeyInfo structure\r",
							"// Note: Currently only works with an RSA public key\r",
							"var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {\r",
							"  name: 'SubjectPublicKeyInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  captureAsn1: 'subjectPublicKeyInfo',\r",
							"  value: [{\r",
							"    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'AlgorithmIdentifier.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'publicKeyOid'\r",
							"    }]\r",
							"  }, {\r",
							"    // subjectPublicKey\r",
							"    name: 'SubjectPublicKeyInfo.subjectPublicKey',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.BITSTRING,\r",
							"    constructed: false,\r",
							"    value: [{\r",
							"      // RSAPublicKey\r",
							"      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      captureAsn1: 'rsaPublicKey'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Wrap digest in DigestInfo object.\r",
							" *\r",
							" * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.\r",
							" *\r",
							" * DigestInfo ::= SEQUENCE {\r",
							" *   digestAlgorithm DigestAlgorithmIdentifier,\r",
							" *   digest Digest\r",
							" * }\r",
							" *\r",
							" * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" * Digest ::= OCTET STRING\r",
							" *\r",
							" * @param md the message digest object with the hash to sign.\r",
							" *\r",
							" * @return the encoded message (ready for RSA encrytion)\r",
							" */\r",
							"var emsaPkcs1v15encode = function(md) {\r",
							"  // get the oid for the algorithm\r",
							"  var oid;\r",
							"  if(md.algorithm in pki.oids) {\r",
							"    oid = pki.oids[md.algorithm];\r",
							"  } else {\r",
							"    var error = new Error('Unknown message digest algorithm.');\r",
							"    error.algorithm = md.algorithm;\r",
							"    throw error;\r",
							"  }\r",
							"  var oidBytes = asn1.oidToDer(oid).getBytes();\r",
							"\r",
							"  // create the digest info\r",
							"  var digestInfo = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"  var digestAlgorithm = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"  digestAlgorithm.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));\r",
							"  digestAlgorithm.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));\r",
							"  var digest = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\r",
							"    false, md.digest().getBytes());\r",
							"  digestInfo.value.push(digestAlgorithm);\r",
							"  digestInfo.value.push(digest);\r",
							"\r",
							"  // encode digest info\r",
							"  return asn1.toDer(digestInfo).getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Performs x^c mod n (RSA encryption or decryption operation).\r",
							" *\r",
							" * @param x the number to raise and mod.\r",
							" * @param key the key to use.\r",
							" * @param pub true if the key is public, false if private.\r",
							" *\r",
							" * @return the result of x^c mod n.\r",
							" */\r",
							"var _modPow = function(x, key, pub) {\r",
							"  if(pub) {\r",
							"    return x.modPow(key.e, key.n);\r",
							"  }\r",
							"\r",
							"  if(!key.p || !key.q) {\r",
							"    // allow calculation without CRT params (slow)\r",
							"    return x.modPow(key.d, key.n);\r",
							"  }\r",
							"\r",
							"  // pre-compute dP, dQ, and qInv if necessary\r",
							"  if(!key.dP) {\r",
							"    key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));\r",
							"  }\r",
							"  if(!key.dQ) {\r",
							"    key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));\r",
							"  }\r",
							"  if(!key.qInv) {\r",
							"    key.qInv = key.q.modInverse(key.p);\r",
							"  }\r",
							"\r",
							"  /* Chinese remainder theorem (CRT) states:\r",
							"\r",
							"    Suppose n1, n2, ..., nk are positive integers which are pairwise\r",
							"    coprime (n1 and n2 have no common factors other than 1). For any\r",
							"    integers x1, x2, ..., xk there exists an integer x solving the\r",
							"    system of simultaneous congruences (where ~= means modularly\r",
							"    congruent so a ~= b mod n means a mod n = b mod n):\r",
							"\r",
							"    x ~= x1 mod n1\r",
							"    x ~= x2 mod n2\r",
							"    ...\r",
							"    x ~= xk mod nk\r",
							"\r",
							"    This system of congruences has a single simultaneous solution x\r",
							"    between 0 and n - 1. Furthermore, each xk solution and x itself\r",
							"    is congruent modulo the product n = n1*n2*...*nk.\r",
							"    So x1 mod n = x2 mod n = xk mod n = x mod n.\r",
							"\r",
							"    The single simultaneous solution x can be solved with the following\r",
							"    equation:\r",
							"\r",
							"    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\r",
							"\r",
							"    Where x is less than n, xi = x mod ni.\r",
							"\r",
							"    For RSA we are only concerned with k = 2. The modulus n = pq, where\r",
							"    p and q are coprime. The RSA decryption algorithm is:\r",
							"\r",
							"    y = x^d mod n\r",
							"\r",
							"    Given the above:\r",
							"\r",
							"    x1 = x^d mod p\r",
							"    r1 = n/p = q\r",
							"    s1 = q^-1 mod p\r",
							"    x2 = x^d mod q\r",
							"    r2 = n/q = p\r",
							"    s2 = p^-1 mod q\r",
							"\r",
							"    So y = (x1r1s1 + x2r2s2) mod n\r",
							"         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\r",
							"\r",
							"    According to Fermat's Little Theorem, if the modulus P is prime,\r",
							"    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\r",
							"    Since A is not divisible by P it follows that if:\r",
							"    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\r",
							"\r",
							"    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\r",
							"    to calculate). In order to calculate x^d mod p more quickly the\r",
							"    exponent d mod (p - 1) is stored in the RSA private key (the same\r",
							"    is done for x^d mod q). These values are referred to as dP and dQ\r",
							"    respectively. Therefore we now have:\r",
							"\r",
							"    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\r",
							"\r",
							"    Since we'll be reducing x^dP by modulo p (same for q) we can also\r",
							"    reduce x by p (and q respectively) before hand. Therefore, let\r",
							"\r",
							"    xp = ((x mod p)^dP mod p), and\r",
							"    xq = ((x mod q)^dQ mod q), yielding:\r",
							"\r",
							"    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\r",
							"\r",
							"    This can be further reduced to a simple algorithm that only\r",
							"    requires 1 inverse (the q inverse is used) to be used and stored.\r",
							"    The algorithm is called Garner's algorithm. If qInv is the\r",
							"    inverse of q, we simply calculate:\r",
							"\r",
							"    y = (qInv*(xp - xq) mod p) * q + xq\r",
							"\r",
							"    However, there are two further complications. First, we need to\r",
							"    ensure that xp > xq to prevent signed BigIntegers from being used\r",
							"    so we add p until this is true (since we will be mod'ing with\r",
							"    p anyway). Then, there is a known timing attack on algorithms\r",
							"    using the CRT. To mitigate this risk, \"cryptographic blinding\"\r",
							"    should be used. This requires simply generating a random number r\r",
							"    between 0 and n-1 and its inverse and multiplying x by r^e before\r",
							"    calculating y and then multiplying y by r^-1 afterwards. Note that\r",
							"    r must be coprime with n (gcd(r, n) === 1) in order to have an\r",
							"    inverse.\r",
							"  */\r",
							"\r",
							"  // cryptographic blinding\r",
							"  var r;\r",
							"  do {\r",
							"    r = new BigInteger(\r",
							"      forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),\r",
							"      16);\r",
							"  } while(r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));\r",
							"  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);\r",
							"\r",
							"  // calculate xp and xq\r",
							"  var xp = x.mod(key.p).modPow(key.dP, key.p);\r",
							"  var xq = x.mod(key.q).modPow(key.dQ, key.q);\r",
							"\r",
							"  // xp must be larger than xq to avoid signed bit usage\r",
							"  while(xp.compareTo(xq) < 0) {\r",
							"    xp = xp.add(key.p);\r",
							"  }\r",
							"\r",
							"  // do last step\r",
							"  var y = xp.subtract(xq)\r",
							"    .multiply(key.qInv).mod(key.p)\r",
							"    .multiply(key.q).add(xq);\r",
							"\r",
							"  // remove effect of random for cryptographic blinding\r",
							"  y = y.multiply(r.modInverse(key.n)).mod(key.n);\r",
							"\r",
							"  return y;\r",
							"};\r",
							"\r",
							"/**\r",
							" * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or\r",
							" * 'encrypt' on a public key object instead.\r",
							" *\r",
							" * Performs RSA encryption.\r",
							" *\r",
							" * The parameter bt controls whether to put padding bytes before the\r",
							" * message passed in. Set bt to either true or false to disable padding\r",
							" * completely (in order to handle e.g. EMSA-PSS encoding seperately before),\r",
							" * signaling whether the encryption operation is a public key operation\r",
							" * (i.e. encrypting data) or not, i.e. private key operation (data signing).\r",
							" *\r",
							" * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01\r",
							" * (for signing) or 0x02 (for encryption). The key operation mode (private\r",
							" * or public) is derived from this flag in that case).\r",
							" *\r",
							" * @param m the message to encrypt as a byte string.\r",
							" * @param key the RSA key to use.\r",
							" * @param bt for PKCS#1 v1.5 padding, the block type to use\r",
							" *   (0x01 for private key, 0x02 for public),\r",
							" *   to disable padding: true = public key, false = private key.\r",
							" *\r",
							" * @return the encrypted bytes as a string.\r",
							" */\r",
							"pki.rsa.encrypt = function(m, key, bt) {\r",
							"  var pub = bt;\r",
							"  var eb;\r",
							"\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  if(bt !== false && bt !== true) {\r",
							"    // legacy, default to PKCS#1 v1.5 padding\r",
							"    pub = (bt === 0x02);\r",
							"    eb = _encodePkcs1_v1_5(m, key, bt);\r",
							"  } else {\r",
							"    eb = forge.util.createBuffer();\r",
							"    eb.putBytes(m);\r",
							"  }\r",
							"\r",
							"  // load encryption block as big integer 'x'\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var x = new BigInteger(eb.toHex(), 16);\r",
							"\r",
							"  // do RSA encryption\r",
							"  var y = _modPow(x, key, pub);\r",
							"\r",
							"  // convert y into the encrypted data byte string, if y is shorter in\r",
							"  // bytes than k, then prepend zero bytes to fill up ed\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var yhex = y.toString(16);\r",
							"  var ed = forge.util.createBuffer();\r",
							"  var zeros = k - Math.ceil(yhex.length / 2);\r",
							"  while(zeros > 0) {\r",
							"    ed.putByte(0x00);\r",
							"    --zeros;\r",
							"  }\r",
							"  ed.putBytes(forge.util.hexToBytes(yhex));\r",
							"  return ed.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or\r",
							" * 'verify' on a public key object instead.\r",
							" *\r",
							" * Performs RSA decryption.\r",
							" *\r",
							" * The parameter ml controls whether to apply PKCS#1 v1.5 padding\r",
							" * or not.  Set ml = false to disable padding removal completely\r",
							" * (in order to handle e.g. EMSA-PSS later on) and simply pass back\r",
							" * the RSA encryption block.\r",
							" *\r",
							" * @param ed the encrypted data to decrypt in as a byte string.\r",
							" * @param key the RSA key to use.\r",
							" * @param pub true for a public key operation, false for private.\r",
							" * @param ml the message length, if known, false to disable padding.\r",
							" *\r",
							" * @return the decrypted message as a byte string.\r",
							" */\r",
							"pki.rsa.decrypt = function(ed, key, pub, ml) {\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  // error if the length of the encrypted data ED is not k\r",
							"  if(ed.length !== k) {\r",
							"    var error = new Error('Encrypted message length is invalid.');\r",
							"    error.length = ed.length;\r",
							"    error.expected = k;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // convert encrypted data into a big integer\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);\r",
							"\r",
							"  // y must be less than the modulus or it wasn't the result of\r",
							"  // a previous mod operation (encryption) using that modulus\r",
							"  if(y.compareTo(key.n) >= 0) {\r",
							"    throw new Error('Encrypted message is invalid.');\r",
							"  }\r",
							"\r",
							"  // do RSA decryption\r",
							"  var x = _modPow(y, key, pub);\r",
							"\r",
							"  // create the encryption block, if x is shorter in bytes than k, then\r",
							"  // prepend zero bytes to fill up eb\r",
							"  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\r",
							"  var xhex = x.toString(16);\r",
							"  var eb = forge.util.createBuffer();\r",
							"  var zeros = k - Math.ceil(xhex.length / 2);\r",
							"  while(zeros > 0) {\r",
							"    eb.putByte(0x00);\r",
							"    --zeros;\r",
							"  }\r",
							"  eb.putBytes(forge.util.hexToBytes(xhex));\r",
							"\r",
							"  if(ml !== false) {\r",
							"    // legacy, default to PKCS#1 v1.5 padding\r",
							"    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);\r",
							"  }\r",
							"\r",
							"  // return message\r",
							"  return eb.getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RSA key-pair generation state object. It is used to allow\r",
							" * key-generation to be performed in steps. It also allows for a UI to\r",
							" * display progress updates.\r",
							" *\r",
							" * @param bits the size for the private key in bits, defaults to 2048.\r",
							" * @param e the public exponent to use, defaults to 65537 (0x10001).\r",
							" * @param [options] the options to use.\r",
							" *          prng a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" *          algorithm the algorithm to use (default: 'PRIMEINC').\r",
							" *\r",
							" * @return the state object to use to generate the key-pair.\r",
							" */\r",
							"pki.rsa.createKeyPairGenerationState = function(bits, e, options) {\r",
							"  // TODO: migrate step-based prime generation code to forge.prime\r",
							"\r",
							"  // set default bits\r",
							"  if(typeof(bits) === 'string') {\r",
							"    bits = parseInt(bits, 10);\r",
							"  }\r",
							"  bits = bits || 2048;\r",
							"\r",
							"  // create prng with api that matches BigInteger secure random\r",
							"  options = options || {};\r",
							"  var prng = options.prng || forge.random;\r",
							"  var rng = {\r",
							"    // x is an array to fill with bytes\r",
							"    nextBytes: function(x) {\r",
							"      var b = prng.getBytesSync(x.length);\r",
							"      for(var i = 0; i < x.length; ++i) {\r",
							"        x[i] = b.charCodeAt(i);\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  var algorithm = options.algorithm || 'PRIMEINC';\r",
							"\r",
							"  // create PRIMEINC algorithm state\r",
							"  var rval;\r",
							"  if(algorithm === 'PRIMEINC') {\r",
							"    rval = {\r",
							"      algorithm: algorithm,\r",
							"      state: 0,\r",
							"      bits: bits,\r",
							"      rng: rng,\r",
							"      eInt: e || 65537,\r",
							"      e: new BigInteger(null),\r",
							"      p: null,\r",
							"      q: null,\r",
							"      qBits: bits >> 1,\r",
							"      pBits: bits - (bits >> 1),\r",
							"      pqState: 0,\r",
							"      num: null,\r",
							"      keys: null\r",
							"    };\r",
							"    rval.e.fromInt(rval.eInt);\r",
							"  } else {\r",
							"    throw new Error('Invalid key generation algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Attempts to runs the key-generation algorithm for at most n seconds\r",
							" * (approximately) using the given state. When key-generation has completed,\r",
							" * the keys will be stored in state.keys.\r",
							" *\r",
							" * To use this function to update a UI while generating a key or to prevent\r",
							" * causing browser lockups/warnings, set \"n\" to a value other than 0. A\r",
							" * simple pattern for generating a key and showing a progress indicator is:\r",
							" *\r",
							" * var state = pki.rsa.createKeyPairGenerationState(2048);\r",
							" * var step = function() {\r",
							" *   // step key-generation, run algorithm for 100 ms, repeat\r",
							" *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {\r",
							" *     setTimeout(step, 1);\r",
							" *   } else {\r",
							" *     // key-generation complete\r",
							" *     // TODO: turn off progress indicator here\r",
							" *     // TODO: use the generated key-pair in \"state.keys\"\r",
							" *   }\r",
							" * };\r",
							" * // TODO: turn on progress indicator here\r",
							" * setTimeout(step, 0);\r",
							" *\r",
							" * @param state the state to use.\r",
							" * @param n the maximum number of milliseconds to run the algorithm for, 0\r",
							" *          to run the algorithm to completion.\r",
							" *\r",
							" * @return true if the key-generation completed, false if not.\r",
							" */\r",
							"pki.rsa.stepKeyPairGenerationState = function(state, n) {\r",
							"  // set default algorithm if not set\r",
							"  if(!('algorithm' in state)) {\r",
							"    state.algorithm = 'PRIMEINC';\r",
							"  }\r",
							"\r",
							"  // TODO: migrate step-based prime generation code to forge.prime\r",
							"  // TODO: abstract as PRIMEINC algorithm\r",
							"\r",
							"  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)\r",
							"  // with some minor optimizations and designed to run in steps\r",
							"\r",
							"  // local state vars\r",
							"  var THIRTY = new BigInteger(null);\r",
							"  THIRTY.fromInt(30);\r",
							"  var deltaIdx = 0;\r",
							"  var op_or = function(x, y) { return x|y; };\r",
							"\r",
							"  // keep stepping until time limit is reached or done\r",
							"  var t1 = +new Date();\r",
							"  var t2;\r",
							"  var total = 0;\r",
							"  while(state.keys === null && (n <= 0 || total < n)) {\r",
							"    // generate p or q\r",
							"    if(state.state === 0) {\r",
							"      /* Note: All primes are of the form:\r",
							"\r",
							"        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i\r",
							"\r",
							"        When we generate a random number, we always align it at 30k + 1. Each\r",
							"        time the number is determined not to be prime we add to get to the\r",
							"        next 'i', eg: if the number was at 30k + 1 we add 6. */\r",
							"      var bits = (state.p === null) ? state.pBits : state.qBits;\r",
							"      var bits1 = bits - 1;\r",
							"\r",
							"      // get a random number\r",
							"      if(state.pqState === 0) {\r",
							"        state.num = new BigInteger(bits, state.rng);\r",
							"        // force MSB set\r",
							"        if(!state.num.testBit(bits1)) {\r",
							"          state.num.bitwiseTo(\r",
							"            BigInteger.ONE.shiftLeft(bits1), op_or, state.num);\r",
							"        }\r",
							"        // align number on 30k+1 boundary\r",
							"        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);\r",
							"        deltaIdx = 0;\r",
							"\r",
							"        ++state.pqState;\r",
							"      } else if(state.pqState === 1) {\r",
							"        // try to make the number a prime\r",
							"        if(state.num.bitLength() > bits) {\r",
							"          // overflow, try again\r",
							"          state.pqState = 0;\r",
							"          // do primality test\r",
							"        } else if(state.num.isProbablePrime(\r",
							"          _getMillerRabinTests(state.num.bitLength()))) {\r",
							"          ++state.pqState;\r",
							"        } else {\r",
							"          // get next potential prime\r",
							"          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\r",
							"        }\r",
							"      } else if(state.pqState === 2) {\r",
							"        // ensure number is coprime with e\r",
							"        state.pqState =\r",
							"          (state.num.subtract(BigInteger.ONE).gcd(state.e)\r",
							"          .compareTo(BigInteger.ONE) === 0) ? 3 : 0;\r",
							"      } else if(state.pqState === 3) {\r",
							"        // store p or q\r",
							"        state.pqState = 0;\r",
							"        if(state.p === null) {\r",
							"          state.p = state.num;\r",
							"        } else {\r",
							"          state.q = state.num;\r",
							"        }\r",
							"\r",
							"        // advance state if both p and q are ready\r",
							"        if(state.p !== null && state.q !== null) {\r",
							"          ++state.state;\r",
							"        }\r",
							"        state.num = null;\r",
							"      }\r",
							"    } else if(state.state === 1) {\r",
							"      // ensure p is larger than q (swap them if not)\r",
							"      if(state.p.compareTo(state.q) < 0) {\r",
							"        state.num = state.p;\r",
							"        state.p = state.q;\r",
							"        state.q = state.num;\r",
							"      }\r",
							"      ++state.state;\r",
							"    } else if(state.state === 2) {\r",
							"      // compute phi: (p - 1)(q - 1) (Euler's totient function)\r",
							"      state.p1 = state.p.subtract(BigInteger.ONE);\r",
							"      state.q1 = state.q.subtract(BigInteger.ONE);\r",
							"      state.phi = state.p1.multiply(state.q1);\r",
							"      ++state.state;\r",
							"    } else if(state.state === 3) {\r",
							"      // ensure e and phi are coprime\r",
							"      if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {\r",
							"        // phi and e are coprime, advance\r",
							"        ++state.state;\r",
							"      } else {\r",
							"        // phi and e aren't coprime, so generate a new p and q\r",
							"        state.p = null;\r",
							"        state.q = null;\r",
							"        state.state = 0;\r",
							"      }\r",
							"    } else if(state.state === 4) {\r",
							"      // create n, ensure n is has the right number of bits\r",
							"      state.n = state.p.multiply(state.q);\r",
							"\r",
							"      // ensure n is right number of bits\r",
							"      if(state.n.bitLength() === state.bits) {\r",
							"        // success, advance\r",
							"        ++state.state;\r",
							"      } else {\r",
							"        // failed, get new q\r",
							"        state.q = null;\r",
							"        state.state = 0;\r",
							"      }\r",
							"    } else if(state.state === 5) {\r",
							"      // set keys\r",
							"      var d = state.e.modInverse(state.phi);\r",
							"      state.keys = {\r",
							"        privateKey: pki.rsa.setPrivateKey(\r",
							"          state.n, state.e, d, state.p, state.q,\r",
							"          d.mod(state.p1), d.mod(state.q1),\r",
							"          state.q.modInverse(state.p)),\r",
							"        publicKey: pki.rsa.setPublicKey(state.n, state.e)\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // update timing\r",
							"    t2 = +new Date();\r",
							"    total += t2 - t1;\r",
							"    t1 = t2;\r",
							"  }\r",
							"\r",
							"  return state.keys !== null;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Generates an RSA public-private key pair in a single call.\r",
							" *\r",
							" * To generate a key-pair in steps (to allow for progress updates and to\r",
							" * prevent blocking or warnings in slow browsers) then use the key-pair\r",
							" * generation state functions.\r",
							" *\r",
							" * To generate a key-pair asynchronously (either through web-workers, if\r",
							" * available, or by breaking up the work on the main thread), pass a\r",
							" * callback function.\r",
							" *\r",
							" * @param [bits] the size for the private key in bits, defaults to 2048.\r",
							" * @param [e] the public exponent to use, defaults to 65537.\r",
							" * @param [options] options for key-pair generation, if given then 'bits'\r",
							" *          and 'e' must *not* be given:\r",
							" *          bits the size for the private key in bits, (default: 2048).\r",
							" *          e the public exponent to use, (default: 65537 (0x10001)).\r",
							" *          workerScript the worker script URL.\r",
							" *          workers the number of web workers (if supported) to use,\r",
							" *            (default: 2).\r",
							" *          workLoad the size of the work load, ie: number of possible prime\r",
							" *            numbers for each web worker to check per work assignment,\r",
							" *            (default: 100).\r",
							" *          prng a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" *          algorithm the algorithm to use (default: 'PRIMEINC').\r",
							" * @param [callback(err, keypair)] called once the operation completes.\r",
							" *\r",
							" * @return an object with privateKey and publicKey properties.\r",
							" */\r",
							"pki.rsa.generateKeyPair = function(bits, e, options, callback) {\r",
							"  // (bits), (options), (callback)\r",
							"  if(arguments.length === 1) {\r",
							"    if(typeof bits === 'object') {\r",
							"      options = bits;\r",
							"      bits = undefined;\r",
							"    } else if(typeof bits === 'function') {\r",
							"      callback = bits;\r",
							"      bits = undefined;\r",
							"    }\r",
							"  } else if(arguments.length === 2) {\r",
							"    // (bits, e), (bits, options), (bits, callback), (options, callback)\r",
							"    if(typeof bits === 'number') {\r",
							"      if(typeof e === 'function') {\r",
							"        callback = e;\r",
							"        e = undefined;\r",
							"      } else if(typeof e !== 'number') {\r",
							"        options = e;\r",
							"        e = undefined;\r",
							"      }\r",
							"    } else {\r",
							"      options = bits;\r",
							"      callback = e;\r",
							"      bits = undefined;\r",
							"      e = undefined;\r",
							"    }\r",
							"  } else if(arguments.length === 3) {\r",
							"    // (bits, e, options), (bits, e, callback), (bits, options, callback)\r",
							"    if(typeof e === 'number') {\r",
							"      if(typeof options === 'function') {\r",
							"        callback = options;\r",
							"        options = undefined;\r",
							"      }\r",
							"    } else {\r",
							"      callback = options;\r",
							"      options = e;\r",
							"      e = undefined;\r",
							"    }\r",
							"  }\r",
							"  options = options || {};\r",
							"  if(bits === undefined) {\r",
							"    bits = options.bits || 2048;\r",
							"  }\r",
							"  if(e === undefined) {\r",
							"    e = options.e || 0x10001;\r",
							"  }\r",
							"\r",
							"  // if native code is permitted and a callback is given, use native\r",
							"  // key generation code if available and if parameters are acceptable\r",
							"  if(!forge.options.usePureJavaScript && callback &&\r",
							"    bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {\r",
							"    if(_detectSubtleCrypto('generateKey') && _detectSubtleCrypto('exportKey')) {\r",
							"      // use standard native generateKey\r",
							"      return window.crypto.subtle.generateKey({\r",
							"        name: 'RSASSA-PKCS1-v1_5',\r",
							"        modulusLength: bits,\r",
							"        publicExponent: _intToUint8Array(e),\r",
							"        hash: {name: 'SHA-256'}\r",
							"      }, true /* key can be exported*/, ['sign', 'verify'])\r",
							"      .then(function(pair) {\r",
							"        return window.crypto.subtle.exportKey('pkcs8', pair.privateKey);\r",
							"      // avoiding catch(function(err) {...}) to support IE <= 8\r",
							"      }).then(undefined, function(err) {\r",
							"        callback(err);\r",
							"      }).then(function(pkcs8) {\r",
							"        if(pkcs8) {\r",
							"          var privateKey = pki.privateKeyFromAsn1(\r",
							"            asn1.fromDer(forge.util.createBuffer(pkcs8)));\r",
							"          callback(null, {\r",
							"            privateKey: privateKey,\r",
							"            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\r",
							"          });\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"    if(_detectSubtleMsCrypto('generateKey') &&\r",
							"      _detectSubtleMsCrypto('exportKey')) {\r",
							"      var genOp = window.msCrypto.subtle.generateKey({\r",
							"        name: 'RSASSA-PKCS1-v1_5',\r",
							"        modulusLength: bits,\r",
							"        publicExponent: _intToUint8Array(e),\r",
							"        hash: {name: 'SHA-256'}\r",
							"      }, true /* key can be exported*/, ['sign', 'verify']);\r",
							"      genOp.oncomplete = function(e) {\r",
							"        var pair = e.target.result;\r",
							"        var exportOp = window.msCrypto.subtle.exportKey(\r",
							"          'pkcs8', pair.privateKey);\r",
							"        exportOp.oncomplete = function(e) {\r",
							"          var pkcs8 = e.target.result;\r",
							"          var privateKey = pki.privateKeyFromAsn1(\r",
							"            asn1.fromDer(forge.util.createBuffer(pkcs8)));\r",
							"          callback(null, {\r",
							"            privateKey: privateKey,\r",
							"            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\r",
							"          });\r",
							"        };\r",
							"        exportOp.onerror = function(err) {\r",
							"          callback(err);\r",
							"        };\r",
							"      };\r",
							"      genOp.onerror = function(err) {\r",
							"        callback(err);\r",
							"      };\r",
							"      return;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // use JavaScript implementation\r",
							"  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);\r",
							"  if(!callback) {\r",
							"    pki.rsa.stepKeyPairGenerationState(state, 0);\r",
							"    return state.keys;\r",
							"  }\r",
							"  _generateKeyPair(state, options, callback);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets an RSA public key from BigIntegers modulus and exponent.\r",
							" *\r",
							" * @param n the modulus.\r",
							" * @param e the exponent.\r",
							" *\r",
							" * @return the public key.\r",
							" */\r",
							"pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {\r",
							"  var key = {\r",
							"    n: n,\r",
							"    e: e\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Encrypts the given data with this public key. Newer applications\r",
							"   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for\r",
							"   * legacy applications.\r",
							"   *\r",
							"   * @param data the byte string to encrypt.\r",
							"   * @param scheme the encryption scheme to use:\r",
							"   *          'RSAES-PKCS1-V1_5' (default),\r",
							"   *          'RSA-OAEP',\r",
							"   *          'RAW', 'NONE', or null to perform raw RSA encryption,\r",
							"   *          an object with an 'encode' property set to a function\r",
							"   *          with the signature 'function(data, key)' that returns\r",
							"   *          a binary-encoded string representing the encoded data.\r",
							"   * @param schemeOptions any scheme-specific options.\r",
							"   *\r",
							"   * @return the encrypted byte string.\r",
							"   */\r",
							"  key.encrypt = function(data, scheme, schemeOptions) {\r",
							"    if(typeof scheme === 'string') {\r",
							"      scheme = scheme.toUpperCase();\r",
							"    } else if(scheme === undefined) {\r",
							"      scheme = 'RSAES-PKCS1-V1_5';\r",
							"    }\r",
							"\r",
							"    if(scheme === 'RSAES-PKCS1-V1_5') {\r",
							"      scheme = {\r",
							"        encode: function(m, key, pub) {\r",
							"          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();\r",
							"        }\r",
							"      };\r",
							"    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\r",
							"      scheme = {\r",
							"        encode: function(m, key) {\r",
							"          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);\r",
							"        }\r",
							"      };\r",
							"    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\r",
							"      scheme = { encode: function(e) { return e; } };\r",
							"    } else if(typeof scheme === 'string') {\r",
							"      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\r",
							"    }\r",
							"\r",
							"    // do scheme-based encoding then rsa encryption\r",
							"    var e = scheme.encode(data, key, true);\r",
							"    return pki.rsa.encrypt(e, key, true);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Verifies the given signature against the given digest.\r",
							"   *\r",
							"   * PKCS#1 supports multiple (currently two) signature schemes:\r",
							"   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\r",
							"   *\r",
							"   * By default this implementation uses the \"old scheme\", i.e.\r",
							"   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the\r",
							"   * signature is an OCTET STRING that holds a DigestInfo.\r",
							"   *\r",
							"   * DigestInfo ::= SEQUENCE {\r",
							"   *   digestAlgorithm DigestAlgorithmIdentifier,\r",
							"   *   digest Digest\r",
							"   * }\r",
							"   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							"   * Digest ::= OCTET STRING\r",
							"   *\r",
							"   * To perform PSS signature verification, provide an instance\r",
							"   * of Forge PSS object as the scheme parameter.\r",
							"   *\r",
							"   * @param digest the message digest hash to compare against the signature,\r",
							"   *          as a binary-encoded string.\r",
							"   * @param signature the signature to verify, as a binary-encoded string.\r",
							"   * @param scheme signature verification scheme to use:\r",
							"   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\r",
							"   *          a Forge PSS object for RSASSA-PSS,\r",
							"   *          'NONE' or null for none, DigestInfo will not be expected, but\r",
							"   *            PKCS#1 v1.5 padding will still be used.\r",
							"   *\r",
							"   * @return true if the signature was verified, false if not.\r",
							"   */\r",
							"   key.verify = function(digest, signature, scheme) {\r",
							"     if(typeof scheme === 'string') {\r",
							"       scheme = scheme.toUpperCase();\r",
							"     } else if(scheme === undefined) {\r",
							"       scheme = 'RSASSA-PKCS1-V1_5';\r",
							"     }\r",
							"\r",
							"     if(scheme === 'RSASSA-PKCS1-V1_5') {\r",
							"       scheme = {\r",
							"         verify: function(digest, d) {\r",
							"           // remove padding\r",
							"           d = _decodePkcs1_v1_5(d, key, true);\r",
							"           // d is ASN.1 BER-encoded DigestInfo\r",
							"           var obj = asn1.fromDer(d);\r",
							"           // compare the given digest to the decrypted one\r",
							"           return digest === obj.value[1].value;\r",
							"         }\r",
							"       };\r",
							"     } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\r",
							"       scheme = {\r",
							"         verify: function(digest, d) {\r",
							"           // remove padding\r",
							"           d = _decodePkcs1_v1_5(d, key, true);\r",
							"           return digest === d;\r",
							"         }\r",
							"       };\r",
							"     }\r",
							"\r",
							"     // do rsa decryption w/o any decoding, then verify -- which does decoding\r",
							"     var d = pki.rsa.decrypt(signature, key, true, false);\r",
							"     return scheme.verify(digest, d, key.n.bitLength());\r",
							"  };\r",
							"\r",
							"  return key;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets an RSA private key from BigIntegers modulus, exponent, primes,\r",
							" * prime exponents, and modular multiplicative inverse.\r",
							" *\r",
							" * @param n the modulus.\r",
							" * @param e the public exponent.\r",
							" * @param d the private exponent ((inverse of e) mod n).\r",
							" * @param p the first prime.\r",
							" * @param q the second prime.\r",
							" * @param dP exponent1 (d mod (p-1)).\r",
							" * @param dQ exponent2 (d mod (q-1)).\r",
							" * @param qInv ((inverse of q) mod p)\r",
							" *\r",
							" * @return the private key.\r",
							" */\r",
							"pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(\r",
							"  n, e, d, p, q, dP, dQ, qInv) {\r",
							"  var key = {\r",
							"    n: n,\r",
							"    e: e,\r",
							"    d: d,\r",
							"    p: p,\r",
							"    q: q,\r",
							"    dP: dP,\r",
							"    dQ: dQ,\r",
							"    qInv: qInv\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Decrypts the given data with this private key. The decryption scheme\r",
							"   * must match the one used to encrypt the data.\r",
							"   *\r",
							"   * @param data the byte string to decrypt.\r",
							"   * @param scheme the decryption scheme to use:\r",
							"   *          'RSAES-PKCS1-V1_5' (default),\r",
							"   *          'RSA-OAEP',\r",
							"   *          'RAW', 'NONE', or null to perform raw RSA decryption.\r",
							"   * @param schemeOptions any scheme-specific options.\r",
							"   *\r",
							"   * @return the decrypted byte string.\r",
							"   */\r",
							"  key.decrypt = function(data, scheme, schemeOptions) {\r",
							"    if(typeof scheme === 'string') {\r",
							"      scheme = scheme.toUpperCase();\r",
							"    } else if(scheme === undefined) {\r",
							"      scheme = 'RSAES-PKCS1-V1_5';\r",
							"    }\r",
							"\r",
							"    // do rsa decryption w/o any decoding\r",
							"    var d = pki.rsa.decrypt(data, key, false, false);\r",
							"\r",
							"    if(scheme === 'RSAES-PKCS1-V1_5') {\r",
							"      scheme = { decode: _decodePkcs1_v1_5 };\r",
							"    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\r",
							"      scheme = {\r",
							"        decode: function(d, key) {\r",
							"          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);\r",
							"        }\r",
							"      };\r",
							"    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\r",
							"      scheme = { decode: function(d) { return d; } };\r",
							"    } else {\r",
							"      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\r",
							"    }\r",
							"\r",
							"    // decode according to scheme\r",
							"    return scheme.decode(d, key, false);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Signs the given digest, producing a signature.\r",
							"   *\r",
							"   * PKCS#1 supports multiple (currently two) signature schemes:\r",
							"   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\r",
							"   *\r",
							"   * By default this implementation uses the \"old scheme\", i.e.\r",
							"   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide\r",
							"   * an instance of Forge PSS object as the scheme parameter.\r",
							"   *\r",
							"   * @param md the message digest object with the hash to sign.\r",
							"   * @param scheme the signature scheme to use:\r",
							"   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\r",
							"   *          a Forge PSS object for RSASSA-PSS,\r",
							"   *          'NONE' or null for none, DigestInfo will not be used but\r",
							"   *            PKCS#1 v1.5 padding will still be used.\r",
							"   *\r",
							"   * @return the signature as a byte string.\r",
							"   */\r",
							"  key.sign = function(md, scheme) {\r",
							"    /* Note: The internal implementation of RSA operations is being\r",
							"      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy\r",
							"      code like the use of an encoding block identifier 'bt' will eventually\r",
							"      be removed. */\r",
							"\r",
							"    // private key operation\r",
							"    var bt = false;\r",
							"\r",
							"    if(typeof scheme === 'string') {\r",
							"      scheme = scheme.toUpperCase();\r",
							"    }\r",
							"\r",
							"    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {\r",
							"      scheme = { encode: emsaPkcs1v15encode };\r",
							"      bt = 0x01;\r",
							"    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\r",
							"      scheme = { encode: function() { return md; } };\r",
							"      bt = 0x01;\r",
							"    }\r",
							"\r",
							"    // encode and then encrypt\r",
							"    var d = scheme.encode(md, key.n.bitLength());\r",
							"    return pki.rsa.encrypt(d, key, bt);\r",
							"  };\r",
							"\r",
							"  return key;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.\r",
							" *\r",
							" * @param rsaKey the ASN.1 RSAPrivateKey.\r",
							" *\r",
							" * @return the ASN.1 PrivateKeyInfo.\r",
							" */\r",
							"pki.wrapRsaPrivateKey = function(rsaKey) {\r",
							"  // PrivateKeyInfo\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version (0)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(0).getBytes()),\r",
							"    // privateKeyAlgorithm\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ]),\r",
							"    // PrivateKey\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"      asn1.toDer(rsaKey).getBytes())\r",
							"    ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a private key from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 representation of a PrivateKeyInfo containing an\r",
							" *          RSAPrivateKey or an RSAPrivateKey.\r",
							" *\r",
							" * @return the private key.\r",
							" */\r",
							"pki.privateKeyFromAsn1 = function(obj) {\r",
							"  // get PrivateKeyInfo\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(asn1.validate(obj, privateKeyValidator, capture, errors)) {\r",
							"    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));\r",
							"  }\r",
							"\r",
							"  // get RSAPrivateKey\r",
							"  capture = {};\r",
							"  errors = [];\r",
							"  if(!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read private key. ' +\r",
							"      'ASN.1 object does not contain an RSAPrivateKey.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // Note: Version is currently ignored.\r",
							"  // capture.privateKeyVersion\r",
							"  // FIXME: inefficient, get a BigInteger that uses byte strings\r",
							"  var n, e, d, p, q, dP, dQ, qInv;\r",
							"  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();\r",
							"  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();\r",
							"  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();\r",
							"  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();\r",
							"  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();\r",
							"  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();\r",
							"  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();\r",
							"  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();\r",
							"\r",
							"  // set private key\r",
							"  return pki.setRsaPrivateKey(\r",
							"    new BigInteger(n, 16),\r",
							"    new BigInteger(e, 16),\r",
							"    new BigInteger(d, 16),\r",
							"    new BigInteger(p, 16),\r",
							"    new BigInteger(q, 16),\r",
							"    new BigInteger(dP, 16),\r",
							"    new BigInteger(dQ, 16),\r",
							"    new BigInteger(qInv, 16));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a private key to an ASN.1 RSAPrivateKey.\r",
							" *\r",
							" * @param key the private key.\r",
							" *\r",
							" * @return the ASN.1 representation of an RSAPrivateKey.\r",
							" */\r",
							"pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {\r",
							"  // RSAPrivateKey\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version (0 = only 2 primes, 1 multiple primes)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(0).getBytes()),\r",
							"    // modulus (n)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.n)),\r",
							"    // publicExponent (e)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.e)),\r",
							"    // privateExponent (d)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.d)),\r",
							"    // privateKeyPrime1 (p)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.p)),\r",
							"    // privateKeyPrime2 (q)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.q)),\r",
							"    // privateKeyExponent1 (dP)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.dP)),\r",
							"    // privateKeyExponent2 (dQ)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.dQ)),\r",
							"    // coefficient (qInv)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.qInv))\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.\r",
							" *\r",
							" * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.\r",
							" *\r",
							" * @return the public key.\r",
							" */\r",
							"pki.publicKeyFromAsn1 = function(obj) {\r",
							"  // get SubjectPublicKeyInfo\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(asn1.validate(obj, publicKeyValidator, capture, errors)) {\r",
							"    // get oid\r",
							"    var oid = asn1.derToOid(capture.publicKeyOid);\r",
							"    if(oid !== pki.oids.rsaEncryption) {\r",
							"      var error = new Error('Cannot read public key. Unknown OID.');\r",
							"      error.oid = oid;\r",
							"      throw error;\r",
							"    }\r",
							"    obj = capture.rsaPublicKey;\r",
							"  }\r",
							"\r",
							"  // get RSA params\r",
							"  errors = [];\r",
							"  if(!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read public key. ' +\r",
							"      'ASN.1 object does not contain an RSAPublicKey.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // FIXME: inefficient, get a BigInteger that uses byte strings\r",
							"  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();\r",
							"  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();\r",
							"\r",
							"  // set public key\r",
							"  return pki.setRsaPublicKey(\r",
							"    new BigInteger(n, 16),\r",
							"    new BigInteger(e, 16));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a public key to an ASN.1 SubjectPublicKeyInfo.\r",
							" *\r",
							" * @param key the public key.\r",
							" *\r",
							" * @return the asn1 representation of a SubjectPublicKeyInfo.\r",
							" */\r",
							"pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {\r",
							"  // SubjectPublicKeyInfo\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // AlgorithmIdentifier\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\r",
							"      // parameters (null)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ]),\r",
							"    // subjectPublicKey\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\r",
							"      pki.publicKeyToRSAPublicKey(key)\r",
							"    ])\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a public key to an ASN.1 RSAPublicKey.\r",
							" *\r",
							" * @param key the public key.\r",
							" *\r",
							" * @return the asn1 representation of a RSAPublicKey.\r",
							" */\r",
							"pki.publicKeyToRSAPublicKey = function(key) {\r",
							"  // RSAPublicKey\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // modulus (n)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.n)),\r",
							"    // publicExponent (e)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      _bnToBytes(key.e))\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a message using PKCS#1 v1.5 padding.\r",
							" *\r",
							" * @param m the message to encode.\r",
							" * @param key the RSA key to use.\r",
							" * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02\r",
							" *          (for encryption).\r",
							" *\r",
							" * @return the padded byte buffer.\r",
							" */\r",
							"function _encodePkcs1_v1_5(m, key, bt) {\r",
							"  var eb = forge.util.createBuffer();\r",
							"\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  /* use PKCS#1 v1.5 padding */\r",
							"  if(m.length > (k - 11)) {\r",
							"    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');\r",
							"    error.length = m.length;\r",
							"    error.max = k - 11;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  /* A block type BT, a padding string PS, and the data D shall be\r",
							"    formatted into an octet string EB, the encryption block:\r",
							"\r",
							"    EB = 00 || BT || PS || 00 || D\r",
							"\r",
							"    The block type BT shall be a single octet indicating the structure of\r",
							"    the encryption block. For this version of the document it shall have\r",
							"    value 00, 01, or 02. For a private-key operation, the block type\r",
							"    shall be 00 or 01. For a public-key operation, it shall be 02.\r",
							"\r",
							"    The padding string PS shall consist of k-3-||D|| octets. For block\r",
							"    type 00, the octets shall have value 00; for block type 01, they\r",
							"    shall have value FF; and for block type 02, they shall be\r",
							"    pseudorandomly generated and nonzero. This makes the length of the\r",
							"    encryption block EB equal to k. */\r",
							"\r",
							"  // build the encryption block\r",
							"  eb.putByte(0x00);\r",
							"  eb.putByte(bt);\r",
							"\r",
							"  // create the padding\r",
							"  var padNum = k - 3 - m.length;\r",
							"  var padByte;\r",
							"  // private key op\r",
							"  if(bt === 0x00 || bt === 0x01) {\r",
							"    padByte = (bt === 0x00) ? 0x00 : 0xFF;\r",
							"    for(var i = 0; i < padNum; ++i) {\r",
							"      eb.putByte(padByte);\r",
							"    }\r",
							"  } else {\r",
							"    // public key op\r",
							"    // pad with random non-zero values\r",
							"    while(padNum > 0) {\r",
							"      var numZeros = 0;\r",
							"      var padBytes = forge.random.getBytes(padNum);\r",
							"      for(var i = 0; i < padNum; ++i) {\r",
							"        padByte = padBytes.charCodeAt(i);\r",
							"        if(padByte === 0) {\r",
							"          ++numZeros;\r",
							"        } else {\r",
							"          eb.putByte(padByte);\r",
							"        }\r",
							"      }\r",
							"      padNum = numZeros;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // zero followed by message\r",
							"  eb.putByte(0x00);\r",
							"  eb.putBytes(m);\r",
							"\r",
							"  return eb;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decodes a message using PKCS#1 v1.5 padding.\r",
							" *\r",
							" * @param em the message to decode.\r",
							" * @param key the RSA key to use.\r",
							" * @param pub true if the key is a public key, false if it is private.\r",
							" * @param ml the message length, if specified.\r",
							" *\r",
							" * @return the decoded bytes.\r",
							" */\r",
							"function _decodePkcs1_v1_5(em, key, pub, ml) {\r",
							"  // get the length of the modulus in bytes\r",
							"  var k = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  /* It is an error if any of the following conditions occurs:\r",
							"\r",
							"    1. The encryption block EB cannot be parsed unambiguously.\r",
							"    2. The padding string PS consists of fewer than eight octets\r",
							"      or is inconsisent with the block type BT.\r",
							"    3. The decryption process is a public-key operation and the block\r",
							"      type BT is not 00 or 01, or the decryption process is a\r",
							"      private-key operation and the block type is not 02.\r",
							"   */\r",
							"\r",
							"  // parse the encryption block\r",
							"  var eb = forge.util.createBuffer(em);\r",
							"  var first = eb.getByte();\r",
							"  var bt = eb.getByte();\r",
							"  if(first !== 0x00 ||\r",
							"    (pub && bt !== 0x00 && bt !== 0x01) ||\r",
							"    (!pub && bt != 0x02) ||\r",
							"    (pub && bt === 0x00 && typeof(ml) === 'undefined')) {\r",
							"    throw new Error('Encryption block is invalid.');\r",
							"  }\r",
							"\r",
							"  var padNum = 0;\r",
							"  if(bt === 0x00) {\r",
							"    // check all padding bytes for 0x00\r",
							"    padNum = k - 3 - ml;\r",
							"    for(var i = 0; i < padNum; ++i) {\r",
							"      if(eb.getByte() !== 0x00) {\r",
							"        throw new Error('Encryption block is invalid.');\r",
							"      }\r",
							"    }\r",
							"  } else if(bt === 0x01) {\r",
							"    // find the first byte that isn't 0xFF, should be after all padding\r",
							"    padNum = 0;\r",
							"    while(eb.length() > 1) {\r",
							"      if(eb.getByte() !== 0xFF) {\r",
							"        --eb.read;\r",
							"        break;\r",
							"      }\r",
							"      ++padNum;\r",
							"    }\r",
							"  } else if(bt === 0x02) {\r",
							"    // look for 0x00 byte\r",
							"    padNum = 0;\r",
							"    while(eb.length() > 1) {\r",
							"      if(eb.getByte() === 0x00) {\r",
							"        --eb.read;\r",
							"        break;\r",
							"      }\r",
							"      ++padNum;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // zero must be 0x00 and padNum must be (k - 3 - message length)\r",
							"  var zero = eb.getByte();\r",
							"  if(zero !== 0x00 || padNum !== (k - 3 - eb.length())) {\r",
							"    throw new Error('Encryption block is invalid.');\r",
							"  }\r",
							"\r",
							"  return eb.getBytes();\r",
							"}\r",
							"\r",
							"/**\r",
							" * Runs the key-generation algorithm asynchronously, either in the background\r",
							" * via Web Workers, or using the main thread and setImmediate.\r",
							" *\r",
							" * @param state the key-pair generation state.\r",
							" * @param [options] options for key-pair generation:\r",
							" *          workerScript the worker script URL.\r",
							" *          workers the number of web workers (if supported) to use,\r",
							" *            (default: 2, -1 to use estimated cores minus one).\r",
							" *          workLoad the size of the work load, ie: number of possible prime\r",
							" *            numbers for each web worker to check per work assignment,\r",
							" *            (default: 100).\r",
							" * @param callback(err, keypair) called once the operation completes.\r",
							" */\r",
							"function _generateKeyPair(state, options, callback) {\r",
							"  if(typeof options === 'function') {\r",
							"    callback = options;\r",
							"    options = {};\r",
							"  }\r",
							"  options = options || {};\r",
							"\r",
							"  var opts = {\r",
							"    algorithm: {\r",
							"      name: options.algorithm || 'PRIMEINC',\r",
							"      options: {\r",
							"        workers: options.workers || 2,\r",
							"        workLoad: options.workLoad || 100,\r",
							"        workerScript: options.workerScript\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"  if('prng' in options) {\r",
							"    opts.prng = options.prng;\r",
							"  }\r",
							"\r",
							"  generate();\r",
							"\r",
							"  function generate() {\r",
							"    // find p and then q (done in series to simplify)\r",
							"    getPrime(state.pBits, function(err, num) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"      state.p = num;\r",
							"      if(state.q !== null) {\r",
							"        return finish(err, state.q);\r",
							"      }\r",
							"      getPrime(state.qBits, finish);\r",
							"    });\r",
							"  }\r",
							"\r",
							"  function getPrime(bits, callback) {\r",
							"    forge.prime.generateProbablePrime(bits, opts, callback);\r",
							"  }\r",
							"\r",
							"  function finish(err, num) {\r",
							"    if(err) {\r",
							"      return callback(err);\r",
							"    }\r",
							"\r",
							"    // set q\r",
							"    state.q = num;\r",
							"\r",
							"    // ensure p is larger than q (swap them if not)\r",
							"    if(state.p.compareTo(state.q) < 0) {\r",
							"      var tmp = state.p;\r",
							"      state.p = state.q;\r",
							"      state.q = tmp;\r",
							"    }\r",
							"\r",
							"    // ensure p is coprime with e\r",
							"    if(state.p.subtract(BigInteger.ONE).gcd(state.e)\r",
							"      .compareTo(BigInteger.ONE) !== 0) {\r",
							"      state.p = null;\r",
							"      generate();\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // ensure q is coprime with e\r",
							"    if(state.q.subtract(BigInteger.ONE).gcd(state.e)\r",
							"      .compareTo(BigInteger.ONE) !== 0) {\r",
							"      state.q = null;\r",
							"      getPrime(state.qBits, finish);\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // compute phi: (p - 1)(q - 1) (Euler's totient function)\r",
							"    state.p1 = state.p.subtract(BigInteger.ONE);\r",
							"    state.q1 = state.q.subtract(BigInteger.ONE);\r",
							"    state.phi = state.p1.multiply(state.q1);\r",
							"\r",
							"    // ensure e and phi are coprime\r",
							"    if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\r",
							"      // phi and e aren't coprime, so generate a new p and q\r",
							"      state.p = state.q = null;\r",
							"      generate();\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // create n, ensure n is has the right number of bits\r",
							"    state.n = state.p.multiply(state.q);\r",
							"    if(state.n.bitLength() !== state.bits) {\r",
							"      // failed, get new q\r",
							"      state.q = null;\r",
							"      getPrime(state.qBits, finish);\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    // set keys\r",
							"    var d = state.e.modInverse(state.phi);\r",
							"    state.keys = {\r",
							"      privateKey: pki.rsa.setPrivateKey(\r",
							"        state.n, state.e, d, state.p, state.q,\r",
							"        d.mod(state.p1), d.mod(state.q1),\r",
							"        state.q.modInverse(state.p)),\r",
							"      publicKey: pki.rsa.setPublicKey(state.n, state.e)\r",
							"    };\r",
							"\r",
							"    callback(null, state.keys);\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a positive BigInteger into 2's-complement big-endian bytes.\r",
							" *\r",
							" * @param b the big integer to convert.\r",
							" *\r",
							" * @return the bytes.\r",
							" */\r",
							"function _bnToBytes(b) {\r",
							"  // prepend 0x00 if first byte >= 0x80\r",
							"  var hex = b.toString(16);\r",
							"  if(hex[0] >= '8') {\r",
							"    hex = '00' + hex;\r",
							"  }\r",
							"  var bytes = forge.util.hexToBytes(hex);\r",
							"\r",
							"  // ensure integer is minimally-encoded\r",
							"  if(bytes.length > 1 &&\r",
							"    // leading 0x00 for positive integer\r",
							"    ((bytes.charCodeAt(0) === 0 &&\r",
							"    (bytes.charCodeAt(1) & 0x80) === 0) ||\r",
							"    // leading 0xFF for negative integer\r",
							"    (bytes.charCodeAt(0) === 0xFF &&\r",
							"    (bytes.charCodeAt(1) & 0x80) === 0x80))) {\r",
							"    return bytes.substr(1);\r",
							"  }\r",
							"  return bytes;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Returns the required number of Miller-Rabin tests to generate a\r",
							" * prime with an error probability of (1/2)^80.\r",
							" *\r",
							" * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\r",
							" *\r",
							" * @param bits the bit size.\r",
							" *\r",
							" * @return the required number of iterations.\r",
							" */\r",
							"function _getMillerRabinTests(bits) {\r",
							"  if(bits <= 100) return 27;\r",
							"  if(bits <= 150) return 18;\r",
							"  if(bits <= 200) return 15;\r",
							"  if(bits <= 250) return 12;\r",
							"  if(bits <= 300) return 9;\r",
							"  if(bits <= 350) return 8;\r",
							"  if(bits <= 400) return 7;\r",
							"  if(bits <= 500) return 6;\r",
							"  if(bits <= 600) return 5;\r",
							"  if(bits <= 800) return 4;\r",
							"  if(bits <= 1250) return 3;\r",
							"  return 2;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Performs feature detection on the SubtleCrypto interface.\r",
							" *\r",
							" * @param fn the feature (function) to detect.\r",
							" *\r",
							" * @return true if detected, false if not.\r",
							" */\r",
							"function _detectSubtleCrypto(fn) {\r",
							"  return (typeof window !== 'undefined' &&\r",
							"    typeof window.crypto === 'object' &&\r",
							"    typeof window.crypto.subtle === 'object' &&\r",
							"    typeof window.crypto.subtle[fn] === 'function');\r",
							"}\r",
							"\r",
							"/**\r",
							" * Performs feature detection on the deprecated Microsoft Internet Explorer\r",
							" * outdated SubtleCrypto interface. This function should only be used after\r",
							" * checking for the modern, standard SubtleCrypto interface.\r",
							" *\r",
							" * @param fn the feature (function) to detect.\r",
							" *\r",
							" * @return true if detected, false if not.\r",
							" */\r",
							"function _detectSubtleMsCrypto(fn) {\r",
							"  return (typeof window !== 'undefined' &&\r",
							"    typeof window.msCrypto === 'object' &&\r",
							"    typeof window.msCrypto.subtle === 'object' &&\r",
							"    typeof window.msCrypto.subtle[fn] === 'function');\r",
							"}\r",
							"\r",
							"function _intToUint8Array(x) {\r",
							"  var bytes = forge.util.hexToBytes(x.toString(16));\r",
							"  var buffer = new Uint8Array(bytes.length);\r",
							"  for(var i = 0; i < bytes.length; ++i) {\r",
							"    buffer[i] = bytes.charCodeAt(i);\r",
							"  }\r",
							"  return buffer;\r",
							"}\r",
							"\r",
							"function _privateKeyFromJwk(jwk) {\r",
							"  if(jwk.kty !== 'RSA') {\r",
							"    throw new Error(\r",
							"      'Unsupported key algorithm \"' + jwk.kty + '\"; algorithm must be \"RSA\".');\r",
							"  }\r",
							"  return pki.setRsaPrivateKey(\r",
							"    _base64ToBigInt(jwk.n),\r",
							"    _base64ToBigInt(jwk.e),\r",
							"    _base64ToBigInt(jwk.d),\r",
							"    _base64ToBigInt(jwk.p),\r",
							"    _base64ToBigInt(jwk.q),\r",
							"    _base64ToBigInt(jwk.dp),\r",
							"    _base64ToBigInt(jwk.dq),\r",
							"    _base64ToBigInt(jwk.qi));\r",
							"}\r",
							"\r",
							"function _publicKeyFromJwk(jwk) {\r",
							"  if(jwk.kty !== 'RSA') {\r",
							"    throw new Error('Key algorithm must be \"RSA\".');\r",
							"  }\r",
							"  return pki.setRsaPublicKey(\r",
							"    _base64ToBigInt(jwk.n),\r",
							"    _base64ToBigInt(jwk.e));\r",
							"}\r",
							"\r",
							"function _base64ToBigInt(b64) {\r",
							"  return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 12 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"// Copyright (c) 2005  Tom Wu\r",
							"// All Rights Reserved.\r",
							"// See \"LICENSE\" for details.\r",
							"\r",
							"// Basic JavaScript BN library - subset useful for RSA encryption.\r",
							"\r",
							"/*\r",
							"Licensing (LICENSE)\r",
							"-------------------\r",
							"\r",
							"This software is covered under the following copyright:\r",
							"*/\r",
							"/*\r",
							" * Copyright (c) 2003-2005  Tom Wu\r",
							" * All Rights Reserved.\r",
							" *\r",
							" * Permission is hereby granted, free of charge, to any person obtaining\r",
							" * a copy of this software and associated documentation files (the\r",
							" * \"Software\"), to deal in the Software without restriction, including\r",
							" * without limitation the rights to use, copy, modify, merge, publish,\r",
							" * distribute, sublicense, and/or sell copies of the Software, and to\r",
							" * permit persons to whom the Software is furnished to do so, subject to\r",
							" * the following conditions:\r",
							" *\r",
							" * The above copyright notice and this permission notice shall be\r",
							" * included in all copies or substantial portions of the Software.\r",
							" *\r",
							" * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\r",
							" * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\r",
							" * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\r",
							" *\r",
							" * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\r",
							" * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\r",
							" * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\r",
							" * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\r",
							" * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r",
							" *\r",
							" * In addition, the following condition applies:\r",
							" *\r",
							" * All redistributions must retain an intact copy of this copyright notice\r",
							" * and disclaimer.\r",
							" */\r",
							"/*\r",
							"Address all questions regarding this license to:\r",
							"\r",
							"  Tom Wu\r",
							"  tjw@cs.Stanford.EDU\r",
							"*/\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"module.exports = forge.jsbn = forge.jsbn || {};\r",
							"\r",
							"// Bits per digit\r",
							"var dbits;\r",
							"\r",
							"// JavaScript engine analysis\r",
							"var canary = 0xdeadbeefcafe;\r",
							"var j_lm = ((canary&0xffffff)==0xefcafe);\r",
							"\r",
							"// (public) Constructor\r",
							"function BigInteger(a,b,c) {\r",
							"  this.data = [];\r",
							"  if(a != null)\r",
							"    if(\"number\" == typeof a) this.fromNumber(a,b,c);\r",
							"    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\r",
							"    else this.fromString(a,b);\r",
							"}\r",
							"forge.jsbn.BigInteger = BigInteger;\r",
							"\r",
							"// return new, unset BigInteger\r",
							"function nbi() { return new BigInteger(null); }\r",
							"\r",
							"// am: Compute w_j += (x*this_i), propagate carries,\r",
							"// c is initial carry, returns final carry.\r",
							"// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\r",
							"// We need to select the fastest one that works in this environment.\r",
							"\r",
							"// am1: use a single mult and divide to get the high bits,\r",
							"// max digit bits should be 26 because\r",
							"// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\r",
							"function am1(i,x,w,j,c,n) {\r",
							"  while(--n >= 0) {\r",
							"    var v = x*this.data[i++]+w.data[j]+c;\r",
							"    c = Math.floor(v/0x4000000);\r",
							"    w.data[j++] = v&0x3ffffff;\r",
							"  }\r",
							"  return c;\r",
							"}\r",
							"// am2 avoids a big mult-and-extract completely.\r",
							"// Max digit bits should be <= 30 because we do bitwise ops\r",
							"// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\r",
							"function am2(i,x,w,j,c,n) {\r",
							"  var xl = x&0x7fff, xh = x>>15;\r",
							"  while(--n >= 0) {\r",
							"    var l = this.data[i]&0x7fff;\r",
							"    var h = this.data[i++]>>15;\r",
							"    var m = xh*l+h*xl;\r",
							"    l = xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);\r",
							"    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\r",
							"    w.data[j++] = l&0x3fffffff;\r",
							"  }\r",
							"  return c;\r",
							"}\r",
							"// Alternately, set max digit bits to 28 since some\r",
							"// browsers slow down when dealing with 32-bit numbers.\r",
							"function am3(i,x,w,j,c,n) {\r",
							"  var xl = x&0x3fff, xh = x>>14;\r",
							"  while(--n >= 0) {\r",
							"    var l = this.data[i]&0x3fff;\r",
							"    var h = this.data[i++]>>14;\r",
							"    var m = xh*l+h*xl;\r",
							"    l = xl*l+((m&0x3fff)<<14)+w.data[j]+c;\r",
							"    c = (l>>28)+(m>>14)+xh*h;\r",
							"    w.data[j++] = l&0xfffffff;\r",
							"  }\r",
							"  return c;\r",
							"}\r",
							"\r",
							"// node.js (no browser)\r",
							"if(typeof(navigator) === 'undefined')\r",
							"{\r",
							"   BigInteger.prototype.am = am3;\r",
							"   dbits = 28;\r",
							"} else if(j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\r",
							"  BigInteger.prototype.am = am2;\r",
							"  dbits = 30;\r",
							"} else if(j_lm && (navigator.appName != \"Netscape\")) {\r",
							"  BigInteger.prototype.am = am1;\r",
							"  dbits = 26;\r",
							"} else { // Mozilla/Netscape seems to prefer am3\r",
							"  BigInteger.prototype.am = am3;\r",
							"  dbits = 28;\r",
							"}\r",
							"\r",
							"BigInteger.prototype.DB = dbits;\r",
							"BigInteger.prototype.DM = ((1<<dbits)-1);\r",
							"BigInteger.prototype.DV = (1<<dbits);\r",
							"\r",
							"var BI_FP = 52;\r",
							"BigInteger.prototype.FV = Math.pow(2,BI_FP);\r",
							"BigInteger.prototype.F1 = BI_FP-dbits;\r",
							"BigInteger.prototype.F2 = 2*dbits-BI_FP;\r",
							"\r",
							"// Digit conversions\r",
							"var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r",
							"var BI_RC = new Array();\r",
							"var rr,vv;\r",
							"rr = \"0\".charCodeAt(0);\r",
							"for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\r",
							"rr = \"a\".charCodeAt(0);\r",
							"for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r",
							"rr = \"A\".charCodeAt(0);\r",
							"for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r",
							"\r",
							"function int2char(n) { return BI_RM.charAt(n); }\r",
							"function intAt(s,i) {\r",
							"  var c = BI_RC[s.charCodeAt(i)];\r",
							"  return (c==null)?-1:c;\r",
							"}\r",
							"\r",
							"// (protected) copy this to r\r",
							"function bnpCopyTo(r) {\r",
							"  for(var i = this.t-1; i >= 0; --i) r.data[i] = this.data[i];\r",
							"  r.t = this.t;\r",
							"  r.s = this.s;\r",
							"}\r",
							"\r",
							"// (protected) set from integer value x, -DV <= x < DV\r",
							"function bnpFromInt(x) {\r",
							"  this.t = 1;\r",
							"  this.s = (x<0)?-1:0;\r",
							"  if(x > 0) this.data[0] = x;\r",
							"  else if(x < -1) this.data[0] = x+this.DV;\r",
							"  else this.t = 0;\r",
							"}\r",
							"\r",
							"// return bigint initialized to value\r",
							"function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\r",
							"\r",
							"// (protected) set from string and radix\r",
							"function bnpFromString(s,b) {\r",
							"  var k;\r",
							"  if(b == 16) k = 4;\r",
							"  else if(b == 8) k = 3;\r",
							"  else if(b == 256) k = 8; // byte array\r",
							"  else if(b == 2) k = 1;\r",
							"  else if(b == 32) k = 5;\r",
							"  else if(b == 4) k = 2;\r",
							"  else { this.fromRadix(s,b); return; }\r",
							"  this.t = 0;\r",
							"  this.s = 0;\r",
							"  var i = s.length, mi = false, sh = 0;\r",
							"  while(--i >= 0) {\r",
							"    var x = (k==8)?s[i]&0xff:intAt(s,i);\r",
							"    if(x < 0) {\r",
							"      if(s.charAt(i) == \"-\") mi = true;\r",
							"      continue;\r",
							"    }\r",
							"    mi = false;\r",
							"    if(sh == 0)\r",
							"      this.data[this.t++] = x;\r",
							"    else if(sh+k > this.DB) {\r",
							"      this.data[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\r",
							"      this.data[this.t++] = (x>>(this.DB-sh));\r",
							"    } else\r",
							"      this.data[this.t-1] |= x<<sh;\r",
							"    sh += k;\r",
							"    if(sh >= this.DB) sh -= this.DB;\r",
							"  }\r",
							"  if(k == 8 && (s[0]&0x80) != 0) {\r",
							"    this.s = -1;\r",
							"    if(sh > 0) this.data[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\r",
							"  }\r",
							"  this.clamp();\r",
							"  if(mi) BigInteger.ZERO.subTo(this,this);\r",
							"}\r",
							"\r",
							"// (protected) clamp off excess high words\r",
							"function bnpClamp() {\r",
							"  var c = this.s&this.DM;\r",
							"  while(this.t > 0 && this.data[this.t-1] == c) --this.t;\r",
							"}\r",
							"\r",
							"// (public) return string representation in given radix\r",
							"function bnToString(b) {\r",
							"  if(this.s < 0) return \"-\"+this.negate().toString(b);\r",
							"  var k;\r",
							"  if(b == 16) k = 4;\r",
							"  else if(b == 8) k = 3;\r",
							"  else if(b == 2) k = 1;\r",
							"  else if(b == 32) k = 5;\r",
							"  else if(b == 4) k = 2;\r",
							"  else return this.toRadix(b);\r",
							"  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\r",
							"  var p = this.DB-(i*this.DB)%k;\r",
							"  if(i-- > 0) {\r",
							"    if(p < this.DB && (d = this.data[i]>>p) > 0) { m = true; r = int2char(d); }\r",
							"    while(i >= 0) {\r",
							"      if(p < k) {\r",
							"        d = (this.data[i]&((1<<p)-1))<<(k-p);\r",
							"        d |= this.data[--i]>>(p+=this.DB-k);\r",
							"      } else {\r",
							"        d = (this.data[i]>>(p-=k))&km;\r",
							"        if(p <= 0) { p += this.DB; --i; }\r",
							"      }\r",
							"      if(d > 0) m = true;\r",
							"      if(m) r += int2char(d);\r",
							"    }\r",
							"  }\r",
							"  return m?r:\"0\";\r",
							"}\r",
							"\r",
							"// (public) -this\r",
							"function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\r",
							"\r",
							"// (public) |this|\r",
							"function bnAbs() { return (this.s<0)?this.negate():this; }\r",
							"\r",
							"// (public) return + if this > a, - if this < a, 0 if equal\r",
							"function bnCompareTo(a) {\r",
							"  var r = this.s-a.s;\r",
							"  if(r != 0) return r;\r",
							"  var i = this.t;\r",
							"  r = i-a.t;\r",
							"  if(r != 0) return (this.s<0)?-r:r;\r",
							"  while(--i >= 0) if((r=this.data[i]-a.data[i]) != 0) return r;\r",
							"  return 0;\r",
							"}\r",
							"\r",
							"// returns bit length of the integer x\r",
							"function nbits(x) {\r",
							"  var r = 1, t;\r",
							"  if((t=x>>>16) != 0) { x = t; r += 16; }\r",
							"  if((t=x>>8) != 0) { x = t; r += 8; }\r",
							"  if((t=x>>4) != 0) { x = t; r += 4; }\r",
							"  if((t=x>>2) != 0) { x = t; r += 2; }\r",
							"  if((t=x>>1) != 0) { x = t; r += 1; }\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// (public) return the number of bits in \"this\"\r",
							"function bnBitLength() {\r",
							"  if(this.t <= 0) return 0;\r",
							"  return this.DB*(this.t-1)+nbits(this.data[this.t-1]^(this.s&this.DM));\r",
							"}\r",
							"\r",
							"// (protected) r = this << n*DB\r",
							"function bnpDLShiftTo(n,r) {\r",
							"  var i;\r",
							"  for(i = this.t-1; i >= 0; --i) r.data[i+n] = this.data[i];\r",
							"  for(i = n-1; i >= 0; --i) r.data[i] = 0;\r",
							"  r.t = this.t+n;\r",
							"  r.s = this.s;\r",
							"}\r",
							"\r",
							"// (protected) r = this >> n*DB\r",
							"function bnpDRShiftTo(n,r) {\r",
							"  for(var i = n; i < this.t; ++i) r.data[i-n] = this.data[i];\r",
							"  r.t = Math.max(this.t-n,0);\r",
							"  r.s = this.s;\r",
							"}\r",
							"\r",
							"// (protected) r = this << n\r",
							"function bnpLShiftTo(n,r) {\r",
							"  var bs = n%this.DB;\r",
							"  var cbs = this.DB-bs;\r",
							"  var bm = (1<<cbs)-1;\r",
							"  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\r",
							"  for(i = this.t-1; i >= 0; --i) {\r",
							"    r.data[i+ds+1] = (this.data[i]>>cbs)|c;\r",
							"    c = (this.data[i]&bm)<<bs;\r",
							"  }\r",
							"  for(i = ds-1; i >= 0; --i) r.data[i] = 0;\r",
							"  r.data[ds] = c;\r",
							"  r.t = this.t+ds+1;\r",
							"  r.s = this.s;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) r = this >> n\r",
							"function bnpRShiftTo(n,r) {\r",
							"  r.s = this.s;\r",
							"  var ds = Math.floor(n/this.DB);\r",
							"  if(ds >= this.t) { r.t = 0; return; }\r",
							"  var bs = n%this.DB;\r",
							"  var cbs = this.DB-bs;\r",
							"  var bm = (1<<bs)-1;\r",
							"  r.data[0] = this.data[ds]>>bs;\r",
							"  for(var i = ds+1; i < this.t; ++i) {\r",
							"    r.data[i-ds-1] |= (this.data[i]&bm)<<cbs;\r",
							"    r.data[i-ds] = this.data[i]>>bs;\r",
							"  }\r",
							"  if(bs > 0) r.data[this.t-ds-1] |= (this.s&bm)<<cbs;\r",
							"  r.t = this.t-ds;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) r = this - a\r",
							"function bnpSubTo(a,r) {\r",
							"  var i = 0, c = 0, m = Math.min(a.t,this.t);\r",
							"  while(i < m) {\r",
							"    c += this.data[i]-a.data[i];\r",
							"    r.data[i++] = c&this.DM;\r",
							"    c >>= this.DB;\r",
							"  }\r",
							"  if(a.t < this.t) {\r",
							"    c -= a.s;\r",
							"    while(i < this.t) {\r",
							"      c += this.data[i];\r",
							"      r.data[i++] = c&this.DM;\r",
							"      c >>= this.DB;\r",
							"    }\r",
							"    c += this.s;\r",
							"  } else {\r",
							"    c += this.s;\r",
							"    while(i < a.t) {\r",
							"      c -= a.data[i];\r",
							"      r.data[i++] = c&this.DM;\r",
							"      c >>= this.DB;\r",
							"    }\r",
							"    c -= a.s;\r",
							"  }\r",
							"  r.s = (c<0)?-1:0;\r",
							"  if(c < -1) r.data[i++] = this.DV+c;\r",
							"  else if(c > 0) r.data[i++] = c;\r",
							"  r.t = i;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) r = this * a, r != this,a (HAC 14.12)\r",
							"// \"this\" should be the larger one if appropriate.\r",
							"function bnpMultiplyTo(a,r) {\r",
							"  var x = this.abs(), y = a.abs();\r",
							"  var i = x.t;\r",
							"  r.t = i+y.t;\r",
							"  while(--i >= 0) r.data[i] = 0;\r",
							"  for(i = 0; i < y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);\r",
							"  r.s = 0;\r",
							"  r.clamp();\r",
							"  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\r",
							"}\r",
							"\r",
							"// (protected) r = this^2, r != this (HAC 14.16)\r",
							"function bnpSquareTo(r) {\r",
							"  var x = this.abs();\r",
							"  var i = r.t = 2*x.t;\r",
							"  while(--i >= 0) r.data[i] = 0;\r",
							"  for(i = 0; i < x.t-1; ++i) {\r",
							"    var c = x.am(i,x.data[i],r,2*i,0,1);\r",
							"    if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\r",
							"      r.data[i+x.t] -= x.DV;\r",
							"      r.data[i+x.t+1] = 1;\r",
							"    }\r",
							"  }\r",
							"  if(r.t > 0) r.data[r.t-1] += x.am(i,x.data[i],r,2*i,0,1);\r",
							"  r.s = 0;\r",
							"  r.clamp();\r",
							"}\r",
							"\r",
							"// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\r",
							"// r != q, this != m.  q or r may be null.\r",
							"function bnpDivRemTo(m,q,r) {\r",
							"  var pm = m.abs();\r",
							"  if(pm.t <= 0) return;\r",
							"  var pt = this.abs();\r",
							"  if(pt.t < pm.t) {\r",
							"    if(q != null) q.fromInt(0);\r",
							"    if(r != null) this.copyTo(r);\r",
							"    return;\r",
							"  }\r",
							"  if(r == null) r = nbi();\r",
							"  var y = nbi(), ts = this.s, ms = m.s;\r",
							"  var nsh = this.DB-nbits(pm.data[pm.t-1]);\t// normalize modulus\r",
							"  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }\r",
							"  var ys = y.t;\r",
							"  var y0 = y.data[ys-1];\r",
							"  if(y0 == 0) return;\r",
							"  var yt = y0*(1<<this.F1)+((ys>1)?y.data[ys-2]>>this.F2:0);\r",
							"  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\r",
							"  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\r",
							"  y.dlShiftTo(j,t);\r",
							"  if(r.compareTo(t) >= 0) {\r",
							"    r.data[r.t++] = 1;\r",
							"    r.subTo(t,r);\r",
							"  }\r",
							"  BigInteger.ONE.dlShiftTo(ys,t);\r",
							"  t.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\r",
							"  while(y.t < ys) y.data[y.t++] = 0;\r",
							"  while(--j >= 0) {\r",
							"    // Estimate quotient digit\r",
							"    var qd = (r.data[--i]==y0)?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);\r",
							"    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\r",
							"      y.dlShiftTo(j,t);\r",
							"      r.subTo(t,r);\r",
							"      while(r.data[i] < --qd) r.subTo(t,r);\r",
							"    }\r",
							"  }\r",
							"  if(q != null) {\r",
							"    r.drShiftTo(ys,q);\r",
							"    if(ts != ms) BigInteger.ZERO.subTo(q,q);\r",
							"  }\r",
							"  r.t = ys;\r",
							"  r.clamp();\r",
							"  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\r",
							"  if(ts < 0) BigInteger.ZERO.subTo(r,r);\r",
							"}\r",
							"\r",
							"// (public) this mod a\r",
							"function bnMod(a) {\r",
							"  var r = nbi();\r",
							"  this.abs().divRemTo(a,null,r);\r",
							"  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// Modular reduction using \"classic\" algorithm\r",
							"function Classic(m) { this.m = m; }\r",
							"function cConvert(x) {\r",
							"  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\r",
							"  else return x;\r",
							"}\r",
							"function cRevert(x) { return x; }\r",
							"function cReduce(x) { x.divRemTo(this.m,null,x); }\r",
							"function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r",
							"function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r",
							"\r",
							"Classic.prototype.convert = cConvert;\r",
							"Classic.prototype.revert = cRevert;\r",
							"Classic.prototype.reduce = cReduce;\r",
							"Classic.prototype.mulTo = cMulTo;\r",
							"Classic.prototype.sqrTo = cSqrTo;\r",
							"\r",
							"// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\r",
							"// justification:\r",
							"//         xy == 1 (mod m)\r",
							"//         xy =  1+km\r",
							"//   xy(2-xy) = (1+km)(1-km)\r",
							"// x[y(2-xy)] = 1-k^2m^2\r",
							"// x[y(2-xy)] == 1 (mod m^2)\r",
							"// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\r",
							"// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\r",
							"// JS multiply \"overflows\" differently from C/C++, so care is needed here.\r",
							"function bnpInvDigit() {\r",
							"  if(this.t < 1) return 0;\r",
							"  var x = this.data[0];\r",
							"  if((x&1) == 0) return 0;\r",
							"  var y = x&3;\t\t// y == 1/x mod 2^2\r",
							"  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\r",
							"  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\r",
							"  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\r",
							"  // last step - calculate inverse mod DV directly;\r",
							"  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\r",
							"  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\r",
							"  // we really want the negative inverse, and -DV < y < DV\r",
							"  return (y>0)?this.DV-y:-y;\r",
							"}\r",
							"\r",
							"// Montgomery reduction\r",
							"function Montgomery(m) {\r",
							"  this.m = m;\r",
							"  this.mp = m.invDigit();\r",
							"  this.mpl = this.mp&0x7fff;\r",
							"  this.mph = this.mp>>15;\r",
							"  this.um = (1<<(m.DB-15))-1;\r",
							"  this.mt2 = 2*m.t;\r",
							"}\r",
							"\r",
							"// xR mod m\r",
							"function montConvert(x) {\r",
							"  var r = nbi();\r",
							"  x.abs().dlShiftTo(this.m.t,r);\r",
							"  r.divRemTo(this.m,null,r);\r",
							"  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// x/R mod m\r",
							"function montRevert(x) {\r",
							"  var r = nbi();\r",
							"  x.copyTo(r);\r",
							"  this.reduce(r);\r",
							"  return r;\r",
							"}\r",
							"\r",
							"// x = x/R mod m (HAC 14.32)\r",
							"function montReduce(x) {\r",
							"  while(x.t <= this.mt2)\t// pad x so am has enough room later\r",
							"    x.data[x.t++] = 0;\r",
							"  for(var i = 0; i < this.m.t; ++i) {\r",
							"    // faster way of calculating u0 = x.data[i]*mp mod DV\r",
							"    var j = x.data[i]&0x7fff;\r",
							"    var u0 = (j*this.mpl+(((j*this.mph+(x.data[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\r",
							"    // use am to combine the multiply-shift-add into one call\r",
							"    j = i+this.m.t;\r",
							"    x.data[j] += this.m.am(0,u0,x,i,0,this.m.t);\r",
							"    // propagate carry\r",
							"    while(x.data[j] >= x.DV) { x.data[j] -= x.DV; x.data[++j]++; }\r",
							"  }\r",
							"  x.clamp();\r",
							"  x.drShiftTo(this.m.t,x);\r",
							"  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r",
							"}\r",
							"\r",
							"// r = \"x^2/R mod m\"; x != r\r",
							"function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r",
							"\r",
							"// r = \"xy/R mod m\"; x,y != r\r",
							"function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r",
							"\r",
							"Montgomery.prototype.convert = montConvert;\r",
							"Montgomery.prototype.revert = montRevert;\r",
							"Montgomery.prototype.reduce = montReduce;\r",
							"Montgomery.prototype.mulTo = montMulTo;\r",
							"Montgomery.prototype.sqrTo = montSqrTo;\r",
							"\r",
							"// (protected) true iff this is even\r",
							"function bnpIsEven() { return ((this.t>0)?(this.data[0]&1):this.s) == 0; }\r",
							"\r",
							"// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\r",
							"function bnpExp(e,z) {\r",
							"  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\r",
							"  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\r",
							"  g.copyTo(r);\r",
							"  while(--i >= 0) {\r",
							"    z.sqrTo(r,r2);\r",
							"    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\r",
							"    else { var t = r; r = r2; r2 = t; }\r",
							"  }\r",
							"  return z.revert(r);\r",
							"}\r",
							"\r",
							"// (public) this^e % m, 0 <= e < 2^32\r",
							"function bnModPowInt(e,m) {\r",
							"  var z;\r",
							"  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\r",
							"  return this.exp(e,z);\r",
							"}\r",
							"\r",
							"// protected\r",
							"BigInteger.prototype.copyTo = bnpCopyTo;\r",
							"BigInteger.prototype.fromInt = bnpFromInt;\r",
							"BigInteger.prototype.fromString = bnpFromString;\r",
							"BigInteger.prototype.clamp = bnpClamp;\r",
							"BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\r",
							"BigInteger.prototype.drShiftTo = bnpDRShiftTo;\r",
							"BigInteger.prototype.lShiftTo = bnpLShiftTo;\r",
							"BigInteger.prototype.rShiftTo = bnpRShiftTo;\r",
							"BigInteger.prototype.subTo = bnpSubTo;\r",
							"BigInteger.prototype.multiplyTo = bnpMultiplyTo;\r",
							"BigInteger.prototype.squareTo = bnpSquareTo;\r",
							"BigInteger.prototype.divRemTo = bnpDivRemTo;\r",
							"BigInteger.prototype.invDigit = bnpInvDigit;\r",
							"BigInteger.prototype.isEven = bnpIsEven;\r",
							"BigInteger.prototype.exp = bnpExp;\r",
							"\r",
							"// public\r",
							"BigInteger.prototype.toString = bnToString;\r",
							"BigInteger.prototype.negate = bnNegate;\r",
							"BigInteger.prototype.abs = bnAbs;\r",
							"BigInteger.prototype.compareTo = bnCompareTo;\r",
							"BigInteger.prototype.bitLength = bnBitLength;\r",
							"BigInteger.prototype.mod = bnMod;\r",
							"BigInteger.prototype.modPowInt = bnModPowInt;\r",
							"\r",
							"// \"constants\"\r",
							"BigInteger.ZERO = nbv(0);\r",
							"BigInteger.ONE = nbv(1);\r",
							"\r",
							"// jsbn2 lib\r",
							"\r",
							"//Copyright (c) 2005-2009  Tom Wu\r",
							"//All Rights Reserved.\r",
							"//See \"LICENSE\" for details (See jsbn.js for LICENSE).\r",
							"\r",
							"//Extended JavaScript BN functions, required for RSA private ops.\r",
							"\r",
							"//Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\r",
							"\r",
							"//(public)\r",
							"function bnClone() { var r = nbi(); this.copyTo(r); return r; }\r",
							"\r",
							"//(public) return value as integer\r",
							"function bnIntValue() {\r",
							"if(this.s < 0) {\r",
							" if(this.t == 1) return this.data[0]-this.DV;\r",
							" else if(this.t == 0) return -1;\r",
							"} else if(this.t == 1) return this.data[0];\r",
							"else if(this.t == 0) return 0;\r",
							"// assumes 16 < DB < 32\r",
							"return ((this.data[1]&((1<<(32-this.DB))-1))<<this.DB)|this.data[0];\r",
							"}\r",
							"\r",
							"//(public) return value as byte\r",
							"function bnByteValue() { return (this.t==0)?this.s:(this.data[0]<<24)>>24; }\r",
							"\r",
							"//(public) return value as short (assumes DB>=16)\r",
							"function bnShortValue() { return (this.t==0)?this.s:(this.data[0]<<16)>>16; }\r",
							"\r",
							"//(protected) return x s.t. r^x < DV\r",
							"function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\r",
							"\r",
							"//(public) 0 if this == 0, 1 if this > 0\r",
							"function bnSigNum() {\r",
							"if(this.s < 0) return -1;\r",
							"else if(this.t <= 0 || (this.t == 1 && this.data[0] <= 0)) return 0;\r",
							"else return 1;\r",
							"}\r",
							"\r",
							"//(protected) convert to radix string\r",
							"function bnpToRadix(b) {\r",
							"if(b == null) b = 10;\r",
							"if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\r",
							"var cs = this.chunkSize(b);\r",
							"var a = Math.pow(b,cs);\r",
							"var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\r",
							"this.divRemTo(d,y,z);\r",
							"while(y.signum() > 0) {\r",
							" r = (a+z.intValue()).toString(b).substr(1) + r;\r",
							" y.divRemTo(d,y,z);\r",
							"}\r",
							"return z.intValue().toString(b) + r;\r",
							"}\r",
							"\r",
							"//(protected) convert from radix string\r",
							"function bnpFromRadix(s,b) {\r",
							"this.fromInt(0);\r",
							"if(b == null) b = 10;\r",
							"var cs = this.chunkSize(b);\r",
							"var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\r",
							"for(var i = 0; i < s.length; ++i) {\r",
							" var x = intAt(s,i);\r",
							" if(x < 0) {\r",
							"   if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\r",
							"   continue;\r",
							" }\r",
							" w = b*w+x;\r",
							" if(++j >= cs) {\r",
							"   this.dMultiply(d);\r",
							"   this.dAddOffset(w,0);\r",
							"   j = 0;\r",
							"   w = 0;\r",
							" }\r",
							"}\r",
							"if(j > 0) {\r",
							" this.dMultiply(Math.pow(b,j));\r",
							" this.dAddOffset(w,0);\r",
							"}\r",
							"if(mi) BigInteger.ZERO.subTo(this,this);\r",
							"}\r",
							"\r",
							"//(protected) alternate constructor\r",
							"function bnpFromNumber(a,b,c) {\r",
							"if(\"number\" == typeof b) {\r",
							" // new BigInteger(int,int,RNG)\r",
							" if(a < 2) this.fromInt(1);\r",
							" else {\r",
							"   this.fromNumber(a,c);\r",
							"   if(!this.testBit(a-1))  // force MSB set\r",
							"     this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\r",
							"   if(this.isEven()) this.dAddOffset(1,0); // force odd\r",
							"   while(!this.isProbablePrime(b)) {\r",
							"     this.dAddOffset(2,0);\r",
							"     if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\r",
							"   }\r",
							" }\r",
							"} else {\r",
							" // new BigInteger(int,RNG)\r",
							" var x = new Array(), t = a&7;\r",
							" x.length = (a>>3)+1;\r",
							" b.nextBytes(x);\r",
							" if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\r",
							" this.fromString(x,256);\r",
							"}\r",
							"}\r",
							"\r",
							"//(public) convert to bigendian byte array\r",
							"function bnToByteArray() {\r",
							"var i = this.t, r = new Array();\r",
							"r[0] = this.s;\r",
							"var p = this.DB-(i*this.DB)%8, d, k = 0;\r",
							"if(i-- > 0) {\r",
							" if(p < this.DB && (d = this.data[i]>>p) != (this.s&this.DM)>>p)\r",
							"   r[k++] = d|(this.s<<(this.DB-p));\r",
							" while(i >= 0) {\r",
							"   if(p < 8) {\r",
							"     d = (this.data[i]&((1<<p)-1))<<(8-p);\r",
							"     d |= this.data[--i]>>(p+=this.DB-8);\r",
							"   } else {\r",
							"     d = (this.data[i]>>(p-=8))&0xff;\r",
							"     if(p <= 0) { p += this.DB; --i; }\r",
							"   }\r",
							"   if((d&0x80) != 0) d |= -256;\r",
							"   if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\r",
							"   if(k > 0 || d != this.s) r[k++] = d;\r",
							" }\r",
							"}\r",
							"return r;\r",
							"}\r",
							"\r",
							"function bnEquals(a) { return(this.compareTo(a)==0); }\r",
							"function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\r",
							"function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\r",
							"\r",
							"//(protected) r = this op a (bitwise)\r",
							"function bnpBitwiseTo(a,op,r) {\r",
							"var i, f, m = Math.min(a.t,this.t);\r",
							"for(i = 0; i < m; ++i) r.data[i] = op(this.data[i],a.data[i]);\r",
							"if(a.t < this.t) {\r",
							" f = a.s&this.DM;\r",
							" for(i = m; i < this.t; ++i) r.data[i] = op(this.data[i],f);\r",
							" r.t = this.t;\r",
							"} else {\r",
							" f = this.s&this.DM;\r",
							" for(i = m; i < a.t; ++i) r.data[i] = op(f,a.data[i]);\r",
							" r.t = a.t;\r",
							"}\r",
							"r.s = op(this.s,a.s);\r",
							"r.clamp();\r",
							"}\r",
							"\r",
							"//(public) this & a\r",
							"function op_and(x,y) { return x&y; }\r",
							"function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\r",
							"\r",
							"//(public) this | a\r",
							"function op_or(x,y) { return x|y; }\r",
							"function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\r",
							"\r",
							"//(public) this ^ a\r",
							"function op_xor(x,y) { return x^y; }\r",
							"function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\r",
							"\r",
							"//(public) this & ~a\r",
							"function op_andnot(x,y) { return x&~y; }\r",
							"function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\r",
							"\r",
							"//(public) ~this\r",
							"function bnNot() {\r",
							"var r = nbi();\r",
							"for(var i = 0; i < this.t; ++i) r.data[i] = this.DM&~this.data[i];\r",
							"r.t = this.t;\r",
							"r.s = ~this.s;\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) this << n\r",
							"function bnShiftLeft(n) {\r",
							"var r = nbi();\r",
							"if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) this >> n\r",
							"function bnShiftRight(n) {\r",
							"var r = nbi();\r",
							"if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//return index of lowest 1-bit in x, x < 2^31\r",
							"function lbit(x) {\r",
							"if(x == 0) return -1;\r",
							"var r = 0;\r",
							"if((x&0xffff) == 0) { x >>= 16; r += 16; }\r",
							"if((x&0xff) == 0) { x >>= 8; r += 8; }\r",
							"if((x&0xf) == 0) { x >>= 4; r += 4; }\r",
							"if((x&3) == 0) { x >>= 2; r += 2; }\r",
							"if((x&1) == 0) ++r;\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) returns index of lowest 1-bit (or -1 if none)\r",
							"function bnGetLowestSetBit() {\r",
							"for(var i = 0; i < this.t; ++i)\r",
							" if(this.data[i] != 0) return i*this.DB+lbit(this.data[i]);\r",
							"if(this.s < 0) return this.t*this.DB;\r",
							"return -1;\r",
							"}\r",
							"\r",
							"//return number of 1 bits in x\r",
							"function cbit(x) {\r",
							"var r = 0;\r",
							"while(x != 0) { x &= x-1; ++r; }\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) return number of set bits\r",
							"function bnBitCount() {\r",
							"var r = 0, x = this.s&this.DM;\r",
							"for(var i = 0; i < this.t; ++i) r += cbit(this.data[i]^x);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) true iff nth bit is set\r",
							"function bnTestBit(n) {\r",
							"var j = Math.floor(n/this.DB);\r",
							"if(j >= this.t) return(this.s!=0);\r",
							"return((this.data[j]&(1<<(n%this.DB)))!=0);\r",
							"}\r",
							"\r",
							"//(protected) this op (1<<n)\r",
							"function bnpChangeBit(n,op) {\r",
							"var r = BigInteger.ONE.shiftLeft(n);\r",
							"this.bitwiseTo(r,op,r);\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) this | (1<<n)\r",
							"function bnSetBit(n) { return this.changeBit(n,op_or); }\r",
							"\r",
							"//(public) this & ~(1<<n)\r",
							"function bnClearBit(n) { return this.changeBit(n,op_andnot); }\r",
							"\r",
							"//(public) this ^ (1<<n)\r",
							"function bnFlipBit(n) { return this.changeBit(n,op_xor); }\r",
							"\r",
							"//(protected) r = this + a\r",
							"function bnpAddTo(a,r) {\r",
							"var i = 0, c = 0, m = Math.min(a.t,this.t);\r",
							"while(i < m) {\r",
							" c += this.data[i]+a.data[i];\r",
							" r.data[i++] = c&this.DM;\r",
							" c >>= this.DB;\r",
							"}\r",
							"if(a.t < this.t) {\r",
							" c += a.s;\r",
							" while(i < this.t) {\r",
							"   c += this.data[i];\r",
							"   r.data[i++] = c&this.DM;\r",
							"   c >>= this.DB;\r",
							" }\r",
							" c += this.s;\r",
							"} else {\r",
							" c += this.s;\r",
							" while(i < a.t) {\r",
							"   c += a.data[i];\r",
							"   r.data[i++] = c&this.DM;\r",
							"   c >>= this.DB;\r",
							" }\r",
							" c += a.s;\r",
							"}\r",
							"r.s = (c<0)?-1:0;\r",
							"if(c > 0) r.data[i++] = c;\r",
							"else if(c < -1) r.data[i++] = this.DV+c;\r",
							"r.t = i;\r",
							"r.clamp();\r",
							"}\r",
							"\r",
							"//(public) this + a\r",
							"function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\r",
							"\r",
							"//(public) this - a\r",
							"function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\r",
							"\r",
							"//(public) this * a\r",
							"function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\r",
							"\r",
							"//(public) this / a\r",
							"function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\r",
							"\r",
							"//(public) this % a\r",
							"function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\r",
							"\r",
							"//(public) [this/a,this%a]\r",
							"function bnDivideAndRemainder(a) {\r",
							"var q = nbi(), r = nbi();\r",
							"this.divRemTo(a,q,r);\r",
							"return new Array(q,r);\r",
							"}\r",
							"\r",
							"//(protected) this *= n, this >= 0, 1 < n < DV\r",
							"function bnpDMultiply(n) {\r",
							"this.data[this.t] = this.am(0,n-1,this,0,0,this.t);\r",
							"++this.t;\r",
							"this.clamp();\r",
							"}\r",
							"\r",
							"//(protected) this += n << w words, this >= 0\r",
							"function bnpDAddOffset(n,w) {\r",
							"if(n == 0) return;\r",
							"while(this.t <= w) this.data[this.t++] = 0;\r",
							"this.data[w] += n;\r",
							"while(this.data[w] >= this.DV) {\r",
							" this.data[w] -= this.DV;\r",
							" if(++w >= this.t) this.data[this.t++] = 0;\r",
							" ++this.data[w];\r",
							"}\r",
							"}\r",
							"\r",
							"//A \"null\" reducer\r",
							"function NullExp() {}\r",
							"function nNop(x) { return x; }\r",
							"function nMulTo(x,y,r) { x.multiplyTo(y,r); }\r",
							"function nSqrTo(x,r) { x.squareTo(r); }\r",
							"\r",
							"NullExp.prototype.convert = nNop;\r",
							"NullExp.prototype.revert = nNop;\r",
							"NullExp.prototype.mulTo = nMulTo;\r",
							"NullExp.prototype.sqrTo = nSqrTo;\r",
							"\r",
							"//(public) this^e\r",
							"function bnPow(e) { return this.exp(e,new NullExp()); }\r",
							"\r",
							"//(protected) r = lower n words of \"this * a\", a.t <= n\r",
							"//\"this\" should be the larger one if appropriate.\r",
							"function bnpMultiplyLowerTo(a,n,r) {\r",
							"var i = Math.min(this.t+a.t,n);\r",
							"r.s = 0; // assumes a,this >= 0\r",
							"r.t = i;\r",
							"while(i > 0) r.data[--i] = 0;\r",
							"var j;\r",
							"for(j = r.t-this.t; i < j; ++i) r.data[i+this.t] = this.am(0,a.data[i],r,i,0,this.t);\r",
							"for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a.data[i],r,i,0,n-i);\r",
							"r.clamp();\r",
							"}\r",
							"\r",
							"//(protected) r = \"this * a\" without lower n words, n > 0\r",
							"//\"this\" should be the larger one if appropriate.\r",
							"function bnpMultiplyUpperTo(a,n,r) {\r",
							"--n;\r",
							"var i = r.t = this.t+a.t-n;\r",
							"r.s = 0; // assumes a,this >= 0\r",
							"while(--i >= 0) r.data[i] = 0;\r",
							"for(i = Math.max(n-this.t,0); i < a.t; ++i)\r",
							" r.data[this.t+i-n] = this.am(n-i,a.data[i],r,0,0,this.t+i-n);\r",
							"r.clamp();\r",
							"r.drShiftTo(1,r);\r",
							"}\r",
							"\r",
							"//Barrett modular reduction\r",
							"function Barrett(m) {\r",
							"// setup Barrett\r",
							"this.r2 = nbi();\r",
							"this.q3 = nbi();\r",
							"BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\r",
							"this.mu = this.r2.divide(m);\r",
							"this.m = m;\r",
							"}\r",
							"\r",
							"function barrettConvert(x) {\r",
							"if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\r",
							"else if(x.compareTo(this.m) < 0) return x;\r",
							"else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\r",
							"}\r",
							"\r",
							"function barrettRevert(x) { return x; }\r",
							"\r",
							"//x = x mod m (HAC 14.42)\r",
							"function barrettReduce(x) {\r",
							"x.drShiftTo(this.m.t-1,this.r2);\r",
							"if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\r",
							"this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\r",
							"this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\r",
							"while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\r",
							"x.subTo(this.r2,x);\r",
							"while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r",
							"}\r",
							"\r",
							"//r = x^2 mod m; x != r\r",
							"function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r",
							"\r",
							"//r = x*y mod m; x,y != r\r",
							"function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r",
							"\r",
							"Barrett.prototype.convert = barrettConvert;\r",
							"Barrett.prototype.revert = barrettRevert;\r",
							"Barrett.prototype.reduce = barrettReduce;\r",
							"Barrett.prototype.mulTo = barrettMulTo;\r",
							"Barrett.prototype.sqrTo = barrettSqrTo;\r",
							"\r",
							"//(public) this^e % m (HAC 14.85)\r",
							"function bnModPow(e,m) {\r",
							"var i = e.bitLength(), k, r = nbv(1), z;\r",
							"if(i <= 0) return r;\r",
							"else if(i < 18) k = 1;\r",
							"else if(i < 48) k = 3;\r",
							"else if(i < 144) k = 4;\r",
							"else if(i < 768) k = 5;\r",
							"else k = 6;\r",
							"if(i < 8)\r",
							" z = new Classic(m);\r",
							"else if(m.isEven())\r",
							" z = new Barrett(m);\r",
							"else\r",
							" z = new Montgomery(m);\r",
							"\r",
							"// precomputation\r",
							"var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\r",
							"g[1] = z.convert(this);\r",
							"if(k > 1) {\r",
							" var g2 = nbi();\r",
							" z.sqrTo(g[1],g2);\r",
							" while(n <= km) {\r",
							"   g[n] = nbi();\r",
							"   z.mulTo(g2,g[n-2],g[n]);\r",
							"   n += 2;\r",
							" }\r",
							"}\r",
							"\r",
							"var j = e.t-1, w, is1 = true, r2 = nbi(), t;\r",
							"i = nbits(e.data[j])-1;\r",
							"while(j >= 0) {\r",
							" if(i >= k1) w = (e.data[j]>>(i-k1))&km;\r",
							" else {\r",
							"   w = (e.data[j]&((1<<(i+1))-1))<<(k1-i);\r",
							"   if(j > 0) w |= e.data[j-1]>>(this.DB+i-k1);\r",
							" }\r",
							"\r",
							" n = k;\r",
							" while((w&1) == 0) { w >>= 1; --n; }\r",
							" if((i -= n) < 0) { i += this.DB; --j; }\r",
							" if(is1) {  // ret == 1, don't bother squaring or multiplying it\r",
							"   g[w].copyTo(r);\r",
							"   is1 = false;\r",
							" } else {\r",
							"   while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\r",
							"   if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\r",
							"   z.mulTo(r2,g[w],r);\r",
							" }\r",
							"\r",
							" while(j >= 0 && (e.data[j]&(1<<i)) == 0) {\r",
							"   z.sqrTo(r,r2); t = r; r = r2; r2 = t;\r",
							"   if(--i < 0) { i = this.DB-1; --j; }\r",
							" }\r",
							"}\r",
							"return z.revert(r);\r",
							"}\r",
							"\r",
							"//(public) gcd(this,a) (HAC 14.54)\r",
							"function bnGCD(a) {\r",
							"var x = (this.s<0)?this.negate():this.clone();\r",
							"var y = (a.s<0)?a.negate():a.clone();\r",
							"if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\r",
							"var i = x.getLowestSetBit(), g = y.getLowestSetBit();\r",
							"if(g < 0) return x;\r",
							"if(i < g) g = i;\r",
							"if(g > 0) {\r",
							" x.rShiftTo(g,x);\r",
							" y.rShiftTo(g,y);\r",
							"}\r",
							"while(x.signum() > 0) {\r",
							" if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\r",
							" if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\r",
							" if(x.compareTo(y) >= 0) {\r",
							"   x.subTo(y,x);\r",
							"   x.rShiftTo(1,x);\r",
							" } else {\r",
							"   y.subTo(x,y);\r",
							"   y.rShiftTo(1,y);\r",
							" }\r",
							"}\r",
							"if(g > 0) y.lShiftTo(g,y);\r",
							"return y;\r",
							"}\r",
							"\r",
							"//(protected) this % n, n < 2^26\r",
							"function bnpModInt(n) {\r",
							"if(n <= 0) return 0;\r",
							"var d = this.DV%n, r = (this.s<0)?n-1:0;\r",
							"if(this.t > 0)\r",
							" if(d == 0) r = this.data[0]%n;\r",
							" else for(var i = this.t-1; i >= 0; --i) r = (d*r+this.data[i])%n;\r",
							"return r;\r",
							"}\r",
							"\r",
							"//(public) 1/this % m (HAC 14.61)\r",
							"function bnModInverse(m) {\r",
							"var ac = m.isEven();\r",
							"if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\r",
							"var u = m.clone(), v = this.clone();\r",
							"var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\r",
							"while(u.signum() != 0) {\r",
							" while(u.isEven()) {\r",
							"   u.rShiftTo(1,u);\r",
							"   if(ac) {\r",
							"     if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\r",
							"     a.rShiftTo(1,a);\r",
							"   } else if(!b.isEven()) b.subTo(m,b);\r",
							"   b.rShiftTo(1,b);\r",
							" }\r",
							" while(v.isEven()) {\r",
							"   v.rShiftTo(1,v);\r",
							"   if(ac) {\r",
							"     if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\r",
							"     c.rShiftTo(1,c);\r",
							"   } else if(!d.isEven()) d.subTo(m,d);\r",
							"   d.rShiftTo(1,d);\r",
							" }\r",
							" if(u.compareTo(v) >= 0) {\r",
							"   u.subTo(v,u);\r",
							"   if(ac) a.subTo(c,a);\r",
							"   b.subTo(d,b);\r",
							" } else {\r",
							"   v.subTo(u,v);\r",
							"   if(ac) c.subTo(a,c);\r",
							"   d.subTo(b,d);\r",
							" }\r",
							"}\r",
							"if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\r",
							"if(d.compareTo(m) >= 0) return d.subtract(m);\r",
							"if(d.signum() < 0) d.addTo(m,d); else return d;\r",
							"if(d.signum() < 0) return d.add(m); else return d;\r",
							"}\r",
							"\r",
							"var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];\r",
							"var lplim = (1<<26)/lowprimes[lowprimes.length-1];\r",
							"\r",
							"//(public) test primality with certainty >= 1-.5^t\r",
							"function bnIsProbablePrime(t) {\r",
							"var i, x = this.abs();\r",
							"if(x.t == 1 && x.data[0] <= lowprimes[lowprimes.length-1]) {\r",
							" for(i = 0; i < lowprimes.length; ++i)\r",
							"   if(x.data[0] == lowprimes[i]) return true;\r",
							" return false;\r",
							"}\r",
							"if(x.isEven()) return false;\r",
							"i = 1;\r",
							"while(i < lowprimes.length) {\r",
							" var m = lowprimes[i], j = i+1;\r",
							" while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\r",
							" m = x.modInt(m);\r",
							" while(i < j) if(m%lowprimes[i++] == 0) return false;\r",
							"}\r",
							"return x.millerRabin(t);\r",
							"}\r",
							"\r",
							"//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\r",
							"function bnpMillerRabin(t) {\r",
							"var n1 = this.subtract(BigInteger.ONE);\r",
							"var k = n1.getLowestSetBit();\r",
							"if(k <= 0) return false;\r",
							"var r = n1.shiftRight(k);\r",
							"var prng = bnGetPrng();\r",
							"var a;\r",
							"for(var i = 0; i < t; ++i) {\r",
							" // select witness 'a' at random from between 1 and n1\r",
							" do {\r",
							"   a = new BigInteger(this.bitLength(), prng);\r",
							" }\r",
							" while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\r",
							" var y = a.modPow(r,this);\r",
							" if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\r",
							"   var j = 1;\r",
							"   while(j++ < k && y.compareTo(n1) != 0) {\r",
							"     y = y.modPowInt(2,this);\r",
							"     if(y.compareTo(BigInteger.ONE) == 0) return false;\r",
							"   }\r",
							"   if(y.compareTo(n1) != 0) return false;\r",
							" }\r",
							"}\r",
							"return true;\r",
							"}\r",
							"\r",
							"// get pseudo random number generator\r",
							"function bnGetPrng() {\r",
							"  // create prng with api that matches BigInteger secure random\r",
							"  return {\r",
							"    // x is an array to fill with bytes\r",
							"    nextBytes: function(x) {\r",
							"      for(var i = 0; i < x.length; ++i) {\r",
							"        x[i] = Math.floor(Math.random() * 0x0100);\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"}\r",
							"\r",
							"//protected\r",
							"BigInteger.prototype.chunkSize = bnpChunkSize;\r",
							"BigInteger.prototype.toRadix = bnpToRadix;\r",
							"BigInteger.prototype.fromRadix = bnpFromRadix;\r",
							"BigInteger.prototype.fromNumber = bnpFromNumber;\r",
							"BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\r",
							"BigInteger.prototype.changeBit = bnpChangeBit;\r",
							"BigInteger.prototype.addTo = bnpAddTo;\r",
							"BigInteger.prototype.dMultiply = bnpDMultiply;\r",
							"BigInteger.prototype.dAddOffset = bnpDAddOffset;\r",
							"BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\r",
							"BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\r",
							"BigInteger.prototype.modInt = bnpModInt;\r",
							"BigInteger.prototype.millerRabin = bnpMillerRabin;\r",
							"\r",
							"//public\r",
							"BigInteger.prototype.clone = bnClone;\r",
							"BigInteger.prototype.intValue = bnIntValue;\r",
							"BigInteger.prototype.byteValue = bnByteValue;\r",
							"BigInteger.prototype.shortValue = bnShortValue;\r",
							"BigInteger.prototype.signum = bnSigNum;\r",
							"BigInteger.prototype.toByteArray = bnToByteArray;\r",
							"BigInteger.prototype.equals = bnEquals;\r",
							"BigInteger.prototype.min = bnMin;\r",
							"BigInteger.prototype.max = bnMax;\r",
							"BigInteger.prototype.and = bnAnd;\r",
							"BigInteger.prototype.or = bnOr;\r",
							"BigInteger.prototype.xor = bnXor;\r",
							"BigInteger.prototype.andNot = bnAndNot;\r",
							"BigInteger.prototype.not = bnNot;\r",
							"BigInteger.prototype.shiftLeft = bnShiftLeft;\r",
							"BigInteger.prototype.shiftRight = bnShiftRight;\r",
							"BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\r",
							"BigInteger.prototype.bitCount = bnBitCount;\r",
							"BigInteger.prototype.testBit = bnTestBit;\r",
							"BigInteger.prototype.setBit = bnSetBit;\r",
							"BigInteger.prototype.clearBit = bnClearBit;\r",
							"BigInteger.prototype.flipBit = bnFlipBit;\r",
							"BigInteger.prototype.add = bnAdd;\r",
							"BigInteger.prototype.subtract = bnSubtract;\r",
							"BigInteger.prototype.multiply = bnMultiply;\r",
							"BigInteger.prototype.divide = bnDivide;\r",
							"BigInteger.prototype.remainder = bnRemainder;\r",
							"BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\r",
							"BigInteger.prototype.modPow = bnModPow;\r",
							"BigInteger.prototype.modInverse = bnModInverse;\r",
							"BigInteger.prototype.pow = bnPow;\r",
							"BigInteger.prototype.gcd = bnGCD;\r",
							"BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\r",
							"\r",
							"//BigInteger interfaces not implemented in jsbn:\r",
							"\r",
							"//BigInteger(int signum, byte[] magnitude)\r",
							"//double doubleValue()\r",
							"//float floatValue()\r",
							"//int hashCode()\r",
							"//long longValue()\r",
							"//static BigInteger valueOf(long val)\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 13 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Cipher base API.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"module.exports = forge.cipher = forge.cipher || {};\r",
							"\r",
							"// registered algorithms\r",
							"forge.cipher.algorithms = forge.cipher.algorithms || {};\r",
							"\r",
							"/**\r",
							" * Creates a cipher object that can be used to encrypt data using the given\r",
							" * algorithm and key. The algorithm may be provided as a string value for a\r",
							" * previously registered algorithm or it may be given as a cipher algorithm\r",
							" * API object.\r",
							" *\r",
							" * @param algorithm the algorithm to use, either a string or an algorithm API\r",
							" *          object.\r",
							" * @param key the key to use, as a binary-encoded string of bytes or a\r",
							" *          byte buffer.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.cipher.createCipher = function(algorithm, key) {\r",
							"  var api = algorithm;\r",
							"  if(typeof api === 'string') {\r",
							"    api = forge.cipher.getAlgorithm(api);\r",
							"    if(api) {\r",
							"      api = api();\r",
							"    }\r",
							"  }\r",
							"  if(!api) {\r",
							"    throw new Error('Unsupported algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  // assume block cipher\r",
							"  return new forge.cipher.BlockCipher({\r",
							"    algorithm: api,\r",
							"    key: key,\r",
							"    decrypt: false\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a decipher object that can be used to decrypt data using the given\r",
							" * algorithm and key. The algorithm may be provided as a string value for a\r",
							" * previously registered algorithm or it may be given as a cipher algorithm\r",
							" * API object.\r",
							" *\r",
							" * @param algorithm the algorithm to use, either a string or an algorithm API\r",
							" *          object.\r",
							" * @param key the key to use, as a binary-encoded string of bytes or a\r",
							" *          byte buffer.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.cipher.createDecipher = function(algorithm, key) {\r",
							"  var api = algorithm;\r",
							"  if(typeof api === 'string') {\r",
							"    api = forge.cipher.getAlgorithm(api);\r",
							"    if(api) {\r",
							"      api = api();\r",
							"    }\r",
							"  }\r",
							"  if(!api) {\r",
							"    throw new Error('Unsupported algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  // assume block cipher\r",
							"  return new forge.cipher.BlockCipher({\r",
							"    algorithm: api,\r",
							"    key: key,\r",
							"    decrypt: true\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Registers an algorithm by name. If the name was already registered, the\r",
							" * algorithm API object will be overwritten.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" * @param algorithm the algorithm API object.\r",
							" */\r",
							"forge.cipher.registerAlgorithm = function(name, algorithm) {\r",
							"  name = name.toUpperCase();\r",
							"  forge.cipher.algorithms[name] = algorithm;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a registered algorithm by name.\r",
							" *\r",
							" * @param name the name of the algorithm.\r",
							" *\r",
							" * @return the algorithm, if found, null if not.\r",
							" */\r",
							"forge.cipher.getAlgorithm = function(name) {\r",
							"  name = name.toUpperCase();\r",
							"  if(name in forge.cipher.algorithms) {\r",
							"    return forge.cipher.algorithms[name];\r",
							"  }\r",
							"  return null;\r",
							"};\r",
							"\r",
							"var BlockCipher = forge.cipher.BlockCipher = function(options) {\r",
							"  this.algorithm = options.algorithm;\r",
							"  this.mode = this.algorithm.mode;\r",
							"  this.blockSize = this.mode.blockSize;\r",
							"  this._finish = false;\r",
							"  this._input = null;\r",
							"  this.output = null;\r",
							"  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\r",
							"  this._decrypt = options.decrypt;\r",
							"  this.algorithm.initialize(options);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Starts or restarts the encryption or decryption process, whichever\r",
							" * was previously configured.\r",
							" *\r",
							" * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\r",
							" * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\r",
							" * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\r",
							" * 32-bit integers, then it must be 4 integers long.\r",
							" *\r",
							" * Note: an IV is not required or used in ECB mode.\r",
							" *\r",
							" * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\r",
							" * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\r",
							" * by NIST SP-800-38D but another length may be given.\r",
							" *\r",
							" * @param options the options to use:\r",
							" *          iv the initialization vector to use as a binary-encoded string of\r",
							" *            bytes, null to reuse the last ciphered block from a previous\r",
							" *            update() (this \"residue\" method is for legacy support only).\r",
							" *          additionalData additional authentication data as a binary-encoded\r",
							" *            string of bytes, for 'GCM' mode, (default: none).\r",
							" *          tagLength desired length of authentication tag, in bits, for\r",
							" *            'GCM' mode (0-128, default: 128).\r",
							" *          tag the authentication tag to check if decrypting, as a\r",
							" *             binary-encoded string of bytes.\r",
							" *          output the output the buffer to write to, null to create one.\r",
							" */\r",
							"BlockCipher.prototype.start = function(options) {\r",
							"  options = options || {};\r",
							"  var opts = {};\r",
							"  for(var key in options) {\r",
							"    opts[key] = options[key];\r",
							"  }\r",
							"  opts.decrypt = this._decrypt;\r",
							"  this._finish = false;\r",
							"  this._input = forge.util.createBuffer();\r",
							"  this.output = options.output || forge.util.createBuffer();\r",
							"  this.mode.start(opts);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Updates the next block according to the cipher mode.\r",
							" *\r",
							" * @param input the buffer to read from.\r",
							" */\r",
							"BlockCipher.prototype.update = function(input) {\r",
							"  if(input) {\r",
							"    // input given, so empty it into the input buffer\r",
							"    this._input.putBuffer(input);\r",
							"  }\r",
							"\r",
							"  // do cipher operation until it needs more input and not finished\r",
							"  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&\r",
							"    !this._finish) {}\r",
							"\r",
							"  // free consumed memory from input buffer\r",
							"  this._input.compact();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Finishes encrypting or decrypting.\r",
							" *\r",
							" * @param pad a padding function to use in CBC mode, null for default,\r",
							" *          signature(blockSize, buffer, decrypt).\r",
							" *\r",
							" * @return true if successful, false on error.\r",
							" */\r",
							"BlockCipher.prototype.finish = function(pad) {\r",
							"  // backwards-compatibility w/deprecated padding API\r",
							"  // Note: will overwrite padding functions even after another start() call\r",
							"  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\r",
							"    this.mode.pad = function(input) {\r",
							"      return pad(this.blockSize, input, false);\r",
							"    };\r",
							"    this.mode.unpad = function(output) {\r",
							"      return pad(this.blockSize, output, true);\r",
							"    };\r",
							"  }\r",
							"\r",
							"  // build options for padding and afterFinish functions\r",
							"  var options = {};\r",
							"  options.decrypt = this._decrypt;\r",
							"\r",
							"  // get # of bytes that won't fill a block\r",
							"  options.overflow = this._input.length() % this.blockSize;\r",
							"\r",
							"  if(!this._decrypt && this.mode.pad) {\r",
							"    if(!this.mode.pad(this._input, options)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // do final update\r",
							"  this._finish = true;\r",
							"  this.update();\r",
							"\r",
							"  if(this._decrypt && this.mode.unpad) {\r",
							"    if(!this.mode.unpad(this.output, options)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(this.mode.afterFinish) {\r",
							"    if(!this.mode.afterFinish(this.output, options)) {\r",
							"      return false;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return true;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 14 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Message Digest Algorithm 5 with 128-bit digest (MD5) implementation.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var md5 = module.exports = forge.md5 = forge.md5 || {};\r",
							"forge.md.md5 = forge.md.algorithms.md5 = md5;\r",
							"\r",
							"/**\r",
							" * Creates an MD5 message digest object.\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"md5.create = function() {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  // MD5 state contains four 32-bit integers\r",
							"  var _state = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for word storage\r",
							"  var _w = new Array(16);\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    algorithm: 'md5',\r",
							"    blockLength: 64,\r",
							"    digestLength: 16,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 8\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength64 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength64 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _state = {\r",
							"      h0: 0x67452301,\r",
							"      h1: 0xEFCDAB89,\r",
							"      h2: 0x98BADCFE,\r",
							"      h3: 0x10325476\r",
							"    };\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = (len[1] / 0x100000000) >>> 0;\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_state, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the digest.\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate MD5 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 448 mod 512. In other words,\r",
							"    the data to be digested must be a multiple of 512 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 8 bytes (64\r",
							"    bits), that means that the last segment of the data must have 56 bytes\r",
							"    (448 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 448 mod 512 because\r",
							"    512 - 128 = 448.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 448 mod 512, then 512 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in little-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry\r",
							"    var bits, carry = 0;\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      bits = md.fullMessageLength[i] * 8 + carry;\r",
							"      carry = (bits / 0x100000000) >>> 0;\r",
							"      finalBlock.putInt32Le(bits >>> 0);\r",
							"    }\r",
							"\r",
							"    var s2 = {\r",
							"      h0: _state.h0,\r",
							"      h1: _state.h1,\r",
							"      h2: _state.h2,\r",
							"      h3: _state.h3\r",
							"    };\r",
							"    _update(s2, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    rval.putInt32Le(s2.h0);\r",
							"    rval.putInt32Le(s2.h1);\r",
							"    rval.putInt32Le(s2.h2);\r",
							"    rval.putInt32Le(s2.h3);\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// padding, constant tables for calculating md5\r",
							"var _padding = null;\r",
							"var _g = null;\r",
							"var _r = null;\r",
							"var _k = null;\r",
							"var _initialized = false;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\r",
							"\r",
							"  // g values\r",
							"  _g = [\r",
							"    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r",
							"    1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,\r",
							"    5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,\r",
							"    0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];\r",
							"\r",
							"  // rounds table\r",
							"  _r = [\r",
							"    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\r",
							"    5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\r",
							"    4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\r",
							"    6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21];\r",
							"\r",
							"  // get the result of abs(sin(i + 1)) as a 32-bit integer\r",
							"  _k = new Array(64);\r",
							"  for(var i = 0; i < 64; ++i) {\r",
							"    _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);\r",
							"  }\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates an MD5 state with the given byte buffer.\r",
							" *\r",
							" * @param s the MD5 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (64 byte) chunks\r",
							"  var t, a, b, c, d, f, r, i;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 64) {\r",
							"    // initialize hash value for this chunk\r",
							"    a = s.h0;\r",
							"    b = s.h1;\r",
							"    c = s.h2;\r",
							"    d = s.h3;\r",
							"\r",
							"    // round 1\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      w[i] = bytes.getInt32Le();\r",
							"      f = d ^ (b & (c ^ d));\r",
							"      t = (a + f + _k[i] + w[i]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"    // round 2\r",
							"    for(; i < 32; ++i) {\r",
							"      f = c ^ (d & (b ^ c));\r",
							"      t = (a + f + _k[i] + w[_g[i]]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"    // round 3\r",
							"    for(; i < 48; ++i) {\r",
							"      f = b ^ c ^ d;\r",
							"      t = (a + f + _k[i] + w[_g[i]]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"    // round 4\r",
							"    for(; i < 64; ++i) {\r",
							"      f = c ^ (b | ~d);\r",
							"      t = (a + f + _k[i] + w[_g[i]]);\r",
							"      r = _r[i];\r",
							"      a = d;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b += (t << r) | (t >>> (32 - r));\r",
							"    }\r",
							"\r",
							"    // update hash state\r",
							"    s.h0 = (s.h0 + a) | 0;\r",
							"    s.h1 = (s.h1 + b) | 0;\r",
							"    s.h2 = (s.h2 + c) | 0;\r",
							"    s.h3 = (s.h3 + d) | 0;\r",
							"\r",
							"    len -= 64;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 15 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Password-Based Key-Derivation Function #2 implementation.\r",
							" *\r",
							" * See RFC 2898 for details.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\r",
							"\r",
							"var crypto;\r",
							"if(forge.util.isNodejs && !forge.options.usePureJavaScript) {\r",
							"  crypto = __webpack_require__(22);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Derives a key from a password.\r",
							" *\r",
							" * @param p the password as a binary-encoded string of bytes.\r",
							" * @param s the salt as a binary-encoded string of bytes.\r",
							" * @param c the iteration count, a positive integer.\r",
							" * @param dkLen the intended length, in bytes, of the derived key,\r",
							" *          (max: 2^32 - 1) * hash length of the PRF.\r",
							" * @param [md] the message digest (or algorithm identifier as a string) to use\r",
							" *          in the PRF, defaults to SHA-1.\r",
							" * @param [callback(err, key)] presence triggers asynchronous version, called\r",
							" *          once the operation completes.\r",
							" *\r",
							" * @return the derived key, as a binary-encoded string of bytes, for the\r",
							" *           synchronous version (if no callback is specified).\r",
							" */\r",
							"module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(\r",
							"  p, s, c, dkLen, md, callback) {\r",
							"  if(typeof md === 'function') {\r",
							"    callback = md;\r",
							"    md = null;\r",
							"  }\r",
							"\r",
							"  // use native implementation if possible and not disabled, note that\r",
							"  // some node versions only support SHA-1, others allow digest to be changed\r",
							"  if(forge.util.isNodejs && !forge.options.usePureJavaScript &&\r",
							"    crypto.pbkdf2 && (md === null || typeof md !== 'object') &&\r",
							"    (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {\r",
							"    if(typeof md !== 'string') {\r",
							"      // default prf to SHA-1\r",
							"      md = 'sha1';\r",
							"    }\r",
							"    p = new Buffer(p, 'binary');\r",
							"    s = new Buffer(s, 'binary');\r",
							"    if(!callback) {\r",
							"      if(crypto.pbkdf2Sync.length === 4) {\r",
							"        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');\r",
							"      }\r",
							"      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');\r",
							"    }\r",
							"    if(crypto.pbkdf2Sync.length === 4) {\r",
							"      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {\r",
							"        if(err) {\r",
							"          return callback(err);\r",
							"        }\r",
							"        callback(null, key.toString('binary'));\r",
							"      });\r",
							"    }\r",
							"    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"      callback(null, key.toString('binary'));\r",
							"    });\r",
							"  }\r",
							"\r",
							"  if(typeof md === 'undefined' || md === null) {\r",
							"    // default prf to SHA-1\r",
							"    md = 'sha1';\r",
							"  }\r",
							"  if(typeof md === 'string') {\r",
							"    if(!(md in forge.md.algorithms)) {\r",
							"      throw new Error('Unknown hash algorithm: ' + md);\r",
							"    }\r",
							"    md = forge.md[md].create();\r",
							"  }\r",
							"\r",
							"  var hLen = md.digestLength;\r",
							"\r",
							"  /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\r",
							"    stop. */\r",
							"  if(dkLen > (0xFFFFFFFF * hLen)) {\r",
							"    var err = new Error('Derived key is too long.');\r",
							"    if(callback) {\r",
							"      return callback(err);\r",
							"    }\r",
							"    throw err;\r",
							"  }\r",
							"\r",
							"  /* 2. Let len be the number of hLen-octet blocks in the derived key,\r",
							"    rounding up, and let r be the number of octets in the last\r",
							"    block:\r",
							"\r",
							"    len = CEIL(dkLen / hLen),\r",
							"    r = dkLen - (len - 1) * hLen. */\r",
							"  var len = Math.ceil(dkLen / hLen);\r",
							"  var r = dkLen - (len - 1) * hLen;\r",
							"\r",
							"  /* 3. For each block of the derived key apply the function F defined\r",
							"    below to the password P, the salt S, the iteration count c, and\r",
							"    the block index to compute the block:\r",
							"\r",
							"    T_1 = F(P, S, c, 1),\r",
							"    T_2 = F(P, S, c, 2),\r",
							"    ...\r",
							"    T_len = F(P, S, c, len),\r",
							"\r",
							"    where the function F is defined as the exclusive-or sum of the\r",
							"    first c iterates of the underlying pseudorandom function PRF\r",
							"    applied to the password P and the concatenation of the salt S\r",
							"    and the block index i:\r",
							"\r",
							"    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\r",
							"\r",
							"    where\r",
							"\r",
							"    u_1 = PRF(P, S || INT(i)),\r",
							"    u_2 = PRF(P, u_1),\r",
							"    ...\r",
							"    u_c = PRF(P, u_{c-1}).\r",
							"\r",
							"    Here, INT(i) is a four-octet encoding of the integer i, most\r",
							"    significant octet first. */\r",
							"  var prf = forge.hmac.create();\r",
							"  prf.start(md, p);\r",
							"  var dk = '';\r",
							"  var xor, u_c, u_c1;\r",
							"\r",
							"  // sync version\r",
							"  if(!callback) {\r",
							"    for(var i = 1; i <= len; ++i) {\r",
							"      // PRF(P, S || INT(i)) (first iteration)\r",
							"      prf.start(null, null);\r",
							"      prf.update(s);\r",
							"      prf.update(forge.util.int32ToBytes(i));\r",
							"      xor = u_c1 = prf.digest().getBytes();\r",
							"\r",
							"      // PRF(P, u_{c-1}) (other iterations)\r",
							"      for(var j = 2; j <= c; ++j) {\r",
							"        prf.start(null, null);\r",
							"        prf.update(u_c1);\r",
							"        u_c = prf.digest().getBytes();\r",
							"        // F(p, s, c, i)\r",
							"        xor = forge.util.xorBytes(xor, u_c, hLen);\r",
							"        u_c1 = u_c;\r",
							"      }\r",
							"\r",
							"      /* 4. Concatenate the blocks and extract the first dkLen octets to\r",
							"        produce a derived key DK:\r",
							"\r",
							"        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\r",
							"      dk += (i < len) ? xor : xor.substr(0, r);\r",
							"    }\r",
							"    /* 5. Output the derived key DK. */\r",
							"    return dk;\r",
							"  }\r",
							"\r",
							"  // async version\r",
							"  var i = 1, j;\r",
							"  function outer() {\r",
							"    if(i > len) {\r",
							"      // done\r",
							"      return callback(null, dk);\r",
							"    }\r",
							"\r",
							"    // PRF(P, S || INT(i)) (first iteration)\r",
							"    prf.start(null, null);\r",
							"    prf.update(s);\r",
							"    prf.update(forge.util.int32ToBytes(i));\r",
							"    xor = u_c1 = prf.digest().getBytes();\r",
							"\r",
							"    // PRF(P, u_{c-1}) (other iterations)\r",
							"    j = 2;\r",
							"    inner();\r",
							"  }\r",
							"\r",
							"  function inner() {\r",
							"    if(j <= c) {\r",
							"      prf.start(null, null);\r",
							"      prf.update(u_c1);\r",
							"      u_c = prf.digest().getBytes();\r",
							"      // F(p, s, c, i)\r",
							"      xor = forge.util.xorBytes(xor, u_c, hLen);\r",
							"      u_c1 = u_c;\r",
							"      ++j;\r",
							"      return forge.util.setImmediate(inner);\r",
							"    }\r",
							"\r",
							"    /* 4. Concatenate the blocks and extract the first dkLen octets to\r",
							"      produce a derived key DK:\r",
							"\r",
							"      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\r",
							"    dk += (i < len) ? xor : xor.substr(0, r);\r",
							"\r",
							"    ++i;\r",
							"    outer();\r",
							"  }\r",
							"\r",
							"  outer();\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 16 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of X.509 and related components (such as\r",
							" * Certification Signing Requests) of a Public Key Infrastructure.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * The ASN.1 representation of an X.509v3 certificate is as follows\r",
							" * (see RFC 2459):\r",
							" *\r",
							" * Certificate ::= SEQUENCE {\r",
							" *   tbsCertificate       TBSCertificate,\r",
							" *   signatureAlgorithm   AlgorithmIdentifier,\r",
							" *   signatureValue       BIT STRING\r",
							" * }\r",
							" *\r",
							" * TBSCertificate ::= SEQUENCE {\r",
							" *   version         [0]  EXPLICIT Version DEFAULT v1,\r",
							" *   serialNumber         CertificateSerialNumber,\r",
							" *   signature            AlgorithmIdentifier,\r",
							" *   issuer               Name,\r",
							" *   validity             Validity,\r",
							" *   subject              Name,\r",
							" *   subjectPublicKeyInfo SubjectPublicKeyInfo,\r",
							" *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\r",
							" *                        -- If present, version shall be v2 or v3\r",
							" *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\r",
							" *                        -- If present, version shall be v2 or v3\r",
							" *   extensions      [3]  EXPLICIT Extensions OPTIONAL\r",
							" *                        -- If present, version shall be v3\r",
							" * }\r",
							" *\r",
							" * Version ::= INTEGER  { v1(0), v2(1), v3(2) }\r",
							" *\r",
							" * CertificateSerialNumber ::= INTEGER\r",
							" *\r",
							" * Name ::= CHOICE {\r",
							" *   // only one possible choice for now\r",
							" *   RDNSequence\r",
							" * }\r",
							" *\r",
							" * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\r",
							" *\r",
							" * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue\r",
							" *\r",
							" * AttributeTypeAndValue ::= SEQUENCE {\r",
							" *   type     AttributeType,\r",
							" *   value    AttributeValue\r",
							" * }\r",
							" * AttributeType ::= OBJECT IDENTIFIER\r",
							" * AttributeValue ::= ANY DEFINED BY AttributeType\r",
							" *\r",
							" * Validity ::= SEQUENCE {\r",
							" *   notBefore      Time,\r",
							" *   notAfter       Time\r",
							" * }\r",
							" *\r",
							" * Time ::= CHOICE {\r",
							" *   utcTime        UTCTime,\r",
							" *   generalTime    GeneralizedTime\r",
							" * }\r",
							" *\r",
							" * UniqueIdentifier ::= BIT STRING\r",
							" *\r",
							" * SubjectPublicKeyInfo ::= SEQUENCE {\r",
							" *   algorithm            AlgorithmIdentifier,\r",
							" *   subjectPublicKey     BIT STRING\r",
							" * }\r",
							" *\r",
							" * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension\r",
							" *\r",
							" * Extension ::= SEQUENCE {\r",
							" *   extnID      OBJECT IDENTIFIER,\r",
							" *   critical    BOOLEAN DEFAULT FALSE,\r",
							" *   extnValue   OCTET STRING\r",
							" * }\r",
							" *\r",
							" * The only key algorithm currently supported for PKI is RSA.\r",
							" *\r",
							" * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.\r",
							" *\r",
							" * PKCS#10 v1.7 describes certificate signing requests:\r",
							" *\r",
							" * CertificationRequestInfo:\r",
							" *\r",
							" * CertificationRequestInfo ::= SEQUENCE {\r",
							" *   version       INTEGER { v1(0) } (v1,...),\r",
							" *   subject       Name,\r",
							" *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},\r",
							" *   attributes    [0] Attributes{{ CRIAttributes }}\r",
							" * }\r",
							" *\r",
							" * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}\r",
							" *\r",
							" * CRIAttributes  ATTRIBUTE  ::= {\r",
							" *   ... -- add any locally defined attributes here -- }\r",
							" *\r",
							" * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {\r",
							" *   type   ATTRIBUTE.&id({IOSet}),\r",
							" *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})\r",
							" * }\r",
							" *\r",
							" * CertificationRequest ::= SEQUENCE {\r",
							" *   certificationRequestInfo CertificationRequestInfo,\r",
							" *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},\r",
							" *   signature          BIT STRING\r",
							" * }\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(38);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(17);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/* Public Key Infrastructure (PKI) implementation. */\r",
							"var pki = module.exports = forge.pki = forge.pki || {};\r",
							"var oids = pki.oids;\r",
							"\r",
							"// short name OID mappings\r",
							"var _shortNames = {};\r",
							"_shortNames['CN'] = oids['commonName'];\r",
							"_shortNames['commonName'] = 'CN';\r",
							"_shortNames['C'] = oids['countryName'];\r",
							"_shortNames['countryName'] = 'C';\r",
							"_shortNames['L'] = oids['localityName'];\r",
							"_shortNames['localityName'] = 'L';\r",
							"_shortNames['ST'] = oids['stateOrProvinceName'];\r",
							"_shortNames['stateOrProvinceName'] = 'ST';\r",
							"_shortNames['O'] = oids['organizationName'];\r",
							"_shortNames['organizationName'] = 'O';\r",
							"_shortNames['OU'] = oids['organizationalUnitName'];\r",
							"_shortNames['organizationalUnitName'] = 'OU';\r",
							"_shortNames['E'] = oids['emailAddress'];\r",
							"_shortNames['emailAddress'] = 'E';\r",
							"\r",
							"// validator for an SubjectPublicKeyInfo structure\r",
							"// Note: Currently only works with an RSA public key\r",
							"var publicKeyValidator = forge.pki.rsa.publicKeyValidator;\r",
							"\r",
							"// validator for an X.509v3 certificate\r",
							"var x509CertificateValidator = {\r",
							"  name: 'Certificate',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'Certificate.TBSCertificate',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'tbsCertificate',\r",
							"    value: [{\r",
							"      name: 'Certificate.TBSCertificate.version',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 0,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.version.integer',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.INTEGER,\r",
							"        constructed: false,\r",
							"        capture: 'certVersion'\r",
							"      }]\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.serialNumber',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'certSerialNumber'\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.signature',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.signature.algorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false,\r",
							"        capture: 'certinfoSignatureOid'\r",
							"      }, {\r",
							"        name: 'Certificate.TBSCertificate.signature.parameters',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        optional: true,\r",
							"        captureAsn1: 'certinfoSignatureParams'\r",
							"      }]\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.issuer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'certIssuer'\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.validity',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      // Note: UTC and generalized times may both appear so the capture\r",
							"      // names are based on their detected order, the names used below\r",
							"      // are only for the common case, which validity time really means\r",
							"      // \"notBefore\" and which means \"notAfter\" will be determined by order\r",
							"      value: [{\r",
							"        // notBefore (Time) (UTC time case)\r",
							"        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.UTCTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity1UTCTime'\r",
							"      }, {\r",
							"        // notBefore (Time) (generalized time case)\r",
							"        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.GENERALIZEDTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity2GeneralizedTime'\r",
							"      }, {\r",
							"        // notAfter (Time) (only UTC time is supported)\r",
							"        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.UTCTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity3UTCTime'\r",
							"      }, {\r",
							"        // notAfter (Time) (only UTC time is supported)\r",
							"        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.GENERALIZEDTIME,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'certValidity4GeneralizedTime'\r",
							"      }]\r",
							"    }, {\r",
							"      // Name (subject) (RDNSequence)\r",
							"      name: 'Certificate.TBSCertificate.subject',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'certSubject'\r",
							"    },\r",
							"      // SubjectPublicKeyInfo\r",
							"      publicKeyValidator,\r",
							"    {\r",
							"      // issuerUniqueID (optional)\r",
							"      name: 'Certificate.TBSCertificate.issuerUniqueID',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 1,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.issuerUniqueID.id',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.BITSTRING,\r",
							"        constructed: false,\r",
							"        // TODO: support arbitrary bit length ids\r",
							"        captureBitStringValue: 'certIssuerUniqueId'\r",
							"      }]\r",
							"    }, {\r",
							"      // subjectUniqueID (optional)\r",
							"      name: 'Certificate.TBSCertificate.subjectUniqueID',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 2,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'Certificate.TBSCertificate.subjectUniqueID.id',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.BITSTRING,\r",
							"        constructed: false,\r",
							"        // TODO: support arbitrary bit length ids\r",
							"        captureBitStringValue: 'certSubjectUniqueId'\r",
							"      }]\r",
							"    }, {\r",
							"      // Extensions (optional)\r",
							"      name: 'Certificate.TBSCertificate.extensions',\r",
							"      tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"      type: 3,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'certExtensions',\r",
							"      optional: true\r",
							"    }]\r",
							"  }, {\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    name: 'Certificate.signatureAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      // algorithm\r",
							"      name: 'Certificate.signatureAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'certSignatureOid'\r",
							"    }, {\r",
							"      name: 'Certificate.TBSCertificate.signature.parameters',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      optional: true,\r",
							"      captureAsn1: 'certSignatureParams'\r",
							"    }]\r",
							"  }, {\r",
							"    // SignatureValue\r",
							"    name: 'Certificate.signatureValue',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.BITSTRING,\r",
							"    constructed: false,\r",
							"    captureBitStringValue: 'certSignature'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var rsassaPssParameterValidator = {\r",
							"  name: 'rsapss',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'rsapss.hashAlgorithm',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.SEQUENCE,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false,\r",
							"        capture: 'hashOid'\r",
							"        /* parameter block omitted, for SHA1 NULL anyhow. */\r",
							"      }]\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'rsapss.maskGenAlgorithm',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 1,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.SEQUENCE,\r",
							"      constructed: true,\r",
							"      optional: true,\r",
							"      value: [{\r",
							"        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false,\r",
							"        capture: 'maskGenOid'\r",
							"      }, {\r",
							"        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SEQUENCE,\r",
							"        constructed: true,\r",
							"        value: [{\r",
							"          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          type: asn1.Type.OID,\r",
							"          constructed: false,\r",
							"          capture: 'maskGenHashOid'\r",
							"          /* parameter block omitted, for SHA1 NULL anyhow. */\r",
							"        }]\r",
							"      }]\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'rsapss.saltLength',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 2,\r",
							"    optional: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.saltLength.saltLength',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'saltLength'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'rsapss.trailerField',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 3,\r",
							"    optional: true,\r",
							"    value: [{\r",
							"      name: 'rsapss.trailer.trailer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'trailer'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for a CertificationRequestInfo structure\r",
							"var certificationRequestInfoValidator = {\r",
							"  name: 'CertificationRequestInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  captureAsn1: 'certificationRequestInfo',\r",
							"  value: [{\r",
							"    name: 'CertificationRequestInfo.integer',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'certificationRequestInfoVersion'\r",
							"  }, {\r",
							"    // Name (subject) (RDNSequence)\r",
							"    name: 'CertificationRequestInfo.subject',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'certificationRequestInfoSubject'\r",
							"  },\r",
							"  // SubjectPublicKeyInfo\r",
							"  publicKeyValidator,\r",
							"  {\r",
							"    name: 'CertificationRequestInfo.attributes',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'certificationRequestInfoAttributes',\r",
							"    value: [{\r",
							"      name: 'CertificationRequestInfo.attributes',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'CertificationRequestInfo.attributes.type',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OID,\r",
							"        constructed: false\r",
							"      }, {\r",
							"        name: 'CertificationRequestInfo.attributes.value',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SET,\r",
							"        constructed: true\r",
							"      }]\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for a CertificationRequest structure\r",
							"var certificationRequestValidator = {\r",
							"  name: 'CertificationRequest',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  captureAsn1: 'csr',\r",
							"  value: [\r",
							"    certificationRequestInfoValidator, {\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    name: 'CertificationRequest.signatureAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      // algorithm\r",
							"      name: 'CertificationRequest.signatureAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'csrSignatureOid'\r",
							"    }, {\r",
							"      name: 'CertificationRequest.signatureAlgorithm.parameters',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      optional: true,\r",
							"      captureAsn1: 'csrSignatureParams'\r",
							"    }]\r",
							"  }, {\r",
							"    // signature\r",
							"    name: 'CertificationRequest.signature',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.BITSTRING,\r",
							"    constructed: false,\r",
							"    captureBitStringValue: 'csrSignature'\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName\r",
							" * sets into an array with objects that have type and value properties.\r",
							" *\r",
							" * @param rdn the RDNSequence to convert.\r",
							" * @param md a message digest to append type and value to if provided.\r",
							" */\r",
							"pki.RDNAttributesAsArray = function(rdn, md) {\r",
							"  var rval = [];\r",
							"\r",
							"  // each value in 'rdn' in is a SET of RelativeDistinguishedName\r",
							"  var set, attr, obj;\r",
							"  for(var si = 0; si < rdn.value.length; ++si) {\r",
							"    // get the RelativeDistinguishedName set\r",
							"    set = rdn.value[si];\r",
							"\r",
							"    // each value in the SET is an AttributeTypeAndValue sequence\r",
							"    // containing first a type (an OID) and second a value (defined by\r",
							"    // the OID)\r",
							"    for(var i = 0; i < set.value.length; ++i) {\r",
							"      obj = {};\r",
							"      attr = set.value[i];\r",
							"      obj.type = asn1.derToOid(attr.value[0].value);\r",
							"      obj.value = attr.value[1].value;\r",
							"      obj.valueTagClass = attr.value[1].type;\r",
							"      // if the OID is known, get its name and short name\r",
							"      if(obj.type in oids) {\r",
							"        obj.name = oids[obj.type];\r",
							"        if(obj.name in _shortNames) {\r",
							"          obj.shortName = _shortNames[obj.name];\r",
							"        }\r",
							"      }\r",
							"      if(md) {\r",
							"        md.update(obj.type);\r",
							"        md.update(obj.value);\r",
							"      }\r",
							"      rval.push(obj);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts ASN.1 CRIAttributes into an array with objects that have type and\r",
							" * value properties.\r",
							" *\r",
							" * @param attributes the CRIAttributes to convert.\r",
							" */\r",
							"pki.CRIAttributesAsArray = function(attributes) {\r",
							"  var rval = [];\r",
							"\r",
							"  // each value in 'attributes' in is a SEQUENCE with an OID and a SET\r",
							"  for(var si = 0; si < attributes.length; ++si) {\r",
							"    // get the attribute sequence\r",
							"    var seq = attributes[si];\r",
							"\r",
							"    // each value in the SEQUENCE containing first a type (an OID) and\r",
							"    // second a set of values (defined by the OID)\r",
							"    var type = asn1.derToOid(seq.value[0].value);\r",
							"    var values = seq.value[1].value;\r",
							"    for(var vi = 0; vi < values.length; ++vi) {\r",
							"      var obj = {};\r",
							"      obj.type = type;\r",
							"      obj.value = values[vi].value;\r",
							"      obj.valueTagClass = values[vi].type;\r",
							"      // if the OID is known, get its name and short name\r",
							"      if(obj.type in oids) {\r",
							"        obj.name = oids[obj.type];\r",
							"        if(obj.name in _shortNames) {\r",
							"          obj.shortName = _shortNames[obj.name];\r",
							"        }\r",
							"      }\r",
							"      // parse extensions\r",
							"      if(obj.type === oids.extensionRequest) {\r",
							"        obj.extensions = [];\r",
							"        for(var ei = 0; ei < obj.value.length; ++ei) {\r",
							"          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));\r",
							"        }\r",
							"      }\r",
							"      rval.push(obj);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets an issuer or subject attribute from its name, type, or short name.\r",
							" *\r",
							" * @param obj the issuer or subject object.\r",
							" * @param options a short name string or an object with:\r",
							" *          shortName the short name for the attribute.\r",
							" *          name the name for the attribute.\r",
							" *          type the type for the attribute.\r",
							" *\r",
							" * @return the attribute.\r",
							" */\r",
							"function _getAttribute(obj, options) {\r",
							"  if(typeof options === 'string') {\r",
							"    options = {shortName: options};\r",
							"  }\r",
							"\r",
							"  var rval = null;\r",
							"  var attr;\r",
							"  for(var i = 0; rval === null && i < obj.attributes.length; ++i) {\r",
							"    attr = obj.attributes[i];\r",
							"    if(options.type && options.type === attr.type) {\r",
							"      rval = attr;\r",
							"    } else if(options.name && options.name === attr.name) {\r",
							"      rval = attr;\r",
							"    } else if(options.shortName && options.shortName === attr.shortName) {\r",
							"      rval = attr;\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts signature parameters from ASN.1 structure.\r",
							" *\r",
							" * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had\r",
							" * no parameters.\r",
							" *\r",
							" * RSASSA-PSS-params  ::=  SEQUENCE  {\r",
							" *   hashAlgorithm      [0] HashAlgorithm DEFAULT\r",
							" *                             sha1Identifier,\r",
							" *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT\r",
							" *                             mgf1SHA1Identifier,\r",
							" *   saltLength         [2] INTEGER DEFAULT 20,\r",
							" *   trailerField       [3] INTEGER DEFAULT 1\r",
							" * }\r",
							" *\r",
							" * HashAlgorithm  ::=  AlgorithmIdentifier\r",
							" *\r",
							" * MaskGenAlgorithm  ::=  AlgorithmIdentifier\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *   algorithm OBJECT IDENTIFIER,\r",
							" *   parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * @param oid The OID specifying the signature algorithm\r",
							" * @param obj The ASN.1 structure holding the parameters\r",
							" * @param fillDefaults Whether to use return default values where omitted\r",
							" * @return signature parameter object\r",
							" */\r",
							"var _readSignatureParameters = function(oid, obj, fillDefaults) {\r",
							"  var params = {};\r",
							"\r",
							"  if(oid !== oids['RSASSA-PSS']) {\r",
							"    return params;\r",
							"  }\r",
							"\r",
							"  if(fillDefaults) {\r",
							"    params = {\r",
							"      hash: {\r",
							"        algorithmOid: oids['sha1']\r",
							"      },\r",
							"      mgf: {\r",
							"        algorithmOid: oids['mgf1'],\r",
							"        hash: {\r",
							"          algorithmOid: oids['sha1']\r",
							"        }\r",
							"      },\r",
							"      saltLength: 20\r",
							"    };\r",
							"  }\r",
							"\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read RSASSA-PSS parameter block.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(capture.hashOid !== undefined) {\r",
							"    params.hash = params.hash || {};\r",
							"    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);\r",
							"  }\r",
							"\r",
							"  if(capture.maskGenOid !== undefined) {\r",
							"    params.mgf = params.mgf || {};\r",
							"    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);\r",
							"    params.mgf.hash = params.mgf.hash || {};\r",
							"    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);\r",
							"  }\r",
							"\r",
							"  if(capture.saltLength !== undefined) {\r",
							"    params.saltLength = capture.saltLength.charCodeAt(0);\r",
							"  }\r",
							"\r",
							"  return params;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509 certificate from PEM format.\r",
							" *\r",
							" * Note: If the certificate is to be verified then compute hash should\r",
							" * be set to true. This will scan the TBSCertificate part of the ASN.1\r",
							" * object while it is converted so it doesn't need to be converted back\r",
							" * to ASN.1-DER-encoding later.\r",
							" *\r",
							" * @param pem the PEM-formatted certificate.\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" * @param strict true to be strict when checking ASN.1 value lengths, false to\r",
							" *          allow truncated values (default: true).\r",
							" *\r",
							" * @return the certificate.\r",
							" */\r",
							"pki.certificateFromPem = function(pem, computeHash, strict) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'CERTIFICATE' &&\r",
							"    msg.type !== 'X509 CERTIFICATE' &&\r",
							"    msg.type !== 'TRUSTED CERTIFICATE') {\r",
							"    var error = new Error('Could not convert certificate from PEM; PEM header type ' +\r",
							"      'is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert certificate from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body, strict);\r",
							"\r",
							"  return pki.certificateFromAsn1(obj, computeHash);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509 certificate to PEM format.\r",
							" *\r",
							" * @param cert the certificate.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted certificate.\r",
							" */\r",
							"pki.certificateToPem = function(cert, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'CERTIFICATE',\r",
							"    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA public key from PEM format.\r",
							" *\r",
							" * @param pem the PEM-formatted public key.\r",
							" *\r",
							" * @return the public key.\r",
							" */\r",
							"pki.publicKeyFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {\r",
							"    var error = new Error('Could not convert public key from PEM; PEM header ' +\r",
							"      'type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert public key from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body);\r",
							"\r",
							"  return pki.publicKeyFromAsn1(obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).\r",
							" *\r",
							" * @param key the public key.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted public key.\r",
							" */\r",
							"pki.publicKeyToPem = function(key, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'PUBLIC KEY',\r",
							"    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA public key to PEM format (using an RSAPublicKey).\r",
							" *\r",
							" * @param key the public key.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted public key.\r",
							" */\r",
							"pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'RSA PUBLIC KEY',\r",
							"    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a fingerprint for the given public key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          [md] the message digest object to use (defaults to forge.md.sha1).\r",
							" *          [type] the type of fingerprint, such as 'RSAPublicKey',\r",
							" *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').\r",
							" *          [encoding] an alternative output encoding, such as 'hex'\r",
							" *            (defaults to none, outputs a byte buffer).\r",
							" *          [delimiter] the delimiter to use between bytes for 'hex' encoded\r",
							" *            output, eg: ':' (defaults to none).\r",
							" *\r",
							" * @return the fingerprint as a byte buffer or other encoding based on options.\r",
							" */\r",
							"pki.getPublicKeyFingerprint = function(key, options) {\r",
							"  options = options || {};\r",
							"  var md = options.md || forge.md.sha1.create();\r",
							"  var type = options.type || 'RSAPublicKey';\r",
							"\r",
							"  var bytes;\r",
							"  switch(type) {\r",
							"  case 'RSAPublicKey':\r",
							"    bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();\r",
							"    break;\r",
							"  case 'SubjectPublicKeyInfo':\r",
							"    bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();\r",
							"    break;\r",
							"  default:\r",
							"    throw new Error('Unknown fingerprint type \"' + options.type + '\".');\r",
							"  }\r",
							"\r",
							"  // hash public key bytes\r",
							"  md.start();\r",
							"  md.update(bytes);\r",
							"  var digest = md.digest();\r",
							"  if(options.encoding === 'hex') {\r",
							"    var hex = digest.toHex();\r",
							"    if(options.delimiter) {\r",
							"      return hex.match(/.{2}/g).join(options.delimiter);\r",
							"    }\r",
							"    return hex;\r",
							"  } else if(options.encoding === 'binary') {\r",
							"    return digest.getBytes();\r",
							"  } else if(options.encoding) {\r",
							"    throw new Error('Unknown encoding \"' + options.encoding + '\".');\r",
							"  }\r",
							"  return digest;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request (CSR) from PEM format.\r",
							" *\r",
							" * Note: If the certification request is to be verified then compute hash\r",
							" * should be set to true. This will scan the CertificationRequestInfo part of\r",
							" * the ASN.1 object while it is converted so it doesn't need to be converted\r",
							" * back to ASN.1-DER-encoding later.\r",
							" *\r",
							" * @param pem the PEM-formatted certificate.\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" * @param strict true to be strict when checking ASN.1 value lengths, false to\r",
							" *          allow truncated values (default: true).\r",
							" *\r",
							" * @return the certification request (CSR).\r",
							" */\r",
							"pki.certificationRequestFromPem = function(pem, computeHash, strict) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'CERTIFICATE REQUEST') {\r",
							"    var error = new Error('Could not convert certification request from PEM; ' +\r",
							"      'PEM header type is not \"CERTIFICATE REQUEST\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert certification request from PEM; ' +\r",
							"      'PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body, strict);\r",
							"\r",
							"  return pki.certificationRequestFromAsn1(obj, computeHash);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request (CSR) to PEM format.\r",
							" *\r",
							" * @param csr the certification request.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted certification request.\r",
							" */\r",
							"pki.certificationRequestToPem = function(csr, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'CERTIFICATE REQUEST',\r",
							"    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty X.509v3 RSA certificate.\r",
							" *\r",
							" * @return the certificate.\r",
							" */\r",
							"pki.createCertificate = function() {\r",
							"  var cert = {};\r",
							"  cert.version = 0x02;\r",
							"  cert.serialNumber = '00';\r",
							"  cert.signatureOid = null;\r",
							"  cert.signature = null;\r",
							"  cert.siginfo = {};\r",
							"  cert.siginfo.algorithmOid = null;\r",
							"  cert.validity = {};\r",
							"  cert.validity.notBefore = new Date();\r",
							"  cert.validity.notAfter = new Date();\r",
							"\r",
							"  cert.issuer = {};\r",
							"  cert.issuer.getField = function(sn) {\r",
							"    return _getAttribute(cert.issuer, sn);\r",
							"  };\r",
							"  cert.issuer.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.issuer.attributes.push(attr);\r",
							"  };\r",
							"  cert.issuer.attributes = [];\r",
							"  cert.issuer.hash = null;\r",
							"\r",
							"  cert.subject = {};\r",
							"  cert.subject.getField = function(sn) {\r",
							"    return _getAttribute(cert.subject, sn);\r",
							"  };\r",
							"  cert.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.subject.attributes.push(attr);\r",
							"  };\r",
							"  cert.subject.attributes = [];\r",
							"  cert.subject.hash = null;\r",
							"\r",
							"  cert.extensions = [];\r",
							"  cert.publicKey = null;\r",
							"  cert.md = null;\r",
							"\r",
							"  /**\r",
							"   * Sets the subject of this certificate.\r",
							"   *\r",
							"   * @param attrs the array of subject attributes to use.\r",
							"   * @param uniqueId an optional a unique ID to use.\r",
							"   */\r",
							"  cert.setSubject = function(attrs, uniqueId) {\r",
							"    // set new attributes, clear hash\r",
							"    _fillMissingFields(attrs);\r",
							"    cert.subject.attributes = attrs;\r",
							"    delete cert.subject.uniqueId;\r",
							"    if(uniqueId) {\r",
							"      // TODO: support arbitrary bit length ids\r",
							"      cert.subject.uniqueId = uniqueId;\r",
							"    }\r",
							"    cert.subject.hash = null;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Sets the issuer of this certificate.\r",
							"   *\r",
							"   * @param attrs the array of issuer attributes to use.\r",
							"   * @param uniqueId an optional a unique ID to use.\r",
							"   */\r",
							"  cert.setIssuer = function(attrs, uniqueId) {\r",
							"    // set new attributes, clear hash\r",
							"    _fillMissingFields(attrs);\r",
							"    cert.issuer.attributes = attrs;\r",
							"    delete cert.issuer.uniqueId;\r",
							"    if(uniqueId) {\r",
							"      // TODO: support arbitrary bit length ids\r",
							"      cert.issuer.uniqueId = uniqueId;\r",
							"    }\r",
							"    cert.issuer.hash = null;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Sets the extensions of this certificate.\r",
							"   *\r",
							"   * @param exts the array of extensions to use.\r",
							"   */\r",
							"  cert.setExtensions = function(exts) {\r",
							"    for(var i = 0; i < exts.length; ++i) {\r",
							"      _fillMissingExtensionFields(exts[i], {cert: cert});\r",
							"    }\r",
							"    // set new extensions\r",
							"    cert.extensions = exts;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Gets an extension by its name or id.\r",
							"   *\r",
							"   * @param options the name to use or an object with:\r",
							"   *          name the name to use.\r",
							"   *          id the id to use.\r",
							"   *\r",
							"   * @return the extension or null if not found.\r",
							"   */\r",
							"  cert.getExtension = function(options) {\r",
							"    if(typeof options === 'string') {\r",
							"      options = {name: options};\r",
							"    }\r",
							"\r",
							"    var rval = null;\r",
							"    var ext;\r",
							"    for(var i = 0; rval === null && i < cert.extensions.length; ++i) {\r",
							"      ext = cert.extensions[i];\r",
							"      if(options.id && ext.id === options.id) {\r",
							"        rval = ext;\r",
							"      } else if(options.name && ext.name === options.name) {\r",
							"        rval = ext;\r",
							"      }\r",
							"    }\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Signs this certificate using the given private key.\r",
							"   *\r",
							"   * @param key the private key to sign with.\r",
							"   * @param md the message digest object to use (defaults to forge.md.sha1).\r",
							"   */\r",
							"  cert.sign = function(key, md) {\r",
							"    // TODO: get signature OID from private key\r",
							"    cert.md = md || forge.md.sha1.create();\r",
							"    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];\r",
							"    if(!algorithmOid) {\r",
							"      var error = new Error('Could not compute certificate digest. ' +\r",
							"        'Unknown message digest algorithm OID.');\r",
							"      error.algorithm = cert.md.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;\r",
							"\r",
							"    // get TBSCertificate, convert to DER\r",
							"    cert.tbsCertificate = pki.getTBSCertificate(cert);\r",
							"    var bytes = asn1.toDer(cert.tbsCertificate);\r",
							"\r",
							"    // digest and sign\r",
							"    cert.md.update(bytes.getBytes());\r",
							"    cert.signature = key.sign(cert.md);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Attempts verify the signature on the passed certificate using this\r",
							"   * certificate's public key.\r",
							"   *\r",
							"   * @param child the certificate to verify.\r",
							"   *\r",
							"   * @return true if verified, false if not.\r",
							"   */\r",
							"  cert.verify = function(child) {\r",
							"    var rval = false;\r",
							"\r",
							"    if(!cert.issued(child)) {\r",
							"      var issuer = child.issuer;\r",
							"      var subject = cert.subject;\r",
							"      var error = new Error('The parent certificate did not issue the given child ' +\r",
							"        'certificate; the child certificate\\'s issuer does not match the ' +\r",
							"        'parent\\'s subject.');\r",
							"      error.expectedIssuer = issuer.attributes;\r",
							"      error.actualIssuer = subject.attributes;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    var md = child.md;\r",
							"    if(md === null) {\r",
							"      // check signature OID for supported signature types\r",
							"      if(child.signatureOid in oids) {\r",
							"        var oid = oids[child.signatureOid];\r",
							"        switch(oid) {\r",
							"        case 'sha1WithRSAEncryption':\r",
							"          md = forge.md.sha1.create();\r",
							"          break;\r",
							"        case 'md5WithRSAEncryption':\r",
							"          md = forge.md.md5.create();\r",
							"          break;\r",
							"        case 'sha256WithRSAEncryption':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        case 'sha384WithRSAEncryption':\r",
							"          md = forge.md.sha384.create();\r",
							"          break;\r",
							"        case 'sha512WithRSAEncryption':\r",
							"          md = forge.md.sha512.create();\r",
							"          break;\r",
							"        case 'RSASSA-PSS':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        }\r",
							"      }\r",
							"      if(md === null) {\r",
							"        var error = new Error('Could not compute certificate digest. ' +\r",
							"          'Unknown signature OID.');\r",
							"        error.signatureOid = child.signatureOid;\r",
							"        throw error;\r",
							"      }\r",
							"\r",
							"      // produce DER formatted TBSCertificate and digest it\r",
							"      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);\r",
							"      var bytes = asn1.toDer(tbsCertificate);\r",
							"      md.update(bytes.getBytes());\r",
							"    }\r",
							"\r",
							"    if(md !== null) {\r",
							"      var scheme;\r",
							"\r",
							"      switch(child.signatureOid) {\r",
							"      case oids.sha1WithRSAEncryption:\r",
							"        scheme = undefined;  /* use PKCS#1 v1.5 padding scheme */\r",
							"        break;\r",
							"      case oids['RSASSA-PSS']:\r",
							"        var hash, mgf;\r",
							"\r",
							"        /* initialize mgf */\r",
							"        hash = oids[child.signatureParameters.mgf.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          var error = new Error('Unsupported MGF hash function.');\r",
							"          error.oid = child.signatureParameters.mgf.hash.algorithmOid;\r",
							"          error.name = hash;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = oids[child.signatureParameters.mgf.algorithmOid];\r",
							"        if(mgf === undefined || forge.mgf[mgf] === undefined) {\r",
							"          var error = new Error('Unsupported MGF function.');\r",
							"          error.oid = child.signatureParameters.mgf.algorithmOid;\r",
							"          error.name = mgf;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = forge.mgf[mgf].create(forge.md[hash].create());\r",
							"\r",
							"        /* initialize hash function */\r",
							"        hash = oids[child.signatureParameters.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          throw {\r",
							"            message: 'Unsupported RSASSA-PSS hash function.',\r",
							"            oid: child.signatureParameters.hash.algorithmOid,\r",
							"            name: hash\r",
							"          };\r",
							"        }\r",
							"\r",
							"        scheme = forge.pss.create(forge.md[hash].create(), mgf,\r",
							"          child.signatureParameters.saltLength);\r",
							"        break;\r",
							"      }\r",
							"\r",
							"      // verify signature on cert using public key\r",
							"      rval = cert.publicKey.verify(\r",
							"        md.digest().getBytes(), child.signature, scheme);\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Returns true if this certificate's issuer matches the passed\r",
							"   * certificate's subject. Note that no signature check is performed.\r",
							"   *\r",
							"   * @param parent the certificate to check.\r",
							"   *\r",
							"   * @return true if this certificate's issuer matches the passed certificate's\r",
							"   *         subject.\r",
							"   */\r",
							"  cert.isIssuer = function(parent) {\r",
							"    var rval = false;\r",
							"\r",
							"    var i = cert.issuer;\r",
							"    var s = parent.subject;\r",
							"\r",
							"    // compare hashes if present\r",
							"    if(i.hash && s.hash) {\r",
							"      rval = (i.hash === s.hash);\r",
							"    } else if(i.attributes.length === s.attributes.length) {\r",
							"      // all attributes are the same so issuer matches subject\r",
							"      rval = true;\r",
							"      var iattr, sattr;\r",
							"      for(var n = 0; rval && n < i.attributes.length; ++n) {\r",
							"        iattr = i.attributes[n];\r",
							"        sattr = s.attributes[n];\r",
							"        if(iattr.type !== sattr.type || iattr.value !== sattr.value) {\r",
							"          // attribute mismatch\r",
							"          rval = false;\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Returns true if this certificate's subject matches the issuer of the\r",
							"   * given certificate). Note that not signature check is performed.\r",
							"   *\r",
							"   * @param child the certificate to check.\r",
							"   *\r",
							"   * @return true if this certificate's subject matches the passed\r",
							"   *         certificate's issuer.\r",
							"   */\r",
							"  cert.issued = function(child) {\r",
							"    return child.isIssuer(cert);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Generates the subjectKeyIdentifier for this certificate as byte buffer.\r",
							"   *\r",
							"   * @return the subjectKeyIdentifier for this certificate as byte buffer.\r",
							"   */\r",
							"  cert.generateSubjectKeyIdentifier = function() {\r",
							"    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:\r",
							"\r",
							"      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the\r",
							"        value of the BIT STRING subjectPublicKey (excluding the tag,\r",
							"        length, and number of unused bits).\r",
							"\r",
							"      (2) The keyIdentifier is composed of a four bit type field with\r",
							"        the value 0100 followed by the least significant 60 bits of the\r",
							"        SHA-1 hash of the value of the BIT STRING subjectPublicKey\r",
							"        (excluding the tag, length, and number of unused bit string bits).\r",
							"    */\r",
							"\r",
							"    // skipping the tag, length, and number of unused bits is the same\r",
							"    // as just using the RSAPublicKey (for RSA keys, which are the\r",
							"    // only ones supported)\r",
							"    return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Verifies the subjectKeyIdentifier extension value for this certificate\r",
							"   * against its public key. If no extension is found, false will be\r",
							"   * returned.\r",
							"   *\r",
							"   * @return true if verified, false if not.\r",
							"   */\r",
							"  cert.verifySubjectKeyIdentifier = function() {\r",
							"    var oid = oids['subjectKeyIdentifier'];\r",
							"    for(var i = 0; i < cert.extensions.length; ++i) {\r",
							"      var ext = cert.extensions[i];\r",
							"      if(ext.id === oid) {\r",
							"        var ski = cert.generateSubjectKeyIdentifier().getBytes();\r",
							"        return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);\r",
							"      }\r",
							"    }\r",
							"    return false;\r",
							"  };\r",
							"\r",
							"  return cert;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509v3 RSA certificate from an ASN.1 object.\r",
							" *\r",
							" * Note: If the certificate is to be verified then compute hash should\r",
							" * be set to true. There is currently no implementation for converting\r",
							" * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1\r",
							" * object needs to be scanned before the cert object is created.\r",
							" *\r",
							" * @param obj the asn1 representation of an X.509v3 RSA certificate.\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" *\r",
							" * @return the certificate.\r",
							" */\r",
							"pki.certificateFromAsn1 = function(obj, computeHash) {\r",
							"  // validate certificate and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, x509CertificateValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read X.509 certificate. ' +\r",
							"      'ASN.1 object is not an X509v3 Certificate.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get oid\r",
							"  var oid = asn1.derToOid(capture.publicKeyOid);\r",
							"  if(oid !== pki.oids.rsaEncryption) {\r",
							"    throw new Error('Cannot read public key. OID is not RSA.');\r",
							"  }\r",
							"\r",
							"  // create certificate\r",
							"  var cert = pki.createCertificate();\r",
							"  cert.version = capture.certVersion ?\r",
							"    capture.certVersion.charCodeAt(0) : 0;\r",
							"  var serial = forge.util.createBuffer(capture.certSerialNumber);\r",
							"  cert.serialNumber = serial.toHex();\r",
							"  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);\r",
							"  cert.signatureParameters = _readSignatureParameters(\r",
							"    cert.signatureOid, capture.certSignatureParams, true);\r",
							"  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);\r",
							"  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid,\r",
							"    capture.certinfoSignatureParams, false);\r",
							"  cert.signature = capture.certSignature;\r",
							"\r",
							"  var validity = [];\r",
							"  if(capture.certValidity1UTCTime !== undefined) {\r",
							"    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));\r",
							"  }\r",
							"  if(capture.certValidity2GeneralizedTime !== undefined) {\r",
							"    validity.push(asn1.generalizedTimeToDate(\r",
							"      capture.certValidity2GeneralizedTime));\r",
							"  }\r",
							"  if(capture.certValidity3UTCTime !== undefined) {\r",
							"    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));\r",
							"  }\r",
							"  if(capture.certValidity4GeneralizedTime !== undefined) {\r",
							"    validity.push(asn1.generalizedTimeToDate(\r",
							"      capture.certValidity4GeneralizedTime));\r",
							"  }\r",
							"  if(validity.length > 2) {\r",
							"    throw new Error('Cannot read notBefore/notAfter validity times; more ' +\r",
							"      'than two times were provided in the certificate.');\r",
							"  }\r",
							"  if(validity.length < 2) {\r",
							"    throw new Error('Cannot read notBefore/notAfter validity times; they ' +\r",
							"      'were not provided as either UTCTime or GeneralizedTime.');\r",
							"  }\r",
							"  cert.validity.notBefore = validity[0];\r",
							"  cert.validity.notAfter = validity[1];\r",
							"\r",
							"  // keep TBSCertificate to preserve signature when exporting\r",
							"  cert.tbsCertificate = capture.tbsCertificate;\r",
							"\r",
							"  if(computeHash) {\r",
							"    // check signature OID for supported signature types\r",
							"    cert.md = null;\r",
							"    if(cert.signatureOid in oids) {\r",
							"      var oid = oids[cert.signatureOid];\r",
							"      switch(oid) {\r",
							"      case 'sha1WithRSAEncryption':\r",
							"        cert.md = forge.md.sha1.create();\r",
							"        break;\r",
							"      case 'md5WithRSAEncryption':\r",
							"        cert.md = forge.md.md5.create();\r",
							"        break;\r",
							"      case 'sha256WithRSAEncryption':\r",
							"        cert.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      case 'sha384WithRSAEncryption':\r",
							"        cert.md = forge.md.sha384.create();\r",
							"        break;\r",
							"      case 'sha512WithRSAEncryption':\r",
							"        cert.md = forge.md.sha512.create();\r",
							"        break;\r",
							"      case 'RSASSA-PSS':\r",
							"        cert.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"    if(cert.md === null) {\r",
							"      var error = new Error('Could not compute certificate digest. ' +\r",
							"        'Unknown signature OID.');\r",
							"      error.signatureOid = cert.signatureOid;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // produce DER formatted TBSCertificate and digest it\r",
							"    var bytes = asn1.toDer(cert.tbsCertificate);\r",
							"    cert.md.update(bytes.getBytes());\r",
							"  }\r",
							"\r",
							"  // handle issuer, build issuer message digest\r",
							"  var imd = forge.md.sha1.create();\r",
							"  cert.issuer.getField = function(sn) {\r",
							"    return _getAttribute(cert.issuer, sn);\r",
							"  };\r",
							"  cert.issuer.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.issuer.attributes.push(attr);\r",
							"  };\r",
							"  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);\r",
							"  if(capture.certIssuerUniqueId) {\r",
							"    cert.issuer.uniqueId = capture.certIssuerUniqueId;\r",
							"  }\r",
							"  cert.issuer.hash = imd.digest().toHex();\r",
							"\r",
							"  // handle subject, build subject message digest\r",
							"  var smd = forge.md.sha1.create();\r",
							"  cert.subject.getField = function(sn) {\r",
							"    return _getAttribute(cert.subject, sn);\r",
							"  };\r",
							"  cert.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    cert.subject.attributes.push(attr);\r",
							"  };\r",
							"  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);\r",
							"  if(capture.certSubjectUniqueId) {\r",
							"    cert.subject.uniqueId = capture.certSubjectUniqueId;\r",
							"  }\r",
							"  cert.subject.hash = smd.digest().toHex();\r",
							"\r",
							"  // handle extensions\r",
							"  if(capture.certExtensions) {\r",
							"    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);\r",
							"  } else {\r",
							"    cert.extensions = [];\r",
							"  }\r",
							"\r",
							"  // convert RSA public key from ASN.1\r",
							"  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\r",
							"\r",
							"  return cert;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an ASN.1 extensions object (with extension sequences as its\r",
							" * values) into an array of extension objects with types and values.\r",
							" *\r",
							" * Supported extensions:\r",
							" *\r",
							" * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }\r",
							" * KeyUsage ::= BIT STRING {\r",
							" *   digitalSignature        (0),\r",
							" *   nonRepudiation          (1),\r",
							" *   keyEncipherment         (2),\r",
							" *   dataEncipherment        (3),\r",
							" *   keyAgreement            (4),\r",
							" *   keyCertSign             (5),\r",
							" *   cRLSign                 (6),\r",
							" *   encipherOnly            (7),\r",
							" *   decipherOnly            (8)\r",
							" * }\r",
							" *\r",
							" * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }\r",
							" * BasicConstraints ::= SEQUENCE {\r",
							" *   cA                      BOOLEAN DEFAULT FALSE,\r",
							" *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL\r",
							" * }\r",
							" *\r",
							" * subjectAltName EXTENSION ::= {\r",
							" *   SYNTAX GeneralNames\r",
							" *   IDENTIFIED BY id-ce-subjectAltName\r",
							" * }\r",
							" *\r",
							" * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\r",
							" *\r",
							" * GeneralName ::= CHOICE {\r",
							" *   otherName      [0] INSTANCE OF OTHER-NAME,\r",
							" *   rfc822Name     [1] IA5String,\r",
							" *   dNSName        [2] IA5String,\r",
							" *   x400Address    [3] ORAddress,\r",
							" *   directoryName  [4] Name,\r",
							" *   ediPartyName   [5] EDIPartyName,\r",
							" *   uniformResourceIdentifier [6] IA5String,\r",
							" *   IPAddress      [7] OCTET STRING,\r",
							" *   registeredID   [8] OBJECT IDENTIFIER\r",
							" * }\r",
							" *\r",
							" * OTHER-NAME ::= TYPE-IDENTIFIER\r",
							" *\r",
							" * EDIPartyName ::= SEQUENCE {\r",
							" *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,\r",
							" *   partyName    [1] DirectoryString {ub-name}\r",
							" * }\r",
							" *\r",
							" * @param exts the extensions ASN.1 with extension sequences to parse.\r",
							" *\r",
							" * @return the array.\r",
							" */\r",
							"pki.certificateExtensionsFromAsn1 = function(exts) {\r",
							"  var rval = [];\r",
							"  for(var i = 0; i < exts.value.length; ++i) {\r",
							"    // get extension sequence\r",
							"    var extseq = exts.value[i];\r",
							"    for(var ei = 0; ei < extseq.value.length; ++ei) {\r",
							"      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses a single certificate extension from ASN.1.\r",
							" *\r",
							" * @param ext the extension in ASN.1 format.\r",
							" *\r",
							" * @return the parsed extension as an object.\r",
							" */\r",
							"pki.certificateExtensionFromAsn1 = function(ext) {\r",
							"  // an extension has:\r",
							"  // [0] extnID      OBJECT IDENTIFIER\r",
							"  // [1] critical    BOOLEAN DEFAULT FALSE\r",
							"  // [2] extnValue   OCTET STRING\r",
							"  var e = {};\r",
							"  e.id = asn1.derToOid(ext.value[0].value);\r",
							"  e.critical = false;\r",
							"  if(ext.value[1].type === asn1.Type.BOOLEAN) {\r",
							"    e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);\r",
							"    e.value = ext.value[2].value;\r",
							"  } else {\r",
							"    e.value = ext.value[1].value;\r",
							"  }\r",
							"  // if the oid is known, get its name\r",
							"  if(e.id in oids) {\r",
							"    e.name = oids[e.id];\r",
							"\r",
							"    // handle key usage\r",
							"    if(e.name === 'keyUsage') {\r",
							"      // get value as BIT STRING\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      var b2 = 0x00;\r",
							"      var b3 = 0x00;\r",
							"      if(ev.value.length > 1) {\r",
							"        // skip first byte, just indicates unused bits which\r",
							"        // will be padded with 0s anyway\r",
							"        // get bytes with flag bits\r",
							"        b2 = ev.value.charCodeAt(1);\r",
							"        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;\r",
							"      }\r",
							"      // set flags\r",
							"      e.digitalSignature = (b2 & 0x80) === 0x80;\r",
							"      e.nonRepudiation = (b2 & 0x40) === 0x40;\r",
							"      e.keyEncipherment = (b2 & 0x20) === 0x20;\r",
							"      e.dataEncipherment = (b2 & 0x10) === 0x10;\r",
							"      e.keyAgreement = (b2 & 0x08) === 0x08;\r",
							"      e.keyCertSign = (b2 & 0x04) === 0x04;\r",
							"      e.cRLSign = (b2 & 0x02) === 0x02;\r",
							"      e.encipherOnly = (b2 & 0x01) === 0x01;\r",
							"      e.decipherOnly = (b3 & 0x80) === 0x80;\r",
							"    } else if(e.name === 'basicConstraints') {\r",
							"      // handle basic constraints\r",
							"      // get value as SEQUENCE\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      // get cA BOOLEAN flag (defaults to false)\r",
							"      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {\r",
							"        e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);\r",
							"      } else {\r",
							"        e.cA = false;\r",
							"      }\r",
							"      // get path length constraint\r",
							"      var value = null;\r",
							"      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {\r",
							"        value = ev.value[0].value;\r",
							"      } else if(ev.value.length > 1) {\r",
							"        value = ev.value[1].value;\r",
							"      }\r",
							"      if(value !== null) {\r",
							"        e.pathLenConstraint = asn1.derToInteger(value);\r",
							"      }\r",
							"    } else if(e.name === 'extKeyUsage') {\r",
							"      // handle extKeyUsage\r",
							"      // value is a SEQUENCE of OIDs\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      for(var vi = 0; vi < ev.value.length; ++vi) {\r",
							"        var oid = asn1.derToOid(ev.value[vi].value);\r",
							"        if(oid in oids) {\r",
							"          e[oids[oid]] = true;\r",
							"        } else {\r",
							"          e[oid] = true;\r",
							"        }\r",
							"      }\r",
							"    } else if(e.name === 'nsCertType') {\r",
							"      // handle nsCertType\r",
							"      // get value as BIT STRING\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      var b2 = 0x00;\r",
							"      if(ev.value.length > 1) {\r",
							"        // skip first byte, just indicates unused bits which\r",
							"        // will be padded with 0s anyway\r",
							"        // get bytes with flag bits\r",
							"        b2 = ev.value.charCodeAt(1);\r",
							"      }\r",
							"      // set flags\r",
							"      e.client = (b2 & 0x80) === 0x80;\r",
							"      e.server = (b2 & 0x40) === 0x40;\r",
							"      e.email = (b2 & 0x20) === 0x20;\r",
							"      e.objsign = (b2 & 0x10) === 0x10;\r",
							"      e.reserved = (b2 & 0x08) === 0x08;\r",
							"      e.sslCA = (b2 & 0x04) === 0x04;\r",
							"      e.emailCA = (b2 & 0x02) === 0x02;\r",
							"      e.objCA = (b2 & 0x01) === 0x01;\r",
							"    } else if(\r",
							"      e.name === 'subjectAltName' ||\r",
							"      e.name === 'issuerAltName') {\r",
							"      // handle subjectAltName/issuerAltName\r",
							"      e.altNames = [];\r",
							"\r",
							"      // ev is a SYNTAX SEQUENCE\r",
							"      var gn;\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      for(var n = 0; n < ev.value.length; ++n) {\r",
							"        // get GeneralName\r",
							"        gn = ev.value[n];\r",
							"\r",
							"        var altName = {\r",
							"          type: gn.type,\r",
							"          value: gn.value\r",
							"        };\r",
							"        e.altNames.push(altName);\r",
							"\r",
							"        // Note: Support for types 1,2,6,7,8\r",
							"        switch(gn.type) {\r",
							"        // rfc822Name\r",
							"        case 1:\r",
							"        // dNSName\r",
							"        case 2:\r",
							"        // uniformResourceIdentifier (URI)\r",
							"        case 6:\r",
							"          break;\r",
							"        // IPAddress\r",
							"        case 7:\r",
							"          // convert to IPv4/IPv6 string representation\r",
							"          altName.ip = forge.util.bytesToIP(gn.value);\r",
							"          break;\r",
							"        // registeredID\r",
							"        case 8:\r",
							"          altName.oid = asn1.derToOid(gn.value);\r",
							"          break;\r",
							"        default:\r",
							"          // unsupported\r",
							"        }\r",
							"      }\r",
							"    } else if(e.name === 'subjectKeyIdentifier') {\r",
							"      // value is an OCTETSTRING w/the hash of the key-type specific\r",
							"      // public key structure (eg: RSAPublicKey)\r",
							"      var ev = asn1.fromDer(e.value);\r",
							"      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);\r",
							"    }\r",
							"  }\r",
							"  return e;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.\r",
							" *\r",
							" * Note: If the certification request is to be verified then compute hash\r",
							" * should be set to true. There is currently no implementation for converting\r",
							" * a certificate back to ASN.1 so the CertificationRequestInfo part of the\r",
							" * ASN.1 object needs to be scanned before the csr object is created.\r",
							" *\r",
							" * @param obj the asn1 representation of a PKCS#10 certification request (CSR).\r",
							" * @param computeHash true to compute the hash for verification.\r",
							" *\r",
							" * @return the certification request (CSR).\r",
							" */\r",
							"pki.certificationRequestFromAsn1 = function(obj, computeHash) {\r",
							"  // validate certification request and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, certificationRequestValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#10 certificate request. ' +\r",
							"      'ASN.1 object is not a PKCS#10 CertificationRequest.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get oid\r",
							"  var oid = asn1.derToOid(capture.publicKeyOid);\r",
							"  if(oid !== pki.oids.rsaEncryption) {\r",
							"    throw new Error('Cannot read public key. OID is not RSA.');\r",
							"  }\r",
							"\r",
							"  // create certification request\r",
							"  var csr = pki.createCertificationRequest();\r",
							"  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;\r",
							"  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);\r",
							"  csr.signatureParameters = _readSignatureParameters(\r",
							"    csr.signatureOid, capture.csrSignatureParams, true);\r",
							"  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);\r",
							"  csr.siginfo.parameters = _readSignatureParameters(\r",
							"    csr.siginfo.algorithmOid, capture.csrSignatureParams, false);\r",
							"  csr.signature = capture.csrSignature;\r",
							"\r",
							"  // keep CertificationRequestInfo to preserve signature when exporting\r",
							"  csr.certificationRequestInfo = capture.certificationRequestInfo;\r",
							"\r",
							"  if(computeHash) {\r",
							"    // check signature OID for supported signature types\r",
							"    csr.md = null;\r",
							"    if(csr.signatureOid in oids) {\r",
							"      var oid = oids[csr.signatureOid];\r",
							"      switch(oid) {\r",
							"      case 'sha1WithRSAEncryption':\r",
							"        csr.md = forge.md.sha1.create();\r",
							"        break;\r",
							"      case 'md5WithRSAEncryption':\r",
							"        csr.md = forge.md.md5.create();\r",
							"        break;\r",
							"      case 'sha256WithRSAEncryption':\r",
							"        csr.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      case 'sha384WithRSAEncryption':\r",
							"        csr.md = forge.md.sha384.create();\r",
							"        break;\r",
							"      case 'sha512WithRSAEncryption':\r",
							"        csr.md = forge.md.sha512.create();\r",
							"        break;\r",
							"      case 'RSASSA-PSS':\r",
							"        csr.md = forge.md.sha256.create();\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"    if(csr.md === null) {\r",
							"      var error = new Error('Could not compute certification request digest. ' +\r",
							"        'Unknown signature OID.');\r",
							"      error.signatureOid = csr.signatureOid;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // produce DER formatted CertificationRequestInfo and digest it\r",
							"    var bytes = asn1.toDer(csr.certificationRequestInfo);\r",
							"    csr.md.update(bytes.getBytes());\r",
							"  }\r",
							"\r",
							"  // handle subject, build subject message digest\r",
							"  var smd = forge.md.sha1.create();\r",
							"  csr.subject.getField = function(sn) {\r",
							"    return _getAttribute(csr.subject, sn);\r",
							"  };\r",
							"  csr.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.subject.attributes.push(attr);\r",
							"  };\r",
							"  csr.subject.attributes = pki.RDNAttributesAsArray(\r",
							"    capture.certificationRequestInfoSubject, smd);\r",
							"  csr.subject.hash = smd.digest().toHex();\r",
							"\r",
							"  // convert RSA public key from ASN.1\r",
							"  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\r",
							"\r",
							"  // convert attributes from ASN.1\r",
							"  csr.getAttribute = function(sn) {\r",
							"    return _getAttribute(csr, sn);\r",
							"  };\r",
							"  csr.addAttribute = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.attributes.push(attr);\r",
							"  };\r",
							"  csr.attributes = pki.CRIAttributesAsArray(\r",
							"    capture.certificationRequestInfoAttributes || []);\r",
							"\r",
							"  return csr;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty certification request (a CSR or certificate signing\r",
							" * request). Once created, its public key and attributes can be set and then\r",
							" * it can be signed.\r",
							" *\r",
							" * @return the empty certification request.\r",
							" */\r",
							"pki.createCertificationRequest = function() {\r",
							"  var csr = {};\r",
							"  csr.version = 0x00;\r",
							"  csr.signatureOid = null;\r",
							"  csr.signature = null;\r",
							"  csr.siginfo = {};\r",
							"  csr.siginfo.algorithmOid = null;\r",
							"\r",
							"  csr.subject = {};\r",
							"  csr.subject.getField = function(sn) {\r",
							"    return _getAttribute(csr.subject, sn);\r",
							"  };\r",
							"  csr.subject.addField = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.subject.attributes.push(attr);\r",
							"  };\r",
							"  csr.subject.attributes = [];\r",
							"  csr.subject.hash = null;\r",
							"\r",
							"  csr.publicKey = null;\r",
							"  csr.attributes = [];\r",
							"  csr.getAttribute = function(sn) {\r",
							"    return _getAttribute(csr, sn);\r",
							"  };\r",
							"  csr.addAttribute = function(attr) {\r",
							"    _fillMissingFields([attr]);\r",
							"    csr.attributes.push(attr);\r",
							"  };\r",
							"  csr.md = null;\r",
							"\r",
							"  /**\r",
							"   * Sets the subject of this certification request.\r",
							"   *\r",
							"   * @param attrs the array of subject attributes to use.\r",
							"   */\r",
							"  csr.setSubject = function(attrs) {\r",
							"    // set new attributes\r",
							"    _fillMissingFields(attrs);\r",
							"    csr.subject.attributes = attrs;\r",
							"    csr.subject.hash = null;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Sets the attributes of this certification request.\r",
							"   *\r",
							"   * @param attrs the array of attributes to use.\r",
							"   */\r",
							"  csr.setAttributes = function(attrs) {\r",
							"    // set new attributes\r",
							"    _fillMissingFields(attrs);\r",
							"    csr.attributes = attrs;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Signs this certification request using the given private key.\r",
							"   *\r",
							"   * @param key the private key to sign with.\r",
							"   * @param md the message digest object to use (defaults to forge.md.sha1).\r",
							"   */\r",
							"  csr.sign = function(key, md) {\r",
							"    // TODO: get signature OID from private key\r",
							"    csr.md = md || forge.md.sha1.create();\r",
							"    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];\r",
							"    if(!algorithmOid) {\r",
							"      var error = new Error('Could not compute certification request digest. ' +\r",
							"        'Unknown message digest algorithm OID.');\r",
							"      error.algorithm = csr.md.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;\r",
							"\r",
							"    // get CertificationRequestInfo, convert to DER\r",
							"    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);\r",
							"    var bytes = asn1.toDer(csr.certificationRequestInfo);\r",
							"\r",
							"    // digest and sign\r",
							"    csr.md.update(bytes.getBytes());\r",
							"    csr.signature = key.sign(csr.md);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Attempts verify the signature on the passed certification request using\r",
							"   * its public key.\r",
							"   *\r",
							"   * A CSR that has been exported to a file in PEM format can be verified using\r",
							"   * OpenSSL using this command:\r",
							"   *\r",
							"   * openssl req -in <the-csr-pem-file> -verify -noout -text\r",
							"   *\r",
							"   * @return true if verified, false if not.\r",
							"   */\r",
							"  csr.verify = function() {\r",
							"    var rval = false;\r",
							"\r",
							"    var md = csr.md;\r",
							"    if(md === null) {\r",
							"      // check signature OID for supported signature types\r",
							"      if(csr.signatureOid in oids) {\r",
							"        // TODO: create DRY `OID to md` function\r",
							"        var oid = oids[csr.signatureOid];\r",
							"        switch(oid) {\r",
							"        case 'sha1WithRSAEncryption':\r",
							"          md = forge.md.sha1.create();\r",
							"          break;\r",
							"        case 'md5WithRSAEncryption':\r",
							"          md = forge.md.md5.create();\r",
							"          break;\r",
							"        case 'sha256WithRSAEncryption':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        case 'sha384WithRSAEncryption':\r",
							"          md = forge.md.sha384.create();\r",
							"          break;\r",
							"        case 'sha512WithRSAEncryption':\r",
							"          md = forge.md.sha512.create();\r",
							"          break;\r",
							"        case 'RSASSA-PSS':\r",
							"          md = forge.md.sha256.create();\r",
							"          break;\r",
							"        }\r",
							"      }\r",
							"      if(md === null) {\r",
							"        var error = new Error('Could not compute certification request digest. ' +\r",
							"          'Unknown signature OID.');\r",
							"        error.signatureOid = csr.signatureOid;\r",
							"        throw error;\r",
							"      }\r",
							"\r",
							"      // produce DER formatted CertificationRequestInfo and digest it\r",
							"      var cri = csr.certificationRequestInfo ||\r",
							"        pki.getCertificationRequestInfo(csr);\r",
							"      var bytes = asn1.toDer(cri);\r",
							"      md.update(bytes.getBytes());\r",
							"    }\r",
							"\r",
							"    if(md !== null) {\r",
							"      var scheme;\r",
							"\r",
							"      switch(csr.signatureOid) {\r",
							"      case oids.sha1WithRSAEncryption:\r",
							"        /* use PKCS#1 v1.5 padding scheme */\r",
							"        break;\r",
							"      case oids['RSASSA-PSS']:\r",
							"        var hash, mgf;\r",
							"\r",
							"        /* initialize mgf */\r",
							"        hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          var error = new Error('Unsupported MGF hash function.');\r",
							"          error.oid = csr.signatureParameters.mgf.hash.algorithmOid;\r",
							"          error.name = hash;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = oids[csr.signatureParameters.mgf.algorithmOid];\r",
							"        if(mgf === undefined || forge.mgf[mgf] === undefined) {\r",
							"          var error = new Error('Unsupported MGF function.');\r",
							"          error.oid = csr.signatureParameters.mgf.algorithmOid;\r",
							"          error.name = mgf;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        mgf = forge.mgf[mgf].create(forge.md[hash].create());\r",
							"\r",
							"        /* initialize hash function */\r",
							"        hash = oids[csr.signatureParameters.hash.algorithmOid];\r",
							"        if(hash === undefined || forge.md[hash] === undefined) {\r",
							"          var error = new Error('Unsupported RSASSA-PSS hash function.');\r",
							"          error.oid = csr.signatureParameters.hash.algorithmOid;\r",
							"          error.name = hash;\r",
							"          throw error;\r",
							"        }\r",
							"\r",
							"        scheme = forge.pss.create(forge.md[hash].create(), mgf,\r",
							"          csr.signatureParameters.saltLength);\r",
							"        break;\r",
							"      }\r",
							"\r",
							"      // verify signature on csr using its public key\r",
							"      rval = csr.publicKey.verify(\r",
							"        md.digest().getBytes(), csr.signature, scheme);\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return csr;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.\r",
							" *\r",
							" * @param obj the subject or issuer (distinguished name).\r",
							" *\r",
							" * @return the ASN.1 RDNSequence.\r",
							" */\r",
							"function _dnToAsn1(obj) {\r",
							"  // create an empty RDNSequence\r",
							"  var rval = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"  // iterate over attributes\r",
							"  var attr, set;\r",
							"  var attrs = obj.attributes;\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    attr = attrs[i];\r",
							"    var value = attr.value;\r",
							"\r",
							"    // reuse tag class for attribute value if available\r",
							"    var valueTagClass = asn1.Type.PRINTABLESTRING;\r",
							"    if('valueTagClass' in attr) {\r",
							"      valueTagClass = attr.valueTagClass;\r",
							"\r",
							"      if(valueTagClass === asn1.Type.UTF8) {\r",
							"        value = forge.util.encodeUtf8(value);\r",
							"      }\r",
							"      // FIXME: handle more encodings\r",
							"    }\r",
							"\r",
							"    // create a RelativeDistinguishedName set\r",
							"    // each value in the set is an AttributeTypeAndValue first\r",
							"    // containing the type (an OID) and second the value\r",
							"    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // AttributeType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(attr.type).getBytes()),\r",
							"        // AttributeValue\r",
							"        asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)\r",
							"      ])\r",
							"    ]);\r",
							"    rval.value.push(set);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Gets all printable attributes (typically of an issuer or subject) in a\r",
							" * simplified JSON format for display.\r",
							" *\r",
							" * @param attrs the attributes.\r",
							" *\r",
							" * @return the JSON for display.\r",
							" */\r",
							"function _getAttributesAsJson(attrs) {\r",
							"  var rval = {};\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    var attr = attrs[i];\r",
							"    if(attr.shortName && (\r",
							"      attr.valueTagClass === asn1.Type.UTF8 ||\r",
							"      attr.valueTagClass === asn1.Type.PRINTABLESTRING ||\r",
							"      attr.valueTagClass === asn1.Type.IA5STRING)) {\r",
							"      var value = attr.value;\r",
							"      if(attr.valueTagClass === asn1.Type.UTF8) {\r",
							"        value = forge.util.encodeUtf8(attr.value);\r",
							"      }\r",
							"      if(!(attr.shortName in rval)) {\r",
							"        rval[attr.shortName] = value;\r",
							"      } else if(forge.util.isArray(rval[attr.shortName])) {\r",
							"        rval[attr.shortName].push(value);\r",
							"      } else {\r",
							"        rval[attr.shortName] = [rval[attr.shortName], value];\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Fills in missing fields in attributes.\r",
							" *\r",
							" * @param attrs the attributes to fill missing fields in.\r",
							" */\r",
							"function _fillMissingFields(attrs) {\r",
							"  var attr;\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    attr = attrs[i];\r",
							"\r",
							"    // populate missing name\r",
							"    if(typeof attr.name === 'undefined') {\r",
							"      if(attr.type && attr.type in pki.oids) {\r",
							"        attr.name = pki.oids[attr.type];\r",
							"      } else if(attr.shortName && attr.shortName in _shortNames) {\r",
							"        attr.name = pki.oids[_shortNames[attr.shortName]];\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // populate missing type (OID)\r",
							"    if(typeof attr.type === 'undefined') {\r",
							"      if(attr.name && attr.name in pki.oids) {\r",
							"        attr.type = pki.oids[attr.name];\r",
							"      } else {\r",
							"        var error = new Error('Attribute type not specified.');\r",
							"        error.attribute = attr;\r",
							"        throw error;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // populate missing shortname\r",
							"    if(typeof attr.shortName === 'undefined') {\r",
							"      if(attr.name && attr.name in _shortNames) {\r",
							"        attr.shortName = _shortNames[attr.name];\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // convert extensions to value\r",
							"    if(attr.type === oids.extensionRequest) {\r",
							"      attr.valueConstructed = true;\r",
							"      attr.valueTagClass = asn1.Type.SEQUENCE;\r",
							"      if(!attr.value && attr.extensions) {\r",
							"        attr.value = [];\r",
							"        for(var ei = 0; ei < attr.extensions.length; ++ei) {\r",
							"          attr.value.push(pki.certificateExtensionToAsn1(\r",
							"            _fillMissingExtensionFields(attr.extensions[ei])));\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(typeof attr.value === 'undefined') {\r",
							"      var error = new Error('Attribute value not specified.');\r",
							"      error.attribute = attr;\r",
							"      throw error;\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Fills in missing fields in certificate extensions.\r",
							" *\r",
							" * @param e the extension.\r",
							" * @param [options] the options to use.\r",
							" *          [cert] the certificate the extensions are for.\r",
							" *\r",
							" * @return the extension.\r",
							" */\r",
							"function _fillMissingExtensionFields(e, options) {\r",
							"  options = options || {};\r",
							"\r",
							"  // populate missing name\r",
							"  if(typeof e.name === 'undefined') {\r",
							"    if(e.id && e.id in pki.oids) {\r",
							"      e.name = pki.oids[e.id];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // populate missing id\r",
							"  if(typeof e.id === 'undefined') {\r",
							"    if(e.name && e.name in pki.oids) {\r",
							"      e.id = pki.oids[e.name];\r",
							"    } else {\r",
							"      var error = new Error('Extension ID not specified.');\r",
							"      error.extension = e;\r",
							"      throw error;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(typeof e.value !== 'undefined') {\r",
							"    return e;\r",
							"  }\r",
							"\r",
							"  // handle missing value:\r",
							"\r",
							"  // value is a BIT STRING\r",
							"  if(e.name === 'keyUsage') {\r",
							"    // build flags\r",
							"    var unused = 0;\r",
							"    var b2 = 0x00;\r",
							"    var b3 = 0x00;\r",
							"    if(e.digitalSignature) {\r",
							"      b2 |= 0x80;\r",
							"      unused = 7;\r",
							"    }\r",
							"    if(e.nonRepudiation) {\r",
							"      b2 |= 0x40;\r",
							"      unused = 6;\r",
							"    }\r",
							"    if(e.keyEncipherment) {\r",
							"      b2 |= 0x20;\r",
							"      unused = 5;\r",
							"    }\r",
							"    if(e.dataEncipherment) {\r",
							"      b2 |= 0x10;\r",
							"      unused = 4;\r",
							"    }\r",
							"    if(e.keyAgreement) {\r",
							"      b2 |= 0x08;\r",
							"      unused = 3;\r",
							"    }\r",
							"    if(e.keyCertSign) {\r",
							"      b2 |= 0x04;\r",
							"      unused = 2;\r",
							"    }\r",
							"    if(e.cRLSign) {\r",
							"      b2 |= 0x02;\r",
							"      unused = 1;\r",
							"    }\r",
							"    if(e.encipherOnly) {\r",
							"      b2 |= 0x01;\r",
							"      unused = 0;\r",
							"    }\r",
							"    if(e.decipherOnly) {\r",
							"      b3 |= 0x80;\r",
							"      unused = 7;\r",
							"    }\r",
							"\r",
							"    // create bit string\r",
							"    var value = String.fromCharCode(unused);\r",
							"    if(b3 !== 0) {\r",
							"      value += String.fromCharCode(b2) + String.fromCharCode(b3);\r",
							"    } else if(b2 !== 0) {\r",
							"      value += String.fromCharCode(b2);\r",
							"    }\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\r",
							"  } else if(e.name === 'basicConstraints') {\r",
							"    // basicConstraints is a SEQUENCE\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    // cA BOOLEAN flag defaults to false\r",
							"    if(e.cA) {\r",
							"      e.value.value.push(asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,\r",
							"        String.fromCharCode(0xFF)));\r",
							"    }\r",
							"    if('pathLenConstraint' in e) {\r",
							"      e.value.value.push(asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        asn1.integerToDer(e.pathLenConstraint).getBytes()));\r",
							"    }\r",
							"  } else if(e.name === 'extKeyUsage') {\r",
							"    // extKeyUsage is a SEQUENCE of OIDs\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    var seq = e.value.value;\r",
							"    for(var key in e) {\r",
							"      if(e[key] !== true) {\r",
							"        continue;\r",
							"      }\r",
							"      // key is name in OID map\r",
							"      if(key in oids) {\r",
							"        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,\r",
							"          false, asn1.oidToDer(oids[key]).getBytes()));\r",
							"      } else if(key.indexOf('.') !== -1) {\r",
							"        // assume key is an OID\r",
							"        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,\r",
							"          false, asn1.oidToDer(key).getBytes()));\r",
							"      }\r",
							"    }\r",
							"  } else if(e.name === 'nsCertType') {\r",
							"    // nsCertType is a BIT STRING\r",
							"    // build flags\r",
							"    var unused = 0;\r",
							"    var b2 = 0x00;\r",
							"\r",
							"    if(e.client) {\r",
							"      b2 |= 0x80;\r",
							"      unused = 7;\r",
							"    }\r",
							"    if(e.server) {\r",
							"      b2 |= 0x40;\r",
							"      unused = 6;\r",
							"    }\r",
							"    if(e.email) {\r",
							"      b2 |= 0x20;\r",
							"      unused = 5;\r",
							"    }\r",
							"    if(e.objsign) {\r",
							"      b2 |= 0x10;\r",
							"      unused = 4;\r",
							"    }\r",
							"    if(e.reserved) {\r",
							"      b2 |= 0x08;\r",
							"      unused = 3;\r",
							"    }\r",
							"    if(e.sslCA) {\r",
							"      b2 |= 0x04;\r",
							"      unused = 2;\r",
							"    }\r",
							"    if(e.emailCA) {\r",
							"      b2 |= 0x02;\r",
							"      unused = 1;\r",
							"    }\r",
							"    if(e.objCA) {\r",
							"      b2 |= 0x01;\r",
							"      unused = 0;\r",
							"    }\r",
							"\r",
							"    // create bit string\r",
							"    var value = String.fromCharCode(unused);\r",
							"    if(b2 !== 0) {\r",
							"      value += String.fromCharCode(b2);\r",
							"    }\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\r",
							"  } else if(e.name === 'subjectAltName' || e.name === 'issuerAltName') {\r",
							"    // SYNTAX SEQUENCE\r",
							"    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"    var altName;\r",
							"    for(var n = 0; n < e.altNames.length; ++n) {\r",
							"      altName = e.altNames[n];\r",
							"      var value = altName.value;\r",
							"      // handle IP\r",
							"      if(altName.type === 7 && altName.ip) {\r",
							"        value = forge.util.bytesFromIP(altName.ip);\r",
							"        if(value === null) {\r",
							"          var error = new Error(\r",
							"            'Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\r",
							"          error.extension = e;\r",
							"          throw error;\r",
							"        }\r",
							"      } else if(altName.type === 8) {\r",
							"        // handle OID\r",
							"        if(altName.oid) {\r",
							"          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\r",
							"        } else {\r",
							"          // deprecated ... convert value to OID\r",
							"          value = asn1.oidToDer(value);\r",
							"        }\r",
							"      }\r",
							"      e.value.value.push(asn1.create(\r",
							"        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,\r",
							"        value));\r",
							"    }\r",
							"  } else if(e.name === 'subjectKeyIdentifier' && options.cert) {\r",
							"    var ski = options.cert.generateSubjectKeyIdentifier();\r",
							"    e.subjectKeyIdentifier = ski.toHex();\r",
							"    // OCTETSTRING w/digest\r",
							"    e.value = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());\r",
							"  } else if(e.name === 'authorityKeyIdentifier' && options.cert) {\r",
							"    // SYNTAX SEQUENCE\r",
							"    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    var seq = e.value.value;\r",
							"\r",
							"    if(e.keyIdentifier) {\r",
							"      var keyIdentifier = (e.keyIdentifier === true ?\r",
							"        options.cert.generateSubjectKeyIdentifier().getBytes() :\r",
							"        e.keyIdentifier);\r",
							"      seq.push(\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));\r",
							"    }\r",
							"\r",
							"    if(e.authorityCertIssuer) {\r",
							"      var authorityCertIssuer = [\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [\r",
							"          _dnToAsn1(e.authorityCertIssuer === true ?\r",
							"            options.cert.issuer : e.authorityCertIssuer)\r",
							"        ])\r",
							"      ];\r",
							"      seq.push(\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));\r",
							"    }\r",
							"\r",
							"    if(e.serialNumber) {\r",
							"      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ?\r",
							"        options.cert.serialNumber : e.serialNumber);\r",
							"      seq.push(\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));\r",
							"    }\r",
							"  } else if (e.name === 'cRLDistributionPoints') {\r",
							"    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"    var seq = e.value.value;\r",
							"\r",
							"    // Create sub SEQUENCE of DistributionPointName\r",
							"    var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"    // Create fullName CHOICE\r",
							"    var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\r",
							"    var altName;\r",
							"    for(var n = 0; n < e.altNames.length; ++n) {\r",
							"      altName = e.altNames[n];\r",
							"      var value = altName.value;\r",
							"      // handle IP\r",
							"      if(altName.type === 7 && altName.ip) {\r",
							"        value = forge.util.bytesFromIP(altName.ip);\r",
							"        if(value === null) {\r",
							"          var error = new Error(\r",
							"            'Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\r",
							"          error.extension = e;\r",
							"          throw error;\r",
							"        }\r",
							"      } else if(altName.type === 8) {\r",
							"        // handle OID\r",
							"        if(altName.oid) {\r",
							"          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\r",
							"        } else {\r",
							"          // deprecated ... convert value to OID\r",
							"          value = asn1.oidToDer(value);\r",
							"        }\r",
							"      }\r",
							"      fullNameGeneralNames.value.push(asn1.create(\r",
							"        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,\r",
							"        value));\r",
							"    }\r",
							"\r",
							"    // Add to the parent SEQUENCE\r",
							"    subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));\r",
							"    seq.push(subSeq);\r",
							"  }\r",
							"\r",
							"  // ensure value has been defined by now\r",
							"  if(typeof e.value === 'undefined') {\r",
							"    var error = new Error('Extension value not specified.');\r",
							"    error.extension = e;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  return e;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Convert signature parameters object to ASN.1\r",
							" *\r",
							" * @param {String} oid Signature algorithm OID\r",
							" * @param params The signature parametrs object\r",
							" * @return ASN.1 object representing signature parameters\r",
							" */\r",
							"function _signatureParametersToAsn1(oid, params) {\r",
							"  switch(oid) {\r",
							"  case oids['RSASSA-PSS']:\r",
							"    var parts = [];\r",
							"\r",
							"    if(params.hash.algorithmOid !== undefined) {\r",
							"      parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(params.hash.algorithmOid).getBytes()),\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"        ])\r",
							"      ]));\r",
							"    }\r",
							"\r",
							"    if(params.mgf.algorithmOid !== undefined) {\r",
							"      parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(params.mgf.algorithmOid).getBytes()),\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"              asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"          ])\r",
							"        ])\r",
							"      ]));\r",
							"    }\r",
							"\r",
							"    if(params.saltLength !== undefined) {\r",
							"      parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"          asn1.integerToDer(params.saltLength).getBytes())\r",
							"      ]));\r",
							"    }\r",
							"\r",
							"    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);\r",
							"\r",
							"  default:\r",
							"    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a certification request's attributes to an ASN.1 set of\r",
							" * CRIAttributes.\r",
							" *\r",
							" * @param csr certification request.\r",
							" *\r",
							" * @return the ASN.1 set of CRIAttributes.\r",
							" */\r",
							"function _CRIAttributesToAsn1(csr) {\r",
							"  // create an empty context-specific container\r",
							"  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\r",
							"\r",
							"  // no attributes, return empty container\r",
							"  if(csr.attributes.length === 0) {\r",
							"    return rval;\r",
							"  }\r",
							"\r",
							"  // each attribute has a sequence with a type and a set of values\r",
							"  var attrs = csr.attributes;\r",
							"  for(var i = 0; i < attrs.length; ++i) {\r",
							"    var attr = attrs[i];\r",
							"    var value = attr.value;\r",
							"\r",
							"    // reuse tag class for attribute value if available\r",
							"    var valueTagClass = asn1.Type.UTF8;\r",
							"    if('valueTagClass' in attr) {\r",
							"      valueTagClass = attr.valueTagClass;\r",
							"    }\r",
							"    if(valueTagClass === asn1.Type.UTF8) {\r",
							"      value = forge.util.encodeUtf8(value);\r",
							"    }\r",
							"    var valueConstructed = false;\r",
							"    if('valueConstructed' in attr) {\r",
							"      valueConstructed = attr.valueConstructed;\r",
							"    }\r",
							"    // FIXME: handle more encodings\r",
							"\r",
							"    // create a RelativeDistinguishedName set\r",
							"    // each value in the set is an AttributeTypeAndValue first\r",
							"    // containing the type (an OID) and second the value\r",
							"    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // AttributeType\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(attr.type).getBytes()),\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"        // AttributeValue\r",
							"        asn1.create(\r",
							"          asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)\r",
							"      ])\r",
							"    ]);\r",
							"    rval.value.push(seq);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.\r",
							" *\r",
							" * @param cert the certificate.\r",
							" *\r",
							" * @return the asn1 TBSCertificate.\r",
							" */\r",
							"pki.getTBSCertificate = function(cert) {\r",
							"  // TBSCertificate\r",
							"  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version\r",
							"    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"      // integer\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        asn1.integerToDer(cert.version).getBytes())\r",
							"    ]),\r",
							"    // serialNumber\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      forge.util.hexToBytes(cert.serialNumber)),\r",
							"    // signature\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),\r",
							"      // parameters\r",
							"      _signatureParametersToAsn1(\r",
							"        cert.siginfo.algorithmOid, cert.siginfo.parameters)\r",
							"    ]),\r",
							"    // issuer\r",
							"    _dnToAsn1(cert.issuer),\r",
							"    // validity\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // notBefore\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\r",
							"        asn1.dateToUtcTime(cert.validity.notBefore)),\r",
							"      // notAfter\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\r",
							"        asn1.dateToUtcTime(cert.validity.notAfter))\r",
							"    ]),\r",
							"    // subject\r",
							"    _dnToAsn1(cert.subject),\r",
							"    // SubjectPublicKeyInfo\r",
							"    pki.publicKeyToAsn1(cert.publicKey)\r",
							"  ]);\r",
							"\r",
							"  if(cert.issuer.uniqueId) {\r",
							"    // issuerUniqueID (optional)\r",
							"    tbs.value.push(\r",
							"      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"          // TODO: support arbitrary bit length ids\r",
							"          String.fromCharCode(0x00) +\r",
							"          cert.issuer.uniqueId\r",
							"        )\r",
							"      ])\r",
							"    );\r",
							"  }\r",
							"  if(cert.subject.uniqueId) {\r",
							"    // subjectUniqueID (optional)\r",
							"    tbs.value.push(\r",
							"      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"          // TODO: support arbitrary bit length ids\r",
							"          String.fromCharCode(0x00) +\r",
							"          cert.subject.uniqueId\r",
							"        )\r",
							"      ])\r",
							"    );\r",
							"  }\r",
							"\r",
							"  if(cert.extensions.length > 0) {\r",
							"    // extensions (optional)\r",
							"    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));\r",
							"  }\r",
							"\r",
							"  return tbs;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the ASN.1 CertificationRequestInfo part of a\r",
							" * PKCS#10 CertificationRequest.\r",
							" *\r",
							" * @param csr the certification request.\r",
							" *\r",
							" * @return the asn1 CertificationRequestInfo.\r",
							" */\r",
							"pki.getCertificationRequestInfo = function(csr) {\r",
							"  // CertificationRequestInfo\r",
							"  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(csr.version).getBytes()),\r",
							"    // subject\r",
							"    _dnToAsn1(csr.subject),\r",
							"    // SubjectPublicKeyInfo\r",
							"    pki.publicKeyToAsn1(csr.publicKey),\r",
							"    // attributes\r",
							"    _CRIAttributesToAsn1(csr)\r",
							"  ]);\r",
							"\r",
							"  return cri;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.\r",
							" *\r",
							" * @param dn the DistinguishedName.\r",
							" *\r",
							" * @return the asn1 representation of a DistinguishedName.\r",
							" */\r",
							"pki.distinguishedNameToAsn1 = function(dn) {\r",
							"  return _dnToAsn1(dn);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an X.509v3 RSA certificate to an ASN.1 object.\r",
							" *\r",
							" * @param cert the certificate.\r",
							" *\r",
							" * @return the asn1 representation of an X.509v3 RSA certificate.\r",
							" */\r",
							"pki.certificateToAsn1 = function(cert) {\r",
							"  // prefer cached TBSCertificate over generating one\r",
							"  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);\r",
							"\r",
							"  // Certificate\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // TBSCertificate\r",
							"    tbsCertificate,\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(cert.signatureOid).getBytes()),\r",
							"      // parameters\r",
							"      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)\r",
							"    ]),\r",
							"    // SignatureValue\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"      String.fromCharCode(0x00) + cert.signature)\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts X.509v3 certificate extensions to ASN.1.\r",
							" *\r",
							" * @param exts the extensions to convert.\r",
							" *\r",
							" * @return the extensions in ASN.1 format.\r",
							" */\r",
							"pki.certificateExtensionsToAsn1 = function(exts) {\r",
							"  // create top-level extension container\r",
							"  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);\r",
							"\r",
							"  // create extension sequence (stores a sequence for each extension)\r",
							"  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"  rval.value.push(seq);\r",
							"\r",
							"  for(var i = 0; i < exts.length; ++i) {\r",
							"    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a single certificate extension to ASN.1.\r",
							" *\r",
							" * @param ext the extension to convert.\r",
							" *\r",
							" * @return the extension in ASN.1 format.\r",
							" */\r",
							"pki.certificateExtensionToAsn1 = function(ext) {\r",
							"  // create a sequence for each extension\r",
							"  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\r",
							"\r",
							"  // extnID (OID)\r",
							"  extseq.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"    asn1.oidToDer(ext.id).getBytes()));\r",
							"\r",
							"  // critical defaults to false\r",
							"  if(ext.critical) {\r",
							"    // critical BOOLEAN DEFAULT FALSE\r",
							"    extseq.value.push(asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,\r",
							"      String.fromCharCode(0xFF)));\r",
							"  }\r",
							"\r",
							"  var value = ext.value;\r",
							"  if(typeof ext.value !== 'string') {\r",
							"    // value is asn.1\r",
							"    value = asn1.toDer(value).getBytes();\r",
							"  }\r",
							"\r",
							"  // extnValue (OCTET STRING)\r",
							"  extseq.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));\r",
							"\r",
							"  return extseq;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#10 certification request to an ASN.1 object.\r",
							" *\r",
							" * @param csr the certification request.\r",
							" *\r",
							" * @return the asn1 representation of a certification request.\r",
							" */\r",
							"pki.certificationRequestToAsn1 = function(csr) {\r",
							"  // prefer cached CertificationRequestInfo over generating one\r",
							"  var cri = csr.certificationRequestInfo ||\r",
							"    pki.getCertificationRequestInfo(csr);\r",
							"\r",
							"  // Certificate\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // CertificationRequestInfo\r",
							"    cri,\r",
							"    // AlgorithmIdentifier (signature algorithm)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(csr.signatureOid).getBytes()),\r",
							"      // parameters\r",
							"      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)\r",
							"    ]),\r",
							"    // signature\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\r",
							"      String.fromCharCode(0x00) + csr.signature)\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a CA store.\r",
							" *\r",
							" * @param certs an optional array of certificate objects or PEM-formatted\r",
							" *          certificate strings to add to the CA store.\r",
							" *\r",
							" * @return the CA store.\r",
							" */\r",
							"pki.createCaStore = function(certs) {\r",
							"  // create CA store\r",
							"  var caStore = {\r",
							"    // stored certificates\r",
							"    certs: {}\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Gets the certificate that issued the passed certificate or its\r",
							"   * 'parent'.\r",
							"   *\r",
							"   * @param cert the certificate to get the parent for.\r",
							"   *\r",
							"   * @return the parent certificate or null if none was found.\r",
							"   */\r",
							"  caStore.getIssuer = function(cert) {\r",
							"    var rval = getBySubject(cert.issuer);\r",
							"\r",
							"    // see if there are multiple matches\r",
							"    /*if(forge.util.isArray(rval)) {\r",
							"      // TODO: resolve multiple matches by checking\r",
							"      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.\r",
							"      // FIXME: or alternatively do authority key mapping\r",
							"      // if possible (X.509v1 certs can't work?)\r",
							"      throw new Error('Resolving multiple issuer matches not implemented yet.');\r",
							"    }*/\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Adds a trusted certificate to the store.\r",
							"   *\r",
							"   * @param cert the certificate to add as a trusted certificate (either a\r",
							"   *          pki.certificate object or a PEM-formatted certificate).\r",
							"   */\r",
							"  caStore.addCertificate = function(cert) {\r",
							"    // convert from pem if necessary\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = forge.pki.certificateFromPem(cert);\r",
							"    }\r",
							"\r",
							"    ensureSubjectHasHash(cert.subject);\r",
							"\r",
							"    if(!caStore.hasCertificate(cert)) {  // avoid duplicate certificates in store\r",
							"      if(cert.subject.hash in caStore.certs) {\r",
							"        // subject hash already exists, append to array\r",
							"        var tmp = caStore.certs[cert.subject.hash];\r",
							"        if(!forge.util.isArray(tmp)) {\r",
							"          tmp = [tmp];\r",
							"        }\r",
							"        tmp.push(cert);\r",
							"        caStore.certs[cert.subject.hash] = tmp;\r",
							"      } else {\r",
							"        caStore.certs[cert.subject.hash] = cert;\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Checks to see if the given certificate is in the store.\r",
							"   *\r",
							"   * @param cert the certificate to check (either a pki.certificate or a\r",
							"   *          PEM-formatted certificate).\r",
							"   *\r",
							"   * @return true if the certificate is in the store, false if not.\r",
							"   */\r",
							"  caStore.hasCertificate = function(cert) {\r",
							"    // convert from pem if necessary\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = forge.pki.certificateFromPem(cert);\r",
							"    }\r",
							"\r",
							"    var match = getBySubject(cert.subject);\r",
							"    if(!match) {\r",
							"      return false;\r",
							"    }\r",
							"    if(!forge.util.isArray(match)) {\r",
							"      match = [match];\r",
							"    }\r",
							"    // compare DER-encoding of certificates\r",
							"    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\r",
							"    for(var i = 0; i < match.length; ++i) {\r",
							"      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\r",
							"      if(der1 === der2) {\r",
							"        return true;\r",
							"      }\r",
							"    }\r",
							"    return false;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Lists all of the certificates kept in the store.\r",
							"   *\r",
							"   * @return an array of all of the pki.certificate objects in the store.\r",
							"   */\r",
							"  caStore.listAllCertificates = function() {\r",
							"    var certList = [];\r",
							"\r",
							"    for(var hash in caStore.certs) {\r",
							"      if(caStore.certs.hasOwnProperty(hash)) {\r",
							"        var value = caStore.certs[hash];\r",
							"        if(!forge.util.isArray(value)) {\r",
							"          certList.push(value);\r",
							"        } else {\r",
							"          for(var i = 0; i < value.length; ++i) {\r",
							"            certList.push(value[i]);\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return certList;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Removes a certificate from the store.\r",
							"   *\r",
							"   * @param cert the certificate to remove (either a pki.certificate or a\r",
							"   *          PEM-formatted certificate).\r",
							"   *\r",
							"   * @return the certificate that was removed or null if the certificate\r",
							"   *           wasn't in store.\r",
							"   */\r",
							"  caStore.removeCertificate = function(cert) {\r",
							"    var result;\r",
							"\r",
							"    // convert from pem if necessary\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = forge.pki.certificateFromPem(cert);\r",
							"    }\r",
							"    ensureSubjectHasHash(cert.subject);\r",
							"    if(!caStore.hasCertificate(cert)) {\r",
							"      return null;\r",
							"    }\r",
							"\r",
							"    var match = getBySubject(cert.subject);\r",
							"\r",
							"    if(!forge.util.isArray(match)) {\r",
							"      result = caStore.certs[cert.subject.hash];\r",
							"      delete caStore.certs[cert.subject.hash];\r",
							"      return result;\r",
							"    }\r",
							"\r",
							"    // compare DER-encoding of certificates\r",
							"    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\r",
							"    for(var i = 0; i < match.length; ++i) {\r",
							"      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\r",
							"      if(der1 === der2) {\r",
							"        result = match[i];\r",
							"        match.splice(i, 1);\r",
							"      }\r",
							"    }\r",
							"    if(match.length === 0) {\r",
							"      delete caStore.certs[cert.subject.hash];\r",
							"    }\r",
							"\r",
							"    return result;\r",
							"  };\r",
							"\r",
							"  function getBySubject(subject) {\r",
							"    ensureSubjectHasHash(subject);\r",
							"    return caStore.certs[subject.hash] || null;\r",
							"  }\r",
							"\r",
							"  function ensureSubjectHasHash(subject) {\r",
							"    // produce subject hash if it doesn't exist\r",
							"    if(!subject.hash) {\r",
							"      var md = forge.md.sha1.create();\r",
							"      subject.attributes =  pki.RDNAttributesAsArray(_dnToAsn1(subject), md);\r",
							"      subject.hash = md.digest().toHex();\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // auto-add passed in certs\r",
							"  if(certs) {\r",
							"    // parse PEM-formatted certificates as necessary\r",
							"    for(var i = 0; i < certs.length; ++i) {\r",
							"      var cert = certs[i];\r",
							"      caStore.addCertificate(cert);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return caStore;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Certificate verification errors, based on TLS.\r",
							" */\r",
							"pki.certificateError = {\r",
							"  bad_certificate: 'forge.pki.BadCertificate',\r",
							"  unsupported_certificate: 'forge.pki.UnsupportedCertificate',\r",
							"  certificate_revoked: 'forge.pki.CertificateRevoked',\r",
							"  certificate_expired: 'forge.pki.CertificateExpired',\r",
							"  certificate_unknown: 'forge.pki.CertificateUnknown',\r",
							"  unknown_ca: 'forge.pki.UnknownCertificateAuthority'\r",
							"};\r",
							"\r",
							"/**\r",
							" * Verifies a certificate chain against the given Certificate Authority store\r",
							" * with an optional custom verify callback.\r",
							" *\r",
							" * @param caStore a certificate store to verify against.\r",
							" * @param chain the certificate chain to verify, with the root or highest\r",
							" *          authority at the end (an array of certificates).\r",
							" * @param verify called for every certificate in the chain.\r",
							" *\r",
							" * The verify callback has the following signature:\r",
							" *\r",
							" * verified - Set to true if certificate was verified, otherwise the\r",
							" *   pki.certificateError for why the certificate failed.\r",
							" * depth - The current index in the chain, where 0 is the end point's cert.\r",
							" * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous\r",
							" *   end point.\r",
							" *\r",
							" * The function returns true on success and on failure either the appropriate\r",
							" * pki.certificateError or an object with 'error' set to the appropriate\r",
							" * pki.certificateError and 'message' set to a custom error message.\r",
							" *\r",
							" * @return true if successful, error thrown if not.\r",
							" */\r",
							"pki.verifyCertificateChain = function(caStore, chain, verify) {\r",
							"  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate\r",
							"    Section 6: Certification Path Validation\r",
							"    See inline parentheticals related to this particular implementation.\r",
							"\r",
							"    The primary goal of path validation is to verify the binding between\r",
							"    a subject distinguished name or a subject alternative name and subject\r",
							"    public key, as represented in the end entity certificate, based on the\r",
							"    public key of the trust anchor. This requires obtaining a sequence of\r",
							"    certificates that support that binding. That sequence should be provided\r",
							"    in the passed 'chain'. The trust anchor should be in the given CA\r",
							"    store. The 'end entity' certificate is the certificate provided by the\r",
							"    end point (typically a server) and is the first in the chain.\r",
							"\r",
							"    To meet this goal, the path validation process verifies, among other\r",
							"    things, that a prospective certification path (a sequence of n\r",
							"    certificates or a 'chain') satisfies the following conditions:\r",
							"\r",
							"    (a) for all x in {1, ..., n-1}, the subject of certificate x is\r",
							"          the issuer of certificate x+1;\r",
							"\r",
							"    (b) certificate 1 is issued by the trust anchor;\r",
							"\r",
							"    (c) certificate n is the certificate to be validated; and\r",
							"\r",
							"    (d) for all x in {1, ..., n}, the certificate was valid at the\r",
							"          time in question.\r",
							"\r",
							"    Note that here 'n' is index 0 in the chain and 1 is the last certificate\r",
							"    in the chain and it must be signed by a certificate in the connection's\r",
							"    CA store.\r",
							"\r",
							"    The path validation process also determines the set of certificate\r",
							"    policies that are valid for this path, based on the certificate policies\r",
							"    extension, policy mapping extension, policy constraints extension, and\r",
							"    inhibit any-policy extension.\r",
							"\r",
							"    Note: Policy mapping extension not supported (Not Required).\r",
							"\r",
							"    Note: If the certificate has an unsupported critical extension, then it\r",
							"    must be rejected.\r",
							"\r",
							"    Note: A certificate is self-issued if the DNs that appear in the subject\r",
							"    and issuer fields are identical and are not empty.\r",
							"\r",
							"    The path validation algorithm assumes the following seven inputs are\r",
							"    provided to the path processing logic. What this specific implementation\r",
							"    will use is provided parenthetically:\r",
							"\r",
							"    (a) a prospective certification path of length n (the 'chain')\r",
							"    (b) the current date/time: ('now').\r",
							"    (c) user-initial-policy-set: A set of certificate policy identifiers\r",
							"          naming the policies that are acceptable to the certificate user.\r",
							"          The user-initial-policy-set contains the special value any-policy\r",
							"          if the user is not concerned about certificate policy\r",
							"          (Not implemented. Any policy is accepted).\r",
							"    (d) trust anchor information, describing a CA that serves as a trust\r",
							"          anchor for the certification path. The trust anchor information\r",
							"          includes:\r",
							"\r",
							"      (1)  the trusted issuer name,\r",
							"      (2)  the trusted public key algorithm,\r",
							"      (3)  the trusted public key, and\r",
							"      (4)  optionally, the trusted public key parameters associated\r",
							"             with the public key.\r",
							"\r",
							"      (Trust anchors are provided via certificates in the CA store).\r",
							"\r",
							"      The trust anchor information may be provided to the path processing\r",
							"      procedure in the form of a self-signed certificate. The trusted anchor\r",
							"      information is trusted because it was delivered to the path processing\r",
							"      procedure by some trustworthy out-of-band procedure. If the trusted\r",
							"      public key algorithm requires parameters, then the parameters are\r",
							"      provided along with the trusted public key (No parameters used in this\r",
							"      implementation).\r",
							"\r",
							"    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is\r",
							"          allowed in the certification path.\r",
							"          (Not implemented, no policy checking)\r",
							"\r",
							"    (f) initial-explicit-policy, which indicates if the path must be valid\r",
							"          for at least one of the certificate policies in the user-initial-\r",
							"          policy-set.\r",
							"          (Not implemented, no policy checking)\r",
							"\r",
							"    (g) initial-any-policy-inhibit, which indicates whether the\r",
							"          anyPolicy OID should be processed if it is included in a\r",
							"          certificate.\r",
							"          (Not implemented, so any policy is valid provided that it is\r",
							"          not marked as critical) */\r",
							"\r",
							"  /* Basic Path Processing:\r",
							"\r",
							"    For each certificate in the 'chain', the following is checked:\r",
							"\r",
							"    1. The certificate validity period includes the current time.\r",
							"    2. The certificate was signed by its parent (where the parent is either\r",
							"       the next in the chain or from the CA store). Allow processing to\r",
							"       continue to the next step if no parent is found but the certificate is\r",
							"       in the CA store.\r",
							"    3. TODO: The certificate has not been revoked.\r",
							"    4. The certificate issuer name matches the parent's subject name.\r",
							"    5. TODO: If the certificate is self-issued and not the final certificate\r",
							"       in the chain, skip this step, otherwise verify that the subject name\r",
							"       is within one of the permitted subtrees of X.500 distinguished names\r",
							"       and that each of the alternative names in the subjectAltName extension\r",
							"       (critical or non-critical) is within one of the permitted subtrees for\r",
							"       that name type.\r",
							"    6. TODO: If the certificate is self-issued and not the final certificate\r",
							"       in the chain, skip this step, otherwise verify that the subject name\r",
							"       is not within one of the excluded subtrees for X.500 distinguished\r",
							"       names and none of the subjectAltName extension names are excluded for\r",
							"       that name type.\r",
							"    7. The other steps in the algorithm for basic path processing involve\r",
							"       handling the policy extension which is not presently supported in this\r",
							"       implementation. Instead, if a critical policy extension is found, the\r",
							"       certificate is rejected as not supported.\r",
							"    8. If the certificate is not the first or if its the only certificate in\r",
							"       the chain (having no parent from the CA store or is self-signed) and it\r",
							"       has a critical key usage extension, verify that the keyCertSign bit is\r",
							"       set. If the key usage extension exists, verify that the basic\r",
							"       constraints extension exists. If the basic constraints extension exists,\r",
							"       verify that the cA flag is set. If pathLenConstraint is set, ensure that\r",
							"       the number of certificates that precede in the chain (come earlier\r",
							"       in the chain as implemented below), excluding the very first in the\r",
							"       chain (typically the end-entity one), isn't greater than the\r",
							"       pathLenConstraint. This constraint limits the number of intermediate\r",
							"       CAs that may appear below a CA before only end-entity certificates\r",
							"       may be issued. */\r",
							"\r",
							"  // copy cert chain references to another array to protect against changes\r",
							"  // in verify callback\r",
							"  chain = chain.slice(0);\r",
							"  var certs = chain.slice(0);\r",
							"\r",
							"  // get current date\r",
							"  var now = new Date();\r",
							"\r",
							"  // verify each cert in the chain using its parent, where the parent\r",
							"  // is either the next in the chain or from the CA store\r",
							"  var first = true;\r",
							"  var error = null;\r",
							"  var depth = 0;\r",
							"  do {\r",
							"    var cert = chain.shift();\r",
							"    var parent = null;\r",
							"    var selfSigned = false;\r",
							"\r",
							"    // 1. check valid time\r",
							"    if(now < cert.validity.notBefore || now > cert.validity.notAfter) {\r",
							"      error = {\r",
							"        message: 'Certificate is not valid yet or has expired.',\r",
							"        error: pki.certificateError.certificate_expired,\r",
							"        notBefore: cert.validity.notBefore,\r",
							"        notAfter: cert.validity.notAfter,\r",
							"        now: now\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // 2. verify with parent from chain or CA store\r",
							"    if(error === null) {\r",
							"      parent = chain[0] || caStore.getIssuer(cert);\r",
							"      if(parent === null) {\r",
							"        // check for self-signed cert\r",
							"        if(cert.isIssuer(cert)) {\r",
							"          selfSigned = true;\r",
							"          parent = cert;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(parent) {\r",
							"        // FIXME: current CA store implementation might have multiple\r",
							"        // certificates where the issuer can't be determined from the\r",
							"        // certificate (happens rarely with, eg: old certificates) so normalize\r",
							"        // by always putting parents into an array\r",
							"        // TODO: there's may be an extreme degenerate case currently uncovered\r",
							"        // where an old intermediate certificate seems to have a matching parent\r",
							"        // but none of the parents actually verify ... but the intermediate\r",
							"        // is in the CA and it should pass this check; needs investigation\r",
							"        var parents = parent;\r",
							"        if(!forge.util.isArray(parents)) {\r",
							"          parents = [parents];\r",
							"        }\r",
							"\r",
							"        // try to verify with each possible parent (typically only one)\r",
							"        var verified = false;\r",
							"        while(!verified && parents.length > 0) {\r",
							"          parent = parents.shift();\r",
							"          try {\r",
							"            verified = parent.verify(cert);\r",
							"          } catch(ex) {\r",
							"            // failure to verify, don't care why, try next one\r",
							"          }\r",
							"        }\r",
							"\r",
							"        if(!verified) {\r",
							"          error = {\r",
							"            message: 'Certificate signature is invalid.',\r",
							"            error: pki.certificateError.bad_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(error === null && (!parent || selfSigned) &&\r",
							"        !caStore.hasCertificate(cert)) {\r",
							"        // no parent issuer and certificate itself is not trusted\r",
							"        error = {\r",
							"          message: 'Certificate is not trusted.',\r",
							"          error: pki.certificateError.unknown_ca\r",
							"        };\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // TODO: 3. check revoked\r",
							"\r",
							"    // 4. check for matching issuer/subject\r",
							"    if(error === null && parent && !cert.isIssuer(parent)) {\r",
							"      // parent is not issuer\r",
							"      error = {\r",
							"        message: 'Certificate issuer is invalid.',\r",
							"        error: pki.certificateError.bad_certificate\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // 5. TODO: check names with permitted names tree\r",
							"\r",
							"    // 6. TODO: check names against excluded names tree\r",
							"\r",
							"    // 7. check for unsupported critical extensions\r",
							"    if(error === null) {\r",
							"      // supported extensions\r",
							"      var se = {\r",
							"        keyUsage: true,\r",
							"        basicConstraints: true\r",
							"      };\r",
							"      for(var i = 0; error === null && i < cert.extensions.length; ++i) {\r",
							"        var ext = cert.extensions[i];\r",
							"        if(ext.critical && !(ext.name in se)) {\r",
							"          error = {\r",
							"            message:\r",
							"              'Certificate has an unsupported critical extension.',\r",
							"            error: pki.certificateError.unsupported_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // 8. check for CA if cert is not first or is the only certificate\r",
							"    // remaining in chain with no parent or is self-signed\r",
							"    if(error === null &&\r",
							"      (!first || (chain.length === 0 && (!parent || selfSigned)))) {\r",
							"      // first check keyUsage extension and then basic constraints\r",
							"      var bcExt = cert.getExtension('basicConstraints');\r",
							"      var keyUsageExt = cert.getExtension('keyUsage');\r",
							"      if(keyUsageExt !== null) {\r",
							"        // keyCertSign must be true and there must be a basic\r",
							"        // constraints extension\r",
							"        if(!keyUsageExt.keyCertSign || bcExt === null) {\r",
							"          // bad certificate\r",
							"          error = {\r",
							"            message:\r",
							"              'Certificate keyUsage or basicConstraints conflict ' +\r",
							"              'or indicate that the certificate is not a CA. ' +\r",
							"              'If the certificate is the only one in the chain or ' +\r",
							"              'isn\\'t the first then the certificate must be a ' +\r",
							"              'valid CA.',\r",
							"            error: pki.certificateError.bad_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"      // basic constraints cA flag must be set\r",
							"      if(error === null && bcExt !== null && !bcExt.cA) {\r",
							"        // bad certificate\r",
							"        error = {\r",
							"          message:\r",
							"            'Certificate basicConstraints indicates the certificate ' +\r",
							"            'is not a CA.',\r",
							"          error: pki.certificateError.bad_certificate\r",
							"        };\r",
							"      }\r",
							"      // if error is not null and keyUsage is available, then we know it\r",
							"      // has keyCertSign and there is a basic constraints extension too,\r",
							"      // which means we can check pathLenConstraint (if it exists)\r",
							"      if(error === null && keyUsageExt !== null &&\r",
							"        'pathLenConstraint' in bcExt) {\r",
							"        // pathLen is the maximum # of intermediate CA certs that can be\r",
							"        // found between the current certificate and the end-entity (depth 0)\r",
							"        // certificate; this number does not include the end-entity (depth 0,\r",
							"        // last in the chain) even if it happens to be a CA certificate itself\r",
							"        var pathLen = depth - 1;\r",
							"        if(pathLen > bcExt.pathLenConstraint) {\r",
							"          // pathLenConstraint violated, bad certificate\r",
							"          error = {\r",
							"            message:\r",
							"              'Certificate basicConstraints pathLenConstraint violated.',\r",
							"            error: pki.certificateError.bad_certificate\r",
							"          };\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // call application callback\r",
							"    var vfd = (error === null) ? true : error.error;\r",
							"    var ret = verify ? verify(vfd, depth, certs) : vfd;\r",
							"    if(ret === true) {\r",
							"      // clear any set error\r",
							"      error = null;\r",
							"    } else {\r",
							"      // if passed basic tests, set default message and alert\r",
							"      if(vfd === true) {\r",
							"        error = {\r",
							"          message: 'The application rejected the certificate.',\r",
							"          error: pki.certificateError.bad_certificate\r",
							"        };\r",
							"      }\r",
							"\r",
							"      // check for custom error info\r",
							"      if(ret || ret === 0) {\r",
							"        // set custom message and error\r",
							"        if(typeof ret === 'object' && !forge.util.isArray(ret)) {\r",
							"          if(ret.message) {\r",
							"             error.message = ret.message;\r",
							"          }\r",
							"          if(ret.error) {\r",
							"            error.error = ret.error;\r",
							"          }\r",
							"        } else if(typeof ret === 'string') {\r",
							"          // set custom error\r",
							"          error.error = ret;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // throw error\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // no longer first cert in chain\r",
							"    first = false;\r",
							"    ++depth;\r",
							"  } while(chain.length > 0);\r",
							"\r",
							"  return true;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 17 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of PKCS#1 PSS signature padding.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for PSS API\r",
							"var pss = module.exports = forge.pss = forge.pss || {};\r",
							"\r",
							"/**\r",
							" * Creates a PSS signature scheme object.\r",
							" *\r",
							" * There are several ways to provide a salt for encoding:\r",
							" *\r",
							" * 1. Specify the saltLength only and the built-in PRNG will generate it.\r",
							" * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\r",
							" *   will be used.\r",
							" * 3. Specify the salt itself as a forge.util.ByteBuffer.\r",
							" *\r",
							" * @param options the options to use:\r",
							" *          md the message digest object to use, a forge md instance.\r",
							" *          mgf the mask generation function to use, a forge mgf instance.\r",
							" *          [saltLength] the length of the salt in octets.\r",
							" *          [prng] the pseudo-random number generator to use to produce a salt.\r",
							" *          [salt] the salt to use when encoding.\r",
							" *\r",
							" * @return a signature scheme object.\r",
							" */\r",
							"pss.create = function(options) {\r",
							"  // backwards compatibility w/legacy args: hash, mgf, sLen\r",
							"  if(arguments.length === 3) {\r",
							"    options = {\r",
							"      md: arguments[0],\r",
							"      mgf: arguments[1],\r",
							"      saltLength: arguments[2]\r",
							"    };\r",
							"  }\r",
							"\r",
							"  var hash = options.md;\r",
							"  var mgf = options.mgf;\r",
							"  var hLen = hash.digestLength;\r",
							"\r",
							"  var salt_ = options.salt || null;\r",
							"  if(typeof salt_ === 'string') {\r",
							"    // assume binary-encoded string\r",
							"    salt_ = forge.util.createBuffer(salt_);\r",
							"  }\r",
							"\r",
							"  var sLen;\r",
							"  if('saltLength' in options) {\r",
							"    sLen = options.saltLength;\r",
							"  } else if(salt_ !== null) {\r",
							"    sLen = salt_.length();\r",
							"  } else {\r",
							"    throw new Error('Salt length not specified or specific salt not given.');\r",
							"  }\r",
							"\r",
							"  if(salt_ !== null && salt_.length() !== sLen) {\r",
							"    throw new Error('Given salt length does not match length of given salt.');\r",
							"  }\r",
							"\r",
							"  var prng = options.prng || forge.random;\r",
							"\r",
							"  var pssobj = {};\r",
							"\r",
							"  /**\r",
							"   * Encodes a PSS signature.\r",
							"   *\r",
							"   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\r",
							"   *\r",
							"   * @param md the message digest object with the hash to sign.\r",
							"   * @param modsBits the length of the RSA modulus in bits.\r",
							"   *\r",
							"   * @return the encoded message as a binary-encoded string of length\r",
							"   *           ceil((modBits - 1) / 8).\r",
							"   */\r",
							"  pssobj.encode = function(md, modBits) {\r",
							"    var i;\r",
							"    var emBits = modBits - 1;\r",
							"    var emLen = Math.ceil(emBits / 8);\r",
							"\r",
							"    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\r",
							"    var mHash = md.digest().getBytes();\r",
							"\r",
							"    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\r",
							"    if(emLen < hLen + sLen + 2) {\r",
							"      throw new Error('Message is too long to encrypt.');\r",
							"    }\r",
							"\r",
							"    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\r",
							"     *    then salt is the empty string. */\r",
							"    var salt;\r",
							"    if(salt_ === null) {\r",
							"      salt = prng.getBytesSync(sLen);\r",
							"    } else {\r",
							"      salt = salt_.bytes();\r",
							"    }\r",
							"\r",
							"    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\r",
							"    var m_ = new forge.util.ByteBuffer();\r",
							"    m_.fillWithByte(0, 8);\r",
							"    m_.putBytes(mHash);\r",
							"    m_.putBytes(salt);\r",
							"\r",
							"    /* 6. Let H = Hash(M'), an octet string of length hLen. */\r",
							"    hash.start();\r",
							"    hash.update(m_.getBytes());\r",
							"    var h = hash.digest().getBytes();\r",
							"\r",
							"    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\r",
							"     *    zero octets.  The length of PS may be 0. */\r",
							"    var ps = new forge.util.ByteBuffer();\r",
							"    ps.fillWithByte(0, emLen - sLen - hLen - 2);\r",
							"\r",
							"    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\r",
							"     *    emLen - hLen - 1. */\r",
							"    ps.putByte(0x01);\r",
							"    ps.putBytes(salt);\r",
							"    var db = ps.getBytes();\r",
							"\r",
							"    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\r",
							"    var maskLen = emLen - hLen - 1;\r",
							"    var dbMask = mgf.generate(h, maskLen);\r",
							"\r",
							"    /* 10. Let maskedDB = DB \\xor dbMask. */\r",
							"    var maskedDB = '';\r",
							"    for(i = 0; i < maskLen; i++) {\r",
							"      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\r",
							"    }\r",
							"\r",
							"    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\r",
							"     *     maskedDB to zero. */\r",
							"    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\r",
							"    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +\r",
							"      maskedDB.substr(1);\r",
							"\r",
							"    /* 12. Let EM = maskedDB || H || 0xbc.\r",
							"     * 13. Output EM. */\r",
							"    return maskedDB + h + String.fromCharCode(0xbc);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Verifies a PSS signature.\r",
							"   *\r",
							"   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\r",
							"   *\r",
							"   * @param mHash the message digest hash, as a binary-encoded string, to\r",
							"   *         compare against the signature.\r",
							"   * @param em the encoded message, as a binary-encoded string\r",
							"   *          (RSA decryption result).\r",
							"   * @param modsBits the length of the RSA modulus in bits.\r",
							"   *\r",
							"   * @return true if the signature was verified, false if not.\r",
							"   */\r",
							"  pssobj.verify = function(mHash, em, modBits) {\r",
							"    var i;\r",
							"    var emBits = modBits - 1;\r",
							"    var emLen = Math.ceil(emBits / 8);\r",
							"\r",
							"    /* c. Convert the message representative m to an encoded message EM\r",
							"     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\r",
							"     *    is the length in bits of the RSA modulus n */\r",
							"    em = em.substr(-emLen);\r",
							"\r",
							"    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\r",
							"    if(emLen < hLen + sLen + 2) {\r",
							"      throw new Error('Inconsistent parameters to PSS signature verification.');\r",
							"    }\r",
							"\r",
							"    /* 4. If the rightmost octet of EM does not have hexadecimal value\r",
							"     *    0xbc, output \"inconsistent\" and stop. */\r",
							"    if(em.charCodeAt(emLen - 1) !== 0xbc) {\r",
							"      throw new Error('Encoded message does not end in 0xBC.');\r",
							"    }\r",
							"\r",
							"    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\r",
							"     *    let H be the next hLen octets. */\r",
							"    var maskLen = emLen - hLen - 1;\r",
							"    var maskedDB = em.substr(0, maskLen);\r",
							"    var h = em.substr(maskLen, hLen);\r",
							"\r",
							"    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\r",
							"     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\r",
							"    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\r",
							"    if((maskedDB.charCodeAt(0) & mask) !== 0) {\r",
							"      throw new Error('Bits beyond keysize not zero as expected.');\r",
							"    }\r",
							"\r",
							"    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\r",
							"    var dbMask = mgf.generate(h, maskLen);\r",
							"\r",
							"    /* 8. Let DB = maskedDB \\xor dbMask. */\r",
							"    var db = '';\r",
							"    for(i = 0; i < maskLen; i++) {\r",
							"      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\r",
							"    }\r",
							"\r",
							"    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\r",
							"     * in DB to zero. */\r",
							"    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\r",
							"\r",
							"    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\r",
							"     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\r",
							"     * position is \"position 1\") does not have hexadecimal value 0x01,\r",
							"     * output \"inconsistent\" and stop. */\r",
							"    var checkLen = emLen - hLen - sLen - 2;\r",
							"    for(i = 0; i < checkLen; i++) {\r",
							"      if(db.charCodeAt(i) !== 0x00) {\r",
							"        throw new Error('Leftmost octets not zero as expected');\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(db.charCodeAt(checkLen) !== 0x01) {\r",
							"      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\r",
							"    }\r",
							"\r",
							"    /* 11. Let salt be the last sLen octets of DB. */\r",
							"    var salt = db.substr(-sLen);\r",
							"\r",
							"    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\r",
							"    var m_ = new forge.util.ByteBuffer();\r",
							"    m_.fillWithByte(0, 8);\r",
							"    m_.putBytes(mHash);\r",
							"    m_.putBytes(salt);\r",
							"\r",
							"    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\r",
							"    hash.start();\r",
							"    hash.update(m_.getBytes());\r",
							"    var h_ = hash.digest().getBytes();\r",
							"\r",
							"    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\r",
							"    return h === h_;\r",
							"  };\r",
							"\r",
							"  return pssobj;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 18 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Supported cipher modes.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"forge.cipher = forge.cipher || {};\r",
							"\r",
							"// supported cipher modes\r",
							"var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\r",
							"\r",
							"/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\r",
							"\r",
							"modes.ecb = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'ECB';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = new Array(this._ints);\r",
							"  this._outBlock = new Array(this._ints);\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.start = function(options) {};\r",
							"\r",
							"modes.ecb.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = input.getInt32();\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i]);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = input.getInt32();\r",
							"  }\r",
							"\r",
							"  // decrypt block\r",
							"  this.cipher.decrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i]);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.pad = function(input, options) {\r",
							"  // add PKCS#7 padding to block (each pad byte is the\r",
							"  // value of the number of pad bytes)\r",
							"  var padding = (input.length() === this.blockSize ?\r",
							"    this.blockSize : (this.blockSize - input.length()));\r",
							"  input.fillWithByte(padding, padding);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"modes.ecb.prototype.unpad = function(output, options) {\r",
							"  // check for error: input data not a multiple of blockSize\r",
							"  if(options.overflow > 0) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // ensure padding byte count is valid\r",
							"  var len = output.length();\r",
							"  var count = output.at(len - 1);\r",
							"  if(count > (this.blockSize << 2)) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // trim off padding bytes\r",
							"  output.truncate(count);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"/** Cipher-block Chaining (CBC) **/\r",
							"\r",
							"modes.cbc = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'CBC';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = new Array(this._ints);\r",
							"  this._outBlock = new Array(this._ints);\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.start = function(options) {\r",
							"  // Note: legacy support for using IV residue (has security flaws)\r",
							"  // if IV is null, reuse block from previous processing\r",
							"  if(options.iv === null) {\r",
							"    // must have a previous block\r",
							"    if(!this._prev) {\r",
							"      throw new Error('Invalid IV parameter.');\r",
							"    }\r",
							"    this._iv = this._prev.slice(0);\r",
							"  } else if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  } else {\r",
							"    // save IV as \"previous\" block\r",
							"    this._iv = transformIV(options.iv);\r",
							"    this._prev = this._iv.slice(0);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  // CBC XOR's IV (or previous block) with plaintext\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = this._prev[i] ^ input.getInt32();\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output, save previous block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i]);\r",
							"  }\r",
							"  this._prev = this._outBlock;\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // get next block\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._inBlock[i] = input.getInt32();\r",
							"  }\r",
							"\r",
							"  // decrypt block\r",
							"  this.cipher.decrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // write output, save previous ciphered block\r",
							"  // CBC XOR's IV (or previous block) with ciphertext\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._prev[i] ^ this._outBlock[i]);\r",
							"  }\r",
							"  this._prev = this._inBlock.slice(0);\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.pad = function(input, options) {\r",
							"  // add PKCS#7 padding to block (each pad byte is the\r",
							"  // value of the number of pad bytes)\r",
							"  var padding = (input.length() === this.blockSize ?\r",
							"    this.blockSize : (this.blockSize - input.length()));\r",
							"  input.fillWithByte(padding, padding);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"modes.cbc.prototype.unpad = function(output, options) {\r",
							"  // check for error: input data not a multiple of blockSize\r",
							"  if(options.overflow > 0) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // ensure padding byte count is valid\r",
							"  var len = output.length();\r",
							"  var count = output.at(len - 1);\r",
							"  if(count > (this.blockSize << 2)) {\r",
							"    return false;\r",
							"  }\r",
							"\r",
							"  // trim off padding bytes\r",
							"  output.truncate(count);\r",
							"  return true;\r",
							"};\r",
							"\r",
							"/** Cipher feedback (CFB) **/\r",
							"\r",
							"modes.cfb = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'CFB';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = null;\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.cfb.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // use IV as first input\r",
							"  this._iv = transformIV(options.iv);\r",
							"  this._inBlock = this._iv.slice(0);\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.cfb.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output, write input as output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\r",
							"      output.putInt32(this._inBlock[i]);\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // handle partial block\r",
							"  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"  if(partialBytes > 0) {\r",
							"    partialBytes = this.blockSize - partialBytes;\r",
							"  }\r",
							"\r",
							"  // XOR input with output, write input as partial output\r",
							"  this._partialOutput.clear();\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\r",
							"    this._partialOutput.putInt32(this._partialBlock[i]);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0) {\r",
							"    // block still incomplete, restore input buffer\r",
							"    input.read -= this.blockSize;\r",
							"  } else {\r",
							"    // block complete, update input block\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = this._partialBlock[i];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // skip any previous partial bytes\r",
							"  if(this._partialBytes > 0) {\r",
							"    this._partialOutput.getBytes(this._partialBytes);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0 && !finish) {\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      partialBytes - this._partialBytes));\r",
							"    this._partialBytes = partialBytes;\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  output.putBytes(this._partialOutput.getBytes(\r",
							"    inputLength - this._partialBytes));\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.cfb.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (CFB always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output, write input as output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = input.getInt32();\r",
							"      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // handle partial block\r",
							"  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"  if(partialBytes > 0) {\r",
							"    partialBytes = this.blockSize - partialBytes;\r",
							"  }\r",
							"\r",
							"  // XOR input with output, write input as partial output\r",
							"  this._partialOutput.clear();\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._partialBlock[i] = input.getInt32();\r",
							"    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0) {\r",
							"    // block still incomplete, restore input buffer\r",
							"    input.read -= this.blockSize;\r",
							"  } else {\r",
							"    // block complete, update input block\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = this._partialBlock[i];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // skip any previous partial bytes\r",
							"  if(this._partialBytes > 0) {\r",
							"    this._partialOutput.getBytes(this._partialBytes);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0 && !finish) {\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      partialBytes - this._partialBytes));\r",
							"    this._partialBytes = partialBytes;\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  output.putBytes(this._partialOutput.getBytes(\r",
							"    inputLength - this._partialBytes));\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"/** Output feedback (OFB) **/\r",
							"\r",
							"modes.ofb = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'OFB';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = null;\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ofb.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // use IV as first input\r",
							"  this._iv = transformIV(options.iv);\r",
							"  this._inBlock = this._iv.slice(0);\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ofb.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(input.length() === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (OFB always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output and update next input\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      output.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"      this._inBlock[i] = this._outBlock[i];\r",
							"    }\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // handle partial block\r",
							"  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"  if(partialBytes > 0) {\r",
							"    partialBytes = this.blockSize - partialBytes;\r",
							"  }\r",
							"\r",
							"  // XOR input with output\r",
							"  this._partialOutput.clear();\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0) {\r",
							"    // block still incomplete, restore input buffer\r",
							"    input.read -= this.blockSize;\r",
							"  } else {\r",
							"    // block complete, update input block\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._inBlock[i] = this._outBlock[i];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // skip any previous partial bytes\r",
							"  if(this._partialBytes > 0) {\r",
							"    this._partialOutput.getBytes(this._partialBytes);\r",
							"  }\r",
							"\r",
							"  if(partialBytes > 0 && !finish) {\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      partialBytes - this._partialBytes));\r",
							"    this._partialBytes = partialBytes;\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  output.putBytes(this._partialOutput.getBytes(\r",
							"    inputLength - this._partialBytes));\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\r",
							"\r",
							"/** Counter (CTR) **/\r",
							"\r",
							"modes.ctr = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'CTR';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = null;\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ctr.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // use IV as first input\r",
							"  this._iv = transformIV(options.iv);\r",
							"  this._inBlock = this._iv.slice(0);\r",
							"  this._partialBytes = 0;\r",
							"};\r",
							"\r",
							"modes.ctr.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (CTR always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      output.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"    }\r",
							"  } else {\r",
							"    // handle partial block\r",
							"    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"    if(partialBytes > 0) {\r",
							"      partialBytes = this.blockSize - partialBytes;\r",
							"    }\r",
							"\r",
							"    // XOR input with output\r",
							"    this._partialOutput.clear();\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"    }\r",
							"\r",
							"    if(partialBytes > 0) {\r",
							"      // block still incomplete, restore input buffer\r",
							"      input.read -= this.blockSize;\r",
							"    }\r",
							"\r",
							"    // skip any previous partial bytes\r",
							"    if(this._partialBytes > 0) {\r",
							"      this._partialOutput.getBytes(this._partialBytes);\r",
							"    }\r",
							"\r",
							"    if(partialBytes > 0 && !finish) {\r",
							"      output.putBytes(this._partialOutput.getBytes(\r",
							"        partialBytes - this._partialBytes));\r",
							"      this._partialBytes = partialBytes;\r",
							"      return true;\r",
							"    }\r",
							"\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      inputLength - this._partialBytes));\r",
							"    this._partialBytes = 0;\r",
							"  }\r",
							"\r",
							"  // block complete, increment counter (input block)\r",
							"  inc32(this._inBlock);\r",
							"};\r",
							"\r",
							"modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\r",
							"\r",
							"/** Galois/Counter Mode (GCM) **/\r",
							"\r",
							"modes.gcm = function(options) {\r",
							"  options = options || {};\r",
							"  this.name = 'GCM';\r",
							"  this.cipher = options.cipher;\r",
							"  this.blockSize = options.blockSize || 16;\r",
							"  this._ints = this.blockSize / 4;\r",
							"  this._inBlock = new Array(this._ints);\r",
							"  this._outBlock = new Array(this._ints);\r",
							"  this._partialOutput = forge.util.createBuffer();\r",
							"  this._partialBytes = 0;\r",
							"\r",
							"  // R is actually this value concatenated with 120 more zero bits, but\r",
							"  // we only XOR against R so the other zeros have no effect -- we just\r",
							"  // apply this value to the first integer in a block\r",
							"  this._R = 0xE1000000;\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.start = function(options) {\r",
							"  if(!('iv' in options)) {\r",
							"    throw new Error('Invalid IV parameter.');\r",
							"  }\r",
							"  // ensure IV is a byte buffer\r",
							"  var iv = forge.util.createBuffer(options.iv);\r",
							"\r",
							"  // no ciphered data processed yet\r",
							"  this._cipherLength = 0;\r",
							"\r",
							"  // default additional data is none\r",
							"  var additionalData;\r",
							"  if('additionalData' in options) {\r",
							"    additionalData = forge.util.createBuffer(options.additionalData);\r",
							"  } else {\r",
							"    additionalData = forge.util.createBuffer();\r",
							"  }\r",
							"\r",
							"  // default tag length is 128 bits\r",
							"  if('tagLength' in options) {\r",
							"    this._tagLength = options.tagLength;\r",
							"  } else {\r",
							"    this._tagLength = 128;\r",
							"  }\r",
							"\r",
							"  // if tag is given, ensure tag matches tag length\r",
							"  this._tag = null;\r",
							"  if(options.decrypt) {\r",
							"    // save tag to check later\r",
							"    this._tag = forge.util.createBuffer(options.tag).getBytes();\r",
							"    if(this._tag.length !== (this._tagLength / 8)) {\r",
							"      throw new Error('Authentication tag does not match tag length.');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // create tmp storage for hash calculation\r",
							"  this._hashBlock = new Array(this._ints);\r",
							"\r",
							"  // no tag generated yet\r",
							"  this.tag = null;\r",
							"\r",
							"  // generate hash subkey\r",
							"  // (apply block cipher to \"zero\" block)\r",
							"  this._hashSubkey = new Array(this._ints);\r",
							"  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\r",
							"\r",
							"  // generate table M\r",
							"  // use 4-bit tables (32 component decomposition of a 16 byte value)\r",
							"  // 8-bit tables take more space and are known to have security\r",
							"  // vulnerabilities (in native implementations)\r",
							"  this.componentBits = 4;\r",
							"  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\r",
							"\r",
							"  // Note: support IV length different from 96 bits? (only supporting\r",
							"  // 96 bits is recommended by NIST SP-800-38D)\r",
							"  // generate J_0\r",
							"  var ivLength = iv.length();\r",
							"  if(ivLength === 12) {\r",
							"    // 96-bit IV\r",
							"    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\r",
							"  } else {\r",
							"    // IV is NOT 96-bits\r",
							"    this._j0 = [0, 0, 0, 0];\r",
							"    while(iv.length() > 0) {\r",
							"      this._j0 = this.ghash(\r",
							"        this._hashSubkey, this._j0,\r",
							"        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\r",
							"    }\r",
							"    this._j0 = this.ghash(\r",
							"      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\r",
							"  }\r",
							"\r",
							"  // generate ICB (initial counter block)\r",
							"  this._inBlock = this._j0.slice(0);\r",
							"  inc32(this._inBlock);\r",
							"  this._partialBytes = 0;\r",
							"\r",
							"  // consume authentication data\r",
							"  additionalData = forge.util.createBuffer(additionalData);\r",
							"  // save additional data length as a BE 64-bit number\r",
							"  this._aDataLength = from64To32(additionalData.length() * 8);\r",
							"  // pad additional data to 128 bit (16 byte) block size\r",
							"  var overflow = additionalData.length() % this.blockSize;\r",
							"  if(overflow) {\r",
							"    additionalData.fillWithByte(0, this.blockSize - overflow);\r",
							"  }\r",
							"  this._s = [0, 0, 0, 0];\r",
							"  while(additionalData.length() > 0) {\r",
							"    this._s = this.ghash(this._hashSubkey, this._s, [\r",
							"      additionalData.getInt32(),\r",
							"      additionalData.getInt32(),\r",
							"      additionalData.getInt32(),\r",
							"      additionalData.getInt32()\r",
							"    ]);\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.encrypt = function(input, output, finish) {\r",
							"  // not enough input to encrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength === 0) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // handle full block\r",
							"  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\r",
							"    // XOR input with output\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      output.putInt32(this._outBlock[i] ^= input.getInt32());\r",
							"    }\r",
							"    this._cipherLength += this.blockSize;\r",
							"  } else {\r",
							"    // handle partial block\r",
							"    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\r",
							"    if(partialBytes > 0) {\r",
							"      partialBytes = this.blockSize - partialBytes;\r",
							"    }\r",
							"\r",
							"    // XOR input with output\r",
							"    this._partialOutput.clear();\r",
							"    for(var i = 0; i < this._ints; ++i) {\r",
							"      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\r",
							"    }\r",
							"\r",
							"    if(partialBytes === 0 || finish) {\r",
							"      // handle overflow prior to hashing\r",
							"      if(finish) {\r",
							"        // get block overflow\r",
							"        var overflow = inputLength % this.blockSize;\r",
							"        this._cipherLength += overflow;\r",
							"        // truncate for hash function\r",
							"        this._partialOutput.truncate(this.blockSize - overflow);\r",
							"      } else {\r",
							"        this._cipherLength += this.blockSize;\r",
							"      }\r",
							"\r",
							"      // get output block for hashing\r",
							"      for(var i = 0; i < this._ints; ++i) {\r",
							"        this._outBlock[i] = this._partialOutput.getInt32();\r",
							"      }\r",
							"      this._partialOutput.read -= this.blockSize;\r",
							"    }\r",
							"\r",
							"    // skip any previous partial bytes\r",
							"    if(this._partialBytes > 0) {\r",
							"      this._partialOutput.getBytes(this._partialBytes);\r",
							"    }\r",
							"\r",
							"    if(partialBytes > 0 && !finish) {\r",
							"      // block still incomplete, restore input buffer, get partial output,\r",
							"      // and return early\r",
							"      input.read -= this.blockSize;\r",
							"      output.putBytes(this._partialOutput.getBytes(\r",
							"        partialBytes - this._partialBytes));\r",
							"      this._partialBytes = partialBytes;\r",
							"      return true;\r",
							"    }\r",
							"\r",
							"    output.putBytes(this._partialOutput.getBytes(\r",
							"      inputLength - this._partialBytes));\r",
							"    this._partialBytes = 0;\r",
							"  }\r",
							"\r",
							"  // update hash block S\r",
							"  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\r",
							"\r",
							"  // increment counter (input block)\r",
							"  inc32(this._inBlock);\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.decrypt = function(input, output, finish) {\r",
							"  // not enough input to decrypt\r",
							"  var inputLength = input.length();\r",
							"  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {\r",
							"    return true;\r",
							"  }\r",
							"\r",
							"  // encrypt block (GCM always uses encryption mode)\r",
							"  this.cipher.encrypt(this._inBlock, this._outBlock);\r",
							"\r",
							"  // increment counter (input block)\r",
							"  inc32(this._inBlock);\r",
							"\r",
							"  // update hash block S\r",
							"  this._hashBlock[0] = input.getInt32();\r",
							"  this._hashBlock[1] = input.getInt32();\r",
							"  this._hashBlock[2] = input.getInt32();\r",
							"  this._hashBlock[3] = input.getInt32();\r",
							"  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\r",
							"\r",
							"  // XOR hash input with output\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\r",
							"  }\r",
							"\r",
							"  // increment cipher data length\r",
							"  if(inputLength < this.blockSize) {\r",
							"    this._cipherLength += inputLength % this.blockSize;\r",
							"  } else {\r",
							"    this._cipherLength += this.blockSize;\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.afterFinish = function(output, options) {\r",
							"  var rval = true;\r",
							"\r",
							"  // handle overflow\r",
							"  if(options.decrypt && options.overflow) {\r",
							"    output.truncate(this.blockSize - options.overflow);\r",
							"  }\r",
							"\r",
							"  // handle authentication tag\r",
							"  this.tag = forge.util.createBuffer();\r",
							"\r",
							"  // concatenate additional data length with cipher length\r",
							"  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\r",
							"\r",
							"  // include lengths in hash\r",
							"  this._s = this.ghash(this._hashSubkey, this._s, lengths);\r",
							"\r",
							"  // do GCTR(J_0, S)\r",
							"  var tag = [];\r",
							"  this.cipher.encrypt(this._j0, tag);\r",
							"  for(var i = 0; i < this._ints; ++i) {\r",
							"    this.tag.putInt32(this._s[i] ^ tag[i]);\r",
							"  }\r",
							"\r",
							"  // trim tag to length\r",
							"  this.tag.truncate(this.tag.length() % (this._tagLength / 8));\r",
							"\r",
							"  // check authentication tag\r",
							"  if(options.decrypt && this.tag.bytes() !== this._tag) {\r",
							"    rval = false;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\r",
							" * field multiplication. The field, GF(2^128), is defined by the polynomial:\r",
							" *\r",
							" * x^128 + x^7 + x^2 + x + 1\r",
							" *\r",
							" * Which is represented in little-endian binary form as: 11100001 (0xe1). When\r",
							" * the value of a coefficient is 1, a bit is set. The value R, is the\r",
							" * concatenation of this value and 120 zero bits, yielding a 128-bit value\r",
							" * which matches the block size.\r",
							" *\r",
							" * This function will multiply two elements (vectors of bytes), X and Y, in\r",
							" * the field GF(2^128). The result is initialized to zero. For each bit of\r",
							" * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\r",
							" * by the current value of Y. For each bit, the value of Y will be raised by\r",
							" * a power of x (multiplied by the polynomial x). This can be achieved by\r",
							" * shifting Y once to the right. If the current value of Y, prior to being\r",
							" * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\r",
							" * Otherwise, we must divide by R after shifting to find the remainder.\r",
							" *\r",
							" * @param x the first block to multiply by the second.\r",
							" * @param y the second block to multiply by the first.\r",
							" *\r",
							" * @return the block result of the multiplication.\r",
							" */\r",
							"modes.gcm.prototype.multiply = function(x, y) {\r",
							"  var z_i = [0, 0, 0, 0];\r",
							"  var v_i = y.slice(0);\r",
							"\r",
							"  // calculate Z_128 (block has 128 bits)\r",
							"  for(var i = 0; i < 128; ++i) {\r",
							"    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\r",
							"    // else Z_{i+1} = Z_i ^ V_i\r",
							"    // get x_i by finding 32-bit int position, then left shift 1 by remainder\r",
							"    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));\r",
							"    if(x_i) {\r",
							"      z_i[0] ^= v_i[0];\r",
							"      z_i[1] ^= v_i[1];\r",
							"      z_i[2] ^= v_i[2];\r",
							"      z_i[3] ^= v_i[3];\r",
							"    }\r",
							"\r",
							"    // if LSB(V_i) is 1, V_i = V_i >> 1\r",
							"    // else V_i = (V_i >> 1) ^ R\r",
							"    this.pow(v_i, v_i);\r",
							"  }\r",
							"\r",
							"  return z_i;\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.pow = function(x, out) {\r",
							"  // if LSB(x) is 1, x = x >>> 1\r",
							"  // else x = (x >>> 1) ^ R\r",
							"  var lsb = x[3] & 1;\r",
							"\r",
							"  // always do x >>> 1:\r",
							"  // starting with the rightmost integer, shift each integer to the right\r",
							"  // one bit, pulling in the bit from the integer to the left as its top\r",
							"  // most bit (do this for the last 3 integers)\r",
							"  for(var i = 3; i > 0; --i) {\r",
							"    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);\r",
							"  }\r",
							"  // shift the first integer normally\r",
							"  out[0] = x[0] >>> 1;\r",
							"\r",
							"  // if lsb was not set, then polynomial had a degree of 127 and doesn't\r",
							"  // need to divided; otherwise, XOR with R to find the remainder; we only\r",
							"  // need to XOR the first integer since R technically ends w/120 zero bits\r",
							"  if(lsb) {\r",
							"    out[0] ^= this._R;\r",
							"  }\r",
							"};\r",
							"\r",
							"modes.gcm.prototype.tableMultiply = function(x) {\r",
							"  // assumes 4-bit tables are used\r",
							"  var z = [0, 0, 0, 0];\r",
							"  for(var i = 0; i < 32; ++i) {\r",
							"    var idx = (i / 8) | 0;\r",
							"    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;\r",
							"    var ah = this._m[i][x_i];\r",
							"    z[0] ^= ah[0];\r",
							"    z[1] ^= ah[1];\r",
							"    z[2] ^= ah[2];\r",
							"    z[3] ^= ah[3];\r",
							"  }\r",
							"  return z;\r",
							"};\r",
							"\r",
							"/**\r",
							" * A continuing version of the GHASH algorithm that operates on a single\r",
							" * block. The hash block, last hash value (Ym) and the new block to hash\r",
							" * are given.\r",
							" *\r",
							" * @param h the hash block.\r",
							" * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\r",
							" * @param x the block to hash.\r",
							" *\r",
							" * @return the hashed value (Ym).\r",
							" */\r",
							"modes.gcm.prototype.ghash = function(h, y, x) {\r",
							"  y[0] ^= x[0];\r",
							"  y[1] ^= x[1];\r",
							"  y[2] ^= x[2];\r",
							"  y[3] ^= x[3];\r",
							"  return this.tableMultiply(y);\r",
							"  //return this.multiply(y, h);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Precomputes a table for multiplying against the hash subkey. This\r",
							" * mechanism provides a substantial speed increase over multiplication\r",
							" * performed without a table. The table-based multiplication this table is\r",
							" * for solves X * H by multiplying each component of X by H and then\r",
							" * composing the results together using XOR.\r",
							" *\r",
							" * This function can be used to generate tables with different bit sizes\r",
							" * for the components, however, this implementation assumes there are\r",
							" * 32 components of X (which is a 16 byte vector), therefore each component\r",
							" * takes 4-bits (so the table is constructed with bits=4).\r",
							" *\r",
							" * @param h the hash subkey.\r",
							" * @param bits the bit size for a component.\r",
							" */\r",
							"modes.gcm.prototype.generateHashTable = function(h, bits) {\r",
							"  // TODO: There are further optimizations that would use only the\r",
							"  // first table M_0 (or some variant) along with a remainder table;\r",
							"  // this can be explored in the future\r",
							"  var multiplier = 8 / bits;\r",
							"  var perInt = 4 * multiplier;\r",
							"  var size = 16 * multiplier;\r",
							"  var m = new Array(size);\r",
							"  for(var i = 0; i < size; ++i) {\r",
							"    var tmp = [0, 0, 0, 0];\r",
							"    var idx = (i / perInt) | 0;\r",
							"    var shft = ((perInt - 1 - (i % perInt)) * bits);\r",
							"    tmp[idx] = (1 << (bits - 1)) << shft;\r",
							"    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\r",
							"  }\r",
							"  return m;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Generates a table for multiplying against the hash subkey for one\r",
							" * particular component (out of all possible component values).\r",
							" *\r",
							" * @param mid the pre-multiplied value for the middle key of the table.\r",
							" * @param bits the bit size for a component.\r",
							" */\r",
							"modes.gcm.prototype.generateSubHashTable = function(mid, bits) {\r",
							"  // compute the table quickly by minimizing the number of\r",
							"  // POW operations -- they only need to be performed for powers of 2,\r",
							"  // all other entries can be composed from those powers using XOR\r",
							"  var size = 1 << bits;\r",
							"  var half = size >>> 1;\r",
							"  var m = new Array(size);\r",
							"  m[half] = mid.slice(0);\r",
							"  var i = half >>> 1;\r",
							"  while(i > 0) {\r",
							"    // raise m0[2 * i] and store in m0[i]\r",
							"    this.pow(m[2 * i], m[i] = []);\r",
							"    i >>= 1;\r",
							"  }\r",
							"  i = 2;\r",
							"  while(i < half) {\r",
							"    for(var j = 1; j < i; ++j) {\r",
							"      var m_i = m[i];\r",
							"      var m_j = m[j];\r",
							"      m[i + j] = [\r",
							"        m_i[0] ^ m_j[0],\r",
							"        m_i[1] ^ m_j[1],\r",
							"        m_i[2] ^ m_j[2],\r",
							"        m_i[3] ^ m_j[3]\r",
							"      ];\r",
							"    }\r",
							"    i *= 2;\r",
							"  }\r",
							"  m[0] = [0, 0, 0, 0];\r",
							"  /* Note: We could avoid storing these by doing composition during multiply\r",
							"  calculate top half using composition by speed is preferred. */\r",
							"  for(i = half + 1; i < size; ++i) {\r",
							"    var c = m[i ^ half];\r",
							"    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\r",
							"  }\r",
							"  return m;\r",
							"};\r",
							"\r",
							"/** Utility functions */\r",
							"\r",
							"function transformIV(iv) {\r",
							"  if(typeof iv === 'string') {\r",
							"    // convert iv string into byte buffer\r",
							"    iv = forge.util.createBuffer(iv);\r",
							"  }\r",
							"\r",
							"  if(forge.util.isArray(iv) && iv.length > 4) {\r",
							"    // convert iv byte array into byte buffer\r",
							"    var tmp = iv;\r",
							"    iv = forge.util.createBuffer();\r",
							"    for(var i = 0; i < tmp.length; ++i) {\r",
							"      iv.putByte(tmp[i]);\r",
							"    }\r",
							"  }\r",
							"  if(!forge.util.isArray(iv)) {\r",
							"    // convert iv byte buffer into 32-bit integer array\r",
							"    iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];\r",
							"  }\r",
							"\r",
							"  return iv;\r",
							"}\r",
							"\r",
							"function inc32(block) {\r",
							"  // increment last 32 bits of block only\r",
							"  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;\r",
							"}\r",
							"\r",
							"function from64To32(num) {\r",
							"  // convert 64-bit number to two BE Int32s\r",
							"  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 19 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * A Javascript implementation of Transport Layer Security (TLS).\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2009-2014 Digital Bazaar, Inc.\r",
							" *\r",
							" * The TLS Handshake Protocol involves the following steps:\r",
							" *\r",
							" * - Exchange hello messages to agree on algorithms, exchange random values,\r",
							" * and check for session resumption.\r",
							" *\r",
							" * - Exchange the necessary cryptographic parameters to allow the client and\r",
							" * server to agree on a premaster secret.\r",
							" *\r",
							" * - Exchange certificates and cryptographic information to allow the client\r",
							" * and server to authenticate themselves.\r",
							" *\r",
							" * - Generate a master secret from the premaster secret and exchanged random\r",
							" * values.\r",
							" *\r",
							" * - Provide security parameters to the record layer.\r",
							" *\r",
							" * - Allow the client and server to verify that their peer has calculated the\r",
							" * same security parameters and that the handshake occurred without tampering\r",
							" * by an attacker.\r",
							" *\r",
							" * Up to 4 different messages may be sent during a key exchange. The server\r",
							" * certificate, the server key exchange, the client certificate, and the\r",
							" * client key exchange.\r",
							" *\r",
							" * A typical handshake (from the client's perspective).\r",
							" *\r",
							" * 1. Client sends ClientHello.\r",
							" * 2. Client receives ServerHello.\r",
							" * 3. Client receives optional Certificate.\r",
							" * 4. Client receives optional ServerKeyExchange.\r",
							" * 5. Client receives ServerHelloDone.\r",
							" * 6. Client sends optional Certificate.\r",
							" * 7. Client sends ClientKeyExchange.\r",
							" * 8. Client sends optional CertificateVerify.\r",
							" * 9. Client sends ChangeCipherSpec.\r",
							" * 10. Client sends Finished.\r",
							" * 11. Client receives ChangeCipherSpec.\r",
							" * 12. Client receives Finished.\r",
							" * 13. Client sends/receives application data.\r",
							" *\r",
							" * To reuse an existing session:\r",
							" *\r",
							" * 1. Client sends ClientHello with session ID for reuse.\r",
							" * 2. Client receives ServerHello with same session ID if reusing.\r",
							" * 3. Client receives ChangeCipherSpec message if reusing.\r",
							" * 4. Client receives Finished.\r",
							" * 5. Client sends ChangeCipherSpec.\r",
							" * 6. Client sends Finished.\r",
							" *\r",
							" * Note: Client ignores HelloRequest if in the middle of a handshake.\r",
							" *\r",
							" * Record Layer:\r",
							" *\r",
							" * The record layer fragments information blocks into TLSPlaintext records\r",
							" * carrying data in chunks of 2^14 bytes or less. Client message boundaries are\r",
							" * not preserved in the record layer (i.e., multiple client messages of the\r",
							" * same ContentType MAY be coalesced into a single TLSPlaintext record, or a\r",
							" * single message MAY be fragmented across several records).\r",
							" *\r",
							" * struct {\r",
							" *   uint8 major;\r",
							" *   uint8 minor;\r",
							" * } ProtocolVersion;\r",
							" *\r",
							" * struct {\r",
							" *   ContentType type;\r",
							" *   ProtocolVersion version;\r",
							" *   uint16 length;\r",
							" *   opaque fragment[TLSPlaintext.length];\r",
							" * } TLSPlaintext;\r",
							" *\r",
							" * type:\r",
							" *   The higher-level protocol used to process the enclosed fragment.\r",
							" *\r",
							" * version:\r",
							" *   The version of the protocol being employed. TLS Version 1.2 uses version\r",
							" *   {3, 3}. TLS Version 1.0 uses version {3, 1}. Note that a client that\r",
							" *   supports multiple versions of TLS may not know what version will be\r",
							" *   employed before it receives the ServerHello.\r",
							" *\r",
							" * length:\r",
							" *   The length (in bytes) of the following TLSPlaintext.fragment. The length\r",
							" *   MUST NOT exceed 2^14 = 16384 bytes.\r",
							" *\r",
							" * fragment:\r",
							" *   The application data. This data is transparent and treated as an\r",
							" *   independent block to be dealt with by the higher-level protocol specified\r",
							" *   by the type field.\r",
							" *\r",
							" * Implementations MUST NOT send zero-length fragments of Handshake, Alert, or\r",
							" * ChangeCipherSpec content types. Zero-length fragments of Application data\r",
							" * MAY be sent as they are potentially useful as a traffic analysis\r",
							" * countermeasure.\r",
							" *\r",
							" * Note: Data of different TLS record layer content types MAY be interleaved.\r",
							" * Application data is generally of lower precedence for transmission than\r",
							" * other content types. However, records MUST be delivered to the network in\r",
							" * the same order as they are protected by the record layer. Recipients MUST\r",
							" * receive and process interleaved application layer traffic during handshakes\r",
							" * subsequent to the first one on a connection.\r",
							" *\r",
							" * struct {\r",
							" *   ContentType type;       // same as TLSPlaintext.type\r",
							" *   ProtocolVersion version;// same as TLSPlaintext.version\r",
							" *   uint16 length;\r",
							" *   opaque fragment[TLSCompressed.length];\r",
							" * } TLSCompressed;\r",
							" *\r",
							" * length:\r",
							" *   The length (in bytes) of the following TLSCompressed.fragment.\r",
							" *   The length MUST NOT exceed 2^14 + 1024.\r",
							" *\r",
							" * fragment:\r",
							" *   The compressed form of TLSPlaintext.fragment.\r",
							" *\r",
							" * Note: A CompressionMethod.null operation is an identity operation; no fields\r",
							" * are altered. In this implementation, since no compression is supported,\r",
							" * uncompressed records are always the same as compressed records.\r",
							" *\r",
							" * Encryption Information:\r",
							" *\r",
							" * The encryption and MAC functions translate a TLSCompressed structure into a\r",
							" * TLSCiphertext. The decryption functions reverse the process. The MAC of the\r",
							" * record also includes a sequence number so that missing, extra, or repeated\r",
							" * messages are detectable.\r",
							" *\r",
							" * struct {\r",
							" *   ContentType type;\r",
							" *   ProtocolVersion version;\r",
							" *   uint16 length;\r",
							" *   select (SecurityParameters.cipher_type) {\r",
							" *     case stream: GenericStreamCipher;\r",
							" *     case block:  GenericBlockCipher;\r",
							" *     case aead:   GenericAEADCipher;\r",
							" *   } fragment;\r",
							" * } TLSCiphertext;\r",
							" *\r",
							" * type:\r",
							" *   The type field is identical to TLSCompressed.type.\r",
							" *\r",
							" * version:\r",
							" *   The version field is identical to TLSCompressed.version.\r",
							" *\r",
							" * length:\r",
							" *   The length (in bytes) of the following TLSCiphertext.fragment.\r",
							" *   The length MUST NOT exceed 2^14 + 2048.\r",
							" *\r",
							" * fragment:\r",
							" *   The encrypted form of TLSCompressed.fragment, with the MAC.\r",
							" *\r",
							" * Note: Only CBC Block Ciphers are supported by this implementation.\r",
							" *\r",
							" * The TLSCompressed.fragment structures are converted to/from block\r",
							" * TLSCiphertext.fragment structures.\r",
							" *\r",
							" * struct {\r",
							" *   opaque IV[SecurityParameters.record_iv_length];\r",
							" *   block-ciphered struct {\r",
							" *     opaque content[TLSCompressed.length];\r",
							" *     opaque MAC[SecurityParameters.mac_length];\r",
							" *     uint8 padding[GenericBlockCipher.padding_length];\r",
							" *     uint8 padding_length;\r",
							" *   };\r",
							" * } GenericBlockCipher;\r",
							" *\r",
							" * The MAC is generated as described in Section 6.2.3.1.\r",
							" *\r",
							" * IV:\r",
							" *   The Initialization Vector (IV) SHOULD be chosen at random, and MUST be\r",
							" *   unpredictable. Note that in versions of TLS prior to 1.1, there was no\r",
							" *   IV field, and the last ciphertext block of the previous record (the \"CBC\r",
							" *   residue\") was used as the IV. This was changed to prevent the attacks\r",
							" *   described in [CBCATT]. For block ciphers, the IV length is of length\r",
							" *   SecurityParameters.record_iv_length, which is equal to the\r",
							" *   SecurityParameters.block_size.\r",
							" *\r",
							" * padding:\r",
							" *   Padding that is added to force the length of the plaintext to be an\r",
							" *   integral multiple of the block cipher's block length. The padding MAY be\r",
							" *   any length up to 255 bytes, as long as it results in the\r",
							" *   TLSCiphertext.length being an integral multiple of the block length.\r",
							" *   Lengths longer than necessary might be desirable to frustrate attacks on\r",
							" *   a protocol that are based on analysis of the lengths of exchanged\r",
							" *   messages. Each uint8 in the padding data vector MUST be filled with the\r",
							" *   padding length value. The receiver MUST check this padding and MUST use\r",
							" *   the bad_record_mac alert to indicate padding errors.\r",
							" *\r",
							" * padding_length:\r",
							" *   The padding length MUST be such that the total size of the\r",
							" *   GenericBlockCipher structure is a multiple of the cipher's block length.\r",
							" *   Legal values range from zero to 255, inclusive. This length specifies the\r",
							" *   length of the padding field exclusive of the padding_length field itself.\r",
							" *\r",
							" * The encrypted data length (TLSCiphertext.length) is one more than the sum of\r",
							" * SecurityParameters.block_length, TLSCompressed.length,\r",
							" * SecurityParameters.mac_length, and padding_length.\r",
							" *\r",
							" * Example: If the block length is 8 bytes, the content length\r",
							" * (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the\r",
							" * length before padding is 82 bytes (this does not include the IV. Thus, the\r",
							" * padding length modulo 8 must be equal to 6 in order to make the total length\r",
							" * an even multiple of 8 bytes (the block length). The padding length can be\r",
							" * 6, 14, 22, and so on, through 254. If the padding length were the minimum\r",
							" * necessary, 6, the padding would be 6 bytes, each containing the value 6.\r",
							" * Thus, the last 8 octets of the GenericBlockCipher before block encryption\r",
							" * would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.\r",
							" *\r",
							" * Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical\r",
							" * that the entire plaintext of the record be known before any ciphertext is\r",
							" * transmitted. Otherwise, it is possible for the attacker to mount the attack\r",
							" * described in [CBCATT].\r",
							" *\r",
							" * Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing\r",
							" * attack on CBC padding based on the time required to compute the MAC. In\r",
							" * order to defend against this attack, implementations MUST ensure that\r",
							" * record processing time is essentially the same whether or not the padding\r",
							" * is correct. In general, the best way to do this is to compute the MAC even\r",
							" * if the padding is incorrect, and only then reject the packet. For instance,\r",
							" * if the pad appears to be incorrect, the implementation might assume a\r",
							" * zero-length pad and then compute the MAC. This leaves a small timing\r",
							" * channel, since MAC performance depends, to some extent, on the size of the\r",
							" * data fragment, but it is not believed to be large enough to be exploitable,\r",
							" * due to the large block size of existing MACs and the small size of the\r",
							" * timing signal.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(14);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(20);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/**\r",
							" * Generates pseudo random bytes by mixing the result of two hash functions,\r",
							" * MD5 and SHA-1.\r",
							" *\r",
							" * prf_TLS1(secret, label, seed) =\r",
							" *   P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed);\r",
							" *\r",
							" * Each P_hash function functions as follows:\r",
							" *\r",
							" * P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +\r",
							" *                        HMAC_hash(secret, A(2) + seed) +\r",
							" *                        HMAC_hash(secret, A(3) + seed) + ...\r",
							" * A() is defined as:\r",
							" *   A(0) = seed\r",
							" *   A(i) = HMAC_hash(secret, A(i-1))\r",
							" *\r",
							" * The '+' operator denotes concatenation.\r",
							" *\r",
							" * As many iterations A(N) as are needed are performed to generate enough\r",
							" * pseudo random byte output. If an iteration creates more data than is\r",
							" * necessary, then it is truncated.\r",
							" *\r",
							" * Therefore:\r",
							" * A(1) = HMAC_hash(secret, A(0))\r",
							" *      = HMAC_hash(secret, seed)\r",
							" * A(2) = HMAC_hash(secret, A(1))\r",
							" *      = HMAC_hash(secret, HMAC_hash(secret, seed))\r",
							" *\r",
							" * Therefore:\r",
							" * P_hash(secret, seed) =\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, A(0)) + seed) +\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, A(1)) + seed) +\r",
							" *   ...\r",
							" *\r",
							" * Therefore:\r",
							" * P_hash(secret, seed) =\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, seed) + seed) +\r",
							" *   HMAC_hash(secret, HMAC_hash(secret, HMAC_hash(secret, seed)) + seed) +\r",
							" *   ...\r",
							" *\r",
							" * @param secret the secret to use.\r",
							" * @param label the label to use.\r",
							" * @param seed the seed value to use.\r",
							" * @param length the number of bytes to generate.\r",
							" *\r",
							" * @return the pseudo random bytes in a byte buffer.\r",
							" */\r",
							"var prf_TLS1 = function(secret, label, seed, length) {\r",
							"  var rval = forge.util.createBuffer();\r",
							"\r",
							"  /* For TLS 1.0, the secret is split in half, into two secrets of equal\r",
							"    length. If the secret has an odd length then the last byte of the first\r",
							"    half will be the same as the first byte of the second. The length of the\r",
							"    two secrets is half of the secret rounded up. */\r",
							"  var idx = (secret.length >> 1);\r",
							"  var slen = idx + (secret.length & 1);\r",
							"  var s1 = secret.substr(0, slen);\r",
							"  var s2 = secret.substr(idx, slen);\r",
							"  var ai = forge.util.createBuffer();\r",
							"  var hmac = forge.hmac.create();\r",
							"  seed = label + seed;\r",
							"\r",
							"  // determine the number of iterations that must be performed to generate\r",
							"  // enough output bytes, md5 creates 16 byte hashes, sha1 creates 20\r",
							"  var md5itr = Math.ceil(length / 16);\r",
							"  var sha1itr = Math.ceil(length / 20);\r",
							"\r",
							"  // do md5 iterations\r",
							"  hmac.start('MD5', s1);\r",
							"  var md5bytes = forge.util.createBuffer();\r",
							"  ai.putBytes(seed);\r",
							"  for(var i = 0; i < md5itr; ++i) {\r",
							"    // HMAC_hash(secret, A(i-1))\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.getBytes());\r",
							"    ai.putBuffer(hmac.digest());\r",
							"\r",
							"    // HMAC_hash(secret, A(i) + seed)\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.bytes() + seed);\r",
							"    md5bytes.putBuffer(hmac.digest());\r",
							"  }\r",
							"\r",
							"  // do sha1 iterations\r",
							"  hmac.start('SHA1', s2);\r",
							"  var sha1bytes = forge.util.createBuffer();\r",
							"  ai.clear();\r",
							"  ai.putBytes(seed);\r",
							"  for(var i = 0; i < sha1itr; ++i) {\r",
							"    // HMAC_hash(secret, A(i-1))\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.getBytes());\r",
							"    ai.putBuffer(hmac.digest());\r",
							"\r",
							"    // HMAC_hash(secret, A(i) + seed)\r",
							"    hmac.start(null, null);\r",
							"    hmac.update(ai.bytes() + seed);\r",
							"    sha1bytes.putBuffer(hmac.digest());\r",
							"  }\r",
							"\r",
							"  // XOR the md5 bytes with the sha1 bytes\r",
							"  rval.putBytes(forge.util.xorBytes(\r",
							"    md5bytes.getBytes(), sha1bytes.getBytes(), length));\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Generates pseudo random bytes using a SHA256 algorithm. For TLS 1.2.\r",
							" *\r",
							" * @param secret the secret to use.\r",
							" * @param label the label to use.\r",
							" * @param seed the seed value to use.\r",
							" * @param length the number of bytes to generate.\r",
							" *\r",
							" * @return the pseudo random bytes in a byte buffer.\r",
							" */\r",
							"var prf_sha256 = function(secret, label, seed, length) {\r",
							"   // FIXME: implement me for TLS 1.2\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets a MAC for a record using the SHA-1 hash algorithm.\r",
							" *\r",
							" * @param key the mac key.\r",
							" * @param state the sequence number (array of two 32-bit integers).\r",
							" * @param record the record.\r",
							" *\r",
							" * @return the sha-1 hash (20 bytes) for the given record.\r",
							" */\r",
							"var hmac_sha1 = function(key, seqNum, record) {\r",
							"  /* MAC is computed like so:\r",
							"  HMAC_hash(\r",
							"    key, seqNum +\r",
							"      TLSCompressed.type +\r",
							"      TLSCompressed.version +\r",
							"      TLSCompressed.length +\r",
							"      TLSCompressed.fragment)\r",
							"  */\r",
							"  var hmac = forge.hmac.create();\r",
							"  hmac.start('SHA1', key);\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putInt32(seqNum[0]);\r",
							"  b.putInt32(seqNum[1]);\r",
							"  b.putByte(record.type);\r",
							"  b.putByte(record.version.major);\r",
							"  b.putByte(record.version.minor);\r",
							"  b.putInt16(record.length);\r",
							"  b.putBytes(record.fragment.bytes());\r",
							"  hmac.update(b.getBytes());\r",
							"  return hmac.digest().getBytes();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compresses the TLSPlaintext record into a TLSCompressed record using the\r",
							" * deflate algorithm.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param record the TLSPlaintext record to compress.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"var deflate = function(c, record, s) {\r",
							"  var rval = false;\r",
							"\r",
							"  try {\r",
							"    var bytes = c.deflate(record.fragment.getBytes());\r",
							"    record.fragment = forge.util.createBuffer(bytes);\r",
							"    record.length = bytes.length;\r",
							"    rval = true;\r",
							"  } catch(ex) {\r",
							"    // deflate error, fail out\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decompresses the TLSCompressed record into a TLSPlaintext record using the\r",
							" * deflate algorithm.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param record the TLSCompressed record to decompress.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"var inflate = function(c, record, s) {\r",
							"  var rval = false;\r",
							"\r",
							"  try {\r",
							"    var bytes = c.inflate(record.fragment.getBytes());\r",
							"    record.fragment = forge.util.createBuffer(bytes);\r",
							"    record.length = bytes.length;\r",
							"    rval = true;\r",
							"  } catch(ex) {\r",
							"    // inflate error, fail out\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Reads a TLS variable-length vector from a byte buffer.\r",
							" *\r",
							" * Variable-length vectors are defined by specifying a subrange of legal\r",
							" * lengths, inclusively, using the notation <floor..ceiling>. When these are\r",
							" * encoded, the actual length precedes the vector's contents in the byte\r",
							" * stream. The length will be in the form of a number consuming as many bytes\r",
							" * as required to hold the vector's specified maximum (ceiling) length. A\r",
							" * variable-length vector with an actual length field of zero is referred to\r",
							" * as an empty vector.\r",
							" *\r",
							" * @param b the byte buffer.\r",
							" * @param lenBytes the number of bytes required to store the length.\r",
							" *\r",
							" * @return the resulting byte buffer.\r",
							" */\r",
							"var readVector = function(b, lenBytes) {\r",
							"  var len = 0;\r",
							"  switch(lenBytes) {\r",
							"  case 1:\r",
							"    len = b.getByte();\r",
							"    break;\r",
							"  case 2:\r",
							"    len = b.getInt16();\r",
							"    break;\r",
							"  case 3:\r",
							"    len = b.getInt24();\r",
							"    break;\r",
							"  case 4:\r",
							"    len = b.getInt32();\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  // read vector bytes into a new buffer\r",
							"  return forge.util.createBuffer(b.getBytes(len));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Writes a TLS variable-length vector to a byte buffer.\r",
							" *\r",
							" * @param b the byte buffer.\r",
							" * @param lenBytes the number of bytes required to store the length.\r",
							" * @param v the byte buffer vector.\r",
							" */\r",
							"var writeVector = function(b, lenBytes, v) {\r",
							"  // encode length at the start of the vector, where the number of bytes for\r",
							"  // the length is the maximum number of bytes it would take to encode the\r",
							"  // vector's ceiling\r",
							"  b.putInt(v.length(), lenBytes << 3);\r",
							"  b.putBuffer(v);\r",
							"};\r",
							"\r",
							"/**\r",
							" * The tls implementation.\r",
							" */\r",
							"var tls = {};\r",
							"\r",
							"/**\r",
							" * Version: TLS 1.2 = 3.3, TLS 1.1 = 3.2, TLS 1.0 = 3.1. Both TLS 1.1 and\r",
							" * TLS 1.2 were still too new (ie: openSSL didn't implement them) at the time\r",
							" * of this implementation so TLS 1.0 was implemented instead.\r",
							" */\r",
							"tls.Versions = {\r",
							"  TLS_1_0: {major: 3, minor: 1},\r",
							"  TLS_1_1: {major: 3, minor: 2},\r",
							"  TLS_1_2: {major: 3, minor: 3}\r",
							"};\r",
							"tls.SupportedVersions = [\r",
							"  tls.Versions.TLS_1_1,\r",
							"  tls.Versions.TLS_1_0\r",
							"];\r",
							"tls.Version = tls.SupportedVersions[0];\r",
							"\r",
							"/**\r",
							" * Maximum fragment size. True maximum is 16384, but we fragment before that\r",
							" * to allow for unusual small increases during compression.\r",
							" */\r",
							"tls.MaxFragment = 16384 - 1024;\r",
							"\r",
							"/**\r",
							" * Whether this entity is considered the \"client\" or \"server\".\r",
							" * enum { server, client } ConnectionEnd;\r",
							" */\r",
							"tls.ConnectionEnd = {\r",
							"  server: 0,\r",
							"  client: 1\r",
							"};\r",
							"\r",
							"/**\r",
							" * Pseudo-random function algorithm used to generate keys from the master\r",
							" * secret.\r",
							" * enum { tls_prf_sha256 } PRFAlgorithm;\r",
							" */\r",
							"tls.PRFAlgorithm = {\r",
							"  tls_prf_sha256: 0\r",
							"};\r",
							"\r",
							"/**\r",
							" * Bulk encryption algorithms.\r",
							" * enum { null, rc4, des3, aes } BulkCipherAlgorithm;\r",
							" */\r",
							"tls.BulkCipherAlgorithm = {\r",
							"  none: null,\r",
							"  rc4: 0,\r",
							"  des3: 1,\r",
							"  aes: 2\r",
							"};\r",
							"\r",
							"/**\r",
							" * Cipher types.\r",
							" * enum { stream, block, aead } CipherType;\r",
							" */\r",
							"tls.CipherType = {\r",
							"  stream: 0,\r",
							"  block: 1,\r",
							"  aead: 2\r",
							"};\r",
							"\r",
							"/**\r",
							" * MAC (Message Authentication Code) algorithms.\r",
							" * enum { null, hmac_md5, hmac_sha1, hmac_sha256,\r",
							" *   hmac_sha384, hmac_sha512} MACAlgorithm;\r",
							" */\r",
							"tls.MACAlgorithm = {\r",
							"  none: null,\r",
							"  hmac_md5: 0,\r",
							"  hmac_sha1: 1,\r",
							"  hmac_sha256: 2,\r",
							"  hmac_sha384: 3,\r",
							"  hmac_sha512: 4\r",
							"};\r",
							"\r",
							"/**\r",
							" * Compression algorithms.\r",
							" * enum { null(0), deflate(1), (255) } CompressionMethod;\r",
							" */\r",
							"tls.CompressionMethod = {\r",
							"  none: 0,\r",
							"  deflate: 1\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS record content types.\r",
							" * enum {\r",
							" *   change_cipher_spec(20), alert(21), handshake(22),\r",
							" *   application_data(23), (255)\r",
							" * } ContentType;\r",
							" */\r",
							"tls.ContentType = {\r",
							"  change_cipher_spec: 20,\r",
							"  alert: 21,\r",
							"  handshake: 22,\r",
							"  application_data: 23,\r",
							"  heartbeat: 24\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS handshake types.\r",
							" * enum {\r",
							" *   hello_request(0), client_hello(1), server_hello(2),\r",
							" *   certificate(11), server_key_exchange (12),\r",
							" *   certificate_request(13), server_hello_done(14),\r",
							" *   certificate_verify(15), client_key_exchange(16),\r",
							" *   finished(20), (255)\r",
							" * } HandshakeType;\r",
							" */\r",
							"tls.HandshakeType = {\r",
							"  hello_request: 0,\r",
							"  client_hello: 1,\r",
							"  server_hello: 2,\r",
							"  certificate: 11,\r",
							"  server_key_exchange: 12,\r",
							"  certificate_request: 13,\r",
							"  server_hello_done: 14,\r",
							"  certificate_verify: 15,\r",
							"  client_key_exchange: 16,\r",
							"  finished: 20\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS Alert Protocol.\r",
							" *\r",
							" * enum { warning(1), fatal(2), (255) } AlertLevel;\r",
							" *\r",
							" * enum {\r",
							" *   close_notify(0),\r",
							" *   unexpected_message(10),\r",
							" *   bad_record_mac(20),\r",
							" *   decryption_failed(21),\r",
							" *   record_overflow(22),\r",
							" *   decompression_failure(30),\r",
							" *   handshake_failure(40),\r",
							" *   bad_certificate(42),\r",
							" *   unsupported_certificate(43),\r",
							" *   certificate_revoked(44),\r",
							" *   certificate_expired(45),\r",
							" *   certificate_unknown(46),\r",
							" *   illegal_parameter(47),\r",
							" *   unknown_ca(48),\r",
							" *   access_denied(49),\r",
							" *   decode_error(50),\r",
							" *   decrypt_error(51),\r",
							" *   export_restriction(60),\r",
							" *   protocol_version(70),\r",
							" *   insufficient_security(71),\r",
							" *   internal_error(80),\r",
							" *   user_canceled(90),\r",
							" *   no_renegotiation(100),\r",
							" *   (255)\r",
							" * } AlertDescription;\r",
							" *\r",
							" * struct {\r",
							" *   AlertLevel level;\r",
							" *   AlertDescription description;\r",
							" * } Alert;\r",
							" */\r",
							"tls.Alert = {};\r",
							"tls.Alert.Level = {\r",
							"  warning: 1,\r",
							"  fatal: 2\r",
							"};\r",
							"tls.Alert.Description = {\r",
							"  close_notify: 0,\r",
							"  unexpected_message: 10,\r",
							"  bad_record_mac: 20,\r",
							"  decryption_failed: 21,\r",
							"  record_overflow: 22,\r",
							"  decompression_failure: 30,\r",
							"  handshake_failure: 40,\r",
							"  bad_certificate: 42,\r",
							"  unsupported_certificate: 43,\r",
							"  certificate_revoked: 44,\r",
							"  certificate_expired: 45,\r",
							"  certificate_unknown: 46,\r",
							"  illegal_parameter: 47,\r",
							"  unknown_ca: 48,\r",
							"  access_denied: 49,\r",
							"  decode_error: 50,\r",
							"  decrypt_error: 51,\r",
							"  export_restriction: 60,\r",
							"  protocol_version: 70,\r",
							"  insufficient_security: 71,\r",
							"  internal_error: 80,\r",
							"  user_canceled: 90,\r",
							"  no_renegotiation: 100\r",
							"};\r",
							"\r",
							"/**\r",
							" * TLS Heartbeat Message types.\r",
							" * enum {\r",
							" *   heartbeat_request(1),\r",
							" *   heartbeat_response(2),\r",
							" *   (255)\r",
							" * } HeartbeatMessageType;\r",
							" */\r",
							"tls.HeartbeatMessageType = {\r",
							"  heartbeat_request: 1,\r",
							"  heartbeat_response: 2\r",
							"};\r",
							"\r",
							"/**\r",
							" * Supported cipher suites.\r",
							" */\r",
							"tls.CipherSuites = {};\r",
							"\r",
							"/**\r",
							" * Gets a supported cipher suite from its 2 byte ID.\r",
							" *\r",
							" * @param twoBytes two bytes in a string.\r",
							" *\r",
							" * @return the matching supported cipher suite or null.\r",
							" */\r",
							"tls.getCipherSuite = function(twoBytes) {\r",
							"  var rval = null;\r",
							"  for(var key in tls.CipherSuites) {\r",
							"    var cs = tls.CipherSuites[key];\r",
							"    if(cs.id[0] === twoBytes.charCodeAt(0) &&\r",
							"      cs.id[1] === twoBytes.charCodeAt(1)) {\r",
							"      rval = cs;\r",
							"      break;\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when an unexpected record is encountered.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleUnexpected = function(c, record) {\r",
							"  // if connection is client and closed, ignore unexpected messages\r",
							"  var ignore = (!c.open && c.entity === tls.ConnectionEnd.client);\r",
							"  if(!ignore) {\r",
							"    c.error(c, {\r",
							"      message: 'Unexpected message. Received TLS record out of order.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.unexpected_message\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a HelloRequest record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleHelloRequest = function(c, record, length) {\r",
							"  // ignore renegotiation requests from the server during a handshake, but\r",
							"  // if handshaking, send a warning alert that renegotation is denied\r",
							"  if(!c.handshaking && c.handshakes > 0) {\r",
							"    // send alert warning\r",
							"    tls.queue(c, tls.createAlert(c, {\r",
							"       level: tls.Alert.Level.warning,\r",
							"       description: tls.Alert.Description.no_renegotiation\r",
							"    }));\r",
							"    tls.flush(c);\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Parses a hello message from a ClientHello or ServerHello record.\r",
							" *\r",
							" * @param record the record to parse.\r",
							" *\r",
							" * @return the parsed message.\r",
							" */\r",
							"tls.parseHelloMessage = function(c, record, length) {\r",
							"  var msg = null;\r",
							"\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"\r",
							"  // minimum of 38 bytes in message\r",
							"  if(length < 38) {\r",
							"    c.error(c, {\r",
							"      message: client ?\r",
							"        'Invalid ServerHello message. Message too short.' :\r",
							"        'Invalid ClientHello message. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  } else {\r",
							"    // use 'remaining' to calculate # of remaining bytes in the message\r",
							"    var b = record.fragment;\r",
							"    var remaining = b.length();\r",
							"    msg = {\r",
							"      version: {\r",
							"        major: b.getByte(),\r",
							"        minor: b.getByte()\r",
							"      },\r",
							"      random: forge.util.createBuffer(b.getBytes(32)),\r",
							"      session_id: readVector(b, 1),\r",
							"      extensions: []\r",
							"    };\r",
							"    if(client) {\r",
							"      msg.cipher_suite = b.getBytes(2);\r",
							"      msg.compression_method = b.getByte();\r",
							"    } else {\r",
							"      msg.cipher_suites = readVector(b, 2);\r",
							"      msg.compression_methods = readVector(b, 1);\r",
							"    }\r",
							"\r",
							"    // read extensions if there are any bytes left in the message\r",
							"    remaining = length - (remaining - b.length());\r",
							"    if(remaining > 0) {\r",
							"      // parse extensions\r",
							"      var exts = readVector(b, 2);\r",
							"      while(exts.length() > 0) {\r",
							"        msg.extensions.push({\r",
							"          type: [exts.getByte(), exts.getByte()],\r",
							"          data: readVector(exts, 2)\r",
							"        });\r",
							"      }\r",
							"\r",
							"      // TODO: make extension support modular\r",
							"      if(!client) {\r",
							"        for(var i = 0; i < msg.extensions.length; ++i) {\r",
							"          var ext = msg.extensions[i];\r",
							"\r",
							"          // support SNI extension\r",
							"          if(ext.type[0] === 0x00 && ext.type[1] === 0x00) {\r",
							"            // get server name list\r",
							"            var snl = readVector(ext.data, 2);\r",
							"            while(snl.length() > 0) {\r",
							"              // read server name type\r",
							"              var snType = snl.getByte();\r",
							"\r",
							"              // only HostName type (0x00) is known, break out if\r",
							"              // another type is detected\r",
							"              if(snType !== 0x00) {\r",
							"                break;\r",
							"              }\r",
							"\r",
							"              // add host name to server name list\r",
							"              c.session.extensions.server_name.serverNameList.push(\r",
							"                readVector(snl, 2).getBytes());\r",
							"            }\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // version already set, do not allow version change\r",
							"    if(c.session.version) {\r",
							"      if(msg.version.major !== c.session.version.major ||\r",
							"        msg.version.minor !== c.session.version.minor) {\r",
							"        return c.error(c, {\r",
							"          message: 'TLS version change is disallowed during renegotiation.',\r",
							"          send: true,\r",
							"          alert: {\r",
							"            level: tls.Alert.Level.fatal,\r",
							"            description: tls.Alert.Description.protocol_version\r",
							"          }\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // get the chosen (ServerHello) cipher suite\r",
							"    if(client) {\r",
							"      // FIXME: should be checking configured acceptable cipher suites\r",
							"      c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);\r",
							"    } else {\r",
							"      // get a supported preferred (ClientHello) cipher suite\r",
							"      // choose the first supported cipher suite\r",
							"      var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());\r",
							"      while(tmp.length() > 0) {\r",
							"        // FIXME: should be checking configured acceptable suites\r",
							"        // cipher suites take up 2 bytes\r",
							"        c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));\r",
							"        if(c.session.cipherSuite !== null) {\r",
							"          break;\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // cipher suite not supported\r",
							"    if(c.session.cipherSuite === null) {\r",
							"      return c.error(c, {\r",
							"        message: 'No cipher suites in common.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.handshake_failure\r",
							"        },\r",
							"        cipherSuite: forge.util.bytesToHex(msg.cipher_suite)\r",
							"      });\r",
							"    }\r",
							"\r",
							"    // TODO: handle compression methods\r",
							"    if(client) {\r",
							"      c.session.compressionMethod = msg.compression_method;\r",
							"    } else {\r",
							"      // no compression\r",
							"      c.session.compressionMethod = tls.CompressionMethod.none;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates security parameters for the given connection based on the given\r",
							" * hello message.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param msg the hello message.\r",
							" */\r",
							"tls.createSecurityParameters = function(c, msg) {\r",
							"  /* Note: security params are from TLS 1.2, some values like prf_algorithm\r",
							"  are ignored for TLS 1.0/1.1 and the builtin as specified in the spec is\r",
							"  used. */\r",
							"\r",
							"  // TODO: handle other options from server when more supported\r",
							"\r",
							"  // get client and server randoms\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var msgRandom = msg.random.bytes();\r",
							"  var cRandom = client ? c.session.sp.client_random : msgRandom;\r",
							"  var sRandom = client ? msgRandom : tls.createRandom().getBytes();\r",
							"\r",
							"  // create new security parameters\r",
							"  c.session.sp = {\r",
							"    entity: c.entity,\r",
							"    prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,\r",
							"    bulk_cipher_algorithm: null,\r",
							"    cipher_type: null,\r",
							"    enc_key_length: null,\r",
							"    block_length: null,\r",
							"    fixed_iv_length: null,\r",
							"    record_iv_length: null,\r",
							"    mac_algorithm: null,\r",
							"    mac_length: null,\r",
							"    mac_key_length: null,\r",
							"    compression_algorithm: c.session.compressionMethod,\r",
							"    pre_master_secret: null,\r",
							"    master_secret: null,\r",
							"    client_random: cRandom,\r",
							"    server_random: sRandom\r",
							"  };\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ServerHello record.\r",
							" *\r",
							" * When a ServerHello message will be sent:\r",
							" *   The server will send this message in response to a client hello message\r",
							" *   when it was able to find an acceptable set of algorithms. If it cannot\r",
							" *   find such a match, it will respond with a handshake failure alert.\r",
							" *\r",
							" * uint24 length;\r",
							" * struct {\r",
							" *   ProtocolVersion server_version;\r",
							" *   Random random;\r",
							" *   SessionID session_id;\r",
							" *   CipherSuite cipher_suite;\r",
							" *   CompressionMethod compression_method;\r",
							" *   select(extensions_present) {\r",
							" *     case false:\r",
							" *       struct {};\r",
							" *     case true:\r",
							" *       Extension extensions<0..2^16-1>;\r",
							" *   };\r",
							" * } ServerHello;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleServerHello = function(c, record, length) {\r",
							"  var msg = tls.parseHelloMessage(c, record, length);\r",
							"  if(c.fail) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // ensure server version is compatible\r",
							"  if(msg.version.minor <= c.version.minor) {\r",
							"    c.version.minor = msg.version.minor;\r",
							"  } else {\r",
							"    return c.error(c, {\r",
							"      message: 'Incompatible TLS version.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.protocol_version\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // indicate session version has been set\r",
							"  c.session.version = c.version;\r",
							"\r",
							"  // get the session ID from the message\r",
							"  var sessionId = msg.session_id.bytes();\r",
							"\r",
							"  // if the session ID is not blank and matches the cached one, resume\r",
							"  // the session\r",
							"  if(sessionId.length > 0 && sessionId === c.session.id) {\r",
							"    // resuming session, expect a ChangeCipherSpec next\r",
							"    c.expect = SCC;\r",
							"    c.session.resuming = true;\r",
							"\r",
							"    // get new server random\r",
							"    c.session.sp.server_random = msg.random.bytes();\r",
							"  } else {\r",
							"    // not resuming, expect a server Certificate message next\r",
							"    c.expect = SCE;\r",
							"    c.session.resuming = false;\r",
							"\r",
							"    // create new security parameters\r",
							"    tls.createSecurityParameters(c, msg);\r",
							"  }\r",
							"\r",
							"  // set new session ID\r",
							"  c.session.id = sessionId;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a server receives a ClientHello record.\r",
							" *\r",
							" * When a ClientHello message will be sent:\r",
							" *   When a client first connects to a server it is required to send the\r",
							" *   client hello as its first message. The client can also send a client\r",
							" *   hello in response to a hello request or on its own initiative in order\r",
							" *   to renegotiate the security parameters in an existing connection.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleClientHello = function(c, record, length) {\r",
							"  var msg = tls.parseHelloMessage(c, record, length);\r",
							"  if(c.fail) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  // get the session ID from the message\r",
							"  var sessionId = msg.session_id.bytes();\r",
							"\r",
							"  // see if the given session ID is in the cache\r",
							"  var session = null;\r",
							"  if(c.sessionCache) {\r",
							"    session = c.sessionCache.getSession(sessionId);\r",
							"    if(session === null) {\r",
							"      // session ID not found\r",
							"      sessionId = '';\r",
							"    } else if(session.version.major !== msg.version.major ||\r",
							"      session.version.minor > msg.version.minor) {\r",
							"      // if session version is incompatible with client version, do not resume\r",
							"      session = null;\r",
							"      sessionId = '';\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // no session found to resume, generate a new session ID\r",
							"  if(sessionId.length === 0) {\r",
							"    sessionId = forge.random.getBytes(32);\r",
							"  }\r",
							"\r",
							"  // update session\r",
							"  c.session.id = sessionId;\r",
							"  c.session.clientHelloVersion = msg.version;\r",
							"  c.session.sp = {};\r",
							"  if(session) {\r",
							"    // use version and security parameters from resumed session\r",
							"    c.version = c.session.version = session.version;\r",
							"    c.session.sp = session.sp;\r",
							"  } else {\r",
							"    // use highest compatible minor version\r",
							"    var version;\r",
							"    for(var i = 1; i < tls.SupportedVersions.length; ++i) {\r",
							"      version = tls.SupportedVersions[i];\r",
							"      if(version.minor <= msg.version.minor) {\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"    c.version = {major: version.major, minor: version.minor};\r",
							"    c.session.version = c.version;\r",
							"  }\r",
							"\r",
							"  // if a session is set, resume it\r",
							"  if(session !== null) {\r",
							"    // resuming session, expect a ChangeCipherSpec next\r",
							"    c.expect = CCC;\r",
							"    c.session.resuming = true;\r",
							"\r",
							"    // get new client random\r",
							"    c.session.sp.client_random = msg.random.bytes();\r",
							"  } else {\r",
							"    // not resuming, expect a Certificate or ClientKeyExchange\r",
							"    c.expect = (c.verifyClient !== false) ? CCE : CKE;\r",
							"    c.session.resuming = false;\r",
							"\r",
							"    // create new security parameters\r",
							"    tls.createSecurityParameters(c, msg);\r",
							"  }\r",
							"\r",
							"  // connection now open\r",
							"  c.open = true;\r",
							"\r",
							"  // queue server hello\r",
							"  tls.queue(c, tls.createRecord(c, {\r",
							"    type: tls.ContentType.handshake,\r",
							"    data: tls.createServerHello(c)\r",
							"  }));\r",
							"\r",
							"  if(c.session.resuming) {\r",
							"    // queue change cipher spec message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.change_cipher_spec,\r",
							"      data: tls.createChangeCipherSpec()\r",
							"    }));\r",
							"\r",
							"    // create pending state\r",
							"    c.state.pending = tls.createConnectionState(c);\r",
							"\r",
							"    // change current write state to pending write state\r",
							"    c.state.current.write = c.state.pending.write;\r",
							"\r",
							"    // queue finished\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createFinished(c)\r",
							"    }));\r",
							"  } else {\r",
							"    // queue server certificate\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createCertificate(c)\r",
							"    }));\r",
							"\r",
							"    if(!c.fail) {\r",
							"      // queue server key exchange\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createServerKeyExchange(c)\r",
							"      }));\r",
							"\r",
							"      // request client certificate if set\r",
							"      if(c.verifyClient !== false) {\r",
							"        // queue certificate request\r",
							"        tls.queue(c, tls.createRecord(c, {\r",
							"          type: tls.ContentType.handshake,\r",
							"          data: tls.createCertificateRequest(c)\r",
							"        }));\r",
							"      }\r",
							"\r",
							"      // queue server hello done\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createServerHelloDone(c)\r",
							"      }));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // send records\r",
							"  tls.flush(c);\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a Certificate record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   The server must send a certificate whenever the agreed-upon key exchange\r",
							" *   method is not an anonymous one. This message will always immediately\r",
							" *   follow the server hello message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   The certificate type must be appropriate for the selected cipher suite's\r",
							" *   key exchange algorithm, and is generally an X.509v3 certificate. It must\r",
							" *   contain a key which matches the key exchange method, as follows. Unless\r",
							" *   otherwise specified, the signing algorithm for the certificate must be\r",
							" *   the same as the algorithm for the certificate key. Unless otherwise\r",
							" *   specified, the public key may be of any length.\r",
							" *\r",
							" * opaque ASN.1Cert<1..2^24-1>;\r",
							" * struct {\r",
							" *   ASN.1Cert certificate_list<1..2^24-1>;\r",
							" * } Certificate;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleCertificate = function(c, record, length) {\r",
							"  // minimum of 3 bytes in message\r",
							"  if(length < 3) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid Certificate message. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  var b = record.fragment;\r",
							"  var msg = {\r",
							"    certificate_list: readVector(b, 3)\r",
							"  };\r",
							"\r",
							"  /* The sender's certificate will be first in the list (chain), each\r",
							"    subsequent one that follows will certify the previous one, but root\r",
							"    certificates (self-signed) that specify the certificate authority may\r",
							"    be omitted under the assumption that clients must already possess it. */\r",
							"  var cert, asn1;\r",
							"  var certs = [];\r",
							"  try {\r",
							"    while(msg.certificate_list.length() > 0) {\r",
							"      // each entry in msg.certificate_list is a vector with 3 len bytes\r",
							"      cert = readVector(msg.certificate_list, 3);\r",
							"      asn1 = forge.asn1.fromDer(cert);\r",
							"      cert = forge.pki.certificateFromAsn1(asn1, true);\r",
							"      certs.push(cert);\r",
							"    }\r",
							"  } catch(ex) {\r",
							"    return c.error(c, {\r",
							"      message: 'Could not parse certificate list.',\r",
							"      cause: ex,\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.bad_certificate\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // ensure at least 1 certificate was provided if in client-mode\r",
							"  // or if verifyClient was set to true to require a certificate\r",
							"  // (as opposed to 'optional')\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  if((client || c.verifyClient === true) && certs.length === 0) {\r",
							"    // error, no certificate\r",
							"    c.error(c, {\r",
							"      message: client ?\r",
							"        'No server certificate provided.' :\r",
							"        'No client certificate provided.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  } else if(certs.length === 0) {\r",
							"    // no certs to verify\r",
							"    // expect a ServerKeyExchange or ClientKeyExchange message next\r",
							"    c.expect = client ? SKE : CKE;\r",
							"  } else {\r",
							"    // save certificate in session\r",
							"    if(client) {\r",
							"      c.session.serverCertificate = certs[0];\r",
							"    } else {\r",
							"      c.session.clientCertificate = certs[0];\r",
							"    }\r",
							"\r",
							"    if(tls.verifyCertificateChain(c, certs)) {\r",
							"      // expect a ServerKeyExchange or ClientKeyExchange message next\r",
							"      c.expect = client ? SKE : CKE;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ServerKeyExchange record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This message will be sent immediately after the server certificate\r",
							" *   message (or the server hello message, if this is an anonymous\r",
							" *   negotiation).\r",
							" *\r",
							" *   The server key exchange message is sent by the server only when the\r",
							" *   server certificate message (if sent) does not contain enough data to\r",
							" *   allow the client to exchange a premaster secret.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   This message conveys cryptographic information to allow the client to\r",
							" *   communicate the premaster secret: either an RSA public key to encrypt\r",
							" *   the premaster secret with, or a Diffie-Hellman public key with which the\r",
							" *   client can complete a key exchange (with the result being the premaster\r",
							" *   secret.)\r",
							" *\r",
							" * enum {\r",
							" *   dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa\r",
							" * } KeyExchangeAlgorithm;\r",
							" *\r",
							" * struct {\r",
							" *   opaque dh_p<1..2^16-1>;\r",
							" *   opaque dh_g<1..2^16-1>;\r",
							" *   opaque dh_Ys<1..2^16-1>;\r",
							" * } ServerDHParams;\r",
							" *\r",
							" * struct {\r",
							" *   select(KeyExchangeAlgorithm) {\r",
							" *     case dh_anon:\r",
							" *       ServerDHParams params;\r",
							" *     case dhe_dss:\r",
							" *     case dhe_rsa:\r",
							" *       ServerDHParams params;\r",
							" *       digitally-signed struct {\r",
							" *         opaque client_random[32];\r",
							" *         opaque server_random[32];\r",
							" *         ServerDHParams params;\r",
							" *       } signed_params;\r",
							" *     case rsa:\r",
							" *     case dh_dss:\r",
							" *     case dh_rsa:\r",
							" *       struct {};\r",
							" *   };\r",
							" * } ServerKeyExchange;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleServerKeyExchange = function(c, record, length) {\r",
							"  // this implementation only supports RSA, no Diffie-Hellman support\r",
							"  // so any length > 0 is invalid\r",
							"  if(length > 0) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid key parameters. Only RSA is supported.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.unsupported_certificate\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // expect an optional CertificateRequest message next\r",
							"  c.expect = SCR;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ClientKeyExchange record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleClientKeyExchange = function(c, record, length) {\r",
							"  // this implementation only supports RSA, no Diffie-Hellman support\r",
							"  // so any length < 48 is invalid\r",
							"  if(length < 48) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid key parameters. Only RSA is supported.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.unsupported_certificate\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  var b = record.fragment;\r",
							"  var msg = {\r",
							"    enc_pre_master_secret: readVector(b, 2).getBytes()\r",
							"  };\r",
							"\r",
							"  // do rsa decryption\r",
							"  var privateKey = null;\r",
							"  if(c.getPrivateKey) {\r",
							"    try {\r",
							"      privateKey = c.getPrivateKey(c, c.session.serverCertificate);\r",
							"      privateKey = forge.pki.privateKeyFromPem(privateKey);\r",
							"    } catch(ex) {\r",
							"      c.error(c, {\r",
							"        message: 'Could not get private key.',\r",
							"        cause: ex,\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(privateKey === null) {\r",
							"    return c.error(c, {\r",
							"      message: 'No private key set.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.internal_error\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  try {\r",
							"    // decrypt 48-byte pre-master secret\r",
							"    var sp = c.session.sp;\r",
							"    sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);\r",
							"\r",
							"    // ensure client hello version matches first 2 bytes\r",
							"    var version = c.session.clientHelloVersion;\r",
							"    if(version.major !== sp.pre_master_secret.charCodeAt(0) ||\r",
							"      version.minor !== sp.pre_master_secret.charCodeAt(1)) {\r",
							"      // error, do not send alert (see BLEI attack below)\r",
							"      throw new Error('TLS version rollback attack detected.');\r",
							"    }\r",
							"  } catch(ex) {\r",
							"    /* Note: Daniel Bleichenbacher [BLEI] can be used to attack a\r",
							"      TLS server which is using PKCS#1 encoded RSA, so instead of\r",
							"      failing here, we generate 48 random bytes and use that as\r",
							"      the pre-master secret. */\r",
							"    sp.pre_master_secret = forge.random.getBytes(48);\r",
							"  }\r",
							"\r",
							"  // expect a CertificateVerify message if a Certificate was received that\r",
							"  // does not have fixed Diffie-Hellman params, otherwise expect\r",
							"  // ChangeCipherSpec\r",
							"  c.expect = CCC;\r",
							"  if(c.session.clientCertificate !== null) {\r",
							"    // only RSA support, so expect CertificateVerify\r",
							"    // TODO: support Diffie-Hellman\r",
							"    c.expect = CCV;\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a CertificateRequest record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   A non-anonymous server can optionally request a certificate from the\r",
							" *   client, if appropriate for the selected cipher suite. This message, if\r",
							" *   sent, will immediately follow the Server Key Exchange message (if it is\r",
							" *   sent; otherwise, the Server Certificate message).\r",
							" *\r",
							" * enum {\r",
							" *   rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\r",
							" *   rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\r",
							" *   fortezza_dms_RESERVED(20), (255)\r",
							" * } ClientCertificateType;\r",
							" *\r",
							" * opaque DistinguishedName<1..2^16-1>;\r",
							" *\r",
							" * struct {\r",
							" *   ClientCertificateType certificate_types<1..2^8-1>;\r",
							" *   SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;\r",
							" *   DistinguishedName certificate_authorities<0..2^16-1>;\r",
							" * } CertificateRequest;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleCertificateRequest = function(c, record, length) {\r",
							"  // minimum of 3 bytes in message\r",
							"  if(length < 3) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid CertificateRequest. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // TODO: TLS 1.2+ has different format including\r",
							"  // SignatureAndHashAlgorithm after cert types\r",
							"  var b = record.fragment;\r",
							"  var msg = {\r",
							"    certificate_types: readVector(b, 1),\r",
							"    certificate_authorities: readVector(b, 2)\r",
							"  };\r",
							"\r",
							"  // save certificate request in session\r",
							"  c.session.certificateRequest = msg;\r",
							"\r",
							"  // expect a ServerHelloDone message next\r",
							"  c.expect = SHD;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a server receives a CertificateVerify record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleCertificateVerify = function(c, record, length) {\r",
							"  if(length < 2) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid CertificateVerify. Message too short.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // rewind to get full bytes for message so it can be manually\r",
							"  // digested below (special case for CertificateVerify messages because\r",
							"  // they must be digested *after* handling as opposed to all others)\r",
							"  var b = record.fragment;\r",
							"  b.read -= 4;\r",
							"  var msgBytes = b.bytes();\r",
							"  b.read += 4;\r",
							"\r",
							"  var msg = {\r",
							"    signature: readVector(b, 2).getBytes()\r",
							"  };\r",
							"\r",
							"  // TODO: add support for DSA\r",
							"\r",
							"  // generate data to verify\r",
							"  var verify = forge.util.createBuffer();\r",
							"  verify.putBuffer(c.session.md5.digest());\r",
							"  verify.putBuffer(c.session.sha1.digest());\r",
							"  verify = verify.getBytes();\r",
							"\r",
							"  try {\r",
							"    var cert = c.session.clientCertificate;\r",
							"    /*b = forge.pki.rsa.decrypt(\r",
							"      msg.signature, cert.publicKey, true, verify.length);\r",
							"    if(b !== verify) {*/\r",
							"    if(!cert.publicKey.verify(verify, msg.signature, 'NONE')) {\r",
							"      throw new Error('CertificateVerify signature does not match.');\r",
							"    }\r",
							"\r",
							"    // digest message now that it has been handled\r",
							"    c.session.md5.update(msgBytes);\r",
							"    c.session.sha1.update(msgBytes);\r",
							"  } catch(ex) {\r",
							"    return c.error(c, {\r",
							"      message: 'Bad signature in CertificateVerify.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.handshake_failure\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // expect ChangeCipherSpec\r",
							"  c.expect = CCC;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a client receives a ServerHelloDone record.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   The server hello done message is sent by the server to indicate the end\r",
							" *   of the server hello and associated messages. After sending this message\r",
							" *   the server will wait for a client response.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   This message means that the server is done sending messages to support\r",
							" *   the key exchange, and the client can proceed with its phase of the key\r",
							" *   exchange.\r",
							" *\r",
							" *   Upon receipt of the server hello done message the client should verify\r",
							" *   that the server provided a valid certificate if required and check that\r",
							" *   the server hello parameters are acceptable.\r",
							" *\r",
							" * struct {} ServerHelloDone;\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleServerHelloDone = function(c, record, length) {\r",
							"  // len must be 0 bytes\r",
							"  if(length > 0) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid ServerHelloDone message. Invalid length.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.record_overflow\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  if(c.serverCertificate === null) {\r",
							"    // no server certificate was provided\r",
							"    var error = {\r",
							"      message: 'No server certificate provided. Not enough security.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.insufficient_security\r",
							"      }\r",
							"    };\r",
							"\r",
							"    // call application callback\r",
							"    var depth = 0;\r",
							"    var ret = c.verify(c, error.alert.description, depth, []);\r",
							"    if(ret !== true) {\r",
							"      // check for custom alert info\r",
							"      if(ret || ret === 0) {\r",
							"        // set custom message and alert description\r",
							"        if(typeof ret === 'object' && !forge.util.isArray(ret)) {\r",
							"          if(ret.message) {\r",
							"            error.message = ret.message;\r",
							"          }\r",
							"          if(ret.alert) {\r",
							"            error.alert.description = ret.alert;\r",
							"          }\r",
							"        } else if(typeof ret === 'number') {\r",
							"          // set custom alert description\r",
							"          error.alert.description = ret;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // send error\r",
							"      return c.error(c, error);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // create client certificate message if requested\r",
							"  if(c.session.certificateRequest !== null) {\r",
							"    record = tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createCertificate(c)\r",
							"    });\r",
							"    tls.queue(c, record);\r",
							"  }\r",
							"\r",
							"  // create client key exchange message\r",
							"  record = tls.createRecord(c, {\r",
							"     type: tls.ContentType.handshake,\r",
							"     data: tls.createClientKeyExchange(c)\r",
							"  });\r",
							"  tls.queue(c, record);\r",
							"\r",
							"  // expect no messages until the following callback has been called\r",
							"  c.expect = SER;\r",
							"\r",
							"  // create callback to handle client signature (for client-certs)\r",
							"  var callback = function(c, signature) {\r",
							"    if(c.session.certificateRequest !== null &&\r",
							"      c.session.clientCertificate !== null) {\r",
							"      // create certificate verify message\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createCertificateVerify(c, signature)\r",
							"      }));\r",
							"    }\r",
							"\r",
							"    // create change cipher spec message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.change_cipher_spec,\r",
							"      data: tls.createChangeCipherSpec()\r",
							"    }));\r",
							"\r",
							"    // create pending state\r",
							"    c.state.pending = tls.createConnectionState(c);\r",
							"\r",
							"    // change current write state to pending write state\r",
							"    c.state.current.write = c.state.pending.write;\r",
							"\r",
							"    // create finished message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createFinished(c)\r",
							"    }));\r",
							"\r",
							"    // expect a server ChangeCipherSpec message next\r",
							"    c.expect = SCC;\r",
							"\r",
							"    // send records\r",
							"    tls.flush(c);\r",
							"\r",
							"    // continue\r",
							"    c.process();\r",
							"  };\r",
							"\r",
							"  // if there is no certificate request or no client certificate, do\r",
							"  // callback immediately\r",
							"  if(c.session.certificateRequest === null ||\r",
							"    c.session.clientCertificate === null) {\r",
							"    return callback(c, null);\r",
							"  }\r",
							"\r",
							"  // otherwise get the client signature\r",
							"  tls.getClientSignature(c, callback);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a ChangeCipherSpec record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleChangeCipherSpec = function(c, record) {\r",
							"  if(record.fragment.getByte() !== 0x01) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid ChangeCipherSpec message received.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.illegal_parameter\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // create pending state if:\r",
							"  // 1. Resuming session in client mode OR\r",
							"  // 2. NOT resuming session in server mode\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  if((c.session.resuming && client) || (!c.session.resuming && !client)) {\r",
							"    c.state.pending = tls.createConnectionState(c);\r",
							"  }\r",
							"\r",
							"  // change current read state to pending read state\r",
							"  c.state.current.read = c.state.pending.read;\r",
							"\r",
							"  // clear pending state if:\r",
							"  // 1. NOT resuming session in client mode OR\r",
							"  // 2. resuming a session in server mode\r",
							"  if((!c.session.resuming && client) || (c.session.resuming && !client)) {\r",
							"    c.state.pending = null;\r",
							"  }\r",
							"\r",
							"  // expect a Finished record next\r",
							"  c.expect = client ? SFI : CFI;\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a Finished record is received.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   A finished message is always sent immediately after a change\r",
							" *   cipher spec message to verify that the key exchange and\r",
							" *   authentication processes were successful. It is essential that a\r",
							" *   change cipher spec message be received between the other\r",
							" *   handshake messages and the Finished message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   The finished message is the first protected with the just-\r",
							" *   negotiated algorithms, keys, and secrets. Recipients of finished\r",
							" *   messages must verify that the contents are correct.  Once a side\r",
							" *   has sent its Finished message and received and validated the\r",
							" *   Finished message from its peer, it may begin to send and receive\r",
							" *   application data over the connection.\r",
							" *\r",
							" * struct {\r",
							" *   opaque verify_data[verify_data_length];\r",
							" * } Finished;\r",
							" *\r",
							" * verify_data\r",
							" *   PRF(master_secret, finished_label, Hash(handshake_messages))\r",
							" *     [0..verify_data_length-1];\r",
							" *\r",
							" * finished_label\r",
							" *   For Finished messages sent by the client, the string\r",
							" *   \"client finished\". For Finished messages sent by the server, the\r",
							" *   string \"server finished\".\r",
							" *\r",
							" * verify_data_length depends on the cipher suite. If it is not specified\r",
							" * by the cipher suite, then it is 12. Versions of TLS < 1.2 always used\r",
							" * 12 bytes.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" * @param length the length of the handshake message.\r",
							" */\r",
							"tls.handleFinished = function(c, record, length) {\r",
							"  // rewind to get full bytes for message so it can be manually\r",
							"  // digested below (special case for Finished messages because they\r",
							"  // must be digested *after* handling as opposed to all others)\r",
							"  var b = record.fragment;\r",
							"  b.read -= 4;\r",
							"  var msgBytes = b.bytes();\r",
							"  b.read += 4;\r",
							"\r",
							"  // message contains only verify_data\r",
							"  var vd = record.fragment.getBytes();\r",
							"\r",
							"  // ensure verify data is correct\r",
							"  b = forge.util.createBuffer();\r",
							"  b.putBuffer(c.session.md5.digest());\r",
							"  b.putBuffer(c.session.sha1.digest());\r",
							"\r",
							"  // set label based on entity type\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var label = client ? 'server finished' : 'client finished';\r",
							"\r",
							"  // TODO: determine prf function and verify length for TLS 1.2\r",
							"  var sp = c.session.sp;\r",
							"  var vdl = 12;\r",
							"  var prf = prf_TLS1;\r",
							"  b = prf(sp.master_secret, label, b.getBytes(), vdl);\r",
							"  if(b.getBytes() !== vd) {\r",
							"    return c.error(c, {\r",
							"      message: 'Invalid verify_data in Finished message.',\r",
							"      send: true,\r",
							"      alert: {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: tls.Alert.Description.decrypt_error\r",
							"      }\r",
							"    });\r",
							"  }\r",
							"\r",
							"  // digest finished message now that it has been handled\r",
							"  c.session.md5.update(msgBytes);\r",
							"  c.session.sha1.update(msgBytes);\r",
							"\r",
							"  // resuming session as client or NOT resuming session as server\r",
							"  if((c.session.resuming && client) || (!c.session.resuming && !client)) {\r",
							"    // create change cipher spec message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.change_cipher_spec,\r",
							"      data: tls.createChangeCipherSpec()\r",
							"    }));\r",
							"\r",
							"    // change current write state to pending write state, clear pending\r",
							"    c.state.current.write = c.state.pending.write;\r",
							"    c.state.pending = null;\r",
							"\r",
							"    // create finished message\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.handshake,\r",
							"      data: tls.createFinished(c)\r",
							"    }));\r",
							"  }\r",
							"\r",
							"  // expect application data next\r",
							"  c.expect = client ? SAD : CAD;\r",
							"\r",
							"  // handshake complete\r",
							"  c.handshaking = false;\r",
							"  ++c.handshakes;\r",
							"\r",
							"  // save access to peer certificate\r",
							"  c.peerCertificate = client ?\r",
							"    c.session.serverCertificate : c.session.clientCertificate;\r",
							"\r",
							"  // send records\r",
							"  tls.flush(c);\r",
							"\r",
							"  // now connected\r",
							"  c.isConnected = true;\r",
							"  c.connected(c);\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when an Alert record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleAlert = function(c, record) {\r",
							"  // read alert\r",
							"  var b = record.fragment;\r",
							"  var alert = {\r",
							"    level: b.getByte(),\r",
							"    description: b.getByte()\r",
							"  };\r",
							"\r",
							"  // TODO: consider using a table?\r",
							"  // get appropriate message\r",
							"  var msg;\r",
							"  switch(alert.description) {\r",
							"  case tls.Alert.Description.close_notify:\r",
							"    msg = 'Connection closed.';\r",
							"    break;\r",
							"  case tls.Alert.Description.unexpected_message:\r",
							"    msg = 'Unexpected message.';\r",
							"    break;\r",
							"  case tls.Alert.Description.bad_record_mac:\r",
							"    msg = 'Bad record MAC.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decryption_failed:\r",
							"    msg = 'Decryption failed.';\r",
							"    break;\r",
							"  case tls.Alert.Description.record_overflow:\r",
							"    msg = 'Record overflow.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decompression_failure:\r",
							"    msg = 'Decompression failed.';\r",
							"    break;\r",
							"  case tls.Alert.Description.handshake_failure:\r",
							"    msg = 'Handshake failure.';\r",
							"    break;\r",
							"  case tls.Alert.Description.bad_certificate:\r",
							"    msg = 'Bad certificate.';\r",
							"    break;\r",
							"  case tls.Alert.Description.unsupported_certificate:\r",
							"    msg = 'Unsupported certificate.';\r",
							"    break;\r",
							"  case tls.Alert.Description.certificate_revoked:\r",
							"    msg = 'Certificate revoked.';\r",
							"    break;\r",
							"  case tls.Alert.Description.certificate_expired:\r",
							"    msg = 'Certificate expired.';\r",
							"    break;\r",
							"  case tls.Alert.Description.certificate_unknown:\r",
							"    msg = 'Certificate unknown.';\r",
							"    break;\r",
							"  case tls.Alert.Description.illegal_parameter:\r",
							"    msg = 'Illegal parameter.';\r",
							"    break;\r",
							"  case tls.Alert.Description.unknown_ca:\r",
							"    msg = 'Unknown certificate authority.';\r",
							"    break;\r",
							"  case tls.Alert.Description.access_denied:\r",
							"    msg = 'Access denied.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decode_error:\r",
							"    msg = 'Decode error.';\r",
							"    break;\r",
							"  case tls.Alert.Description.decrypt_error:\r",
							"    msg = 'Decrypt error.';\r",
							"    break;\r",
							"  case tls.Alert.Description.export_restriction:\r",
							"    msg = 'Export restriction.';\r",
							"    break;\r",
							"  case tls.Alert.Description.protocol_version:\r",
							"    msg = 'Unsupported protocol version.';\r",
							"    break;\r",
							"  case tls.Alert.Description.insufficient_security:\r",
							"    msg = 'Insufficient security.';\r",
							"    break;\r",
							"  case tls.Alert.Description.internal_error:\r",
							"    msg = 'Internal error.';\r",
							"    break;\r",
							"  case tls.Alert.Description.user_canceled:\r",
							"    msg = 'User canceled.';\r",
							"    break;\r",
							"  case tls.Alert.Description.no_renegotiation:\r",
							"    msg = 'Renegotiation not supported.';\r",
							"    break;\r",
							"  default:\r",
							"    msg = 'Unknown error.';\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  // close connection on close_notify, not an error\r",
							"  if(alert.description === tls.Alert.Description.close_notify) {\r",
							"    return c.close();\r",
							"  }\r",
							"\r",
							"  // call error handler\r",
							"  c.error(c, {\r",
							"    message: msg,\r",
							"    send: false,\r",
							"    // origin is the opposite end\r",
							"    origin: (c.entity === tls.ConnectionEnd.client) ? 'server' : 'client',\r",
							"    alert: alert\r",
							"  });\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a Handshake record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleHandshake = function(c, record) {\r",
							"  // get the handshake type and message length\r",
							"  var b = record.fragment;\r",
							"  var type = b.getByte();\r",
							"  var length = b.getInt24();\r",
							"\r",
							"  // see if the record fragment doesn't yet contain the full message\r",
							"  if(length > b.length()) {\r",
							"    // cache the record, clear its fragment, and reset the buffer read\r",
							"    // pointer before the type and length were read\r",
							"    c.fragmented = record;\r",
							"    record.fragment = forge.util.createBuffer();\r",
							"    b.read -= 4;\r",
							"\r",
							"    // continue\r",
							"    return c.process();\r",
							"  }\r",
							"\r",
							"  // full message now available, clear cache, reset read pointer to\r",
							"  // before type and length\r",
							"  c.fragmented = null;\r",
							"  b.read -= 4;\r",
							"\r",
							"  // save the handshake bytes for digestion after handler is found\r",
							"  // (include type and length of handshake msg)\r",
							"  var bytes = b.bytes(length + 4);\r",
							"\r",
							"  // restore read pointer\r",
							"  b.read += 4;\r",
							"\r",
							"  // handle expected message\r",
							"  if(type in hsTable[c.entity][c.expect]) {\r",
							"    // initialize server session\r",
							"    if(c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {\r",
							"      c.handshaking = true;\r",
							"      c.session = {\r",
							"        version: null,\r",
							"        extensions: {\r",
							"          server_name: {\r",
							"            serverNameList: []\r",
							"          }\r",
							"        },\r",
							"        cipherSuite: null,\r",
							"        compressionMethod: null,\r",
							"        serverCertificate: null,\r",
							"        clientCertificate: null,\r",
							"        md5: forge.md.md5.create(),\r",
							"        sha1: forge.md.sha1.create()\r",
							"      };\r",
							"    }\r",
							"\r",
							"    /* Update handshake messages digest. Finished and CertificateVerify\r",
							"      messages are not digested here. They can't be digested as part of\r",
							"      the verify_data that they contain. These messages are manually\r",
							"      digested in their handlers. HelloRequest messages are simply never\r",
							"      included in the handshake message digest according to spec. */\r",
							"    if(type !== tls.HandshakeType.hello_request &&\r",
							"      type !== tls.HandshakeType.certificate_verify &&\r",
							"      type !== tls.HandshakeType.finished) {\r",
							"      c.session.md5.update(bytes);\r",
							"      c.session.sha1.update(bytes);\r",
							"    }\r",
							"\r",
							"    // handle specific handshake type record\r",
							"    hsTable[c.entity][c.expect][type](c, record, length);\r",
							"  } else {\r",
							"    // unexpected record\r",
							"    tls.handleUnexpected(c, record);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when an ApplicationData record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleApplicationData = function(c, record) {\r",
							"  // buffer data, notify that its ready\r",
							"  c.data.putBuffer(record.fragment);\r",
							"  c.dataReady(c);\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * Called when a Heartbeat record is received.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record.\r",
							" */\r",
							"tls.handleHeartbeat = function(c, record) {\r",
							"  // get the heartbeat type and payload\r",
							"  var b = record.fragment;\r",
							"  var type = b.getByte();\r",
							"  var length = b.getInt16();\r",
							"  var payload = b.getBytes(length);\r",
							"\r",
							"  if(type === tls.HeartbeatMessageType.heartbeat_request) {\r",
							"    // discard request during handshake or if length is too large\r",
							"    if(c.handshaking || length > payload.length) {\r",
							"      // continue\r",
							"      return c.process();\r",
							"    }\r",
							"    // retransmit payload\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.heartbeat,\r",
							"      data: tls.createHeartbeat(\r",
							"        tls.HeartbeatMessageType.heartbeat_response, payload)\r",
							"    }));\r",
							"    tls.flush(c);\r",
							"  } else if(type === tls.HeartbeatMessageType.heartbeat_response) {\r",
							"    // check payload against expected payload, discard heartbeat if no match\r",
							"    if(payload !== c.expectedHeartbeatPayload) {\r",
							"      // continue\r",
							"      return c.process();\r",
							"    }\r",
							"\r",
							"    // notify that a valid heartbeat was received\r",
							"    if(c.heartbeatReceived) {\r",
							"      c.heartbeatReceived(c, forge.util.createBuffer(payload));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // continue\r",
							"  c.process();\r",
							"};\r",
							"\r",
							"/**\r",
							" * The transistional state tables for receiving TLS records. It maps the\r",
							" * current TLS engine state and a received record to a function to handle the\r",
							" * record and update the state.\r",
							" *\r",
							" * For instance, if the current state is SHE, then the TLS engine is expecting\r",
							" * a ServerHello record. Once a record is received, the handler function is\r",
							" * looked up using the state SHE and the record's content type.\r",
							" *\r",
							" * The resulting function will either be an error handler or a record handler.\r",
							" * The function will take whatever action is appropriate and update the state\r",
							" * for the next record.\r",
							" *\r",
							" * The states are all based on possible server record types. Note that the\r",
							" * client will never specifically expect to receive a HelloRequest or an alert\r",
							" * from the server so there is no state that reflects this. These messages may\r",
							" * occur at any time.\r",
							" *\r",
							" * There are two tables for mapping states because there is a second tier of\r",
							" * types for handshake messages. Once a record with a content type of handshake\r",
							" * is received, the handshake record handler will look up the handshake type in\r",
							" * the secondary map to get its appropriate handler.\r",
							" *\r",
							" * Valid message orders are as follows:\r",
							" *\r",
							" * =======================FULL HANDSHAKE======================\r",
							" * Client                                               Server\r",
							" *\r",
							" * ClientHello                  -------->\r",
							" *                                                 ServerHello\r",
							" *                                                Certificate*\r",
							" *                                          ServerKeyExchange*\r",
							" *                                         CertificateRequest*\r",
							" *                              <--------      ServerHelloDone\r",
							" * Certificate*\r",
							" * ClientKeyExchange\r",
							" * CertificateVerify*\r",
							" * [ChangeCipherSpec]\r",
							" * Finished                     -------->\r",
							" *                                          [ChangeCipherSpec]\r",
							" *                              <--------             Finished\r",
							" * Application Data             <------->     Application Data\r",
							" *\r",
							" * =====================SESSION RESUMPTION=====================\r",
							" * Client                                                Server\r",
							" *\r",
							" * ClientHello                   -------->\r",
							" *                                                  ServerHello\r",
							" *                                           [ChangeCipherSpec]\r",
							" *                               <--------             Finished\r",
							" * [ChangeCipherSpec]\r",
							" * Finished                      -------->\r",
							" * Application Data              <------->     Application Data\r",
							" */\r",
							"// client expect states (indicate which records are expected to be received)\r",
							"var SHE = 0; // rcv server hello\r",
							"var SCE = 1; // rcv server certificate\r",
							"var SKE = 2; // rcv server key exchange\r",
							"var SCR = 3; // rcv certificate request\r",
							"var SHD = 4; // rcv server hello done\r",
							"var SCC = 5; // rcv change cipher spec\r",
							"var SFI = 6; // rcv finished\r",
							"var SAD = 7; // rcv application data\r",
							"var SER = 8; // not expecting any messages at this point\r",
							"\r",
							"// server expect states\r",
							"var CHE = 0; // rcv client hello\r",
							"var CCE = 1; // rcv client certificate\r",
							"var CKE = 2; // rcv client key exchange\r",
							"var CCV = 3; // rcv certificate verify\r",
							"var CCC = 4; // rcv change cipher spec\r",
							"var CFI = 5; // rcv finished\r",
							"var CAD = 6; // rcv application data\r",
							"var CER = 7; // not expecting any messages at this point\r",
							"\r",
							"// map client current expect state and content type to function\r",
							"var __ = tls.handleUnexpected;\r",
							"var R0 = tls.handleChangeCipherSpec;\r",
							"var R1 = tls.handleAlert;\r",
							"var R2 = tls.handleHandshake;\r",
							"var R3 = tls.handleApplicationData;\r",
							"var R4 = tls.handleHeartbeat;\r",
							"var ctTable = [];\r",
							"ctTable[tls.ConnectionEnd.client] = [\r",
							"//      CC,AL,HS,AD,HB\r",
							"/*SHE*/[__,R1,R2,__,R4],\r",
							"/*SCE*/[__,R1,R2,__,R4],\r",
							"/*SKE*/[__,R1,R2,__,R4],\r",
							"/*SCR*/[__,R1,R2,__,R4],\r",
							"/*SHD*/[__,R1,R2,__,R4],\r",
							"/*SCC*/[R0,R1,__,__,R4],\r",
							"/*SFI*/[__,R1,R2,__,R4],\r",
							"/*SAD*/[__,R1,R2,R3,R4],\r",
							"/*SER*/[__,R1,R2,__,R4]\r",
							"];\r",
							"\r",
							"// map server current expect state and content type to function\r",
							"ctTable[tls.ConnectionEnd.server] = [\r",
							"//      CC,AL,HS,AD\r",
							"/*CHE*/[__,R1,R2,__,R4],\r",
							"/*CCE*/[__,R1,R2,__,R4],\r",
							"/*CKE*/[__,R1,R2,__,R4],\r",
							"/*CCV*/[__,R1,R2,__,R4],\r",
							"/*CCC*/[R0,R1,__,__,R4],\r",
							"/*CFI*/[__,R1,R2,__,R4],\r",
							"/*CAD*/[__,R1,R2,R3,R4],\r",
							"/*CER*/[__,R1,R2,__,R4]\r",
							"];\r",
							"\r",
							"// map client current expect state and handshake type to function\r",
							"var H0 = tls.handleHelloRequest;\r",
							"var H1 = tls.handleServerHello;\r",
							"var H2 = tls.handleCertificate;\r",
							"var H3 = tls.handleServerKeyExchange;\r",
							"var H4 = tls.handleCertificateRequest;\r",
							"var H5 = tls.handleServerHelloDone;\r",
							"var H6 = tls.handleFinished;\r",
							"var hsTable = [];\r",
							"hsTable[tls.ConnectionEnd.client] = [\r",
							"//      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI\r",
							"/*SHE*/[__,__,H1,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*SCE*/[H0,__,__,__,__,__,__,__,__,__,__,H2,H3,H4,H5,__,__,__,__,__,__],\r",
							"/*SKE*/[H0,__,__,__,__,__,__,__,__,__,__,__,H3,H4,H5,__,__,__,__,__,__],\r",
							"/*SCR*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,H4,H5,__,__,__,__,__,__],\r",
							"/*SHD*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,H5,__,__,__,__,__,__],\r",
							"/*SCC*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*SFI*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H6],\r",
							"/*SAD*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*SER*/[H0,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__]\r",
							"];\r",
							"\r",
							"// map server current expect state and handshake type to function\r",
							"// Note: CAD[CH] does not map to FB because renegotation is prohibited\r",
							"var H7 = tls.handleClientHello;\r",
							"var H8 = tls.handleClientKeyExchange;\r",
							"var H9 = tls.handleCertificateVerify;\r",
							"hsTable[tls.ConnectionEnd.server] = [\r",
							"//      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI\r",
							"/*CHE*/[__,H7,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*CCE*/[__,__,__,__,__,__,__,__,__,__,__,H2,__,__,__,__,__,__,__,__,__],\r",
							"/*CKE*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H8,__,__,__,__],\r",
							"/*CCV*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H9,__,__,__,__,__],\r",
							"/*CCC*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*CFI*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,H6],\r",
							"/*CAD*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__],\r",
							"/*CER*/[__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__]\r",
							"];\r",
							"\r",
							"/**\r",
							" * Generates the master_secret and keys using the given security parameters.\r",
							" *\r",
							" * The security parameters for a TLS connection state are defined as such:\r",
							" *\r",
							" * struct {\r",
							" *   ConnectionEnd          entity;\r",
							" *   PRFAlgorithm           prf_algorithm;\r",
							" *   BulkCipherAlgorithm    bulk_cipher_algorithm;\r",
							" *   CipherType             cipher_type;\r",
							" *   uint8                  enc_key_length;\r",
							" *   uint8                  block_length;\r",
							" *   uint8                  fixed_iv_length;\r",
							" *   uint8                  record_iv_length;\r",
							" *   MACAlgorithm           mac_algorithm;\r",
							" *   uint8                  mac_length;\r",
							" *   uint8                  mac_key_length;\r",
							" *   CompressionMethod      compression_algorithm;\r",
							" *   opaque                 master_secret[48];\r",
							" *   opaque                 client_random[32];\r",
							" *   opaque                 server_random[32];\r",
							" * } SecurityParameters;\r",
							" *\r",
							" * Note that this definition is from TLS 1.2. In TLS 1.0 some of these\r",
							" * parameters are ignored because, for instance, the PRFAlgorithm is a\r",
							" * builtin-fixed algorithm combining iterations of MD5 and SHA-1 in TLS 1.0.\r",
							" *\r",
							" * The Record Protocol requires an algorithm to generate keys required by the\r",
							" * current connection state.\r",
							" *\r",
							" * The master secret is expanded into a sequence of secure bytes, which is then\r",
							" * split to a client write MAC key, a server write MAC key, a client write\r",
							" * encryption key, and a server write encryption key. In TLS 1.0 a client write\r",
							" * IV and server write IV are also generated. Each of these is generated from\r",
							" * the byte sequence in that order. Unused values are empty. In TLS 1.2, some\r",
							" * AEAD ciphers may additionally require a client write IV and a server write\r",
							" * IV (see Section 6.2.3.3).\r",
							" *\r",
							" * When keys, MAC keys, and IVs are generated, the master secret is used as an\r",
							" * entropy source.\r",
							" *\r",
							" * To generate the key material, compute:\r",
							" *\r",
							" * master_secret = PRF(pre_master_secret, \"master secret\",\r",
							" *                     ClientHello.random + ServerHello.random)\r",
							" *\r",
							" * key_block = PRF(SecurityParameters.master_secret,\r",
							" *                 \"key expansion\",\r",
							" *                 SecurityParameters.server_random +\r",
							" *                 SecurityParameters.client_random);\r",
							" *\r",
							" * until enough output has been generated. Then, the key_block is\r",
							" * partitioned as follows:\r",
							" *\r",
							" * client_write_MAC_key[SecurityParameters.mac_key_length]\r",
							" * server_write_MAC_key[SecurityParameters.mac_key_length]\r",
							" * client_write_key[SecurityParameters.enc_key_length]\r",
							" * server_write_key[SecurityParameters.enc_key_length]\r",
							" * client_write_IV[SecurityParameters.fixed_iv_length]\r",
							" * server_write_IV[SecurityParameters.fixed_iv_length]\r",
							" *\r",
							" * In TLS 1.2, the client_write_IV and server_write_IV are only generated for\r",
							" * implicit nonce techniques as described in Section 3.2.1 of [AEAD]. This\r",
							" * implementation uses TLS 1.0 so IVs are generated.\r",
							" *\r",
							" * Implementation note: The currently defined cipher suite which requires the\r",
							" * most material is AES_256_CBC_SHA256. It requires 2 x 32 byte keys and 2 x 32\r",
							" * byte MAC keys, for a total 128 bytes of key material. In TLS 1.0 it also\r",
							" * requires 2 x 16 byte IVs, so it actually takes 160 bytes of key material.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param sp the security parameters to use.\r",
							" *\r",
							" * @return the security keys.\r",
							" */\r",
							"tls.generateKeys = function(c, sp) {\r",
							"  // TLS_RSA_WITH_AES_128_CBC_SHA (required to be compliant with TLS 1.2) &\r",
							"  // TLS_RSA_WITH_AES_256_CBC_SHA are the only cipher suites implemented\r",
							"  // at present\r",
							"\r",
							"  // TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA is required to be compliant with\r",
							"  // TLS 1.0 but we don't care right now because AES is better and we have\r",
							"  // an implementation for it\r",
							"\r",
							"  // TODO: TLS 1.2 implementation\r",
							"  /*\r",
							"  // determine the PRF\r",
							"  var prf;\r",
							"  switch(sp.prf_algorithm) {\r",
							"  case tls.PRFAlgorithm.tls_prf_sha256:\r",
							"    prf = prf_sha256;\r",
							"    break;\r",
							"  default:\r",
							"    // should never happen\r",
							"    throw new Error('Invalid PRF');\r",
							"  }\r",
							"  */\r",
							"\r",
							"  // TLS 1.0/1.1 implementation\r",
							"  var prf = prf_TLS1;\r",
							"\r",
							"  // concatenate server and client random\r",
							"  var random = sp.client_random + sp.server_random;\r",
							"\r",
							"  // only create master secret if session is new\r",
							"  if(!c.session.resuming) {\r",
							"    // create master secret, clean up pre-master secret\r",
							"    sp.master_secret = prf(\r",
							"      sp.pre_master_secret, 'master secret', random, 48).bytes();\r",
							"    sp.pre_master_secret = null;\r",
							"  }\r",
							"\r",
							"  // generate the amount of key material needed\r",
							"  random = sp.server_random + sp.client_random;\r",
							"  var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;\r",
							"\r",
							"  // include IV for TLS/1.0\r",
							"  var tls10 = (c.version.major === tls.Versions.TLS_1_0.major &&\r",
							"    c.version.minor === tls.Versions.TLS_1_0.minor);\r",
							"  if(tls10) {\r",
							"    length += 2 * sp.fixed_iv_length;\r",
							"  }\r",
							"  var km = prf(sp.master_secret, 'key expansion', random, length);\r",
							"\r",
							"  // split the key material into the MAC and encryption keys\r",
							"  var rval = {\r",
							"    client_write_MAC_key: km.getBytes(sp.mac_key_length),\r",
							"    server_write_MAC_key: km.getBytes(sp.mac_key_length),\r",
							"    client_write_key: km.getBytes(sp.enc_key_length),\r",
							"    server_write_key: km.getBytes(sp.enc_key_length)\r",
							"  };\r",
							"\r",
							"  // include TLS 1.0 IVs\r",
							"  if(tls10) {\r",
							"    rval.client_write_IV = km.getBytes(sp.fixed_iv_length);\r",
							"    rval.server_write_IV = km.getBytes(sp.fixed_iv_length);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new initialized TLS connection state. A connection state has\r",
							" * a read mode and a write mode.\r",
							" *\r",
							" * compression state:\r",
							" *   The current state of the compression algorithm.\r",
							" *\r",
							" * cipher state:\r",
							" *   The current state of the encryption algorithm. This will consist of the\r",
							" *   scheduled key for that connection. For stream ciphers, this will also\r",
							" *   contain whatever state information is necessary to allow the stream to\r",
							" *   continue to encrypt or decrypt data.\r",
							" *\r",
							" * MAC key:\r",
							" *   The MAC key for the connection.\r",
							" *\r",
							" * sequence number:\r",
							" *   Each connection state contains a sequence number, which is maintained\r",
							" *   separately for read and write states. The sequence number MUST be set to\r",
							" *   zero whenever a connection state is made the active state. Sequence\r",
							" *   numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do\r",
							" *   not wrap. If a TLS implementation would need to wrap a sequence number,\r",
							" *   it must renegotiate instead. A sequence number is incremented after each\r",
							" *   record: specifically, the first record transmitted under a particular\r",
							" *   connection state MUST use sequence number 0.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the new initialized TLS connection state.\r",
							" */\r",
							"tls.createConnectionState = function(c) {\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"\r",
							"  var createMode = function() {\r",
							"    var mode = {\r",
							"      // two 32-bit numbers, first is most significant\r",
							"      sequenceNumber: [0, 0],\r",
							"      macKey: null,\r",
							"      macLength: 0,\r",
							"      macFunction: null,\r",
							"      cipherState: null,\r",
							"      cipherFunction: function(record) {return true;},\r",
							"      compressionState: null,\r",
							"      compressFunction: function(record) {return true;},\r",
							"      updateSequenceNumber: function() {\r",
							"        if(mode.sequenceNumber[1] === 0xFFFFFFFF) {\r",
							"          mode.sequenceNumber[1] = 0;\r",
							"          ++mode.sequenceNumber[0];\r",
							"        } else {\r",
							"          ++mode.sequenceNumber[1];\r",
							"        }\r",
							"      }\r",
							"    };\r",
							"    return mode;\r",
							"  };\r",
							"  var state = {\r",
							"    read: createMode(),\r",
							"    write: createMode()\r",
							"  };\r",
							"\r",
							"  // update function in read mode will decrypt then decompress a record\r",
							"  state.read.update = function(c, record) {\r",
							"    if(!state.read.cipherFunction(record, state.read)) {\r",
							"      c.error(c, {\r",
							"        message: 'Could not decrypt record or bad MAC.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          // doesn't matter if decryption failed or MAC was\r",
							"          // invalid, return the same error so as not to reveal\r",
							"          // which one occurred\r",
							"          description: tls.Alert.Description.bad_record_mac\r",
							"        }\r",
							"      });\r",
							"    } else if(!state.read.compressFunction(c, record, state.read)) {\r",
							"      c.error(c, {\r",
							"        message: 'Could not decompress record.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.decompression_failure\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"    return !c.fail;\r",
							"  };\r",
							"\r",
							"  // update function in write mode will compress then encrypt a record\r",
							"  state.write.update = function(c, record) {\r",
							"    if(!state.write.compressFunction(c, record, state.write)) {\r",
							"      // error, but do not send alert since it would require\r",
							"      // compression as well\r",
							"      c.error(c, {\r",
							"        message: 'Could not compress record.',\r",
							"        send: false,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    } else if(!state.write.cipherFunction(record, state.write)) {\r",
							"      // error, but do not send alert since it would require\r",
							"      // encryption as well\r",
							"      c.error(c, {\r",
							"        message: 'Could not encrypt record.',\r",
							"        send: false,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"    return !c.fail;\r",
							"  };\r",
							"\r",
							"  // handle security parameters\r",
							"  if(c.session) {\r",
							"    var sp = c.session.sp;\r",
							"    c.session.cipherSuite.initSecurityParameters(sp);\r",
							"\r",
							"    // generate keys\r",
							"    sp.keys = tls.generateKeys(c, sp);\r",
							"    state.read.macKey = client ?\r",
							"      sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;\r",
							"    state.write.macKey = client ?\r",
							"      sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;\r",
							"\r",
							"    // cipher suite setup\r",
							"    c.session.cipherSuite.initConnectionState(state, c, sp);\r",
							"\r",
							"    // compression setup\r",
							"    switch(sp.compression_algorithm) {\r",
							"    case tls.CompressionMethod.none:\r",
							"      break;\r",
							"    case tls.CompressionMethod.deflate:\r",
							"      state.read.compressFunction = inflate;\r",
							"      state.write.compressFunction = deflate;\r",
							"      break;\r",
							"    default:\r",
							"      throw new Error('Unsupported compression algorithm.');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return state;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a Random structure.\r",
							" *\r",
							" * struct {\r",
							" *   uint32 gmt_unix_time;\r",
							" *   opaque random_bytes[28];\r",
							" * } Random;\r",
							" *\r",
							" * gmt_unix_time:\r",
							" *   The current time and date in standard UNIX 32-bit format (seconds since\r",
							" *   the midnight starting Jan 1, 1970, UTC, ignoring leap seconds) according\r",
							" *   to the sender's internal clock. Clocks are not required to be set\r",
							" *   correctly by the basic TLS protocol; higher-level or application\r",
							" *   protocols may define additional requirements. Note that, for historical\r",
							" *   reasons, the data element is named using GMT, the predecessor of the\r",
							" *   current worldwide time base, UTC.\r",
							" * random_bytes:\r",
							" *   28 bytes generated by a secure random number generator.\r",
							" *\r",
							" * @return the Random structure as a byte array.\r",
							" */\r",
							"tls.createRandom = function() {\r",
							"  // get UTC milliseconds\r",
							"  var d = new Date();\r",
							"  var utc = +d + d.getTimezoneOffset() * 60000;\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putInt32(utc);\r",
							"  rval.putBytes(forge.random.getBytes(28));\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a TLS record with the given type and data.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param options:\r",
							" *   type: the record type.\r",
							" *   data: the plain text data in a byte buffer.\r",
							" *\r",
							" * @return the created record.\r",
							" */\r",
							"tls.createRecord = function(c, options) {\r",
							"  if(!options.data) {\r",
							"    return null;\r",
							"  }\r",
							"  var record = {\r",
							"    type: options.type,\r",
							"    version: {\r",
							"      major: c.version.major,\r",
							"      minor: c.version.minor\r",
							"    },\r",
							"    length: options.data.length(),\r",
							"    fragment: options.data\r",
							"  };\r",
							"  return record;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a TLS alert record.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param alert:\r",
							" *   level: the TLS alert level.\r",
							" *   description: the TLS alert description.\r",
							" *\r",
							" * @return the created alert record.\r",
							" */\r",
							"tls.createAlert = function(c, alert) {\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putByte(alert.level);\r",
							"  b.putByte(alert.description);\r",
							"  return tls.createRecord(c, {\r",
							"    type: tls.ContentType.alert,\r",
							"    data: b\r",
							"  });\r",
							"};\r",
							"\r",
							"/* The structure of a TLS handshake message.\r",
							" *\r",
							" * struct {\r",
							" *    HandshakeType msg_type;    // handshake type\r",
							" *    uint24 length;             // bytes in message\r",
							" *    select(HandshakeType) {\r",
							" *       case hello_request:       HelloRequest;\r",
							" *       case client_hello:        ClientHello;\r",
							" *       case server_hello:        ServerHello;\r",
							" *       case certificate:         Certificate;\r",
							" *       case server_key_exchange: ServerKeyExchange;\r",
							" *       case certificate_request: CertificateRequest;\r",
							" *       case server_hello_done:   ServerHelloDone;\r",
							" *       case certificate_verify:  CertificateVerify;\r",
							" *       case client_key_exchange: ClientKeyExchange;\r",
							" *       case finished:            Finished;\r",
							" *    } body;\r",
							" * } Handshake;\r",
							" */\r",
							"\r",
							"/**\r",
							" * Creates a ClientHello message.\r",
							" *\r",
							" * opaque SessionID<0..32>;\r",
							" * enum { null(0), deflate(1), (255) } CompressionMethod;\r",
							" * uint8 CipherSuite[2];\r",
							" *\r",
							" * struct {\r",
							" *   ProtocolVersion client_version;\r",
							" *   Random random;\r",
							" *   SessionID session_id;\r",
							" *   CipherSuite cipher_suites<2..2^16-2>;\r",
							" *   CompressionMethod compression_methods<1..2^8-1>;\r",
							" *   select(extensions_present) {\r",
							" *     case false:\r",
							" *       struct {};\r",
							" *     case true:\r",
							" *       Extension extensions<0..2^16-1>;\r",
							" *   };\r",
							" * } ClientHello;\r",
							" *\r",
							" * The extension format for extended client hellos and server hellos is:\r",
							" *\r",
							" * struct {\r",
							" *   ExtensionType extension_type;\r",
							" *   opaque extension_data<0..2^16-1>;\r",
							" * } Extension;\r",
							" *\r",
							" * Here:\r",
							" *\r",
							" * - \"extension_type\" identifies the particular extension type.\r",
							" * - \"extension_data\" contains information specific to the particular\r",
							" * extension type.\r",
							" *\r",
							" * The extension types defined in this document are:\r",
							" *\r",
							" * enum {\r",
							" *   server_name(0), max_fragment_length(1),\r",
							" *   client_certificate_url(2), trusted_ca_keys(3),\r",
							" *   truncated_hmac(4), status_request(5), (65535)\r",
							" * } ExtensionType;\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ClientHello byte buffer.\r",
							" */\r",
							"tls.createClientHello = function(c) {\r",
							"  // save hello version\r",
							"  c.session.clientHelloVersion = {\r",
							"    major: c.version.major,\r",
							"    minor: c.version.minor\r",
							"  };\r",
							"\r",
							"  // create supported cipher suites\r",
							"  var cipherSuites = forge.util.createBuffer();\r",
							"  for(var i = 0; i < c.cipherSuites.length; ++i) {\r",
							"    var cs = c.cipherSuites[i];\r",
							"    cipherSuites.putByte(cs.id[0]);\r",
							"    cipherSuites.putByte(cs.id[1]);\r",
							"  }\r",
							"  var cSuites = cipherSuites.length();\r",
							"\r",
							"  // create supported compression methods, null always supported, but\r",
							"  // also support deflate if connection has inflate and deflate methods\r",
							"  var compressionMethods = forge.util.createBuffer();\r",
							"  compressionMethods.putByte(tls.CompressionMethod.none);\r",
							"  // FIXME: deflate support disabled until issues with raw deflate data\r",
							"  // without zlib headers are resolved\r",
							"  /*\r",
							"  if(c.inflate !== null && c.deflate !== null) {\r",
							"    compressionMethods.putByte(tls.CompressionMethod.deflate);\r",
							"  }\r",
							"  */\r",
							"  var cMethods = compressionMethods.length();\r",
							"\r",
							"  // create TLS SNI (server name indication) extension if virtual host\r",
							"  // has been specified, see RFC 3546\r",
							"  var extensions = forge.util.createBuffer();\r",
							"  if(c.virtualHost) {\r",
							"    // create extension struct\r",
							"    var ext = forge.util.createBuffer();\r",
							"    ext.putByte(0x00); // type server_name (ExtensionType is 2 bytes)\r",
							"    ext.putByte(0x00);\r",
							"\r",
							"    /* In order to provide the server name, clients MAY include an\r",
							"     * extension of type \"server_name\" in the (extended) client hello.\r",
							"     * The \"extension_data\" field of this extension SHALL contain\r",
							"     * \"ServerNameList\" where:\r",
							"     *\r",
							"     * struct {\r",
							"     *   NameType name_type;\r",
							"     *   select(name_type) {\r",
							"     *     case host_name: HostName;\r",
							"     *   } name;\r",
							"     * } ServerName;\r",
							"     *\r",
							"     * enum {\r",
							"     *   host_name(0), (255)\r",
							"     * } NameType;\r",
							"     *\r",
							"     * opaque HostName<1..2^16-1>;\r",
							"     *\r",
							"     * struct {\r",
							"     *   ServerName server_name_list<1..2^16-1>\r",
							"     * } ServerNameList;\r",
							"     */\r",
							"    var serverName = forge.util.createBuffer();\r",
							"    serverName.putByte(0x00); // type host_name\r",
							"    writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));\r",
							"\r",
							"    // ServerNameList is in extension_data\r",
							"    var snList = forge.util.createBuffer();\r",
							"    writeVector(snList, 2, serverName);\r",
							"    writeVector(ext, 2, snList);\r",
							"    extensions.putBuffer(ext);\r",
							"  }\r",
							"  var extLength = extensions.length();\r",
							"  if(extLength > 0) {\r",
							"    // add extension vector length\r",
							"    extLength += 2;\r",
							"  }\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  // cipher suites and compression methods size will need to be\r",
							"  // updated if more get added to the list\r",
							"  var sessionId = c.session.id;\r",
							"  var length =\r",
							"    sessionId.length + 1 + // session ID vector\r",
							"    2 +                    // version (major + minor)\r",
							"    4 + 28 +               // random time and random bytes\r",
							"    2 + cSuites +          // cipher suites vector\r",
							"    1 + cMethods +         // compression methods vector\r",
							"    extLength;             // extensions vector\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.client_hello);\r",
							"  rval.putInt24(length);                     // handshake length\r",
							"  rval.putByte(c.version.major);             // major version\r",
							"  rval.putByte(c.version.minor);             // minor version\r",
							"  rval.putBytes(c.session.sp.client_random); // random time + bytes\r",
							"  writeVector(rval, 1, forge.util.createBuffer(sessionId));\r",
							"  writeVector(rval, 2, cipherSuites);\r",
							"  writeVector(rval, 1, compressionMethods);\r",
							"  if(extLength > 0) {\r",
							"    writeVector(rval, 2, extensions);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ServerHello message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ServerHello byte buffer.\r",
							" */\r",
							"tls.createServerHello = function(c) {\r",
							"  // determine length of the handshake message\r",
							"  var sessionId = c.session.id;\r",
							"  var length =\r",
							"    sessionId.length + 1 + // session ID vector\r",
							"    2 +                    // version (major + minor)\r",
							"    4 + 28 +               // random time and random bytes\r",
							"    2 +                    // chosen cipher suite\r",
							"    1;                     // chosen compression method\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.server_hello);\r",
							"  rval.putInt24(length);                     // handshake length\r",
							"  rval.putByte(c.version.major);             // major version\r",
							"  rval.putByte(c.version.minor);             // minor version\r",
							"  rval.putBytes(c.session.sp.server_random); // random time + bytes\r",
							"  writeVector(rval, 1, forge.util.createBuffer(sessionId));\r",
							"  rval.putByte(c.session.cipherSuite.id[0]);\r",
							"  rval.putByte(c.session.cipherSuite.id[1]);\r",
							"  rval.putByte(c.session.compressionMethod);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a Certificate message.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This is the first message the client can send after receiving a server\r",
							" *   hello done message and the first message the server can send after\r",
							" *   sending a ServerHello. This client message is only sent if the server\r",
							" *   requests a certificate. If no suitable certificate is available, the\r",
							" *   client should send a certificate message containing no certificates. If\r",
							" *   client authentication is required by the server for the handshake to\r",
							" *   continue, it may respond with a fatal handshake failure alert.\r",
							" *\r",
							" * opaque ASN.1Cert<1..2^24-1>;\r",
							" *\r",
							" * struct {\r",
							" *   ASN.1Cert certificate_list<0..2^24-1>;\r",
							" * } Certificate;\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the Certificate byte buffer.\r",
							" */\r",
							"tls.createCertificate = function(c) {\r",
							"  // TODO: check certificate request to ensure types are supported\r",
							"\r",
							"  // get a certificate (a certificate as a PEM string)\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var cert = null;\r",
							"  if(c.getCertificate) {\r",
							"    var hint;\r",
							"    if(client) {\r",
							"      hint = c.session.certificateRequest;\r",
							"    } else {\r",
							"      hint = c.session.extensions.server_name.serverNameList;\r",
							"    }\r",
							"    cert = c.getCertificate(c, hint);\r",
							"  }\r",
							"\r",
							"  // buffer to hold certificate list\r",
							"  var certList = forge.util.createBuffer();\r",
							"  if(cert !== null) {\r",
							"    try {\r",
							"      // normalize cert to a chain of certificates\r",
							"      if(!forge.util.isArray(cert)) {\r",
							"        cert = [cert];\r",
							"      }\r",
							"      var asn1 = null;\r",
							"      for(var i = 0; i < cert.length; ++i) {\r",
							"        var msg = forge.pem.decode(cert[i])[0];\r",
							"        if(msg.type !== 'CERTIFICATE' &&\r",
							"          msg.type !== 'X509 CERTIFICATE' &&\r",
							"          msg.type !== 'TRUSTED CERTIFICATE') {\r",
							"          var error = new Error('Could not convert certificate from PEM; PEM ' +\r",
							"            'header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or ' +\r",
							"            '\"TRUSTED CERTIFICATE\".');\r",
							"          error.headerType = msg.type;\r",
							"          throw error;\r",
							"        }\r",
							"        if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"          throw new Error('Could not convert certificate from PEM; PEM is encrypted.');\r",
							"        }\r",
							"\r",
							"        var der = forge.util.createBuffer(msg.body);\r",
							"        if(asn1 === null) {\r",
							"          asn1 = forge.asn1.fromDer(der.bytes(), false);\r",
							"        }\r",
							"\r",
							"        // certificate entry is itself a vector with 3 length bytes\r",
							"        var certBuffer = forge.util.createBuffer();\r",
							"        writeVector(certBuffer, 3, der);\r",
							"\r",
							"        // add cert vector to cert list vector\r",
							"        certList.putBuffer(certBuffer);\r",
							"      }\r",
							"\r",
							"      // save certificate\r",
							"      cert = forge.pki.certificateFromAsn1(asn1);\r",
							"      if(client) {\r",
							"        c.session.clientCertificate = cert;\r",
							"      } else {\r",
							"        c.session.serverCertificate = cert;\r",
							"      }\r",
							"    } catch(ex) {\r",
							"      return c.error(c, {\r",
							"        message: 'Could not send certificate list.',\r",
							"        cause: ex,\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.bad_certificate\r",
							"        }\r",
							"      });\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = 3 + certList.length(); // cert list vector\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.certificate);\r",
							"  rval.putInt24(length);\r",
							"  writeVector(rval, 3, certList);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ClientKeyExchange message.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This message is always sent by the client. It will immediately follow the\r",
							" *   client certificate message, if it is sent. Otherwise it will be the first\r",
							" *   message sent by the client after it receives the server hello done\r",
							" *   message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   With this message, the premaster secret is set, either though direct\r",
							" *   transmission of the RSA-encrypted secret, or by the transmission of\r",
							" *   Diffie-Hellman parameters which will allow each side to agree upon the\r",
							" *   same premaster secret. When the key exchange method is DH_RSA or DH_DSS,\r",
							" *   client certification has been requested, and the client was able to\r",
							" *   respond with a certificate which contained a Diffie-Hellman public key\r",
							" *   whose parameters (group and generator) matched those specified by the\r",
							" *   server in its certificate, this message will not contain any data.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   If RSA is being used for key agreement and authentication, the client\r",
							" *   generates a 48-byte premaster secret, encrypts it using the public key\r",
							" *   from the server's certificate or the temporary RSA key provided in a\r",
							" *   server key exchange message, and sends the result in an encrypted\r",
							" *   premaster secret message. This structure is a variant of the client\r",
							" *   key exchange message, not a message in itself.\r",
							" *\r",
							" * struct {\r",
							" *   select(KeyExchangeAlgorithm) {\r",
							" *     case rsa: EncryptedPreMasterSecret;\r",
							" *     case diffie_hellman: ClientDiffieHellmanPublic;\r",
							" *   } exchange_keys;\r",
							" * } ClientKeyExchange;\r",
							" *\r",
							" * struct {\r",
							" *   ProtocolVersion client_version;\r",
							" *   opaque random[46];\r",
							" * } PreMasterSecret;\r",
							" *\r",
							" * struct {\r",
							" *   public-key-encrypted PreMasterSecret pre_master_secret;\r",
							" * } EncryptedPreMasterSecret;\r",
							" *\r",
							" * A public-key-encrypted element is encoded as a vector <0..2^16-1>.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ClientKeyExchange byte buffer.\r",
							" */\r",
							"tls.createClientKeyExchange = function(c) {\r",
							"  // create buffer to encrypt\r",
							"  var b = forge.util.createBuffer();\r",
							"\r",
							"  // add highest client-supported protocol to help server avoid version\r",
							"  // rollback attacks\r",
							"  b.putByte(c.session.clientHelloVersion.major);\r",
							"  b.putByte(c.session.clientHelloVersion.minor);\r",
							"\r",
							"  // generate and add 46 random bytes\r",
							"  b.putBytes(forge.random.getBytes(46));\r",
							"\r",
							"  // save pre-master secret\r",
							"  var sp = c.session.sp;\r",
							"  sp.pre_master_secret = b.getBytes();\r",
							"\r",
							"  // RSA-encrypt the pre-master secret\r",
							"  var key = c.session.serverCertificate.publicKey;\r",
							"  b = key.encrypt(sp.pre_master_secret);\r",
							"\r",
							"  /* Note: The encrypted pre-master secret will be stored in a\r",
							"    public-key-encrypted opaque vector that has the length prefixed using\r",
							"    2 bytes, so include those 2 bytes in the handshake message length. This\r",
							"    is done as a minor optimization instead of calling writeVector(). */\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = b.length + 2;\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.client_key_exchange);\r",
							"  rval.putInt24(length);\r",
							"  // add vector length bytes\r",
							"  rval.putInt16(b.length);\r",
							"  rval.putBytes(b);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ServerKeyExchange message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ServerKeyExchange byte buffer.\r",
							" */\r",
							"tls.createServerKeyExchange = function(c) {\r",
							"  // this implementation only supports RSA, no Diffie-Hellman support,\r",
							"  // so this record is empty\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = 0;\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  if(length > 0) {\r",
							"    rval.putByte(tls.HandshakeType.server_key_exchange);\r",
							"    rval.putInt24(length);\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the signed data used to verify a client-side certificate. See\r",
							" * tls.createCertificateVerify() for details.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param callback the callback to call once the signed data is ready.\r",
							" */\r",
							"tls.getClientSignature = function(c, callback) {\r",
							"  // generate data to RSA encrypt\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putBuffer(c.session.md5.digest());\r",
							"  b.putBuffer(c.session.sha1.digest());\r",
							"  b = b.getBytes();\r",
							"\r",
							"  // create default signing function as necessary\r",
							"  c.getSignature = c.getSignature || function(c, b, callback) {\r",
							"    // do rsa encryption, call callback\r",
							"    var privateKey = null;\r",
							"    if(c.getPrivateKey) {\r",
							"      try {\r",
							"        privateKey = c.getPrivateKey(c, c.session.clientCertificate);\r",
							"        privateKey = forge.pki.privateKeyFromPem(privateKey);\r",
							"      } catch(ex) {\r",
							"        c.error(c, {\r",
							"          message: 'Could not get private key.',\r",
							"          cause: ex,\r",
							"          send: true,\r",
							"          alert: {\r",
							"            level: tls.Alert.Level.fatal,\r",
							"            description: tls.Alert.Description.internal_error\r",
							"          }\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"    if(privateKey === null) {\r",
							"      c.error(c, {\r",
							"        message: 'No private key set.',\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: tls.Alert.Description.internal_error\r",
							"        }\r",
							"      });\r",
							"    } else {\r",
							"      b = privateKey.sign(b, null);\r",
							"    }\r",
							"    callback(c, b);\r",
							"  };\r",
							"\r",
							"  // get client signature\r",
							"  c.getSignature(c, b, callback);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a CertificateVerify message.\r",
							" *\r",
							" * Meaning of this message:\r",
							" *   This structure conveys the client's Diffie-Hellman public value\r",
							" *   (Yc) if it was not already included in the client's certificate.\r",
							" *   The encoding used for Yc is determined by the enumerated\r",
							" *   PublicValueEncoding. This structure is a variant of the client\r",
							" *   key exchange message, not a message in itself.\r",
							" *\r",
							" * When this message will be sent:\r",
							" *   This message is used to provide explicit verification of a client\r",
							" *   certificate. This message is only sent following a client\r",
							" *   certificate that has signing capability (i.e. all certificates\r",
							" *   except those containing fixed Diffie-Hellman parameters). When\r",
							" *   sent, it will immediately follow the client key exchange message.\r",
							" *\r",
							" * struct {\r",
							" *   Signature signature;\r",
							" * } CertificateVerify;\r",
							" *\r",
							" * CertificateVerify.signature.md5_hash\r",
							" *   MD5(handshake_messages);\r",
							" *\r",
							" * Certificate.signature.sha_hash\r",
							" *   SHA(handshake_messages);\r",
							" *\r",
							" * Here handshake_messages refers to all handshake messages sent or\r",
							" * received starting at client hello up to but not including this\r",
							" * message, including the type and length fields of the handshake\r",
							" * messages.\r",
							" *\r",
							" * select(SignatureAlgorithm) {\r",
							" *   case anonymous: struct { };\r",
							" *   case rsa:\r",
							" *     digitally-signed struct {\r",
							" *       opaque md5_hash[16];\r",
							" *       opaque sha_hash[20];\r",
							" *     };\r",
							" *   case dsa:\r",
							" *     digitally-signed struct {\r",
							" *       opaque sha_hash[20];\r",
							" *     };\r",
							" * } Signature;\r",
							" *\r",
							" * In digital signing, one-way hash functions are used as input for a\r",
							" * signing algorithm. A digitally-signed element is encoded as an opaque\r",
							" * vector <0..2^16-1>, where the length is specified by the signing\r",
							" * algorithm and key.\r",
							" *\r",
							" * In RSA signing, a 36-byte structure of two hashes (one SHA and one\r",
							" * MD5) is signed (encrypted with the private key). It is encoded with\r",
							" * PKCS #1 block type 0 or type 1 as described in [PKCS1].\r",
							" *\r",
							" * In DSS, the 20 bytes of the SHA hash are run directly through the\r",
							" * Digital Signing Algorithm with no additional hashing.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param signature the signature to include in the message.\r",
							" *\r",
							" * @return the CertificateVerify byte buffer.\r",
							" */\r",
							"tls.createCertificateVerify = function(c, signature) {\r",
							"  /* Note: The signature will be stored in a \"digitally-signed\" opaque\r",
							"    vector that has the length prefixed using 2 bytes, so include those\r",
							"    2 bytes in the handshake message length. This is done as a minor\r",
							"    optimization instead of calling writeVector(). */\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length = signature.length + 2;\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.certificate_verify);\r",
							"  rval.putInt24(length);\r",
							"  // add vector length bytes\r",
							"  rval.putInt16(signature.length);\r",
							"  rval.putBytes(signature);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a CertificateRequest message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the CertificateRequest byte buffer.\r",
							" */\r",
							"tls.createCertificateRequest = function(c) {\r",
							"  // TODO: support other certificate types\r",
							"  var certTypes = forge.util.createBuffer();\r",
							"\r",
							"  // common RSA certificate type\r",
							"  certTypes.putByte(0x01);\r",
							"\r",
							"  // add distinguished names from CA store\r",
							"  var cAs = forge.util.createBuffer();\r",
							"  for(var key in c.caStore.certs) {\r",
							"    var cert = c.caStore.certs[key];\r",
							"    var dn = forge.pki.distinguishedNameToAsn1(cert.subject);\r",
							"    var byteBuffer = forge.asn1.toDer(dn);\r",
							"    cAs.putInt16(byteBuffer.length());\r",
							"    cAs.putBuffer(byteBuffer);\r",
							"  }\r",
							"\r",
							"  // TODO: TLS 1.2+ has a different format\r",
							"\r",
							"  // determine length of the handshake message\r",
							"  var length =\r",
							"    1 + certTypes.length() +\r",
							"    2 + cAs.length();\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.certificate_request);\r",
							"  rval.putInt24(length);\r",
							"  writeVector(rval, 1, certTypes);\r",
							"  writeVector(rval, 2, cAs);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ServerHelloDone message.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the ServerHelloDone byte buffer.\r",
							" */\r",
							"tls.createServerHelloDone = function(c) {\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.server_hello_done);\r",
							"  rval.putInt24(0);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a ChangeCipherSpec message.\r",
							" *\r",
							" * The change cipher spec protocol exists to signal transitions in\r",
							" * ciphering strategies. The protocol consists of a single message,\r",
							" * which is encrypted and compressed under the current (not the pending)\r",
							" * connection state. The message consists of a single byte of value 1.\r",
							" *\r",
							" * struct {\r",
							" *   enum { change_cipher_spec(1), (255) } type;\r",
							" * } ChangeCipherSpec;\r",
							" *\r",
							" * @return the ChangeCipherSpec byte buffer.\r",
							" */\r",
							"tls.createChangeCipherSpec = function() {\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(0x01);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a Finished message.\r",
							" *\r",
							" * struct {\r",
							" *   opaque verify_data[12];\r",
							" * } Finished;\r",
							" *\r",
							" * verify_data\r",
							" *   PRF(master_secret, finished_label, MD5(handshake_messages) +\r",
							" *   SHA-1(handshake_messages)) [0..11];\r",
							" *\r",
							" * finished_label\r",
							" *   For Finished messages sent by the client, the string \"client\r",
							" *   finished\". For Finished messages sent by the server, the\r",
							" *   string \"server finished\".\r",
							" *\r",
							" * handshake_messages\r",
							" *   All of the data from all handshake messages up to but not\r",
							" *   including this message. This is only data visible at the\r",
							" *   handshake layer and does not include record layer headers.\r",
							" *   This is the concatenation of all the Handshake structures as\r",
							" *   defined in 7.4 exchanged thus far.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return the Finished byte buffer.\r",
							" */\r",
							"tls.createFinished = function(c) {\r",
							"  // generate verify_data\r",
							"  var b = forge.util.createBuffer();\r",
							"  b.putBuffer(c.session.md5.digest());\r",
							"  b.putBuffer(c.session.sha1.digest());\r",
							"\r",
							"  // TODO: determine prf function and verify length for TLS 1.2\r",
							"  var client = (c.entity === tls.ConnectionEnd.client);\r",
							"  var sp = c.session.sp;\r",
							"  var vdl = 12;\r",
							"  var prf = prf_TLS1;\r",
							"  var label = client ? 'client finished' : 'server finished';\r",
							"  b = prf(sp.master_secret, label, b.getBytes(), vdl);\r",
							"\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(tls.HandshakeType.finished);\r",
							"  rval.putInt24(b.length());\r",
							"  rval.putBuffer(b);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a HeartbeatMessage (See RFC 6520).\r",
							" *\r",
							" * struct {\r",
							" *   HeartbeatMessageType type;\r",
							" *   uint16 payload_length;\r",
							" *   opaque payload[HeartbeatMessage.payload_length];\r",
							" *   opaque padding[padding_length];\r",
							" * } HeartbeatMessage;\r",
							" *\r",
							" * The total length of a HeartbeatMessage MUST NOT exceed 2^14 or\r",
							" * max_fragment_length when negotiated as defined in [RFC6066].\r",
							" *\r",
							" * type: The message type, either heartbeat_request or heartbeat_response.\r",
							" *\r",
							" * payload_length: The length of the payload.\r",
							" *\r",
							" * payload: The payload consists of arbitrary content.\r",
							" *\r",
							" * padding: The padding is random content that MUST be ignored by the\r",
							" *   receiver. The length of a HeartbeatMessage is TLSPlaintext.length\r",
							" *   for TLS and DTLSPlaintext.length for DTLS. Furthermore, the\r",
							" *   length of the type field is 1 byte, and the length of the\r",
							" *   payload_length is 2. Therefore, the padding_length is\r",
							" *   TLSPlaintext.length - payload_length - 3 for TLS and\r",
							" *   DTLSPlaintext.length - payload_length - 3 for DTLS. The\r",
							" *   padding_length MUST be at least 16.\r",
							" *\r",
							" * The sender of a HeartbeatMessage MUST use a random padding of at\r",
							" * least 16 bytes. The padding of a received HeartbeatMessage message\r",
							" * MUST be ignored.\r",
							" *\r",
							" * If the payload_length of a received HeartbeatMessage is too large,\r",
							" * the received HeartbeatMessage MUST be discarded silently.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param type the tls.HeartbeatMessageType.\r",
							" * @param payload the heartbeat data to send as the payload.\r",
							" * @param [payloadLength] the payload length to use, defaults to the\r",
							" *          actual payload length.\r",
							" *\r",
							" * @return the HeartbeatRequest byte buffer.\r",
							" */\r",
							"tls.createHeartbeat = function(type, payload, payloadLength) {\r",
							"  if(typeof payloadLength === 'undefined') {\r",
							"    payloadLength = payload.length;\r",
							"  }\r",
							"  // build record fragment\r",
							"  var rval = forge.util.createBuffer();\r",
							"  rval.putByte(type);               // heartbeat message type\r",
							"  rval.putInt16(payloadLength);     // payload length\r",
							"  rval.putBytes(payload);           // payload\r",
							"  // padding\r",
							"  var plaintextLength = rval.length();\r",
							"  var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);\r",
							"  rval.putBytes(forge.random.getBytes(paddingLength));\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Fragments, compresses, encrypts, and queues a record for delivery.\r",
							" *\r",
							" * @param c the connection.\r",
							" * @param record the record to queue.\r",
							" */\r",
							"tls.queue = function(c, record) {\r",
							"  // error during record creation\r",
							"  if(!record) {\r",
							"    return;\r",
							"  }\r",
							"\r",
							"  if(record.fragment.length() === 0) {\r",
							"    if(record.type === tls.ContentType.handshake ||\r",
							"      record.type === tls.ContentType.alert ||\r",
							"      record.type === tls.ContentType.change_cipher_spec) {\r",
							"      // Empty handshake, alert of change cipher spec messages are not allowed per the TLS specification and should not be sent.\r",
							"      return;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // if the record is a handshake record, update handshake hashes\r",
							"  if(record.type === tls.ContentType.handshake) {\r",
							"    var bytes = record.fragment.bytes();\r",
							"    c.session.md5.update(bytes);\r",
							"    c.session.sha1.update(bytes);\r",
							"    bytes = null;\r",
							"  }\r",
							"\r",
							"  // handle record fragmentation\r",
							"  var records;\r",
							"  if(record.fragment.length() <= tls.MaxFragment) {\r",
							"    records = [record];\r",
							"  } else {\r",
							"    // fragment data as long as it is too long\r",
							"    records = [];\r",
							"    var data = record.fragment.bytes();\r",
							"    while(data.length > tls.MaxFragment) {\r",
							"      records.push(tls.createRecord(c, {\r",
							"        type: record.type,\r",
							"        data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))\r",
							"      }));\r",
							"      data = data.slice(tls.MaxFragment);\r",
							"    }\r",
							"    // add last record\r",
							"    if(data.length > 0) {\r",
							"      records.push(tls.createRecord(c, {\r",
							"        type: record.type,\r",
							"        data: forge.util.createBuffer(data)\r",
							"      }));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // compress and encrypt all fragmented records\r",
							"  for(var i = 0; i < records.length && !c.fail; ++i) {\r",
							"    // update the record using current write state\r",
							"    var rec = records[i];\r",
							"    var s = c.state.current.write;\r",
							"    if(s.update(c, rec)) {\r",
							"      // store record\r",
							"      c.records.push(rec);\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Flushes all queued records to the output buffer and calls the\r",
							" * tlsDataReady() handler on the given connection.\r",
							" *\r",
							" * @param c the connection.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"tls.flush = function(c) {\r",
							"  for(var i = 0; i < c.records.length; ++i) {\r",
							"    var record = c.records[i];\r",
							"\r",
							"    // add record header and fragment\r",
							"    c.tlsData.putByte(record.type);\r",
							"    c.tlsData.putByte(record.version.major);\r",
							"    c.tlsData.putByte(record.version.minor);\r",
							"    c.tlsData.putInt16(record.fragment.length());\r",
							"    c.tlsData.putBuffer(c.records[i].fragment);\r",
							"  }\r",
							"  c.records = [];\r",
							"  return c.tlsDataReady(c);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Maps a pki.certificateError to a tls.Alert.Description.\r",
							" *\r",
							" * @param error the error to map.\r",
							" *\r",
							" * @return the alert description.\r",
							" */\r",
							"var _certErrorToAlertDesc = function(error) {\r",
							"  switch(error) {\r",
							"  case true:\r",
							"    return true;\r",
							"  case forge.pki.certificateError.bad_certificate:\r",
							"    return tls.Alert.Description.bad_certificate;\r",
							"  case forge.pki.certificateError.unsupported_certificate:\r",
							"    return tls.Alert.Description.unsupported_certificate;\r",
							"  case forge.pki.certificateError.certificate_revoked:\r",
							"    return tls.Alert.Description.certificate_revoked;\r",
							"  case forge.pki.certificateError.certificate_expired:\r",
							"    return tls.Alert.Description.certificate_expired;\r",
							"  case forge.pki.certificateError.certificate_unknown:\r",
							"    return tls.Alert.Description.certificate_unknown;\r",
							"  case forge.pki.certificateError.unknown_ca:\r",
							"    return tls.Alert.Description.unknown_ca;\r",
							"  default:\r",
							"    return tls.Alert.Description.bad_certificate;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Maps a tls.Alert.Description to a pki.certificateError.\r",
							" *\r",
							" * @param desc the alert description.\r",
							" *\r",
							" * @return the certificate error.\r",
							" */\r",
							"var _alertDescToCertError = function(desc) {\r",
							"  switch(desc) {\r",
							"  case true:\r",
							"    return true;\r",
							"  case tls.Alert.Description.bad_certificate:\r",
							"    return forge.pki.certificateError.bad_certificate;\r",
							"  case tls.Alert.Description.unsupported_certificate:\r",
							"    return forge.pki.certificateError.unsupported_certificate;\r",
							"  case tls.Alert.Description.certificate_revoked:\r",
							"    return forge.pki.certificateError.certificate_revoked;\r",
							"  case tls.Alert.Description.certificate_expired:\r",
							"    return forge.pki.certificateError.certificate_expired;\r",
							"  case tls.Alert.Description.certificate_unknown:\r",
							"    return forge.pki.certificateError.certificate_unknown;\r",
							"  case tls.Alert.Description.unknown_ca:\r",
							"    return forge.pki.certificateError.unknown_ca;\r",
							"  default:\r",
							"    return forge.pki.certificateError.bad_certificate;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Verifies a certificate chain against the given connection's\r",
							" * Certificate Authority store.\r",
							" *\r",
							" * @param c the TLS connection.\r",
							" * @param chain the certificate chain to verify, with the root or highest\r",
							" *          authority at the end.\r",
							" *\r",
							" * @return true if successful, false if not.\r",
							" */\r",
							"tls.verifyCertificateChain = function(c, chain) {\r",
							"  try {\r",
							"    // verify chain\r",
							"    forge.pki.verifyCertificateChain(c.caStore, chain,\r",
							"      function verify(vfd, depth, chain) {\r",
							"        // convert pki.certificateError to tls alert description\r",
							"        var desc = _certErrorToAlertDesc(vfd);\r",
							"\r",
							"        // call application callback\r",
							"        var ret = c.verify(c, vfd, depth, chain);\r",
							"        if(ret !== true) {\r",
							"          if(typeof ret === 'object' && !forge.util.isArray(ret)) {\r",
							"            // throw custom error\r",
							"            var error = new Error('The application rejected the certificate.');\r",
							"            error.send = true;\r",
							"            error.alert = {\r",
							"              level: tls.Alert.Level.fatal,\r",
							"              description: tls.Alert.Description.bad_certificate\r",
							"            };\r",
							"            if(ret.message) {\r",
							"              error.message = ret.message;\r",
							"            }\r",
							"            if(ret.alert) {\r",
							"              error.alert.description = ret.alert;\r",
							"            }\r",
							"            throw error;\r",
							"          }\r",
							"\r",
							"          // convert tls alert description to pki.certificateError\r",
							"          if(ret !== vfd) {\r",
							"            ret = _alertDescToCertError(ret);\r",
							"          }\r",
							"        }\r",
							"\r",
							"        return ret;\r",
							"      });\r",
							"  } catch(ex) {\r",
							"    // build tls error if not already customized\r",
							"    var err = ex;\r",
							"    if(typeof err !== 'object' || forge.util.isArray(err)) {\r",
							"      err = {\r",
							"        send: true,\r",
							"        alert: {\r",
							"          level: tls.Alert.Level.fatal,\r",
							"          description: _certErrorToAlertDesc(ex)\r",
							"        }\r",
							"      };\r",
							"    }\r",
							"    if(!('send' in err)) {\r",
							"      err.send = true;\r",
							"    }\r",
							"    if(!('alert' in err)) {\r",
							"      err.alert = {\r",
							"        level: tls.Alert.Level.fatal,\r",
							"        description: _certErrorToAlertDesc(err.error)\r",
							"      };\r",
							"    }\r",
							"\r",
							"    // send error\r",
							"    c.error(c, err);\r",
							"  }\r",
							"\r",
							"  return !c.fail;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new TLS session cache.\r",
							" *\r",
							" * @param cache optional map of session ID to cached session.\r",
							" * @param capacity the maximum size for the cache (default: 100).\r",
							" *\r",
							" * @return the new TLS session cache.\r",
							" */\r",
							"tls.createSessionCache = function(cache, capacity) {\r",
							"  var rval = null;\r",
							"\r",
							"  // assume input is already a session cache object\r",
							"  if(cache && cache.getSession && cache.setSession && cache.order) {\r",
							"    rval = cache;\r",
							"  } else {\r",
							"    // create cache\r",
							"    rval = {};\r",
							"    rval.cache = cache || {};\r",
							"    rval.capacity = Math.max(capacity || 100, 1);\r",
							"    rval.order = [];\r",
							"\r",
							"    // store order for sessions, delete session overflow\r",
							"    for(var key in cache) {\r",
							"      if(rval.order.length <= capacity) {\r",
							"        rval.order.push(key);\r",
							"      } else {\r",
							"        delete cache[key];\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // get a session from a session ID (or get any session)\r",
							"    rval.getSession = function(sessionId) {\r",
							"      var session = null;\r",
							"      var key = null;\r",
							"\r",
							"      // if session ID provided, use it\r",
							"      if(sessionId) {\r",
							"        key = forge.util.bytesToHex(sessionId);\r",
							"      } else if(rval.order.length > 0) {\r",
							"        // get first session from cache\r",
							"        key = rval.order[0];\r",
							"      }\r",
							"\r",
							"      if(key !== null && key in rval.cache) {\r",
							"        // get cached session and remove from cache\r",
							"        session = rval.cache[key];\r",
							"        delete rval.cache[key];\r",
							"        for(var i in rval.order) {\r",
							"          if(rval.order[i] === key) {\r",
							"            rval.order.splice(i, 1);\r",
							"            break;\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"\r",
							"      return session;\r",
							"    };\r",
							"\r",
							"    // set a session in the cache\r",
							"    rval.setSession = function(sessionId, session) {\r",
							"      // remove session from cache if at capacity\r",
							"      if(rval.order.length === rval.capacity) {\r",
							"        var key = rval.order.shift();\r",
							"        delete rval.cache[key];\r",
							"      }\r",
							"      // add session to cache\r",
							"      var key = forge.util.bytesToHex(sessionId);\r",
							"      rval.order.push(key);\r",
							"      rval.cache[key] = session;\r",
							"    };\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a new TLS connection.\r",
							" *\r",
							" * See public createConnection() docs for more details.\r",
							" *\r",
							" * @param options the options for this connection.\r",
							" *\r",
							" * @return the new TLS connection.\r",
							" */\r",
							"tls.createConnection = function(options) {\r",
							"  var caStore = null;\r",
							"  if(options.caStore) {\r",
							"    // if CA store is an array, convert it to a CA store object\r",
							"    if(forge.util.isArray(options.caStore)) {\r",
							"      caStore = forge.pki.createCaStore(options.caStore);\r",
							"    } else {\r",
							"      caStore = options.caStore;\r",
							"    }\r",
							"  } else {\r",
							"    // create empty CA store\r",
							"    caStore = forge.pki.createCaStore();\r",
							"  }\r",
							"\r",
							"  // setup default cipher suites\r",
							"  var cipherSuites = options.cipherSuites || null;\r",
							"  if(cipherSuites === null) {\r",
							"    cipherSuites = [];\r",
							"    for(var key in tls.CipherSuites) {\r",
							"      cipherSuites.push(tls.CipherSuites[key]);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // set default entity\r",
							"  var entity = (options.server || false) ?\r",
							"    tls.ConnectionEnd.server : tls.ConnectionEnd.client;\r",
							"\r",
							"  // create session cache if requested\r",
							"  var sessionCache = options.sessionCache ?\r",
							"    tls.createSessionCache(options.sessionCache) : null;\r",
							"\r",
							"  // create TLS connection\r",
							"  var c = {\r",
							"    version: {major: tls.Version.major, minor: tls.Version.minor},\r",
							"    entity: entity,\r",
							"    sessionId: options.sessionId,\r",
							"    caStore: caStore,\r",
							"    sessionCache: sessionCache,\r",
							"    cipherSuites: cipherSuites,\r",
							"    connected: options.connected,\r",
							"    virtualHost: options.virtualHost || null,\r",
							"    verifyClient: options.verifyClient || false,\r",
							"    verify: options.verify || function(cn, vfd, dpth, cts) {return vfd;},\r",
							"    getCertificate: options.getCertificate || null,\r",
							"    getPrivateKey: options.getPrivateKey || null,\r",
							"    getSignature: options.getSignature || null,\r",
							"    input: forge.util.createBuffer(),\r",
							"    tlsData: forge.util.createBuffer(),\r",
							"    data: forge.util.createBuffer(),\r",
							"    tlsDataReady: options.tlsDataReady,\r",
							"    dataReady: options.dataReady,\r",
							"    heartbeatReceived: options.heartbeatReceived,\r",
							"    closed: options.closed,\r",
							"    error: function(c, ex) {\r",
							"      // set origin if not set\r",
							"      ex.origin = ex.origin ||\r",
							"        ((c.entity === tls.ConnectionEnd.client) ? 'client' : 'server');\r",
							"\r",
							"      // send TLS alert\r",
							"      if(ex.send) {\r",
							"        tls.queue(c, tls.createAlert(c, ex.alert));\r",
							"        tls.flush(c);\r",
							"      }\r",
							"\r",
							"      // error is fatal by default\r",
							"      var fatal = (ex.fatal !== false);\r",
							"      if(fatal) {\r",
							"        // set fail flag\r",
							"        c.fail = true;\r",
							"      }\r",
							"\r",
							"      // call error handler first\r",
							"      options.error(c, ex);\r",
							"\r",
							"      if(fatal) {\r",
							"        // fatal error, close connection, do not clear fail\r",
							"        c.close(false);\r",
							"      }\r",
							"    },\r",
							"    deflate: options.deflate || null,\r",
							"    inflate: options.inflate || null\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Resets a closed TLS connection for reuse. Called in c.close().\r",
							"   *\r",
							"   * @param clearFail true to clear the fail flag (default: true).\r",
							"   */\r",
							"  c.reset = function(clearFail) {\r",
							"    c.version = {major: tls.Version.major, minor: tls.Version.minor};\r",
							"    c.record = null;\r",
							"    c.session = null;\r",
							"    c.peerCertificate = null;\r",
							"    c.state = {\r",
							"      pending: null,\r",
							"      current: null\r",
							"    };\r",
							"    c.expect = (c.entity === tls.ConnectionEnd.client) ? SHE : CHE;\r",
							"    c.fragmented = null;\r",
							"    c.records = [];\r",
							"    c.open = false;\r",
							"    c.handshakes = 0;\r",
							"    c.handshaking = false;\r",
							"    c.isConnected = false;\r",
							"    c.fail = !(clearFail || typeof(clearFail) === 'undefined');\r",
							"    c.input.clear();\r",
							"    c.tlsData.clear();\r",
							"    c.data.clear();\r",
							"    c.state.current = tls.createConnectionState(c);\r",
							"  };\r",
							"\r",
							"  // do initial reset of connection\r",
							"  c.reset();\r",
							"\r",
							"  /**\r",
							"   * Updates the current TLS engine state based on the given record.\r",
							"   *\r",
							"   * @param c the TLS connection.\r",
							"   * @param record the TLS record to act on.\r",
							"   */\r",
							"  var _update = function(c, record) {\r",
							"    // get record handler (align type in table by subtracting lowest)\r",
							"    var aligned = record.type - tls.ContentType.change_cipher_spec;\r",
							"    var handlers = ctTable[c.entity][c.expect];\r",
							"    if(aligned in handlers) {\r",
							"      handlers[aligned](c, record);\r",
							"    } else {\r",
							"      // unexpected record\r",
							"      tls.handleUnexpected(c, record);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Reads the record header and initializes the next record on the given\r",
							"   * connection.\r",
							"   *\r",
							"   * @param c the TLS connection with the next record.\r",
							"   *\r",
							"   * @return 0 if the input data could be processed, otherwise the\r",
							"   *         number of bytes required for data to be processed.\r",
							"   */\r",
							"  var _readRecordHeader = function(c) {\r",
							"    var rval = 0;\r",
							"\r",
							"    // get input buffer and its length\r",
							"    var b = c.input;\r",
							"    var len = b.length();\r",
							"\r",
							"    // need at least 5 bytes to initialize a record\r",
							"    if(len < 5) {\r",
							"      rval = 5 - len;\r",
							"    } else {\r",
							"      // enough bytes for header\r",
							"      // initialize record\r",
							"      c.record = {\r",
							"        type: b.getByte(),\r",
							"        version: {\r",
							"          major: b.getByte(),\r",
							"          minor: b.getByte()\r",
							"        },\r",
							"        length: b.getInt16(),\r",
							"        fragment: forge.util.createBuffer(),\r",
							"        ready: false\r",
							"      };\r",
							"\r",
							"      // check record version\r",
							"      var compatibleVersion = (c.record.version.major === c.version.major);\r",
							"      if(compatibleVersion && c.session && c.session.version) {\r",
							"        // session version already set, require same minor version\r",
							"        compatibleVersion = (c.record.version.minor === c.version.minor);\r",
							"      }\r",
							"      if(!compatibleVersion) {\r",
							"        c.error(c, {\r",
							"          message: 'Incompatible TLS version.',\r",
							"          send: true,\r",
							"          alert: {\r",
							"            level: tls.Alert.Level.fatal,\r",
							"            description: tls.Alert.Description.protocol_version\r",
							"          }\r",
							"        });\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Reads the next record's contents and appends its message to any\r",
							"   * previously fragmented message.\r",
							"   *\r",
							"   * @param c the TLS connection with the next record.\r",
							"   *\r",
							"   * @return 0 if the input data could be processed, otherwise the\r",
							"   *         number of bytes required for data to be processed.\r",
							"   */\r",
							"  var _readRecord = function(c) {\r",
							"    var rval = 0;\r",
							"\r",
							"    // ensure there is enough input data to get the entire record\r",
							"    var b = c.input;\r",
							"    var len = b.length();\r",
							"    if(len < c.record.length) {\r",
							"      // not enough data yet, return how much is required\r",
							"      rval = c.record.length - len;\r",
							"    } else {\r",
							"      // there is enough data to parse the pending record\r",
							"      // fill record fragment and compact input buffer\r",
							"      c.record.fragment.putBytes(b.getBytes(c.record.length));\r",
							"      b.compact();\r",
							"\r",
							"      // update record using current read state\r",
							"      var s = c.state.current.read;\r",
							"      if(s.update(c, c.record)) {\r",
							"        // see if there is a previously fragmented message that the\r",
							"        // new record's message fragment should be appended to\r",
							"        if(c.fragmented !== null) {\r",
							"          // if the record type matches a previously fragmented\r",
							"          // record, append the record fragment to it\r",
							"          if(c.fragmented.type === c.record.type) {\r",
							"            // concatenate record fragments\r",
							"            c.fragmented.fragment.putBuffer(c.record.fragment);\r",
							"            c.record = c.fragmented;\r",
							"          } else {\r",
							"            // error, invalid fragmented record\r",
							"            c.error(c, {\r",
							"              message: 'Invalid fragmented record.',\r",
							"              send: true,\r",
							"              alert: {\r",
							"                level: tls.Alert.Level.fatal,\r",
							"                description:\r",
							"                  tls.Alert.Description.unexpected_message\r",
							"              }\r",
							"            });\r",
							"          }\r",
							"        }\r",
							"\r",
							"        // record is now ready\r",
							"        c.record.ready = true;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Performs a handshake using the TLS Handshake Protocol, as a client.\r",
							"   *\r",
							"   * This method should only be called if the connection is in client mode.\r",
							"   *\r",
							"   * @param sessionId the session ID to use, null to start a new one.\r",
							"   */\r",
							"  c.handshake = function(sessionId) {\r",
							"    // error to call this in non-client mode\r",
							"    if(c.entity !== tls.ConnectionEnd.client) {\r",
							"      // not fatal error\r",
							"      c.error(c, {\r",
							"        message: 'Cannot initiate handshake as a server.',\r",
							"        fatal: false\r",
							"      });\r",
							"    } else if(c.handshaking) {\r",
							"      // handshake is already in progress, fail but not fatal error\r",
							"      c.error(c, {\r",
							"        message: 'Handshake already in progress.',\r",
							"        fatal: false\r",
							"      });\r",
							"    } else {\r",
							"      // clear fail flag on reuse\r",
							"      if(c.fail && !c.open && c.handshakes === 0) {\r",
							"        c.fail = false;\r",
							"      }\r",
							"\r",
							"      // now handshaking\r",
							"      c.handshaking = true;\r",
							"\r",
							"      // default to blank (new session)\r",
							"      sessionId = sessionId || '';\r",
							"\r",
							"      // if a session ID was specified, try to find it in the cache\r",
							"      var session = null;\r",
							"      if(sessionId.length > 0) {\r",
							"        if(c.sessionCache) {\r",
							"          session = c.sessionCache.getSession(sessionId);\r",
							"        }\r",
							"\r",
							"        // matching session not found in cache, clear session ID\r",
							"        if(session === null) {\r",
							"          sessionId = '';\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // no session given, grab a session from the cache, if available\r",
							"      if(sessionId.length === 0 && c.sessionCache) {\r",
							"        session = c.sessionCache.getSession();\r",
							"        if(session !== null) {\r",
							"          sessionId = session.id;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // set up session\r",
							"      c.session = {\r",
							"        id: sessionId,\r",
							"        version: null,\r",
							"        cipherSuite: null,\r",
							"        compressionMethod: null,\r",
							"        serverCertificate: null,\r",
							"        certificateRequest: null,\r",
							"        clientCertificate: null,\r",
							"        sp: {},\r",
							"        md5: forge.md.md5.create(),\r",
							"        sha1: forge.md.sha1.create()\r",
							"      };\r",
							"\r",
							"      // use existing session information\r",
							"      if(session) {\r",
							"        // only update version on connection, session version not yet set\r",
							"        c.version = session.version;\r",
							"        c.session.sp = session.sp;\r",
							"      }\r",
							"\r",
							"      // generate new client random\r",
							"      c.session.sp.client_random = tls.createRandom().getBytes();\r",
							"\r",
							"      // connection now open\r",
							"      c.open = true;\r",
							"\r",
							"      // send hello\r",
							"      tls.queue(c, tls.createRecord(c, {\r",
							"        type: tls.ContentType.handshake,\r",
							"        data: tls.createClientHello(c)\r",
							"      }));\r",
							"      tls.flush(c);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Called when TLS protocol data has been received from somewhere and should\r",
							"   * be processed by the TLS engine.\r",
							"   *\r",
							"   * @param data the TLS protocol data, as a string, to process.\r",
							"   *\r",
							"   * @return 0 if the data could be processed, otherwise the number of bytes\r",
							"   *         required for data to be processed.\r",
							"   */\r",
							"  c.process = function(data) {\r",
							"    var rval = 0;\r",
							"\r",
							"    // buffer input data\r",
							"    if(data) {\r",
							"      c.input.putBytes(data);\r",
							"    }\r",
							"\r",
							"    // process next record if no failure, process will be called after\r",
							"    // each record is handled (since handling can be asynchronous)\r",
							"    if(!c.fail) {\r",
							"      // reset record if ready and now empty\r",
							"      if(c.record !== null &&\r",
							"        c.record.ready && c.record.fragment.isEmpty()) {\r",
							"        c.record = null;\r",
							"      }\r",
							"\r",
							"      // if there is no pending record, try to read record header\r",
							"      if(c.record === null) {\r",
							"        rval = _readRecordHeader(c);\r",
							"      }\r",
							"\r",
							"      // read the next record (if record not yet ready)\r",
							"      if(!c.fail && c.record !== null && !c.record.ready) {\r",
							"        rval = _readRecord(c);\r",
							"      }\r",
							"\r",
							"      // record ready to be handled, update engine state\r",
							"      if(!c.fail && c.record !== null && c.record.ready) {\r",
							"        _update(c, c.record);\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Requests that application data be packaged into a TLS record. The\r",
							"   * tlsDataReady handler will be called when the TLS record(s) have been\r",
							"   * prepared.\r",
							"   *\r",
							"   * @param data the application data, as a raw 'binary' encoded string, to\r",
							"   *          be sent; to send utf-16/utf-8 string data, use the return value\r",
							"   *          of util.encodeUtf8(str).\r",
							"   *\r",
							"   * @return true on success, false on failure.\r",
							"   */\r",
							"  c.prepare = function(data) {\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.application_data,\r",
							"      data: forge.util.createBuffer(data)\r",
							"    }));\r",
							"    return tls.flush(c);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Requests that a heartbeat request be packaged into a TLS record for\r",
							"   * transmission. The tlsDataReady handler will be called when TLS record(s)\r",
							"   * have been prepared.\r",
							"   *\r",
							"   * When a heartbeat response has been received, the heartbeatReceived\r",
							"   * handler will be called with the matching payload. This handler can\r",
							"   * be used to clear a retransmission timer, etc.\r",
							"   *\r",
							"   * @param payload the heartbeat data to send as the payload in the message.\r",
							"   * @param [payloadLength] the payload length to use, defaults to the\r",
							"   *          actual payload length.\r",
							"   *\r",
							"   * @return true on success, false on failure.\r",
							"   */\r",
							"  c.prepareHeartbeatRequest = function(payload, payloadLength) {\r",
							"    if(payload instanceof forge.util.ByteBuffer) {\r",
							"      payload = payload.bytes();\r",
							"    }\r",
							"    if(typeof payloadLength === 'undefined') {\r",
							"      payloadLength = payload.length;\r",
							"    }\r",
							"    c.expectedHeartbeatPayload = payload;\r",
							"    tls.queue(c, tls.createRecord(c, {\r",
							"      type: tls.ContentType.heartbeat,\r",
							"      data: tls.createHeartbeat(\r",
							"        tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)\r",
							"    }));\r",
							"    return tls.flush(c);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Closes the connection (sends a close_notify alert).\r",
							"   *\r",
							"   * @param clearFail true to clear the fail flag (default: true).\r",
							"   */\r",
							"  c.close = function(clearFail) {\r",
							"    // save session if connection didn't fail\r",
							"    if(!c.fail && c.sessionCache && c.session) {\r",
							"      // only need to preserve session ID, version, and security params\r",
							"      var session = {\r",
							"        id: c.session.id,\r",
							"        version: c.session.version,\r",
							"        sp: c.session.sp\r",
							"      };\r",
							"      session.sp.keys = null;\r",
							"      c.sessionCache.setSession(session.id, session);\r",
							"    }\r",
							"\r",
							"    if(c.open) {\r",
							"      // connection no longer open, clear input\r",
							"      c.open = false;\r",
							"      c.input.clear();\r",
							"\r",
							"      // if connected or handshaking, send an alert\r",
							"      if(c.isConnected || c.handshaking) {\r",
							"        c.isConnected = c.handshaking = false;\r",
							"\r",
							"        // send close_notify alert\r",
							"        tls.queue(c, tls.createAlert(c, {\r",
							"          level: tls.Alert.Level.warning,\r",
							"          description: tls.Alert.Description.close_notify\r",
							"        }));\r",
							"        tls.flush(c);\r",
							"      }\r",
							"\r",
							"      // call handler\r",
							"      c.closed(c);\r",
							"    }\r",
							"\r",
							"    // reset TLS connection, do not clear fail flag\r",
							"    c.reset(clearFail);\r",
							"  };\r",
							"\r",
							"  return c;\r",
							"};\r",
							"\r",
							"/* TLS API */\r",
							"module.exports = forge.tls = forge.tls || {};\r",
							"\r",
							"// expose non-functions\r",
							"for(var key in tls) {\r",
							"  if(typeof tls[key] !== 'function') {\r",
							"    forge.tls[key] = tls[key];\r",
							"  }\r",
							"}\r",
							"\r",
							"// expose prf_tls1 for testing\r",
							"forge.tls.prf_tls1 = prf_TLS1;\r",
							"\r",
							"// expose sha1 hmac method\r",
							"forge.tls.hmac_sha1 = hmac_sha1;\r",
							"\r",
							"// expose session cache creation\r",
							"forge.tls.createSessionCache = tls.createSessionCache;\r",
							"\r",
							"/**\r",
							" * Creates a new TLS connection. This does not make any assumptions about the\r",
							" * transport layer that TLS is working on top of, ie: it does not assume there\r",
							" * is a TCP/IP connection or establish one. A TLS connection is totally\r",
							" * abstracted away from the layer is runs on top of, it merely establishes a\r",
							" * secure channel between a client\" and a \"server\".\r",
							" *\r",
							" * A TLS connection contains 4 connection states: pending read and write, and\r",
							" * current read and write.\r",
							" *\r",
							" * At initialization, the current read and write states will be null. Only once\r",
							" * the security parameters have been set and the keys have been generated can\r",
							" * the pending states be converted into current states. Current states will be\r",
							" * updated for each record processed.\r",
							" *\r",
							" * A custom certificate verify callback may be provided to check information\r",
							" * like the common name on the server's certificate. It will be called for\r",
							" * every certificate in the chain. It has the following signature:\r",
							" *\r",
							" * variable func(c, certs, index, preVerify)\r",
							" * Where:\r",
							" * c         The TLS connection\r",
							" * verified  Set to true if certificate was verified, otherwise the alert\r",
							" *           tls.Alert.Description for why the certificate failed.\r",
							" * depth     The current index in the chain, where 0 is the server's cert.\r",
							" * certs     The certificate chain, *NOTE* if the server was anonymous then\r",
							" *           the chain will be empty.\r",
							" *\r",
							" * The function returns true on success and on failure either the appropriate\r",
							" * tls.Alert.Description or an object with 'alert' set to the appropriate\r",
							" * tls.Alert.Description and 'message' set to a custom error message. If true\r",
							" * is not returned then the connection will abort using, in order of\r",
							" * availability, first the returned alert description, second the preVerify\r",
							" * alert description, and lastly the default 'bad_certificate'.\r",
							" *\r",
							" * There are three callbacks that can be used to make use of client-side\r",
							" * certificates where each takes the TLS connection as the first parameter:\r",
							" *\r",
							" * getCertificate(conn, hint)\r",
							" *   The second parameter is a hint as to which certificate should be\r",
							" *   returned. If the connection entity is a client, then the hint will be\r",
							" *   the CertificateRequest message from the server that is part of the\r",
							" *   TLS protocol. If the connection entity is a server, then it will be\r",
							" *   the servername list provided via an SNI extension the ClientHello, if\r",
							" *   one was provided (empty array if not). The hint can be examined to\r",
							" *   determine which certificate to use (advanced). Most implementations\r",
							" *   will just return a certificate. The return value must be a\r",
							" *   PEM-formatted certificate or an array of PEM-formatted certificates\r",
							" *   that constitute a certificate chain, with the first in the array/chain\r",
							" *   being the client's certificate.\r",
							" * getPrivateKey(conn, certificate)\r",
							" *   The second parameter is an forge.pki X.509 certificate object that\r",
							" *   is associated with the requested private key. The return value must\r",
							" *   be a PEM-formatted private key.\r",
							" * getSignature(conn, bytes, callback)\r",
							" *   This callback can be used instead of getPrivateKey if the private key\r",
							" *   is not directly accessible in javascript or should not be. For\r",
							" *   instance, a secure external web service could provide the signature\r",
							" *   in exchange for appropriate credentials. The second parameter is a\r",
							" *   string of bytes to be signed that are part of the TLS protocol. These\r",
							" *   bytes are used to verify that the private key for the previously\r",
							" *   provided client-side certificate is accessible to the client. The\r",
							" *   callback is a function that takes 2 parameters, the TLS connection\r",
							" *   and the RSA encrypted (signed) bytes as a string. This callback must\r",
							" *   be called once the signature is ready.\r",
							" *\r",
							" * @param options the options for this connection:\r",
							" *   server: true if the connection is server-side, false for client.\r",
							" *   sessionId: a session ID to reuse, null for a new connection.\r",
							" *   caStore: an array of certificates to trust.\r",
							" *   sessionCache: a session cache to use.\r",
							" *   cipherSuites: an optional array of cipher suites to use,\r",
							" *     see tls.CipherSuites.\r",
							" *   connected: function(conn) called when the first handshake completes.\r",
							" *   virtualHost: the virtual server name to use in a TLS SNI extension.\r",
							" *   verifyClient: true to require a client certificate in server mode,\r",
							" *     'optional' to request one, false not to (default: false).\r",
							" *   verify: a handler used to custom verify certificates in the chain.\r",
							" *   getCertificate: an optional callback used to get a certificate or\r",
							" *     a chain of certificates (as an array).\r",
							" *   getPrivateKey: an optional callback used to get a private key.\r",
							" *   getSignature: an optional callback used to get a signature.\r",
							" *   tlsDataReady: function(conn) called when TLS protocol data has been\r",
							" *     prepared and is ready to be used (typically sent over a socket\r",
							" *     connection to its destination), read from conn.tlsData buffer.\r",
							" *   dataReady: function(conn) called when application data has\r",
							" *     been parsed from a TLS record and should be consumed by the\r",
							" *     application, read from conn.data buffer.\r",
							" *   closed: function(conn) called when the connection has been closed.\r",
							" *   error: function(conn, error) called when there was an error.\r",
							" *   deflate: function(inBytes) if provided, will deflate TLS records using\r",
							" *     the deflate algorithm if the server supports it.\r",
							" *   inflate: function(inBytes) if provided, will inflate TLS records using\r",
							" *     the deflate algorithm if the server supports it.\r",
							" *\r",
							" * @return the new TLS connection.\r",
							" */\r",
							"forge.tls.createConnection = tls.createConnection;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 20 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of a basic Public Key Infrastructure, including\r",
							" * support for RSA public and private keys.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(21);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(15);\r",
							"__webpack_require__(28);\r",
							"__webpack_require__(17);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(16);\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/* Public Key Infrastructure (PKI) implementation. */\r",
							"var pki = module.exports = forge.pki = forge.pki || {};\r",
							"\r",
							"/**\r",
							" * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.\r",
							" *\r",
							" * Converts PEM-formatted data to DER.\r",
							" *\r",
							" * @param pem the PEM-formatted data.\r",
							" *\r",
							" * @return the DER-formatted data.\r",
							" */\r",
							"pki.pemToDer = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert PEM to DER; PEM is encrypted.');\r",
							"  }\r",
							"  return forge.util.createBuffer(msg.body);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA private key from PEM format.\r",
							" *\r",
							" * @param pem the PEM-formatted private key.\r",
							" *\r",
							" * @return the private key.\r",
							" */\r",
							"pki.privateKeyFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {\r",
							"    var error = new Error('Could not convert private key from PEM; PEM ' +\r",
							"      'header type is not \"PRIVATE KEY\" or \"RSA PRIVATE KEY\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert private key from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body);\r",
							"\r",
							"  return pki.privateKeyFromAsn1(obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts an RSA private key to PEM format.\r",
							" *\r",
							" * @param key the private key.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted private key.\r",
							" */\r",
							"pki.privateKeyToPem = function(key, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'RSA PRIVATE KEY',\r",
							"    body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PrivateKeyInfo to PEM format.\r",
							" *\r",
							" * @param pki the PrivateKeyInfo.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted private key.\r",
							" */\r",
							"pki.privateKeyInfoToPem = function(pki, maxline) {\r",
							"  // convert to DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'PRIVATE KEY',\r",
							"    body: asn1.toDer(pki).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 21 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Password-based encryption functions.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * An EncryptedPrivateKeyInfo:\r",
							" *\r",
							" * EncryptedPrivateKeyInfo ::= SEQUENCE {\r",
							" *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,\r",
							" *   encryptedData        EncryptedData }\r",
							" *\r",
							" * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * EncryptedData ::= OCTET STRING\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(15);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(25);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(1);\r",
							"\r",
							"if(typeof BigInteger === 'undefined') {\r",
							"  var BigInteger = forge.jsbn.BigInteger;\r",
							"}\r",
							"\r",
							"// shortcut for asn.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"/* Password-based encryption implementation. */\r",
							"var pki = forge.pki = forge.pki || {};\r",
							"module.exports = pki.pbe = forge.pbe = forge.pbe || {};\r",
							"var oids = pki.oids;\r",
							"\r",
							"// validator for an EncryptedPrivateKeyInfo structure\r",
							"// Note: Currently only works w/algorithm params\r",
							"var encryptedPrivateKeyValidator = {\r",
							"  name: 'EncryptedPrivateKeyInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'AlgorithmIdentifier.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encryptionOid'\r",
							"    }, {\r",
							"      name: 'AlgorithmIdentifier.parameters',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'encryptionParams'\r",
							"    }]\r",
							"  }, {\r",
							"    // encryptedData\r",
							"    name: 'EncryptedPrivateKeyInfo.encryptedData',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'encryptedData'\r",
							"  }]\r",
							"};\r",
							"\r",
							"// validator for a PBES2Algorithms structure\r",
							"// Note: Currently only works w/PBKDF2 + AES encryption schemes\r",
							"var PBES2AlgorithmsValidator = {\r",
							"  name: 'PBES2Algorithms',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'PBES2Algorithms.keyDerivationFunc',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'PBES2Algorithms.keyDerivationFunc.oid',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'kdfOid'\r",
							"    }, {\r",
							"      name: 'PBES2Algorithms.params',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'PBES2Algorithms.params.salt',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OCTETSTRING,\r",
							"        constructed: false,\r",
							"        capture: 'kdfSalt'\r",
							"      }, {\r",
							"        name: 'PBES2Algorithms.params.iterationCount',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.INTEGER,\r",
							"        constructed: false,\r",
							"        capture: 'kdfIterationCount'\r",
							"      }, {\r",
							"        name: 'PBES2Algorithms.params.keyLength',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.INTEGER,\r",
							"        constructed: false,\r",
							"        optional: true,\r",
							"        capture: 'keyLength'\r",
							"      }, {\r",
							"        // prf\r",
							"        name: 'PBES2Algorithms.params.prf',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SEQUENCE,\r",
							"        constructed: true,\r",
							"        optional: true,\r",
							"        value: [{\r",
							"          name: 'PBES2Algorithms.params.prf.algorithm',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          type: asn1.Type.OID,\r",
							"          constructed: false,\r",
							"          capture: 'prfOid'\r",
							"        }]\r",
							"      }]\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'PBES2Algorithms.encryptionScheme',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'PBES2Algorithms.encryptionScheme.oid',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encOid'\r",
							"    }, {\r",
							"      name: 'PBES2Algorithms.encryptionScheme.iv',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OCTETSTRING,\r",
							"      constructed: false,\r",
							"      capture: 'encIv'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"var pkcs12PbeParamsValidator = {\r",
							"  name: 'pkcs-12PbeParams',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'pkcs-12PbeParams.salt',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'salt'\r",
							"  }, {\r",
							"    name: 'pkcs-12PbeParams.iterations',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'iterations'\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.\r",
							" *\r",
							" * PBES2Algorithms ALGORITHM-IDENTIFIER ::=\r",
							" *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}\r",
							" *\r",
							" * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}\r",
							" *\r",
							" * PBES2-params ::= SEQUENCE {\r",
							" *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},\r",
							" *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}\r",
							" * }\r",
							" *\r",
							" * PBES2-KDFs ALGORITHM-IDENTIFIER ::=\r",
							" *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\r",
							" *\r",
							" * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }\r",
							" *\r",
							" * PBKDF2-params ::= SEQUENCE {\r",
							" *   salt CHOICE {\r",
							" *     specified OCTET STRING,\r",
							" *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\r",
							" *   },\r",
							" *   iterationCount INTEGER (1..MAX),\r",
							" *   keyLength INTEGER (1..MAX) OPTIONAL,\r",
							" *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\r",
							" * }\r",
							" *\r",
							" * @param obj the ASN.1 PrivateKeyInfo object.\r",
							" * @param password the password to encrypt with.\r",
							" * @param options:\r",
							" *          algorithm the encryption algorithm to use\r",
							" *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r",
							" *          count the iteration count to use.\r",
							" *          saltSize the salt size to use.\r",
							" *          prfAlgorithm the PRF message digest algorithm to use\r",
							" *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')\r",
							" *\r",
							" * @return the ASN.1 EncryptedPrivateKeyInfo.\r",
							" */\r",
							"pki.encryptPrivateKeyInfo = function(obj, password, options) {\r",
							"  // set default options\r",
							"  options = options || {};\r",
							"  options.saltSize = options.saltSize || 8;\r",
							"  options.count = options.count || 2048;\r",
							"  options.algorithm = options.algorithm || 'aes128';\r",
							"  options.prfAlgorithm = options.prfAlgorithm || 'sha1';\r",
							"\r",
							"  // generate PBE params\r",
							"  var salt = forge.random.getBytesSync(options.saltSize);\r",
							"  var count = options.count;\r",
							"  var countBytes = asn1.integerToDer(count);\r",
							"  var dkLen;\r",
							"  var encryptionAlgorithm;\r",
							"  var encryptedData;\r",
							"  if(options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {\r",
							"    // do PBES2\r",
							"    var ivLen, encOid, cipherFn;\r",
							"    switch(options.algorithm) {\r",
							"    case 'aes128':\r",
							"      dkLen = 16;\r",
							"      ivLen = 16;\r",
							"      encOid = oids['aes128-CBC'];\r",
							"      cipherFn = forge.aes.createEncryptionCipher;\r",
							"      break;\r",
							"    case 'aes192':\r",
							"      dkLen = 24;\r",
							"      ivLen = 16;\r",
							"      encOid = oids['aes192-CBC'];\r",
							"      cipherFn = forge.aes.createEncryptionCipher;\r",
							"      break;\r",
							"    case 'aes256':\r",
							"      dkLen = 32;\r",
							"      ivLen = 16;\r",
							"      encOid = oids['aes256-CBC'];\r",
							"      cipherFn = forge.aes.createEncryptionCipher;\r",
							"      break;\r",
							"    case 'des':\r",
							"      dkLen = 8;\r",
							"      ivLen = 8;\r",
							"      encOid = oids['desCBC'];\r",
							"      cipherFn = forge.des.createEncryptionCipher;\r",
							"      break;\r",
							"    default:\r",
							"      var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');\r",
							"      error.algorithm = options.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // get PRF message digest\r",
							"    var prfAlgorithm = 'hmacWith' + options.prfAlgorithm.toUpperCase();\r",
							"    var md = prfAlgorithmToMessageDigest(prfAlgorithm);\r",
							"\r",
							"    // encrypt private key using pbe SHA-1 and AES/DES\r",
							"    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\r",
							"    var iv = forge.random.getBytesSync(ivLen);\r",
							"    var cipher = cipherFn(dk);\r",
							"    cipher.start(iv);\r",
							"    cipher.update(asn1.toDer(obj));\r",
							"    cipher.finish();\r",
							"    encryptedData = cipher.output.getBytes();\r",
							"\r",
							"    // get PBKDF2-params\r",
							"    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);\r",
							"\r",
							"    encryptionAlgorithm = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // keyDerivationFunc\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),\r",
							"          // PBKDF2-params\r",
							"          params\r",
							"        ]),\r",
							"        // encryptionScheme\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(encOid).getBytes()),\r",
							"          // iv\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)\r",
							"        ])\r",
							"      ])\r",
							"    ]);\r",
							"  } else if(options.algorithm === '3des') {\r",
							"    // Do PKCS12 PBE\r",
							"    dkLen = 24;\r",
							"\r",
							"    var saltBytes = new forge.util.ByteBuffer(salt);\r",
							"    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);\r",
							"    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);\r",
							"    var cipher = forge.des.createEncryptionCipher(dk);\r",
							"    cipher.start(iv);\r",
							"    cipher.update(asn1.toDer(obj));\r",
							"    cipher.finish();\r",
							"    encryptedData = cipher.output.getBytes();\r",
							"\r",
							"    encryptionAlgorithm = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),\r",
							"      // pkcs-12PbeParams\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // salt\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\r",
							"        // iteration count\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"          countBytes.getBytes())\r",
							"      ])\r",
							"    ]);\r",
							"  } else {\r",
							"    var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');\r",
							"    error.algorithm = options.algorithm;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // EncryptedPrivateKeyInfo\r",
							"  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // encryptionAlgorithm\r",
							"    encryptionAlgorithm,\r",
							"    // encryptedData\r",
							"    asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)\r",
							"  ]);\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decrypts a ASN.1 PrivateKeyInfo object.\r",
							" *\r",
							" * @param obj the ASN.1 EncryptedPrivateKeyInfo object.\r",
							" * @param password the password to decrypt with.\r",
							" *\r",
							" * @return the ASN.1 PrivateKeyInfo on success, null on failure.\r",
							" */\r",
							"pki.decryptPrivateKeyInfo = function(obj, password) {\r",
							"  var rval = null;\r",
							"\r",
							"  // get PBE params\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read encrypted private key. ' +\r",
							"      'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get cipher\r",
							"  var oid = asn1.derToOid(capture.encryptionOid);\r",
							"  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);\r",
							"\r",
							"  // get encrypted data\r",
							"  var encrypted = forge.util.createBuffer(capture.encryptedData);\r",
							"\r",
							"  cipher.update(encrypted);\r",
							"  if(cipher.finish()) {\r",
							"    rval = asn1.fromDer(cipher.output);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a EncryptedPrivateKeyInfo to PEM format.\r",
							" *\r",
							" * @param epki the EncryptedPrivateKeyInfo.\r",
							" * @param maxline the maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return the PEM-formatted encrypted private key.\r",
							" */\r",
							"pki.encryptedPrivateKeyToPem = function(epki, maxline) {\r",
							"  // convert to DER, then PEM-encode\r",
							"  var msg = {\r",
							"    type: 'ENCRYPTED PRIVATE KEY',\r",
							"    body: asn1.toDer(epki).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption\r",
							" * is not performed.\r",
							" *\r",
							" * @param pem the EncryptedPrivateKeyInfo in PEM-format.\r",
							" *\r",
							" * @return the ASN.1 EncryptedPrivateKeyInfo.\r",
							" */\r",
							"pki.encryptedPrivateKeyFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'ENCRYPTED PRIVATE KEY') {\r",
							"    var error = new Error('Could not convert encrypted private key from PEM; ' +\r",
							"      'PEM header type is \"ENCRYPTED PRIVATE KEY\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert encrypted private key from PEM; ' +\r",
							"      'PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  return asn1.fromDer(msg.body);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encrypts an RSA private key. By default, the key will be wrapped in\r",
							" * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.\r",
							" * This is the standard, preferred way to encrypt a private key.\r",
							" *\r",
							" * To produce a non-standard PEM-encrypted private key that uses encapsulated\r",
							" * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL\r",
							" * private key encryption), set the 'legacy' option to true. Note: Using this\r",
							" * option will cause the iteration count to be forced to 1.\r",
							" *\r",
							" * Note: The 'des' algorithm is supported, but it is not considered to be\r",
							" * secure because it only uses a single 56-bit key. If possible, it is highly\r",
							" * recommended that a different algorithm be used.\r",
							" *\r",
							" * @param rsaKey the RSA key to encrypt.\r",
							" * @param password the password to use.\r",
							" * @param options:\r",
							" *          algorithm: the encryption algorithm to use\r",
							" *            ('aes128', 'aes192', 'aes256', '3des', 'des').\r",
							" *          count: the iteration count to use.\r",
							" *          saltSize: the salt size to use.\r",
							" *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated\r",
							" *            headers (DEK-Info) private key.\r",
							" *\r",
							" * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.\r",
							" */\r",
							"pki.encryptRsaPrivateKey = function(rsaKey, password, options) {\r",
							"  // standard PKCS#8\r",
							"  options = options || {};\r",
							"  if(!options.legacy) {\r",
							"    // encrypt PrivateKeyInfo\r",
							"    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));\r",
							"    rval = pki.encryptPrivateKeyInfo(rval, password, options);\r",
							"    return pki.encryptedPrivateKeyToPem(rval);\r",
							"  }\r",
							"\r",
							"  // legacy non-PKCS#8\r",
							"  var algorithm;\r",
							"  var iv;\r",
							"  var dkLen;\r",
							"  var cipherFn;\r",
							"  switch(options.algorithm) {\r",
							"  case 'aes128':\r",
							"    algorithm = 'AES-128-CBC';\r",
							"    dkLen = 16;\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"    cipherFn = forge.aes.createEncryptionCipher;\r",
							"    break;\r",
							"  case 'aes192':\r",
							"    algorithm = 'AES-192-CBC';\r",
							"    dkLen = 24;\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"    cipherFn = forge.aes.createEncryptionCipher;\r",
							"    break;\r",
							"  case 'aes256':\r",
							"    algorithm = 'AES-256-CBC';\r",
							"    dkLen = 32;\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"    cipherFn = forge.aes.createEncryptionCipher;\r",
							"    break;\r",
							"  case '3des':\r",
							"    algorithm = 'DES-EDE3-CBC';\r",
							"    dkLen = 24;\r",
							"    iv = forge.random.getBytesSync(8);\r",
							"    cipherFn = forge.des.createEncryptionCipher;\r",
							"    break;\r",
							"  case 'des':\r",
							"    algorithm = 'DES-CBC';\r",
							"    dkLen = 8;\r",
							"    iv = forge.random.getBytesSync(8);\r",
							"    cipherFn = forge.des.createEncryptionCipher;\r",
							"    break;\r",
							"  default:\r",
							"    var error = new Error('Could not encrypt RSA private key; unsupported ' +\r",
							"      'encryption algorithm \"' + options.algorithm + '\".');\r",
							"    error.algorithm = options.algorithm;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // encrypt private key using OpenSSL legacy key derivation\r",
							"  var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\r",
							"  var cipher = cipherFn(dk);\r",
							"  cipher.start(iv);\r",
							"  cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));\r",
							"  cipher.finish();\r",
							"\r",
							"  var msg = {\r",
							"    type: 'RSA PRIVATE KEY',\r",
							"    procType: {\r",
							"      version: '4',\r",
							"      type: 'ENCRYPTED'\r",
							"    },\r",
							"    dekInfo: {\r",
							"      algorithm: algorithm,\r",
							"      parameters: forge.util.bytesToHex(iv).toUpperCase()\r",
							"    },\r",
							"    body: cipher.output.getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(msg);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decrypts an RSA private key.\r",
							" *\r",
							" * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.\r",
							" * @param password the password to use.\r",
							" *\r",
							" * @return the RSA key on success, null on failure.\r",
							" */\r",
							"pki.decryptRsaPrivateKey = function(pem, password) {\r",
							"  var rval = null;\r",
							"\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'ENCRYPTED PRIVATE KEY' &&\r",
							"    msg.type !== 'PRIVATE KEY' &&\r",
							"    msg.type !== 'RSA PRIVATE KEY') {\r",
							"    var error = new Error('Could not convert private key from PEM; PEM header type ' +\r",
							"      'is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".');\r",
							"    error.headerType = error;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    var dkLen;\r",
							"    var cipherFn;\r",
							"    switch(msg.dekInfo.algorithm) {\r",
							"    case 'DES-CBC':\r",
							"      dkLen = 8;\r",
							"      cipherFn = forge.des.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'DES-EDE3-CBC':\r",
							"      dkLen = 24;\r",
							"      cipherFn = forge.des.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'AES-128-CBC':\r",
							"      dkLen = 16;\r",
							"      cipherFn = forge.aes.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'AES-192-CBC':\r",
							"      dkLen = 24;\r",
							"      cipherFn = forge.aes.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'AES-256-CBC':\r",
							"      dkLen = 32;\r",
							"      cipherFn = forge.aes.createDecryptionCipher;\r",
							"      break;\r",
							"    case 'RC2-40-CBC':\r",
							"      dkLen = 5;\r",
							"      cipherFn = function(key) {\r",
							"        return forge.rc2.createDecryptionCipher(key, 40);\r",
							"      };\r",
							"      break;\r",
							"    case 'RC2-64-CBC':\r",
							"      dkLen = 8;\r",
							"      cipherFn = function(key) {\r",
							"        return forge.rc2.createDecryptionCipher(key, 64);\r",
							"      };\r",
							"      break;\r",
							"    case 'RC2-128-CBC':\r",
							"      dkLen = 16;\r",
							"      cipherFn = function(key) {\r",
							"        return forge.rc2.createDecryptionCipher(key, 128);\r",
							"      };\r",
							"      break;\r",
							"    default:\r",
							"      var error = new Error('Could not decrypt private key; unsupported ' +\r",
							"        'encryption algorithm \"' + msg.dekInfo.algorithm + '\".');\r",
							"      error.algorithm = msg.dekInfo.algorithm;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    // use OpenSSL legacy key derivation\r",
							"    var iv = forge.util.hexToBytes(msg.dekInfo.parameters);\r",
							"    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\r",
							"    var cipher = cipherFn(dk);\r",
							"    cipher.start(iv);\r",
							"    cipher.update(forge.util.createBuffer(msg.body));\r",
							"    if(cipher.finish()) {\r",
							"      rval = cipher.output.getBytes();\r",
							"    } else {\r",
							"      return rval;\r",
							"    }\r",
							"  } else {\r",
							"    rval = msg.body;\r",
							"  }\r",
							"\r",
							"  if(msg.type === 'ENCRYPTED PRIVATE KEY') {\r",
							"    rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);\r",
							"  } else {\r",
							"    // decryption already performed above\r",
							"    rval = asn1.fromDer(rval);\r",
							"  }\r",
							"\r",
							"  if(rval !== null) {\r",
							"    rval = pki.privateKeyFromAsn1(rval);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Derives a PKCS#12 key.\r",
							" *\r",
							" * @param password the password to derive the key material from, null or\r",
							" *          undefined for none.\r",
							" * @param salt the salt, as a ByteBuffer, to use.\r",
							" * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r",
							" * @param iter the iteration count.\r",
							" * @param n the number of bytes to derive from the password.\r",
							" * @param md the message digest to use, defaults to SHA-1.\r",
							" *\r",
							" * @return a ByteBuffer with the bytes derived from the password.\r",
							" */\r",
							"pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {\r",
							"  var j, l;\r",
							"\r",
							"  if(typeof md === 'undefined' || md === null) {\r",
							"    if(!('sha1' in forge.md)) {\r",
							"      throw new Error('\"sha1\" hash algorithm unavailable.');\r",
							"    }\r",
							"    md = forge.md.sha1.create();\r",
							"  }\r",
							"\r",
							"  var u = md.digestLength;\r",
							"  var v = md.blockLength;\r",
							"  var result = new forge.util.ByteBuffer();\r",
							"\r",
							"  /* Convert password to Unicode byte buffer + trailing 0-byte. */\r",
							"  var passBuf = new forge.util.ByteBuffer();\r",
							"  if(password !== null && password !== undefined) {\r",
							"    for(l = 0; l < password.length; l++) {\r",
							"      passBuf.putInt16(password.charCodeAt(l));\r",
							"    }\r",
							"    passBuf.putInt16(0);\r",
							"  }\r",
							"\r",
							"  /* Length of salt and password in BYTES. */\r",
							"  var p = passBuf.length();\r",
							"  var s = salt.length();\r",
							"\r",
							"  /* 1. Construct a string, D (the \"diversifier\"), by concatenating\r",
							"        v copies of ID. */\r",
							"  var D = new forge.util.ByteBuffer();\r",
							"  D.fillWithByte(id, v);\r",
							"\r",
							"  /* 2. Concatenate copies of the salt together to create a string S of length\r",
							"        v * ceil(s / v) bytes (the final copy of the salt may be trunacted\r",
							"        to create S).\r",
							"        Note that if the salt is the empty string, then so is S. */\r",
							"  var Slen = v * Math.ceil(s / v);\r",
							"  var S = new forge.util.ByteBuffer();\r",
							"  for(l = 0; l < Slen; l++) {\r",
							"    S.putByte(salt.at(l % s));\r",
							"  }\r",
							"\r",
							"  /* 3. Concatenate copies of the password together to create a string P of\r",
							"        length v * ceil(p / v) bytes (the final copy of the password may be\r",
							"        truncated to create P).\r",
							"        Note that if the password is the empty string, then so is P. */\r",
							"  var Plen = v * Math.ceil(p / v);\r",
							"  var P = new forge.util.ByteBuffer();\r",
							"  for(l = 0; l < Plen; l++) {\r",
							"    P.putByte(passBuf.at(l % p));\r",
							"  }\r",
							"\r",
							"  /* 4. Set I=S||P to be the concatenation of S and P. */\r",
							"  var I = S;\r",
							"  I.putBuffer(P);\r",
							"\r",
							"  /* 5. Set c=ceil(n / u). */\r",
							"  var c = Math.ceil(n / u);\r",
							"\r",
							"  /* 6. For i=1, 2, ..., c, do the following: */\r",
							"  for(var i = 1; i <= c; i++) {\r",
							"    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */\r",
							"    var buf = new forge.util.ByteBuffer();\r",
							"    buf.putBytes(D.bytes());\r",
							"    buf.putBytes(I.bytes());\r",
							"    for(var round = 0; round < iter; round++) {\r",
							"      md.start();\r",
							"      md.update(buf.getBytes());\r",
							"      buf = md.digest();\r",
							"    }\r",
							"\r",
							"    /* b) Concatenate copies of Ai to create a string B of length v bytes (the\r",
							"          final copy of Ai may be truncated to create B). */\r",
							"    var B = new forge.util.ByteBuffer();\r",
							"    for(l = 0; l < v; l++) {\r",
							"      B.putByte(buf.at(l % u));\r",
							"    }\r",
							"\r",
							"    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,\r",
							"          where k=ceil(s / v) + ceil(p / v), modify I by setting\r",
							"          Ij=(Ij+B+1) mod 2v for each j.  */\r",
							"    var k = Math.ceil(s / v) + Math.ceil(p / v);\r",
							"    var Inew = new forge.util.ByteBuffer();\r",
							"    for(j = 0; j < k; j++) {\r",
							"      var chunk = new forge.util.ByteBuffer(I.getBytes(v));\r",
							"      var x = 0x1ff;\r",
							"      for(l = B.length() - 1; l >= 0; l--) {\r",
							"        x = x >> 8;\r",
							"        x += B.at(l) + chunk.at(l);\r",
							"        chunk.setAt(l, x & 0xff);\r",
							"      }\r",
							"      Inew.putBuffer(chunk);\r",
							"    }\r",
							"    I = Inew;\r",
							"\r",
							"    /* Add Ai to A. */\r",
							"    result.putBuffer(buf);\r",
							"  }\r",
							"\r",
							"  result.truncate(result.length() - n);\r",
							"  return result;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Get new Forge cipher object instance.\r",
							" *\r",
							" * @param oid the OID (in string notation).\r",
							" * @param params the ASN.1 params object.\r",
							" * @param password the password to decrypt with.\r",
							" *\r",
							" * @return new cipher object instance.\r",
							" */\r",
							"pki.pbe.getCipher = function(oid, params, password) {\r",
							"  switch(oid) {\r",
							"  case pki.oids['pkcs5PBES2']:\r",
							"    return pki.pbe.getCipherForPBES2(oid, params, password);\r",
							"\r",
							"  case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:\r",
							"  case pki.oids['pbewithSHAAnd40BitRC2-CBC']:\r",
							"    return pki.pbe.getCipherForPKCS12PBE(oid, params, password);\r",
							"\r",
							"  default:\r",
							"    var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');\r",
							"    error.oid = oid;\r",
							"    error.supportedOids = [\r",
							"      'pkcs5PBES2',\r",
							"      'pbeWithSHAAnd3-KeyTripleDES-CBC',\r",
							"      'pbewithSHAAnd40BitRC2-CBC'\r",
							"    ];\r",
							"    throw error;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Get new Forge cipher object instance according to PBES2 params block.\r",
							" *\r",
							" * The returned cipher instance is already started using the IV\r",
							" * from PBES2 parameter block.\r",
							" *\r",
							" * @param oid the PKCS#5 PBKDF2 OID (in string notation).\r",
							" * @param params the ASN.1 PBES2-params object.\r",
							" * @param password the password to decrypt with.\r",
							" *\r",
							" * @return new cipher object instance.\r",
							" */\r",
							"pki.pbe.getCipherForPBES2 = function(oid, params, password) {\r",
							"  // get PBE params\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read password-based-encryption algorithm ' +\r",
							"      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // check oids\r",
							"  oid = asn1.derToOid(capture.kdfOid);\r",
							"  if(oid !== pki.oids['pkcs5PBKDF2']) {\r",
							"    var error = new Error('Cannot read encrypted private key. ' +\r",
							"      'Unsupported key derivation function OID.');\r",
							"    error.oid = oid;\r",
							"    error.supportedOids = ['pkcs5PBKDF2'];\r",
							"    throw error;\r",
							"  }\r",
							"  oid = asn1.derToOid(capture.encOid);\r",
							"  if(oid !== pki.oids['aes128-CBC'] &&\r",
							"    oid !== pki.oids['aes192-CBC'] &&\r",
							"    oid !== pki.oids['aes256-CBC'] &&\r",
							"    oid !== pki.oids['des-EDE3-CBC'] &&\r",
							"    oid !== pki.oids['desCBC']) {\r",
							"    var error = new Error('Cannot read encrypted private key. ' +\r",
							"      'Unsupported encryption scheme OID.');\r",
							"    error.oid = oid;\r",
							"    error.supportedOids = [\r",
							"      'aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // set PBE params\r",
							"  var salt = capture.kdfSalt;\r",
							"  var count = forge.util.createBuffer(capture.kdfIterationCount);\r",
							"  count = count.getInt(count.length() << 3);\r",
							"  var dkLen;\r",
							"  var cipherFn;\r",
							"  switch(pki.oids[oid]) {\r",
							"  case 'aes128-CBC':\r",
							"    dkLen = 16;\r",
							"    cipherFn = forge.aes.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'aes192-CBC':\r",
							"    dkLen = 24;\r",
							"    cipherFn = forge.aes.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'aes256-CBC':\r",
							"    dkLen = 32;\r",
							"    cipherFn = forge.aes.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'des-EDE3-CBC':\r",
							"    dkLen = 24;\r",
							"    cipherFn = forge.des.createDecryptionCipher;\r",
							"    break;\r",
							"  case 'desCBC':\r",
							"    dkLen = 8;\r",
							"    cipherFn = forge.des.createDecryptionCipher;\r",
							"    break;\r",
							"  }\r",
							"\r",
							"  // get PRF message digest\r",
							"  var md = prfOidToMessageDigest(capture.prfOid);\r",
							"\r",
							"  // decrypt private key using pbe with chosen PRF and AES/DES\r",
							"  var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\r",
							"  var iv = capture.encIv;\r",
							"  var cipher = cipherFn(dk);\r",
							"  cipher.start(iv);\r",
							"\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Get new Forge cipher object instance for PKCS#12 PBE.\r",
							" *\r",
							" * The returned cipher instance is already started using the key & IV\r",
							" * derived from the provided password and PKCS#12 PBE salt.\r",
							" *\r",
							" * @param oid The PKCS#12 PBE OID (in string notation).\r",
							" * @param params The ASN.1 PKCS#12 PBE-params object.\r",
							" * @param password The password to decrypt with.\r",
							" *\r",
							" * @return the new cipher object instance.\r",
							" */\r",
							"pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {\r",
							"  // get PBE params\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read password-based-encryption algorithm ' +\r",
							"      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var salt = forge.util.createBuffer(capture.salt);\r",
							"  var count = forge.util.createBuffer(capture.iterations);\r",
							"  count = count.getInt(count.length() << 3);\r",
							"\r",
							"  var dkLen, dIvLen, cipherFn;\r",
							"  switch(oid) {\r",
							"    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:\r",
							"      dkLen = 24;\r",
							"      dIvLen = 8;\r",
							"      cipherFn = forge.des.startDecrypting;\r",
							"      break;\r",
							"\r",
							"    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:\r",
							"      dkLen = 5;\r",
							"      dIvLen = 8;\r",
							"      cipherFn = function(key, iv) {\r",
							"        var cipher = forge.rc2.createDecryptionCipher(key, 40);\r",
							"        cipher.start(iv, null);\r",
							"        return cipher;\r",
							"      };\r",
							"      break;\r",
							"\r",
							"    default:\r",
							"      var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');\r",
							"      error.oid = oid;\r",
							"      throw error;\r",
							"  }\r",
							"\r",
							"  // get PRF message digest\r",
							"  var md = prfOidToMessageDigest(capture.prfOid);\r",
							"  var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);\r",
							"  md.start();\r",
							"  var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);\r",
							"\r",
							"  return cipherFn(key, iv);\r",
							"};\r",
							"\r",
							"/**\r",
							" * OpenSSL's legacy key derivation function.\r",
							" *\r",
							" * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html\r",
							" *\r",
							" * @param password the password to derive the key from.\r",
							" * @param salt the salt to use, null for none.\r",
							" * @param dkLen the number of bytes needed for the derived key.\r",
							" * @param [options] the options to use:\r",
							" *          [md] an optional message digest object to use.\r",
							" */\r",
							"pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {\r",
							"  if(typeof md === 'undefined' || md === null) {\r",
							"    if(!('md5' in forge.md)) {\r",
							"      throw new Error('\"md5\" hash algorithm unavailable.');\r",
							"    }\r",
							"    md = forge.md.md5.create();\r",
							"  }\r",
							"  if(salt === null) {\r",
							"    salt = '';\r",
							"  }\r",
							"  var digests = [hash(md, password + salt)];\r",
							"  for(var length = 16, i = 1; length < dkLen; ++i, length += 16) {\r",
							"    digests.push(hash(md, digests[i - 1] + password + salt));\r",
							"  }\r",
							"  return digests.join('').substr(0, dkLen);\r",
							"};\r",
							"\r",
							"function hash(md, bytes) {\r",
							"  return md.start().update(bytes).digest().getBytes();\r",
							"}\r",
							"\r",
							"function prfOidToMessageDigest(prfOid) {\r",
							"  // get PRF algorithm, default to SHA-1\r",
							"  var prfAlgorithm;\r",
							"  if(!prfOid) {\r",
							"    prfAlgorithm = 'hmacWithSHA1';\r",
							"  } else {\r",
							"    prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];\r",
							"    if(!prfAlgorithm) {\r",
							"      var error = new Error('Unsupported PRF OID.');\r",
							"      error.oid = prfOid;\r",
							"      error.supported = [\r",
							"        'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',\r",
							"        'hmacWithSHA512'];\r",
							"      throw error;\r",
							"    }\r",
							"  }\r",
							"  return prfAlgorithmToMessageDigest(prfAlgorithm);\r",
							"}\r",
							"\r",
							"function prfAlgorithmToMessageDigest(prfAlgorithm) {\r",
							"  var factory = forge.md;\r",
							"  switch(prfAlgorithm) {\r",
							"  case 'hmacWithSHA224':\r",
							"    factory = forge.md.sha512;\r",
							"  case 'hmacWithSHA1':\r",
							"  case 'hmacWithSHA256':\r",
							"  case 'hmacWithSHA384':\r",
							"  case 'hmacWithSHA512':\r",
							"    prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();\r",
							"    break;\r",
							"  default:\r",
							"    var error = new Error('Unsupported PRF algorithm.');\r",
							"    error.algorithm = prfAlgorithm;\r",
							"    error.supported = [\r",
							"      'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',\r",
							"      'hmacWithSHA512'];\r",
							"    throw error;\r",
							"  }\r",
							"  if(!factory || !(prfAlgorithm in factory)) {\r",
							"    throw new Error('Unknown hash algorithm: ' + prfAlgorithm);\r",
							"  }\r",
							"  return factory[prfAlgorithm].create();\r",
							"}\r",
							"\r",
							"function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {\r",
							"  var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // salt\r",
							"    asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\r",
							"    // iteration count\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      countBytes.getBytes())\r",
							"  ]);\r",
							"  // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm\r",
							"  if(prfAlgorithm !== 'hmacWithSHA1') {\r",
							"    params.value.push(\r",
							"      // key length\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        forge.util.hexToBytes(dkLen.toString(16))),\r",
							"      // AlgorithmIdentifier\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // algorithm\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),\r",
							"        // parameters (null)\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"      ]));\r",
							"  }\r",
							"  return params;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 22 */\r",
							"/***/ (function(module, exports) {\r",
							"\r",
							"/* (ignored) */\r",
							"\r",
							"/***/ }),\r",
							"/* 23 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.\r",
							" *\r",
							" * See FIPS 180-2 for details.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2015 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var sha256 = module.exports = forge.sha256 = forge.sha256 || {};\r",
							"forge.md.sha256 = forge.md.algorithms.sha256 = sha256;\r",
							"\r",
							"/**\r",
							" * Creates a SHA-256 message digest object.\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"sha256.create = function() {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  // SHA-256 state contains eight 32-bit integers\r",
							"  var _state = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for word storage\r",
							"  var _w = new Array(64);\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    algorithm: 'sha256',\r",
							"    blockLength: 64,\r",
							"    digestLength: 32,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 8\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength64 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength64 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _state = {\r",
							"      h0: 0x6A09E667,\r",
							"      h1: 0xBB67AE85,\r",
							"      h2: 0x3C6EF372,\r",
							"      h3: 0xA54FF53A,\r",
							"      h4: 0x510E527F,\r",
							"      h5: 0x9B05688C,\r",
							"      h6: 0x1F83D9AB,\r",
							"      h7: 0x5BE0CD19\r",
							"    };\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = ((len[1] / 0x100000000) >>> 0);\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_state, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the digest.\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate SHA-256 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 448 mod 512. In other words,\r",
							"    the data to be digested must be a multiple of 512 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 8 bytes (64\r",
							"    bits), that means that the last segment of the data must have 56 bytes\r",
							"    (448 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 448 mod 512 because\r",
							"    512 - 128 = 448.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 448 mod 512, then 512 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in big-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry from next int\r",
							"    var next, carry;\r",
							"    var bits = md.fullMessageLength[0] * 8;\r",
							"    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\r",
							"      next = md.fullMessageLength[i + 1] * 8;\r",
							"      carry = (next / 0x100000000) >>> 0;\r",
							"      bits += carry;\r",
							"      finalBlock.putInt32(bits >>> 0);\r",
							"      bits = next >>> 0;\r",
							"    }\r",
							"    finalBlock.putInt32(bits);\r",
							"\r",
							"    var s2 = {\r",
							"      h0: _state.h0,\r",
							"      h1: _state.h1,\r",
							"      h2: _state.h2,\r",
							"      h3: _state.h3,\r",
							"      h4: _state.h4,\r",
							"      h5: _state.h5,\r",
							"      h6: _state.h6,\r",
							"      h7: _state.h7\r",
							"    };\r",
							"    _update(s2, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    rval.putInt32(s2.h0);\r",
							"    rval.putInt32(s2.h1);\r",
							"    rval.putInt32(s2.h2);\r",
							"    rval.putInt32(s2.h3);\r",
							"    rval.putInt32(s2.h4);\r",
							"    rval.putInt32(s2.h5);\r",
							"    rval.putInt32(s2.h6);\r",
							"    rval.putInt32(s2.h7);\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// sha-256 padding bytes not initialized yet\r",
							"var _padding = null;\r",
							"var _initialized = false;\r",
							"\r",
							"// table of constants\r",
							"var _k = null;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\r",
							"\r",
							"  // create K table for SHA-256\r",
							"  _k = [\r",
							"    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\r",
							"    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\r",
							"    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\r",
							"    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\r",
							"    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\r",
							"    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\r",
							"    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\r",
							"    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\r",
							"    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\r",
							"    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\r",
							"    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\r",
							"    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\r",
							"    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\r",
							"    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\r",
							"    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\r",
							"    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a SHA-256 state with the given byte buffer.\r",
							" *\r",
							" * @param s the SHA-256 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (64 byte) chunks\r",
							"  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 64) {\r",
							"    // the w array will be populated with sixteen 32-bit big-endian words\r",
							"    // and then extended into 64 32-bit words according to SHA-256\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      w[i] = bytes.getInt32();\r",
							"    }\r",
							"    for(; i < 64; ++i) {\r",
							"      // XOR word 2 words ago rot right 17, rot right 19, shft right 10\r",
							"      t1 = w[i - 2];\r",
							"      t1 =\r",
							"        ((t1 >>> 17) | (t1 << 15)) ^\r",
							"        ((t1 >>> 19) | (t1 << 13)) ^\r",
							"        (t1 >>> 10);\r",
							"      // XOR word 15 words ago rot right 7, rot right 18, shft right 3\r",
							"      t2 = w[i - 15];\r",
							"      t2 =\r",
							"        ((t2 >>> 7) | (t2 << 25)) ^\r",
							"        ((t2 >>> 18) | (t2 << 14)) ^\r",
							"        (t2 >>> 3);\r",
							"      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32\r",
							"      w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;\r",
							"    }\r",
							"\r",
							"    // initialize hash value for this chunk\r",
							"    a = s.h0;\r",
							"    b = s.h1;\r",
							"    c = s.h2;\r",
							"    d = s.h3;\r",
							"    e = s.h4;\r",
							"    f = s.h5;\r",
							"    g = s.h6;\r",
							"    h = s.h7;\r",
							"\r",
							"    // round function\r",
							"    for(i = 0; i < 64; ++i) {\r",
							"      // Sum1(e)\r",
							"      s1 =\r",
							"        ((e >>> 6) | (e << 26)) ^\r",
							"        ((e >>> 11) | (e << 21)) ^\r",
							"        ((e >>> 25) | (e << 7));\r",
							"      // Ch(e, f, g) (optimized the same way as SHA-1)\r",
							"      ch = g ^ (e & (f ^ g));\r",
							"      // Sum0(a)\r",
							"      s0 =\r",
							"        ((a >>> 2) | (a << 30)) ^\r",
							"        ((a >>> 13) | (a << 19)) ^\r",
							"        ((a >>> 22) | (a << 10));\r",
							"      // Maj(a, b, c) (optimized the same way as SHA-1)\r",
							"      maj = (a & b) | (c & (a ^ b));\r",
							"\r",
							"      // main algorithm\r",
							"      t1 = h + s1 + ch + _k[i] + w[i];\r",
							"      t2 = s0 + maj;\r",
							"      h = g;\r",
							"      g = f;\r",
							"      f = e;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      // can't truncate with `| 0`\r",
							"      e = (d + t1) >>> 0;\r",
							"      d = c;\r",
							"      c = b;\r",
							"      b = a;\r",
							"      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\r",
							"      // can't truncate with `| 0`\r",
							"      a = (t1 + t2) >>> 0;\r",
							"    }\r",
							"\r",
							"    // update hash state\r",
							"    s.h0 = (s.h0 + a) | 0;\r",
							"    s.h1 = (s.h1 + b) | 0;\r",
							"    s.h2 = (s.h2 + c) | 0;\r",
							"    s.h3 = (s.h3 + d) | 0;\r",
							"    s.h4 = (s.h4 + e) | 0;\r",
							"    s.h5 = (s.h5 + f) | 0;\r",
							"    s.h6 = (s.h6 + g) | 0;\r",
							"    s.h7 = (s.h7 + h) | 0;\r",
							"    len -= 64;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 24 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * A javascript implementation of a cryptographically-secure\r",
							" * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\r",
							" * here though the use of SHA-256 is not enforced; when generating an\r",
							" * a PRNG context, the hashing algorithm and block cipher used for\r",
							" * the generator are specified via a plugin.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var _crypto = null;\r",
							"if(forge.util.isNodejs && !forge.options.usePureJavaScript &&\r",
							"  !process.versions['node-webkit']) {\r",
							"  _crypto = __webpack_require__(22);\r",
							"}\r",
							"\r",
							"/* PRNG API */\r",
							"var prng = module.exports = forge.prng = forge.prng || {};\r",
							"\r",
							"/**\r",
							" * Creates a new PRNG context.\r",
							" *\r",
							" * A PRNG plugin must be passed in that will provide:\r",
							" *\r",
							" * 1. A function that initializes the key and seed of a PRNG context. It\r",
							" *   will be given a 16 byte key and a 16 byte seed. Any key expansion\r",
							" *   or transformation of the seed from a byte string into an array of\r",
							" *   integers (or similar) should be performed.\r",
							" * 2. The cryptographic function used by the generator. It takes a key and\r",
							" *   a seed.\r",
							" * 3. A seed increment function. It takes the seed and returns seed + 1.\r",
							" * 4. An api to create a message digest.\r",
							" *\r",
							" * For an example, see random.js.\r",
							" *\r",
							" * @param plugin the PRNG plugin to use.\r",
							" */\r",
							"prng.create = function(plugin) {\r",
							"  var ctx = {\r",
							"    plugin: plugin,\r",
							"    key: null,\r",
							"    seed: null,\r",
							"    time: null,\r",
							"    // number of reseeds so far\r",
							"    reseeds: 0,\r",
							"    // amount of data generated so far\r",
							"    generated: 0,\r",
							"    // no initial key bytes\r",
							"    keyBytes: ''\r",
							"  };\r",
							"\r",
							"  // create 32 entropy pools (each is a message digest)\r",
							"  var md = plugin.md;\r",
							"  var pools = new Array(32);\r",
							"  for(var i = 0; i < 32; ++i) {\r",
							"    pools[i] = md.create();\r",
							"  }\r",
							"  ctx.pools = pools;\r",
							"\r",
							"  // entropy pools are written to cyclically, starting at index 0\r",
							"  ctx.pool = 0;\r",
							"\r",
							"  /**\r",
							"   * Generates random bytes. The bytes may be generated synchronously or\r",
							"   * asynchronously. Web workers must use the asynchronous interface or\r",
							"   * else the behavior is undefined.\r",
							"   *\r",
							"   * @param count the number of random bytes to generate.\r",
							"   * @param [callback(err, bytes)] called once the operation completes.\r",
							"   *\r",
							"   * @return count random bytes as a string.\r",
							"   */\r",
							"  ctx.generate = function(count, callback) {\r",
							"    // do synchronously\r",
							"    if(!callback) {\r",
							"      return ctx.generateSync(count);\r",
							"    }\r",
							"\r",
							"    // simple generator using counter-based CBC\r",
							"    var cipher = ctx.plugin.cipher;\r",
							"    var increment = ctx.plugin.increment;\r",
							"    var formatKey = ctx.plugin.formatKey;\r",
							"    var formatSeed = ctx.plugin.formatSeed;\r",
							"    var b = forge.util.createBuffer();\r",
							"\r",
							"    // paranoid deviation from Fortuna:\r",
							"    // reset key for every request to protect previously\r",
							"    // generated random bytes should the key be discovered;\r",
							"    // there is no 100ms based reseeding because of this\r",
							"    // forced reseed for every `generate` call\r",
							"    ctx.key = null;\r",
							"\r",
							"    generate();\r",
							"\r",
							"    function generate(err) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"\r",
							"      // sufficient bytes generated\r",
							"      if(b.length() >= count) {\r",
							"        return callback(null, b.getBytes(count));\r",
							"      }\r",
							"\r",
							"      // if amount of data generated is greater than 1 MiB, trigger reseed\r",
							"      if(ctx.generated > 0xfffff) {\r",
							"        ctx.key = null;\r",
							"      }\r",
							"\r",
							"      if(ctx.key === null) {\r",
							"        // prevent stack overflow\r",
							"        return forge.util.nextTick(function() {\r",
							"          _reseed(generate);\r",
							"        });\r",
							"      }\r",
							"\r",
							"      // generate the random bytes\r",
							"      var bytes = cipher(ctx.key, ctx.seed);\r",
							"      ctx.generated += bytes.length;\r",
							"      b.putBytes(bytes);\r",
							"\r",
							"      // generate bytes for a new key and seed\r",
							"      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\r",
							"      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\r",
							"\r",
							"      forge.util.setImmediate(generate);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Generates random bytes synchronously.\r",
							"   *\r",
							"   * @param count the number of random bytes to generate.\r",
							"   *\r",
							"   * @return count random bytes as a string.\r",
							"   */\r",
							"  ctx.generateSync = function(count) {\r",
							"    // simple generator using counter-based CBC\r",
							"    var cipher = ctx.plugin.cipher;\r",
							"    var increment = ctx.plugin.increment;\r",
							"    var formatKey = ctx.plugin.formatKey;\r",
							"    var formatSeed = ctx.plugin.formatSeed;\r",
							"\r",
							"    // paranoid deviation from Fortuna:\r",
							"    // reset key for every request to protect previously\r",
							"    // generated random bytes should the key be discovered;\r",
							"    // there is no 100ms based reseeding because of this\r",
							"    // forced reseed for every `generateSync` call\r",
							"    ctx.key = null;\r",
							"\r",
							"    var b = forge.util.createBuffer();\r",
							"    while(b.length() < count) {\r",
							"      // if amount of data generated is greater than 1 MiB, trigger reseed\r",
							"      if(ctx.generated > 0xfffff) {\r",
							"        ctx.key = null;\r",
							"      }\r",
							"\r",
							"      if(ctx.key === null) {\r",
							"        _reseedSync();\r",
							"      }\r",
							"\r",
							"      // generate the random bytes\r",
							"      var bytes = cipher(ctx.key, ctx.seed);\r",
							"      ctx.generated += bytes.length;\r",
							"      b.putBytes(bytes);\r",
							"\r",
							"      // generate bytes for a new key and seed\r",
							"      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\r",
							"      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\r",
							"    }\r",
							"\r",
							"    return b.getBytes(count);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Private function that asynchronously reseeds a generator.\r",
							"   *\r",
							"   * @param callback(err) called once the operation completes.\r",
							"   */\r",
							"  function _reseed(callback) {\r",
							"    if(ctx.pools[0].messageLength >= 32) {\r",
							"      _seed();\r",
							"      return callback();\r",
							"    }\r",
							"    // not enough seed data...\r",
							"    var needed = (32 - ctx.pools[0].messageLength) << 5;\r",
							"    ctx.seedFile(needed, function(err, bytes) {\r",
							"      if(err) {\r",
							"        return callback(err);\r",
							"      }\r",
							"      ctx.collect(bytes);\r",
							"      _seed();\r",
							"      callback();\r",
							"    });\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Private function that synchronously reseeds a generator.\r",
							"   */\r",
							"  function _reseedSync() {\r",
							"    if(ctx.pools[0].messageLength >= 32) {\r",
							"      return _seed();\r",
							"    }\r",
							"    // not enough seed data...\r",
							"    var needed = (32 - ctx.pools[0].messageLength) << 5;\r",
							"    ctx.collect(ctx.seedFileSync(needed));\r",
							"    _seed();\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Private function that seeds a generator once enough bytes are available.\r",
							"   */\r",
							"  function _seed() {\r",
							"    // update reseed count\r",
							"    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;\r",
							"\r",
							"    // goal is to update `key` via:\r",
							"    // key = hash(key + s)\r",
							"    //   where 's' is all collected entropy from selected pools, then...\r",
							"\r",
							"    // create a plugin-based message digest\r",
							"    var md = ctx.plugin.md.create();\r",
							"\r",
							"    // consume current key bytes\r",
							"    md.update(ctx.keyBytes);\r",
							"\r",
							"    // digest the entropy of pools whose index k meet the\r",
							"    // condition 'n mod 2^k == 0' where n is the number of reseeds\r",
							"    var _2powK = 1;\r",
							"    for(var k = 0; k < 32; ++k) {\r",
							"      if(ctx.reseeds % _2powK === 0) {\r",
							"        md.update(ctx.pools[k].digest().getBytes());\r",
							"        ctx.pools[k].start();\r",
							"      }\r",
							"      _2powK = _2powK << 1;\r",
							"    }\r",
							"\r",
							"    // get digest for key bytes\r",
							"    ctx.keyBytes = md.digest().getBytes();\r",
							"\r",
							"    // paranoid deviation from Fortuna:\r",
							"    // update `seed` via `seed = hash(key)`\r",
							"    // instead of initializing to zero once and only\r",
							"    // ever incrementing it\r",
							"    md.start();\r",
							"    md.update(ctx.keyBytes);\r",
							"    var seedBytes = md.digest().getBytes();\r",
							"\r",
							"    // update state\r",
							"    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\r",
							"    ctx.seed = ctx.plugin.formatSeed(seedBytes);\r",
							"    ctx.generated = 0;\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * The built-in default seedFile. This seedFile is used when entropy\r",
							"   * is needed immediately.\r",
							"   *\r",
							"   * @param needed the number of bytes that are needed.\r",
							"   *\r",
							"   * @return the random bytes.\r",
							"   */\r",
							"  function defaultSeedFile(needed) {\r",
							"    // use window.crypto.getRandomValues strong source of entropy if available\r",
							"    var getRandomValues = null;\r",
							"    if(typeof window !== 'undefined') {\r",
							"      var _crypto = window.crypto || window.msCrypto;\r",
							"      if(_crypto && _crypto.getRandomValues) {\r",
							"        getRandomValues = function(arr) {\r",
							"          return _crypto.getRandomValues(arr);\r",
							"        };\r",
							"      }\r",
							"    }\r",
							"\r",
							"    var b = forge.util.createBuffer();\r",
							"    if(getRandomValues) {\r",
							"      while(b.length() < needed) {\r",
							"        // max byte length is 65536 before QuotaExceededError is thrown\r",
							"        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\r",
							"        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\r",
							"        var entropy = new Uint32Array(Math.floor(count));\r",
							"        try {\r",
							"          getRandomValues(entropy);\r",
							"          for(var i = 0; i < entropy.length; ++i) {\r",
							"            b.putInt32(entropy[i]);\r",
							"          }\r",
							"        } catch(e) {\r",
							"          /* only ignore QuotaExceededError */\r",
							"          if(!(typeof QuotaExceededError !== 'undefined' &&\r",
							"            e instanceof QuotaExceededError)) {\r",
							"            throw e;\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // be sad and add some weak random data\r",
							"    if(b.length() < needed) {\r",
							"      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\r",
							"      implemented with David G. Carta's optimization: with 32 bit math\r",
							"      and without division (Public Domain). */\r",
							"      var hi, lo, next;\r",
							"      var seed = Math.floor(Math.random() * 0x010000);\r",
							"      while(b.length() < needed) {\r",
							"        lo = 16807 * (seed & 0xFFFF);\r",
							"        hi = 16807 * (seed >> 16);\r",
							"        lo += (hi & 0x7FFF) << 16;\r",
							"        lo += hi >> 15;\r",
							"        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\r",
							"        seed = lo & 0xFFFFFFFF;\r",
							"\r",
							"        // consume lower 3 bytes of seed\r",
							"        for(var i = 0; i < 3; ++i) {\r",
							"          // throw in more pseudo random\r",
							"          next = seed >>> (i << 3);\r",
							"          next ^= Math.floor(Math.random() * 0x0100);\r",
							"          b.putByte(String.fromCharCode(next & 0xFF));\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"\r",
							"    return b.getBytes(needed);\r",
							"  }\r",
							"  // initialize seed file APIs\r",
							"  if(_crypto) {\r",
							"    // use nodejs async API\r",
							"    ctx.seedFile = function(needed, callback) {\r",
							"      _crypto.randomBytes(needed, function(err, bytes) {\r",
							"        if(err) {\r",
							"          return callback(err);\r",
							"        }\r",
							"        callback(null, bytes.toString());\r",
							"      });\r",
							"    };\r",
							"    // use nodejs sync API\r",
							"    ctx.seedFileSync = function(needed) {\r",
							"      return _crypto.randomBytes(needed).toString();\r",
							"    };\r",
							"  } else {\r",
							"    ctx.seedFile = function(needed, callback) {\r",
							"      try {\r",
							"        callback(null, defaultSeedFile(needed));\r",
							"      } catch(e) {\r",
							"        callback(e);\r",
							"      }\r",
							"    };\r",
							"    ctx.seedFileSync = defaultSeedFile;\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Adds entropy to a prng ctx's accumulator.\r",
							"   *\r",
							"   * @param bytes the bytes of entropy as a string.\r",
							"   */\r",
							"  ctx.collect = function(bytes) {\r",
							"    // iterate over pools distributing entropy cyclically\r",
							"    var count = bytes.length;\r",
							"    for(var i = 0; i < count; ++i) {\r",
							"      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\r",
							"      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Collects an integer of n bits.\r",
							"   *\r",
							"   * @param i the integer entropy.\r",
							"   * @param n the number of bits in the integer.\r",
							"   */\r",
							"  ctx.collectInt = function(i, n) {\r",
							"    var bytes = '';\r",
							"    for(var x = 0; x < n; x += 8) {\r",
							"      bytes += String.fromCharCode((i >> x) & 0xFF);\r",
							"    }\r",
							"    ctx.collect(bytes);\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Registers a Web Worker to receive immediate entropy from the main thread.\r",
							"   * This method is required until Web Workers can access the native crypto\r",
							"   * API. This method should be called twice for each created worker, once in\r",
							"   * the main thread, and once in the worker itself.\r",
							"   *\r",
							"   * @param worker the worker to register.\r",
							"   */\r",
							"  ctx.registerWorker = function(worker) {\r",
							"    // worker receives random bytes\r",
							"    if(worker === self) {\r",
							"      ctx.seedFile = function(needed, callback) {\r",
							"        function listener(e) {\r",
							"          var data = e.data;\r",
							"          if(data.forge && data.forge.prng) {\r",
							"            self.removeEventListener('message', listener);\r",
							"            callback(data.forge.prng.err, data.forge.prng.bytes);\r",
							"          }\r",
							"        }\r",
							"        self.addEventListener('message', listener);\r",
							"        self.postMessage({forge: {prng: {needed: needed}}});\r",
							"      };\r",
							"    } else {\r",
							"      // main thread sends random bytes upon request\r",
							"      var listener = function(e) {\r",
							"        var data = e.data;\r",
							"        if(data.forge && data.forge.prng) {\r",
							"          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\r",
							"            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});\r",
							"          });\r",
							"        }\r",
							"      };\r",
							"      // TODO: do we need to remove the event listener when the worker dies?\r",
							"      worker.addEventListener('message', listener);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return ctx;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 25 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * RC2 implementation.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * Information on the RC2 cipher is available from RFC #2268,\r",
							" * http://www.ietf.org/rfc/rfc2268.txt\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var piTable = [\r",
							"  0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d,\r",
							"  0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2,\r",
							"  0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32,\r",
							"  0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82,\r",
							"  0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc,\r",
							"  0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26,\r",
							"  0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03,\r",
							"  0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7,\r",
							"  0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a,\r",
							"  0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec,\r",
							"  0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39,\r",
							"  0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31,\r",
							"  0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9,\r",
							"  0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9,\r",
							"  0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e,\r",
							"  0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad\r",
							"];\r",
							"\r",
							"var s = [1, 2, 3, 5];\r",
							"\r",
							"/**\r",
							" * Rotate a word left by given number of bits.\r",
							" *\r",
							" * Bits that are shifted out on the left are put back in on the right\r",
							" * hand side.\r",
							" *\r",
							" * @param word The word to shift left.\r",
							" * @param bits The number of bits to shift by.\r",
							" * @return The rotated word.\r",
							" */\r",
							"var rol = function(word, bits) {\r",
							"  return ((word << bits) & 0xffff) | ((word & 0xffff) >> (16 - bits));\r",
							"};\r",
							"\r",
							"/**\r",
							" * Rotate a word right by given number of bits.\r",
							" *\r",
							" * Bits that are shifted out on the right are put back in on the left\r",
							" * hand side.\r",
							" *\r",
							" * @param word The word to shift right.\r",
							" * @param bits The number of bits to shift by.\r",
							" * @return The rotated word.\r",
							" */\r",
							"var ror = function(word, bits) {\r",
							"  return ((word & 0xffff) >> bits) | ((word << (16 - bits)) & 0xffff);\r",
							"};\r",
							"\r",
							"/* RC2 API */\r",
							"module.exports = forge.rc2 = forge.rc2 || {};\r",
							"\r",
							"/**\r",
							" * Perform RC2 key expansion as per RFC #2268, section 2.\r",
							" *\r",
							" * @param key variable-length user key (between 1 and 128 bytes)\r",
							" * @param effKeyBits number of effective key bits (default: 128)\r",
							" * @return the expanded RC2 key (ByteBuffer of 128 bytes)\r",
							" */\r",
							"forge.rc2.expandKey = function(key, effKeyBits) {\r",
							"  if(typeof key === 'string') {\r",
							"    key = forge.util.createBuffer(key);\r",
							"  }\r",
							"  effKeyBits = effKeyBits || 128;\r",
							"\r",
							"  /* introduce variables that match the names used in RFC #2268 */\r",
							"  var L = key;\r",
							"  var T = key.length();\r",
							"  var T1 = effKeyBits;\r",
							"  var T8 = Math.ceil(T1 / 8);\r",
							"  var TM = 0xff >> (T1 & 0x07);\r",
							"  var i;\r",
							"\r",
							"  for(i = T; i < 128; i++) {\r",
							"    L.putByte(piTable[(L.at(i - 1) + L.at(i - T)) & 0xff]);\r",
							"  }\r",
							"\r",
							"  L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);\r",
							"\r",
							"  for(i = 127 - T8; i >= 0; i--) {\r",
							"    L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);\r",
							"  }\r",
							"\r",
							"  return L;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a RC2 cipher object.\r",
							" *\r",
							" * @param key the symmetric key to use (as base for key generation).\r",
							" * @param bits the number of effective key bits.\r",
							" * @param encrypt false for decryption, true for encryption.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"var createCipher = function(key, bits, encrypt) {\r",
							"  var _finish = false, _input = null, _output = null, _iv = null;\r",
							"  var mixRound, mashRound;\r",
							"  var i, j, K = [];\r",
							"\r",
							"  /* Expand key and fill into K[] Array */\r",
							"  key = forge.rc2.expandKey(key, bits);\r",
							"  for(i = 0; i < 64; i++) {\r",
							"    K.push(key.getInt16Le());\r",
							"  }\r",
							"\r",
							"  if(encrypt) {\r",
							"    /**\r",
							"     * Perform one mixing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mixing on.\r",
							"     */\r",
							"    mixRound = function(R) {\r",
							"      for(i = 0; i < 4; i++) {\r",
							"        R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +\r",
							"          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);\r",
							"        R[i] = rol(R[i], s[i]);\r",
							"        j++;\r",
							"      }\r",
							"    };\r",
							"\r",
							"    /**\r",
							"     * Perform one mashing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mashing on.\r",
							"     */\r",
							"    mashRound = function(R) {\r",
							"      for(i = 0; i < 4; i++) {\r",
							"        R[i] += K[R[(i + 3) % 4] & 63];\r",
							"      }\r",
							"    };\r",
							"  } else {\r",
							"    /**\r",
							"     * Perform one r-mixing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mixing on.\r",
							"     */\r",
							"    mixRound = function(R) {\r",
							"      for(i = 3; i >= 0; i--) {\r",
							"        R[i] = ror(R[i], s[i]);\r",
							"        R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +\r",
							"          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);\r",
							"        j--;\r",
							"      }\r",
							"    };\r",
							"\r",
							"    /**\r",
							"     * Perform one r-mashing round \"in place\".\r",
							"     *\r",
							"     * @param R Array of four words to perform mashing on.\r",
							"     */\r",
							"    mashRound = function(R) {\r",
							"      for(i = 3; i >= 0; i--) {\r",
							"        R[i] -= K[R[(i + 3) % 4] & 63];\r",
							"      }\r",
							"    };\r",
							"  }\r",
							"\r",
							"  /**\r",
							"   * Run the specified cipher execution plan.\r",
							"   *\r",
							"   * This function takes four words from the input buffer, applies the IV on\r",
							"   * it (if requested) and runs the provided execution plan.\r",
							"   *\r",
							"   * The plan must be put together in form of a array of arrays.  Where the\r",
							"   * outer one is simply a list of steps to perform and the inner one needs\r",
							"   * to have two elements: the first one telling how many rounds to perform,\r",
							"   * the second one telling what to do (i.e. the function to call).\r",
							"   *\r",
							"   * @param {Array} plan The plan to execute.\r",
							"   */\r",
							"  var runPlan = function(plan) {\r",
							"    var R = [];\r",
							"\r",
							"    /* Get data from input buffer and fill the four words into R */\r",
							"    for(i = 0; i < 4; i++) {\r",
							"      var val = _input.getInt16Le();\r",
							"\r",
							"      if(_iv !== null) {\r",
							"        if(encrypt) {\r",
							"          /* We're encrypting, apply the IV first. */\r",
							"          val ^= _iv.getInt16Le();\r",
							"        } else {\r",
							"          /* We're decryption, keep cipher text for next block. */\r",
							"          _iv.putInt16Le(val);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      R.push(val & 0xffff);\r",
							"    }\r",
							"\r",
							"    /* Reset global \"j\" variable as per spec. */\r",
							"    j = encrypt ? 0 : 63;\r",
							"\r",
							"    /* Run execution plan. */\r",
							"    for(var ptr = 0; ptr < plan.length; ptr++) {\r",
							"      for(var ctr = 0; ctr < plan[ptr][0]; ctr++) {\r",
							"        plan[ptr][1](R);\r",
							"      }\r",
							"    }\r",
							"\r",
							"    /* Write back result to output buffer. */\r",
							"    for(i = 0; i < 4; i++) {\r",
							"      if(_iv !== null) {\r",
							"        if(encrypt) {\r",
							"          /* We're encrypting in CBC-mode, feed back encrypted bytes into\r",
							"             IV buffer to carry it forward to next block. */\r",
							"          _iv.putInt16Le(R[i]);\r",
							"        } else {\r",
							"          R[i] ^= _iv.getInt16Le();\r",
							"        }\r",
							"      }\r",
							"\r",
							"      _output.putInt16Le(R[i]);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /* Create cipher object */\r",
							"  var cipher = null;\r",
							"  cipher = {\r",
							"    /**\r",
							"     * Starts or restarts the encryption or decryption process, whichever\r",
							"     * was previously configured.\r",
							"     *\r",
							"     * To use the cipher in CBC mode, iv may be given either as a string\r",
							"     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.\r",
							"     *\r",
							"     * @param iv the initialization vector to use, null for ECB mode.\r",
							"     * @param output the output the buffer to write to, null to create one.\r",
							"     */\r",
							"    start: function(iv, output) {\r",
							"      if(iv) {\r",
							"        /* CBC mode */\r",
							"        if(typeof iv === 'string') {\r",
							"          iv = forge.util.createBuffer(iv);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      _finish = false;\r",
							"      _input = forge.util.createBuffer();\r",
							"      _output = output || new forge.util.createBuffer();\r",
							"      _iv = iv;\r",
							"\r",
							"      cipher.output = _output;\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Updates the next block.\r",
							"     *\r",
							"     * @param input the buffer to read from.\r",
							"     */\r",
							"    update: function(input) {\r",
							"      if(!_finish) {\r",
							"        // not finishing, so fill the input buffer with more input\r",
							"        _input.putBuffer(input);\r",
							"      }\r",
							"\r",
							"      while(_input.length() >= 8) {\r",
							"        runPlan([\r",
							"            [ 5, mixRound ],\r",
							"            [ 1, mashRound ],\r",
							"            [ 6, mixRound ],\r",
							"            [ 1, mashRound ],\r",
							"            [ 5, mixRound ]\r",
							"          ]);\r",
							"      }\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Finishes encrypting or decrypting.\r",
							"     *\r",
							"     * @param pad a padding function to use, null for PKCS#7 padding,\r",
							"     *           signature(blockSize, buffer, decrypt).\r",
							"     *\r",
							"     * @return true if successful, false on error.\r",
							"     */\r",
							"    finish: function(pad) {\r",
							"      var rval = true;\r",
							"\r",
							"      if(encrypt) {\r",
							"        if(pad) {\r",
							"          rval = pad(8, _input, !encrypt);\r",
							"        } else {\r",
							"          // add PKCS#7 padding to block (each pad byte is the\r",
							"          // value of the number of pad bytes)\r",
							"          var padding = (_input.length() === 8) ? 8 : (8 - _input.length());\r",
							"          _input.fillWithByte(padding, padding);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      if(rval) {\r",
							"        // do final update\r",
							"        _finish = true;\r",
							"        cipher.update();\r",
							"      }\r",
							"\r",
							"      if(!encrypt) {\r",
							"        // check for error: input data not a multiple of block size\r",
							"        rval = (_input.length() === 0);\r",
							"        if(rval) {\r",
							"          if(pad) {\r",
							"            rval = pad(8, _output, !encrypt);\r",
							"          } else {\r",
							"            // ensure padding byte count is valid\r",
							"            var len = _output.length();\r",
							"            var count = _output.at(len - 1);\r",
							"\r",
							"            if(count > len) {\r",
							"              rval = false;\r",
							"            } else {\r",
							"              // trim off padding bytes\r",
							"              _output.truncate(count);\r",
							"            }\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"\r",
							"      return rval;\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\r",
							" * given symmetric key. The output will be stored in the 'output' member\r",
							" * of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes or a byte buffer.\r",
							" * The cipher is initialized to use 128 effective key bits.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.startEncrypting = function(key, iv, output) {\r",
							"  var cipher = forge.rc2.createEncryptionCipher(key, 128);\r",
							"  cipher.start(iv, output);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\r",
							" * given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes or a byte buffer.\r",
							" *\r",
							" * To start encrypting call start() on the cipher with an iv and optional\r",
							" * output buffer.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.createEncryptionCipher = function(key, bits) {\r",
							"  return createCipher(key, bits, true);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\r",
							" * given symmetric key. The output will be stored in the 'output' member\r",
							" * of the returned cipher.\r",
							" *\r",
							" * The key and iv may be given as a string of bytes or a byte buffer.\r",
							" * The cipher is initialized to use 128 effective key bits.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" * @param iv the initialization vector to use.\r",
							" * @param output the buffer to write to, null to create one.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.startDecrypting = function(key, iv, output) {\r",
							"  var cipher = forge.rc2.createDecryptionCipher(key, 128);\r",
							"  cipher.start(iv, output);\r",
							"  return cipher;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\r",
							" * given symmetric key.\r",
							" *\r",
							" * The key may be given as a string of bytes or a byte buffer.\r",
							" *\r",
							" * To start decrypting call start() on the cipher with an iv and optional\r",
							" * output buffer.\r",
							" *\r",
							" * @param key the symmetric key to use.\r",
							" *\r",
							" * @return the cipher.\r",
							" */\r",
							"forge.rc2.createDecryptionCipher = function(key, bits) {\r",
							"  return createCipher(key, bits, false);\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 26 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Partial implementation of PKCS#1 v2.2: RSA-OEAP\r",
							" *\r",
							" * Modified but based on the following MIT and BSD licensed code:\r",
							" *\r",
							" * https://github.com/kjur/jsjws/blob/master/rsa.js:\r",
							" *\r",
							" * The 'jsjws'(JSON Web Signature JavaScript Library) License\r",
							" *\r",
							" * Copyright (c) 2012 Kenji Urushima\r",
							" *\r",
							" * Permission is hereby granted, free of charge, to any person obtaining a copy\r",
							" * of this software and associated documentation files (the \"Software\"), to deal\r",
							" * in the Software without restriction, including without limitation the rights\r",
							" * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r",
							" * copies of the Software, and to permit persons to whom the Software is\r",
							" * furnished to do so, subject to the following conditions:\r",
							" *\r",
							" * The above copyright notice and this permission notice shall be included in\r",
							" * all copies or substantial portions of the Software.\r",
							" *\r",
							" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r",
							" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r",
							" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r",
							" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r",
							" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r",
							" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r",
							" * THE SOFTWARE.\r",
							" *\r",
							" * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\r",
							" *\r",
							" * RSAES-OAEP.js\r",
							" * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\r",
							" * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\r",
							" * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\r",
							" * Contact: ellis@nukinetics.com\r",
							" * Distributed under the BSD License.\r",
							" *\r",
							" * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\r",
							" *\r",
							" * @author Evan Jones (http://evanjones.ca/)\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2013-2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(9);\r",
							"\r",
							"// shortcut for PKCS#1 API\r",
							"var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\r",
							"\r",
							"/**\r",
							" * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\r",
							" * and seed.\r",
							" *\r",
							" * This method does not perform RSA encryption, it only encodes the message\r",
							" * using RSAES-OAEP.\r",
							" *\r",
							" * @param key the RSA key to use.\r",
							" * @param message the message to encode.\r",
							" * @param options the options to use:\r",
							" *          label an optional label to use.\r",
							" *          seed the seed to use.\r",
							" *          md the message digest object to use, undefined for SHA-1.\r",
							" *          mgf1 optional mgf1 parameters:\r",
							" *            md the message digest object to use for MGF1.\r",
							" *\r",
							" * @return the encoded message bytes.\r",
							" */\r",
							"pkcs1.encode_rsa_oaep = function(key, message, options) {\r",
							"  // parse arguments\r",
							"  var label;\r",
							"  var seed;\r",
							"  var md;\r",
							"  var mgf1Md;\r",
							"  // legacy args (label, seed, md)\r",
							"  if(typeof options === 'string') {\r",
							"    label = options;\r",
							"    seed = arguments[3] || undefined;\r",
							"    md = arguments[4] || undefined;\r",
							"  } else if(options) {\r",
							"    label = options.label || undefined;\r",
							"    seed = options.seed || undefined;\r",
							"    md = options.md || undefined;\r",
							"    if(options.mgf1 && options.mgf1.md) {\r",
							"      mgf1Md = options.mgf1.md;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // default OAEP to SHA-1 message digest\r",
							"  if(!md) {\r",
							"    md = forge.md.sha1.create();\r",
							"  } else {\r",
							"    md.start();\r",
							"  }\r",
							"\r",
							"  // default MGF-1 to same as OAEP\r",
							"  if(!mgf1Md) {\r",
							"    mgf1Md = md;\r",
							"  }\r",
							"\r",
							"  // compute length in bytes and check output\r",
							"  var keyLength = Math.ceil(key.n.bitLength() / 8);\r",
							"  var maxLength = keyLength - 2 * md.digestLength - 2;\r",
							"  if(message.length > maxLength) {\r",
							"    var error = new Error('RSAES-OAEP input message length is too long.');\r",
							"    error.length = message.length;\r",
							"    error.maxLength = maxLength;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(!label) {\r",
							"    label = '';\r",
							"  }\r",
							"  md.update(label, 'raw');\r",
							"  var lHash = md.digest();\r",
							"\r",
							"  var PS = '';\r",
							"  var PS_length = maxLength - message.length;\r",
							"  for (var i = 0; i < PS_length; i++) {\r",
							"    PS += '\\x00';\r",
							"  }\r",
							"\r",
							"  var DB = lHash.getBytes() + PS + '\\x01' + message;\r",
							"\r",
							"  if(!seed) {\r",
							"    seed = forge.random.getBytes(md.digestLength);\r",
							"  } else if(seed.length !== md.digestLength) {\r",
							"    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +\r",
							"      'match the digest length.');\r",
							"    error.seedLength = seed.length;\r",
							"    error.digestLength = md.digestLength;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\r",
							"  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\r",
							"\r",
							"  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\r",
							"  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\r",
							"\r",
							"  // return encoded message\r",
							"  return '\\x00' + maskedSeed + maskedDB;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\r",
							" * label (L).\r",
							" *\r",
							" * This method does not perform RSA decryption, it only decodes the message\r",
							" * using RSAES-OAEP.\r",
							" *\r",
							" * @param key the RSA key to use.\r",
							" * @param em the encoded message to decode.\r",
							" * @param options the options to use:\r",
							" *          label an optional label to use.\r",
							" *          md the message digest object to use for OAEP, undefined for SHA-1.\r",
							" *          mgf1 optional mgf1 parameters:\r",
							" *            md the message digest object to use for MGF1.\r",
							" *\r",
							" * @return the decoded message bytes.\r",
							" */\r",
							"pkcs1.decode_rsa_oaep = function(key, em, options) {\r",
							"  // parse args\r",
							"  var label;\r",
							"  var md;\r",
							"  var mgf1Md;\r",
							"  // legacy args\r",
							"  if(typeof options === 'string') {\r",
							"    label = options;\r",
							"    md = arguments[3] || undefined;\r",
							"  } else if(options) {\r",
							"    label = options.label || undefined;\r",
							"    md = options.md || undefined;\r",
							"    if(options.mgf1 && options.mgf1.md) {\r",
							"      mgf1Md = options.mgf1.md;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // compute length in bytes\r",
							"  var keyLength = Math.ceil(key.n.bitLength() / 8);\r",
							"\r",
							"  if(em.length !== keyLength) {\r",
							"    var error = new Error('RSAES-OAEP encoded message length is invalid.');\r",
							"    error.length = em.length;\r",
							"    error.expectedLength = keyLength;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // default OAEP to SHA-1 message digest\r",
							"  if(md === undefined) {\r",
							"    md = forge.md.sha1.create();\r",
							"  } else {\r",
							"    md.start();\r",
							"  }\r",
							"\r",
							"  // default MGF-1 to same as OAEP\r",
							"  if(!mgf1Md) {\r",
							"    mgf1Md = md;\r",
							"  }\r",
							"\r",
							"  if(keyLength < 2 * md.digestLength + 2) {\r",
							"    throw new Error('RSAES-OAEP key is too short for the hash function.');\r",
							"  }\r",
							"\r",
							"  if(!label) {\r",
							"    label = '';\r",
							"  }\r",
							"  md.update(label, 'raw');\r",
							"  var lHash = md.digest().getBytes();\r",
							"\r",
							"  // split the message into its parts\r",
							"  var y = em.charAt(0);\r",
							"  var maskedSeed = em.substring(1, md.digestLength + 1);\r",
							"  var maskedDB = em.substring(1 + md.digestLength);\r",
							"\r",
							"  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\r",
							"  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\r",
							"\r",
							"  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\r",
							"  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\r",
							"\r",
							"  var lHashPrime = db.substring(0, md.digestLength);\r",
							"\r",
							"  // constant time check that all values match what is expected\r",
							"  var error = (y !== '\\x00');\r",
							"\r",
							"  // constant time check lHash vs lHashPrime\r",
							"  for(var i = 0; i < md.digestLength; ++i) {\r",
							"    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));\r",
							"  }\r",
							"\r",
							"  // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\r",
							"  // message\r",
							"  // TODO: It must be possible to do this in a better/smarter way?\r",
							"  var in_ps = 1;\r",
							"  var index = md.digestLength;\r",
							"  for(var j = md.digestLength; j < db.length; j++) {\r",
							"    var code = db.charCodeAt(j);\r",
							"\r",
							"    var is_0 = (code & 0x1) ^ 0x1;\r",
							"\r",
							"    // non-zero if not 0 or 1 in the ps section\r",
							"    var error_mask = in_ps ? 0xfffe : 0x0000;\r",
							"    error |= (code & error_mask);\r",
							"\r",
							"    // latch in_ps to zero after we find 0x1\r",
							"    in_ps = in_ps & is_0;\r",
							"    index += in_ps;\r",
							"  }\r",
							"\r",
							"  if(error || db.charCodeAt(index) !== 0x1) {\r",
							"    throw new Error('Invalid RSAES-OAEP padding.');\r",
							"  }\r",
							"\r",
							"  return db.substring(index + 1);\r",
							"};\r",
							"\r",
							"function rsa_mgf1(seed, maskLength, hash) {\r",
							"  // default to SHA-1 message digest\r",
							"  if(!hash) {\r",
							"    hash = forge.md.sha1.create();\r",
							"  }\r",
							"  var t = '';\r",
							"  var count = Math.ceil(maskLength / hash.digestLength);\r",
							"  for(var i = 0; i < count; ++i) {\r",
							"    var c = String.fromCharCode(\r",
							"      (i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);\r",
							"    hash.start();\r",
							"    hash.update(seed + c);\r",
							"    t += hash.digest().getBytes();\r",
							"  }\r",
							"  return t.substring(0, maskLength);\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 27 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Prime number generation API.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(12);\r",
							"__webpack_require__(2);\r",
							"\r",
							"(function() {\r",
							"\r",
							"// forge.prime already defined\r",
							"if(forge.prime) {\r",
							"  module.exports = forge.prime;\r",
							"  return;\r",
							"}\r",
							"\r",
							"/* PRIME API */\r",
							"var prime = module.exports = forge.prime = forge.prime || {};\r",
							"\r",
							"var BigInteger = forge.jsbn.BigInteger;\r",
							"\r",
							"// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\r",
							"var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\r",
							"var THIRTY = new BigInteger(null);\r",
							"THIRTY.fromInt(30);\r",
							"var op_or = function(x, y) {return x|y;};\r",
							"\r",
							"/**\r",
							" * Generates a random probable prime with the given number of bits.\r",
							" *\r",
							" * Alternative algorithms can be specified by name as a string or as an\r",
							" * object with custom options like so:\r",
							" *\r",
							" * {\r",
							" *   name: 'PRIMEINC',\r",
							" *   options: {\r",
							" *     maxBlockTime: <the maximum amount of time to block the main\r",
							" *       thread before allowing I/O other JS to run>,\r",
							" *     millerRabinTests: <the number of miller-rabin tests to run>,\r",
							" *     workerScript: <the worker script URL>,\r",
							" *     workers: <the number of web workers (if supported) to use,\r",
							" *       -1 to use estimated cores minus one>.\r",
							" *     workLoad: the size of the work load, ie: number of possible prime\r",
							" *       numbers for each web worker to check per work assignment,\r",
							" *       (default: 100).\r",
							" *   }\r",
							" * }\r",
							" *\r",
							" * @param bits the number of bits for the prime number.\r",
							" * @param options the options to use.\r",
							" *          [algorithm] the algorithm to use (default: 'PRIMEINC').\r",
							" *          [prng] a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" *\r",
							" * @return callback(err, num) called once the operation completes.\r",
							" */\r",
							"prime.generateProbablePrime = function(bits, options, callback) {\r",
							"  if(typeof options === 'function') {\r",
							"    callback = options;\r",
							"    options = {};\r",
							"  }\r",
							"  options = options || {};\r",
							"\r",
							"  // default to PRIMEINC algorithm\r",
							"  var algorithm = options.algorithm || 'PRIMEINC';\r",
							"  if(typeof algorithm === 'string') {\r",
							"    algorithm = {name: algorithm};\r",
							"  }\r",
							"  algorithm.options = algorithm.options || {};\r",
							"\r",
							"  // create prng with api that matches BigInteger secure random\r",
							"  var prng = options.prng || forge.random;\r",
							"  var rng = {\r",
							"    // x is an array to fill with bytes\r",
							"    nextBytes: function(x) {\r",
							"      var b = prng.getBytesSync(x.length);\r",
							"      for(var i = 0; i < x.length; ++i) {\r",
							"        x[i] = b.charCodeAt(i);\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  if(algorithm.name === 'PRIMEINC') {\r",
							"    return primeincFindPrime(bits, rng, algorithm.options, callback);\r",
							"  }\r",
							"\r",
							"  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);\r",
							"};\r",
							"\r",
							"function primeincFindPrime(bits, rng, options, callback) {\r",
							"  if('workers' in options) {\r",
							"    return primeincFindPrimeWithWorkers(bits, rng, options, callback);\r",
							"  }\r",
							"  return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\r",
							"}\r",
							"\r",
							"function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\r",
							"  // initialize random number\r",
							"  var num = generateRandom(bits, rng);\r",
							"\r",
							"  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\r",
							"  number we are given is always aligned at 30k + 1. Each time the number is\r",
							"  determined not to be prime we add to get to the next 'i', eg: if the number\r",
							"  was at 30k + 1 we add 6. */\r",
							"  var deltaIdx = 0;\r",
							"\r",
							"  // get required number of MR tests\r",
							"  var mrTests = getMillerRabinTests(num.bitLength());\r",
							"  if('millerRabinTests' in options) {\r",
							"    mrTests = options.millerRabinTests;\r",
							"  }\r",
							"\r",
							"  // find prime nearest to 'num' for maxBlockTime ms\r",
							"  // 10 ms gives 5ms of leeway for other calculations before dropping\r",
							"  // below 60fps (1000/60 == 16.67), but in reality, the number will\r",
							"  // likely be higher due to an 'atomic' big int modPow\r",
							"  var maxBlockTime = 10;\r",
							"  if('maxBlockTime' in options) {\r",
							"    maxBlockTime = options.maxBlockTime;\r",
							"  }\r",
							"\r",
							"  _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\r",
							"}\r",
							"\r",
							"function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\r",
							"  var start = +new Date();\r",
							"  do {\r",
							"    // overflow, regenerate random number\r",
							"    if(num.bitLength() > bits) {\r",
							"      num = generateRandom(bits, rng);\r",
							"    }\r",
							"    // do primality test\r",
							"    if(num.isProbablePrime(mrTests)) {\r",
							"      return callback(null, num);\r",
							"    }\r",
							"    // get next potential prime\r",
							"    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\r",
							"  } while(maxBlockTime < 0 || (+new Date() - start < maxBlockTime));\r",
							"\r",
							"  // keep trying later\r",
							"  forge.util.setImmediate(function() {\r",
							"    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\r",
							"  });\r",
							"}\r",
							"\r",
							"// NOTE: This algorithm is indeterminate in nature because workers\r",
							"// run in parallel looking at different segments of numbers. Even if this\r",
							"// algorithm is run twice with the same input from a predictable RNG, it\r",
							"// may produce different outputs.\r",
							"function primeincFindPrimeWithWorkers(bits, rng, options, callback) {\r",
							"  // web workers unavailable\r",
							"  if(typeof Worker === 'undefined') {\r",
							"    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\r",
							"  }\r",
							"\r",
							"  // initialize random number\r",
							"  var num = generateRandom(bits, rng);\r",
							"\r",
							"  // use web workers to generate keys\r",
							"  var numWorkers = options.workers;\r",
							"  var workLoad = options.workLoad || 100;\r",
							"  var range = workLoad * 30 / 8;\r",
							"  var workerScript = options.workerScript || 'forge/prime.worker.js';\r",
							"  if(numWorkers === -1) {\r",
							"    return forge.util.estimateCores(function(err, cores) {\r",
							"      if(err) {\r",
							"        // default to 2\r",
							"        cores = 2;\r",
							"      }\r",
							"      numWorkers = cores - 1;\r",
							"      generate();\r",
							"    });\r",
							"  }\r",
							"  generate();\r",
							"\r",
							"  function generate() {\r",
							"    // require at least 1 worker\r",
							"    numWorkers = Math.max(1, numWorkers);\r",
							"\r",
							"    // TODO: consider optimizing by starting workers outside getPrime() ...\r",
							"    // note that in order to clean up they will have to be made internally\r",
							"    // asynchronous which may actually be slower\r",
							"\r",
							"    // start workers immediately\r",
							"    var workers = [];\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      // FIXME: fix path or use blob URLs\r",
							"      workers[i] = new Worker(workerScript);\r",
							"    }\r",
							"    var running = numWorkers;\r",
							"\r",
							"    // listen for requests from workers and assign ranges to find prime\r",
							"    for(var i = 0; i < numWorkers; ++i) {\r",
							"      workers[i].addEventListener('message', workerMessage);\r",
							"    }\r",
							"\r",
							"    /* Note: The distribution of random numbers is unknown. Therefore, each\r",
							"    web worker is continuously allocated a range of numbers to check for a\r",
							"    random number until one is found.\r",
							"\r",
							"    Every 30 numbers will be checked just 8 times, because prime numbers\r",
							"    have the form:\r",
							"\r",
							"    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\r",
							"\r",
							"    Therefore, if we want a web worker to run N checks before asking for\r",
							"    a new range of numbers, each range must contain N*30/8 numbers.\r",
							"\r",
							"    For 100 checks (workLoad), this is a range of 375. */\r",
							"\r",
							"    var found = false;\r",
							"    function workerMessage(e) {\r",
							"      // ignore message, prime already found\r",
							"      if(found) {\r",
							"        return;\r",
							"      }\r",
							"\r",
							"      --running;\r",
							"      var data = e.data;\r",
							"      if(data.found) {\r",
							"        // terminate all workers\r",
							"        for(var i = 0; i < workers.length; ++i) {\r",
							"          workers[i].terminate();\r",
							"        }\r",
							"        found = true;\r",
							"        return callback(null, new BigInteger(data.prime, 16));\r",
							"      }\r",
							"\r",
							"      // overflow, regenerate random number\r",
							"      if(num.bitLength() > bits) {\r",
							"        num = generateRandom(bits, rng);\r",
							"      }\r",
							"\r",
							"      // assign new range to check\r",
							"      var hex = num.toString(16);\r",
							"\r",
							"      // start prime search\r",
							"      e.target.postMessage({\r",
							"        hex: hex,\r",
							"        workLoad: workLoad\r",
							"      });\r",
							"\r",
							"      num.dAddOffset(range, 0);\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Generates a random number using the given number of bits and RNG.\r",
							" *\r",
							" * @param bits the number of bits for the number.\r",
							" * @param rng the random number generator to use.\r",
							" *\r",
							" * @return the random number.\r",
							" */\r",
							"function generateRandom(bits, rng) {\r",
							"  var num = new BigInteger(bits, rng);\r",
							"  // force MSB set\r",
							"  var bits1 = bits - 1;\r",
							"  if(!num.testBit(bits1)) {\r",
							"    num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\r",
							"  }\r",
							"  // align number on 30k+1 boundary\r",
							"  num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\r",
							"  return num;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Returns the required number of Miller-Rabin tests to generate a\r",
							" * prime with an error probability of (1/2)^80.\r",
							" *\r",
							" * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\r",
							" *\r",
							" * @param bits the bit size.\r",
							" *\r",
							" * @return the required number of iterations.\r",
							" */\r",
							"function getMillerRabinTests(bits) {\r",
							"  if(bits <= 100) return 27;\r",
							"  if(bits <= 150) return 18;\r",
							"  if(bits <= 200) return 15;\r",
							"  if(bits <= 250) return 12;\r",
							"  if(bits <= 300) return 9;\r",
							"  if(bits <= 350) return 8;\r",
							"  if(bits <= 400) return 7;\r",
							"  if(bits <= 500) return 6;\r",
							"  if(bits <= 600) return 5;\r",
							"  if(bits <= 800) return 4;\r",
							"  if(bits <= 1250) return 3;\r",
							"  return 2;\r",
							"}\r",
							"\r",
							"})();\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 28 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of PKCS#12.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * The ASN.1 representation of PKCS#12 is as follows\r",
							" * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\r",
							" *\r",
							" * PFX ::= SEQUENCE {\r",
							" *   version  INTEGER {v3(3)}(v3,...),\r",
							" *   authSafe ContentInfo,\r",
							" *   macData  MacData OPTIONAL\r",
							" * }\r",
							" *\r",
							" * MacData ::= SEQUENCE {\r",
							" *   mac DigestInfo,\r",
							" *   macSalt OCTET STRING,\r",
							" *   iterations INTEGER DEFAULT 1\r",
							" * }\r",
							" * Note: The iterations default is for historical reasons and its use is\r",
							" * deprecated. A higher value, like 1024, is recommended.\r",
							" *\r",
							" * DigestInfo is defined in PKCS#7 as follows:\r",
							" *\r",
							" * DigestInfo ::= SEQUENCE {\r",
							" *   digestAlgorithm DigestAlgorithmIdentifier,\r",
							" *   digest Digest\r",
							" * }\r",
							" *\r",
							" * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r",
							" * for the algorithm, if any. In the case of SHA1 there is none.\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *    algorithm OBJECT IDENTIFIER,\r",
							" *    parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * Digest ::= OCTET STRING\r",
							" *\r",
							" *\r",
							" * ContentInfo ::= SEQUENCE {\r",
							" *   contentType ContentType,\r",
							" *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\r",
							" * }\r",
							" *\r",
							" * ContentType ::= OBJECT IDENTIFIER\r",
							" *\r",
							" * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r",
							" * -- Data if unencrypted\r",
							" * -- EncryptedData if password-encrypted\r",
							" * -- EnvelopedData if public key-encrypted\r",
							" *\r",
							" *\r",
							" * SafeContents ::= SEQUENCE OF SafeBag\r",
							" *\r",
							" * SafeBag ::= SEQUENCE {\r",
							" *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\r",
							" *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r",
							" *   bagAttributes SET OF PKCS12Attribute OPTIONAL\r",
							" * }\r",
							" *\r",
							" * PKCS12Attribute ::= SEQUENCE {\r",
							" *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\r",
							" *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\r",
							" * } -- This type is compatible with the X.500 type Attribute\r",
							" *\r",
							" * PKCS12AttrSet ATTRIBUTE ::= {\r",
							" *   friendlyName | -- from PKCS #9\r",
							" *   localKeyId, -- from PKCS #9\r",
							" *   ... -- Other attributes are allowed\r",
							" * }\r",
							" *\r",
							" * CertBag ::= SEQUENCE {\r",
							" *   certId    BAG-TYPE.&id   ({CertTypes}),\r",
							" *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r",
							" * }\r",
							" *\r",
							" * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\r",
							" *   -- DER-encoded X.509 certificate stored in OCTET STRING\r",
							" *\r",
							" * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\r",
							" * -- Base64-encoded SDSI certificate stored in IA5String\r",
							" *\r",
							" * CertTypes BAG-TYPE ::= {\r",
							" *   x509Certificate |\r",
							" *   sdsiCertificate,\r",
							" *   ... -- For future extensions\r",
							" * }\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(29);\r",
							"__webpack_require__(21);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(11);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(16);\r",
							"\r",
							"// shortcut for asn.1 & PKI API\r",
							"var asn1 = forge.asn1;\r",
							"var pki = forge.pki;\r",
							"\r",
							"// shortcut for PKCS#12 API\r",
							"var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\r",
							"\r",
							"var contentInfoValidator = {\r",
							"  name: 'ContentInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,  // a ContentInfo\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'ContentInfo.contentType',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'contentType'\r",
							"  }, {\r",
							"    name: 'ContentInfo.content',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'content'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var pfxValidator = {\r",
							"  name: 'PFX',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'PFX.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  },\r",
							"  contentInfoValidator, {\r",
							"    name: 'PFX.macData',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    captureAsn1: 'mac',\r",
							"    value: [{\r",
							"      name: 'PFX.macData.mac',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,  // DigestInfo\r",
							"      constructed: true,\r",
							"      value: [{\r",
							"        name: 'PFX.macData.mac.digestAlgorithm',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier\r",
							"        constructed: true,\r",
							"        value: [{\r",
							"          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          type: asn1.Type.OID,\r",
							"          constructed: false,\r",
							"          capture: 'macAlgorithm'\r",
							"        }, {\r",
							"          name: 'PFX.macData.mac.digestAlgorithm.parameters',\r",
							"          tagClass: asn1.Class.UNIVERSAL,\r",
							"          captureAsn1: 'macAlgorithmParameters'\r",
							"        }]\r",
							"      }, {\r",
							"        name: 'PFX.macData.mac.digest',\r",
							"        tagClass: asn1.Class.UNIVERSAL,\r",
							"        type: asn1.Type.OCTETSTRING,\r",
							"        constructed: false,\r",
							"        capture: 'macDigest'\r",
							"      }]\r",
							"    }, {\r",
							"      name: 'PFX.macData.macSalt',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OCTETSTRING,\r",
							"      constructed: false,\r",
							"      capture: 'macSalt'\r",
							"    }, {\r",
							"      name: 'PFX.macData.iterations',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      optional: true,\r",
							"      capture: 'macIterations'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"var safeBagValidator = {\r",
							"  name: 'SafeBag',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'SafeBag.bagId',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'bagId'\r",
							"  }, {\r",
							"    name: 'SafeBag.bagValue',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'bagValue'\r",
							"  }, {\r",
							"    name: 'SafeBag.bagAttributes',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'bagAttributes'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var attributeValidator = {\r",
							"  name: 'Attribute',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'Attribute.attrId',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'oid'\r",
							"  }, {\r",
							"    name: 'Attribute.attrValues',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    capture: 'values'\r",
							"  }]\r",
							"};\r",
							"\r",
							"var certBagValidator = {\r",
							"  name: 'CertBag',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'CertBag.certId',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'certId'\r",
							"  }, {\r",
							"    name: 'CertBag.certValue',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    constructed: true,\r",
							"    /* So far we only support X.509 certificates (which are wrapped in\r",
							"       an OCTET STRING, hence hard code that here). */\r",
							"    value: [{\r",
							"      name: 'CertBag.certValue[0]',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Class.OCTETSTRING,\r",
							"      constructed: false,\r",
							"      capture: 'cert'\r",
							"    }]\r",
							"  }]\r",
							"};\r",
							"\r",
							"/**\r",
							" * Search SafeContents structure for bags with matching attributes.\r",
							" *\r",
							" * The search can optionally be narrowed by a certain bag type.\r",
							" *\r",
							" * @param safeContents the SafeContents structure to search in.\r",
							" * @param attrName the name of the attribute to compare against.\r",
							" * @param attrValue the attribute value to search for.\r",
							" * @param [bagType] bag type to narrow search by.\r",
							" *\r",
							" * @return an array of matching bags.\r",
							" */\r",
							"function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\r",
							"  var result = [];\r",
							"\r",
							"  for(var i = 0; i < safeContents.length; i++) {\r",
							"    for(var j = 0; j < safeContents[i].safeBags.length; j++) {\r",
							"      var bag = safeContents[i].safeBags[j];\r",
							"      if(bagType !== undefined && bag.type !== bagType) {\r",
							"        continue;\r",
							"      }\r",
							"      // only filter by bag type, no attribute specified\r",
							"      if(attrName === null) {\r",
							"        result.push(bag);\r",
							"        continue;\r",
							"      }\r",
							"      if(bag.attributes[attrName] !== undefined &&\r",
							"        bag.attributes[attrName].indexOf(attrValue) >= 0) {\r",
							"        result.push(bag);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return result;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\r",
							" *\r",
							" * @param obj The PKCS#12 PFX in ASN.1 notation.\r",
							" * @param strict true to use strict DER decoding, false not to (default: true).\r",
							" * @param {String} password Password to decrypt with (optional).\r",
							" *\r",
							" * @return PKCS#12 PFX object.\r",
							" */\r",
							"p12.pkcs12FromAsn1 = function(obj, strict, password) {\r",
							"  // handle args\r",
							"  if(typeof strict === 'string') {\r",
							"    password = strict;\r",
							"    strict = true;\r",
							"  } else if(strict === undefined) {\r",
							"    strict = true;\r",
							"  }\r",
							"\r",
							"  // validate PFX and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, pfxValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#12 PFX. ' +\r",
							"      'ASN.1 object is not an PKCS#12 PFX.');\r",
							"    error.errors = error;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var pfx = {\r",
							"    version: capture.version.charCodeAt(0),\r",
							"    safeContents: [],\r",
							"\r",
							"    /**\r",
							"     * Gets bags with matching attributes.\r",
							"     *\r",
							"     * @param filter the attributes to filter by:\r",
							"     *          [localKeyId] the localKeyId to search for.\r",
							"     *          [localKeyIdHex] the localKeyId in hex to search for.\r",
							"     *          [friendlyName] the friendly name to search for.\r",
							"     *          [bagType] bag type to narrow each attribute search by.\r",
							"     *\r",
							"     * @return a map of attribute type to an array of matching bags or, if no\r",
							"     *           attribute was given but a bag type, the map key will be the\r",
							"     *           bag type.\r",
							"     */\r",
							"    getBags: function(filter) {\r",
							"      var rval = {};\r",
							"\r",
							"      var localKeyId;\r",
							"      if('localKeyId' in filter) {\r",
							"        localKeyId = filter.localKeyId;\r",
							"      } else if('localKeyIdHex' in filter) {\r",
							"        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\r",
							"      }\r",
							"\r",
							"      // filter on bagType only\r",
							"      if(localKeyId === undefined && !('friendlyName' in filter) &&\r",
							"        'bagType' in filter) {\r",
							"        rval[filter.bagType] = _getBagsByAttribute(\r",
							"          pfx.safeContents, null, null, filter.bagType);\r",
							"      }\r",
							"\r",
							"      if(localKeyId !== undefined) {\r",
							"        rval.localKeyId = _getBagsByAttribute(\r",
							"          pfx.safeContents, 'localKeyId',\r",
							"          localKeyId, filter.bagType);\r",
							"      }\r",
							"      if('friendlyName' in filter) {\r",
							"        rval.friendlyName = _getBagsByAttribute(\r",
							"          pfx.safeContents, 'friendlyName',\r",
							"          filter.friendlyName, filter.bagType);\r",
							"      }\r",
							"\r",
							"      return rval;\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * DEPRECATED: use getBags() instead.\r",
							"     *\r",
							"     * Get bags with matching friendlyName attribute.\r",
							"     *\r",
							"     * @param friendlyName the friendly name to search for.\r",
							"     * @param [bagType] bag type to narrow search by.\r",
							"     *\r",
							"     * @return an array of bags with matching friendlyName attribute.\r",
							"     */\r",
							"    getBagsByFriendlyName: function(friendlyName, bagType) {\r",
							"      return _getBagsByAttribute(\r",
							"        pfx.safeContents, 'friendlyName', friendlyName, bagType);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * DEPRECATED: use getBags() instead.\r",
							"     *\r",
							"     * Get bags with matching localKeyId attribute.\r",
							"     *\r",
							"     * @param localKeyId the localKeyId to search for.\r",
							"     * @param [bagType] bag type to narrow search by.\r",
							"     *\r",
							"     * @return an array of bags with matching localKeyId attribute.\r",
							"     */\r",
							"    getBagsByLocalKeyId: function(localKeyId, bagType) {\r",
							"      return _getBagsByAttribute(\r",
							"        pfx.safeContents, 'localKeyId', localKeyId, bagType);\r",
							"    }\r",
							"  };\r",
							"\r",
							"  if(capture.version.charCodeAt(0) !== 3) {\r",
							"    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\r",
							"    error.version = capture.version.charCodeAt(0);\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {\r",
							"    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\r",
							"    error.oid = asn1.derToOid(capture.contentType);\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var data = capture.content.value[0];\r",
							"  if(data.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"     data.type !== asn1.Type.OCTETSTRING) {\r",
							"    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\r",
							"  }\r",
							"  data = _decodePkcs7Data(data);\r",
							"\r",
							"  // check for MAC\r",
							"  if(capture.mac) {\r",
							"    var md = null;\r",
							"    var macKeyBytes = 0;\r",
							"    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\r",
							"    switch(macAlgorithm) {\r",
							"    case pki.oids.sha1:\r",
							"      md = forge.md.sha1.create();\r",
							"      macKeyBytes = 20;\r",
							"      break;\r",
							"    case pki.oids.sha256:\r",
							"      md = forge.md.sha256.create();\r",
							"      macKeyBytes = 32;\r",
							"      break;\r",
							"    case pki.oids.sha384:\r",
							"      md = forge.md.sha384.create();\r",
							"      macKeyBytes = 48;\r",
							"      break;\r",
							"    case pki.oids.sha512:\r",
							"      md = forge.md.sha512.create();\r",
							"      macKeyBytes = 64;\r",
							"      break;\r",
							"    case pki.oids.md5:\r",
							"      md = forge.md.md5.create();\r",
							"      macKeyBytes = 16;\r",
							"      break;\r",
							"    }\r",
							"    if(md === null) {\r",
							"      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\r",
							"    }\r",
							"\r",
							"    // verify MAC (iterations default to 1)\r",
							"    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\r",
							"    var macIterations = (('macIterations' in capture) ?\r",
							"      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);\r",
							"    var macKey = p12.generateKey(\r",
							"      password, macSalt, 3, macIterations, macKeyBytes, md);\r",
							"    var mac = forge.hmac.create();\r",
							"    mac.start(md, macKey);\r",
							"    mac.update(data.value);\r",
							"    var macValue = mac.getMac();\r",
							"    if(macValue.getBytes() !== capture.macDigest) {\r",
							"      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\r",
							"  return pfx;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\r",
							" * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\r",
							" * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\r",
							" * function transforms this corner-case into the usual simple,\r",
							" * non-composed/constructed OCTET STRING.\r",
							" *\r",
							" * This function may be moved to ASN.1 at some point to better deal with\r",
							" * more BER-encoding issues, should they arise.\r",
							" *\r",
							" * @param data the ASN.1 Data object to transform.\r",
							" */\r",
							"function _decodePkcs7Data(data) {\r",
							"  // handle special case of \"chunked\" data content: an octet string composed\r",
							"  // of other octet strings\r",
							"  if(data.composed || data.constructed) {\r",
							"    var value = forge.util.createBuffer();\r",
							"    for(var i = 0; i < data.value.length; ++i) {\r",
							"      value.putBytes(data.value[i].value);\r",
							"    }\r",
							"    data.composed = data.constructed = false;\r",
							"    data.value = value.getBytes();\r",
							"  }\r",
							"  return data;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\r",
							" *\r",
							" * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\r",
							" *\r",
							" * @param pfx The PKCS#12 PFX object to fill.\r",
							" * @param {String} authSafe BER-encoded AuthenticatedSafe.\r",
							" * @param strict true to use strict DER decoding, false not to.\r",
							" * @param {String} password Password to decrypt with (optional).\r",
							" */\r",
							"function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\r",
							"  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */\r",
							"\r",
							"  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"     authSafe.type !== asn1.Type.SEQUENCE ||\r",
							"     authSafe.constructed !== true) {\r",
							"    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +\r",
							"      'SEQUENCE OF ContentInfo');\r",
							"  }\r",
							"\r",
							"  for(var i = 0; i < authSafe.value.length; i++) {\r",
							"    var contentInfo = authSafe.value[i];\r",
							"\r",
							"    // validate contentInfo and capture data\r",
							"    var capture = {};\r",
							"    var errors = [];\r",
							"    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\r",
							"      var error = new Error('Cannot read ContentInfo.');\r",
							"      error.errors = errors;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    var obj = {\r",
							"      encrypted: false\r",
							"    };\r",
							"    var safeContents = null;\r",
							"    var data = capture.content.value[0];\r",
							"    switch(asn1.derToOid(capture.contentType)) {\r",
							"    case pki.oids.data:\r",
							"      if(data.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"         data.type !== asn1.Type.OCTETSTRING) {\r",
							"        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\r",
							"      }\r",
							"      safeContents = _decodePkcs7Data(data).value;\r",
							"      break;\r",
							"    case pki.oids.encryptedData:\r",
							"      safeContents = _decryptSafeContents(data, password);\r",
							"      obj.encrypted = true;\r",
							"      break;\r",
							"    default:\r",
							"      var error = new Error('Unsupported PKCS#12 contentType.');\r",
							"      error.contentType = asn1.derToOid(capture.contentType);\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\r",
							"    pfx.safeContents.push(obj);\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decrypt PKCS#7 EncryptedData structure.\r",
							" *\r",
							" * @param data ASN.1 encoded EncryptedContentInfo object.\r",
							" * @param password The user-provided password.\r",
							" *\r",
							" * @return The decrypted SafeContents (ASN.1 object).\r",
							" */\r",
							"function _decryptSafeContents(data, password) {\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(\r",
							"    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read EncryptedContentInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var oid = asn1.derToOid(capture.contentType);\r",
							"  if(oid !== pki.oids.data) {\r",
							"    var error = new Error(\r",
							"      'PKCS#12 EncryptedContentInfo ContentType is not Data.');\r",
							"    error.oid = oid;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // get cipher\r",
							"  oid = asn1.derToOid(capture.encAlgorithm);\r",
							"  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\r",
							"\r",
							"  // get encrypted data\r",
							"  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\r",
							"  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\r",
							"\r",
							"  cipher.update(encrypted);\r",
							"  if(!cipher.finish()) {\r",
							"    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\r",
							"  }\r",
							"\r",
							"  return cipher.output.getBytes();\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\r",
							" *\r",
							" * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\r",
							" *\r",
							" * @param {String} safeContents BER-encoded safeContents.\r",
							" * @param strict true to use strict DER decoding, false not to.\r",
							" * @param {String} password Password to decrypt with (optional).\r",
							" *\r",
							" * @return {Array} Array of Bag objects.\r",
							" */\r",
							"function _decodeSafeContents(safeContents, strict, password) {\r",
							"  // if strict and no safe contents, return empty safes\r",
							"  if(!strict && safeContents.length === 0) {\r",
							"    return [];\r",
							"  }\r",
							"\r",
							"  // actually it's BER-encoded\r",
							"  safeContents = asn1.fromDer(safeContents, strict);\r",
							"\r",
							"  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||\r",
							"    safeContents.type !== asn1.Type.SEQUENCE ||\r",
							"    safeContents.constructed !== true) {\r",
							"    throw new Error(\r",
							"      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\r",
							"  }\r",
							"\r",
							"  var res = [];\r",
							"  for(var i = 0; i < safeContents.value.length; i++) {\r",
							"    var safeBag = safeContents.value[i];\r",
							"\r",
							"    // validate SafeBag and capture data\r",
							"    var capture = {};\r",
							"    var errors = [];\r",
							"    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\r",
							"      var error = new Error('Cannot read SafeBag.');\r",
							"      error.errors = errors;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    /* Create bag object and push to result array. */\r",
							"    var bag = {\r",
							"      type: asn1.derToOid(capture.bagId),\r",
							"      attributes: _decodeBagAttributes(capture.bagAttributes)\r",
							"    };\r",
							"    res.push(bag);\r",
							"\r",
							"    var validator, decoder;\r",
							"    var bagAsn1 = capture.bagValue.value[0];\r",
							"    switch(bag.type) {\r",
							"      case pki.oids.pkcs8ShroudedKeyBag:\r",
							"        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\r",
							"           Afterwards we can handle it like a keyBag,\r",
							"           which is a PrivateKeyInfo. */\r",
							"        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\r",
							"        if(bagAsn1 === null) {\r",
							"          throw new Error(\r",
							"            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\r",
							"        }\r",
							"\r",
							"        /* fall through */\r",
							"      case pki.oids.keyBag:\r",
							"        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\r",
							"           PKI module, hence we don't have to do validation/capturing here,\r",
							"           just pass what we already got. */\r",
							"        try {\r",
							"          bag.key = pki.privateKeyFromAsn1(bagAsn1);\r",
							"        } catch(e) {\r",
							"          // ignore unknown key type, pass asn1 value\r",
							"          bag.key = null;\r",
							"          bag.asn1 = bagAsn1;\r",
							"        }\r",
							"        continue;  /* Nothing more to do. */\r",
							"\r",
							"      case pki.oids.certBag:\r",
							"        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\r",
							"           Therefore put the SafeBag content through another validator to\r",
							"           capture the fields.  Afterwards check & store the results. */\r",
							"        validator = certBagValidator;\r",
							"        decoder = function() {\r",
							"          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\r",
							"            var error = new Error(\r",
							"              'Unsupported certificate type, only X.509 supported.');\r",
							"            error.oid = asn1.derToOid(capture.certId);\r",
							"            throw error;\r",
							"          }\r",
							"\r",
							"          // true=produce cert hash\r",
							"          var certAsn1 = asn1.fromDer(capture.cert, strict);\r",
							"          try {\r",
							"            bag.cert = pki.certificateFromAsn1(certAsn1, true);\r",
							"          } catch(e) {\r",
							"            // ignore unknown cert type, pass asn1 value\r",
							"            bag.cert = null;\r",
							"            bag.asn1 = certAsn1;\r",
							"          }\r",
							"        };\r",
							"        break;\r",
							"\r",
							"      default:\r",
							"        var error = new Error('Unsupported PKCS#12 SafeBag type.');\r",
							"        error.oid = bag.type;\r",
							"        throw error;\r",
							"    }\r",
							"\r",
							"    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\r",
							"    if(validator !== undefined &&\r",
							"       !asn1.validate(bagAsn1, validator, capture, errors)) {\r",
							"      var error = new Error('Cannot read PKCS#12 ' + validator.name);\r",
							"      error.errors = errors;\r",
							"      throw error;\r",
							"    }\r",
							"\r",
							"    /* Call decoder function from above to store the results. */\r",
							"    decoder();\r",
							"  }\r",
							"\r",
							"  return res;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\r",
							" *\r",
							" * @param attributes SET OF PKCS12Attribute (ASN.1 object).\r",
							" *\r",
							" * @return the decoded attributes.\r",
							" */\r",
							"function _decodeBagAttributes(attributes) {\r",
							"  var decodedAttrs = {};\r",
							"\r",
							"  if(attributes !== undefined) {\r",
							"    for(var i = 0; i < attributes.length; ++i) {\r",
							"      var capture = {};\r",
							"      var errors = [];\r",
							"      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\r",
							"        var error = new Error('Cannot read PKCS#12 BagAttribute.');\r",
							"        error.errors = errors;\r",
							"        throw error;\r",
							"      }\r",
							"\r",
							"      var oid = asn1.derToOid(capture.oid);\r",
							"      if(pki.oids[oid] === undefined) {\r",
							"        // unsupported attribute type, ignore.\r",
							"        continue;\r",
							"      }\r",
							"\r",
							"      decodedAttrs[pki.oids[oid]] = [];\r",
							"      for(var j = 0; j < capture.values.length; ++j) {\r",
							"        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return decodedAttrs;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\r",
							" * password is provided then the private key will be encrypted.\r",
							" *\r",
							" * An entire certificate chain may also be included. To do this, pass\r",
							" * an array for the \"cert\" parameter where the first certificate is\r",
							" * the one that is paired with the private key and each subsequent one\r",
							" * verifies the previous one. The certificates may be in PEM format or\r",
							" * have been already parsed by Forge.\r",
							" *\r",
							" * @todo implement password-based-encryption for the whole package\r",
							" *\r",
							" * @param key the private key.\r",
							" * @param cert the certificate (may be an array of certificates in order\r",
							" *          to specify a certificate chain).\r",
							" * @param password the password to use, null for none.\r",
							" * @param options:\r",
							" *          algorithm the encryption algorithm to use\r",
							" *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r",
							" *          count the iteration count to use.\r",
							" *          saltSize the salt size to use.\r",
							" *          useMac true to include a MAC, false not to, defaults to true.\r",
							" *          localKeyId the local key ID to use, in hex.\r",
							" *          friendlyName the friendly name to use.\r",
							" *          generateLocalKeyId true to generate a random local key ID,\r",
							" *            false not to, defaults to true.\r",
							" *\r",
							" * @return the PKCS#12 PFX ASN.1 object.\r",
							" */\r",
							"p12.toPkcs12Asn1 = function(key, cert, password, options) {\r",
							"  // set default options\r",
							"  options = options || {};\r",
							"  options.saltSize = options.saltSize || 8;\r",
							"  options.count = options.count || 2048;\r",
							"  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\r",
							"  if(!('useMac' in options)) {\r",
							"    options.useMac = true;\r",
							"  }\r",
							"  if(!('localKeyId' in options)) {\r",
							"    options.localKeyId = null;\r",
							"  }\r",
							"  if(!('generateLocalKeyId' in options)) {\r",
							"    options.generateLocalKeyId = true;\r",
							"  }\r",
							"\r",
							"  var localKeyId = options.localKeyId;\r",
							"  var bagAttrs;\r",
							"  if(localKeyId !== null) {\r",
							"    localKeyId = forge.util.hexToBytes(localKeyId);\r",
							"  } else if(options.generateLocalKeyId) {\r",
							"    // use SHA-1 of paired cert, if available\r",
							"    if(cert) {\r",
							"      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\r",
							"      if(typeof pairedCert === 'string') {\r",
							"        pairedCert = pki.certificateFromPem(pairedCert);\r",
							"      }\r",
							"      var sha1 = forge.md.sha1.create();\r",
							"      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\r",
							"      localKeyId = sha1.digest().getBytes();\r",
							"    } else {\r",
							"      // FIXME: consider using SHA-1 of public key (which can be generated\r",
							"      // from private key components), see: cert.generateSubjectKeyIdentifier\r",
							"      // generate random bytes\r",
							"      localKeyId = forge.random.getBytes(20);\r",
							"    }\r",
							"  }\r",
							"\r",
							"  var attrs = [];\r",
							"  if(localKeyId !== null) {\r",
							"    attrs.push(\r",
							"      // localKeyID\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // attrId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.localKeyId).getBytes()),\r",
							"        // attrValues\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"            localKeyId)\r",
							"        ])\r",
							"      ]));\r",
							"  }\r",
							"  if('friendlyName' in options) {\r",
							"    attrs.push(\r",
							"      // friendlyName\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // attrId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.friendlyName).getBytes()),\r",
							"        // attrValues\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,\r",
							"            options.friendlyName)\r",
							"        ])\r",
							"      ]));\r",
							"  }\r",
							"\r",
							"  if(attrs.length > 0) {\r",
							"    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\r",
							"  }\r",
							"\r",
							"  // collect contents for AuthenticatedSafe\r",
							"  var contents = [];\r",
							"\r",
							"  // create safe bag(s) for certificate chain\r",
							"  var chain = [];\r",
							"  if(cert !== null) {\r",
							"    if(forge.util.isArray(cert)) {\r",
							"      chain = cert;\r",
							"    } else {\r",
							"      chain = [cert];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  var certSafeBags = [];\r",
							"  for(var i = 0; i < chain.length; ++i) {\r",
							"    // convert cert from PEM as necessary\r",
							"    cert = chain[i];\r",
							"    if(typeof cert === 'string') {\r",
							"      cert = pki.certificateFromPem(cert);\r",
							"    }\r",
							"\r",
							"    // SafeBag\r",
							"    var certBagAttrs = (i === 0) ? bagAttrs : undefined;\r",
							"    var certAsn1 = pki.certificateToAsn1(cert);\r",
							"    var certSafeBag =\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // bagId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.certBag).getBytes()),\r",
							"        // bagValue\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          // CertBag\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            // certId\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\r",
							"            // certValue (x509Certificate)\r",
							"            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"              asn1.create(\r",
							"                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"                asn1.toDer(certAsn1).getBytes())\r",
							"            ])])]),\r",
							"        // bagAttributes (OPTIONAL)\r",
							"        certBagAttrs\r",
							"      ]);\r",
							"    certSafeBags.push(certSafeBag);\r",
							"  }\r",
							"\r",
							"  if(certSafeBags.length > 0) {\r",
							"    // SafeContents\r",
							"    var certSafeContents = asn1.create(\r",
							"      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\r",
							"\r",
							"    // ContentInfo\r",
							"    var certCI =\r",
							"      // PKCS#7 ContentInfo\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // contentType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          // OID for the content type is 'data'\r",
							"          asn1.oidToDer(pki.oids.data).getBytes()),\r",
							"        // content\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"            asn1.toDer(certSafeContents).getBytes())\r",
							"        ])\r",
							"      ]);\r",
							"    contents.push(certCI);\r",
							"  }\r",
							"\r",
							"  // create safe contents for private key\r",
							"  var keyBag = null;\r",
							"  if(key !== null) {\r",
							"    // SafeBag\r",
							"    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\r",
							"    if(password === null) {\r",
							"      // no encryption\r",
							"      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // bagId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.keyBag).getBytes()),\r",
							"        // bagValue\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          // PrivateKeyInfo\r",
							"          pkAsn1\r",
							"        ]),\r",
							"        // bagAttributes (OPTIONAL)\r",
							"        bagAttrs\r",
							"      ]);\r",
							"    } else {\r",
							"      // encrypted PrivateKeyInfo\r",
							"      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // bagId\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\r",
							"        // bagValue\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          // EncryptedPrivateKeyInfo\r",
							"          pki.encryptPrivateKeyInfo(pkAsn1, password, options)\r",
							"        ]),\r",
							"        // bagAttributes (OPTIONAL)\r",
							"        bagAttrs\r",
							"      ]);\r",
							"    }\r",
							"\r",
							"    // SafeContents\r",
							"    var keySafeContents =\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\r",
							"\r",
							"    // ContentInfo\r",
							"    var keyCI =\r",
							"      // PKCS#7 ContentInfo\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // contentType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          // OID for the content type is 'data'\r",
							"          asn1.oidToDer(pki.oids.data).getBytes()),\r",
							"        // content\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"            asn1.toDer(keySafeContents).getBytes())\r",
							"        ])\r",
							"      ]);\r",
							"    contents.push(keyCI);\r",
							"  }\r",
							"\r",
							"  // create AuthenticatedSafe by stringing together the contents\r",
							"  var safe = asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\r",
							"\r",
							"  var macData;\r",
							"  if(options.useMac) {\r",
							"    // MacData\r",
							"    var sha1 = forge.md.sha1.create();\r",
							"    var macSalt = new forge.util.ByteBuffer(\r",
							"      forge.random.getBytes(options.saltSize));\r",
							"    var count = options.count;\r",
							"    // 160-bit key\r",
							"    var key = p12.generateKey(password, macSalt, 3, count, 20);\r",
							"    var mac = forge.hmac.create();\r",
							"    mac.start(sha1, key);\r",
							"    mac.update(asn1.toDer(safe).getBytes());\r",
							"    var macValue = mac.getMac();\r",
							"    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // mac DigestInfo\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // digestAlgorithm\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // algorithm = SHA-1\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(pki.oids.sha1).getBytes()),\r",
							"          // parameters = Null\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"        ]),\r",
							"        // digest\r",
							"        asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\r",
							"          false, macValue.getBytes())\r",
							"      ]),\r",
							"      // macSalt OCTET STRING\r",
							"      asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\r",
							"      // iterations INTEGER (XXX: Only support count < 65536)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        asn1.integerToDer(count).getBytes()\r",
							"      )\r",
							"    ]);\r",
							"  }\r",
							"\r",
							"  // PFX\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version (3)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(3).getBytes()),\r",
							"    // PKCS#7 ContentInfo\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // contentType\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        // OID for the content type is 'data'\r",
							"        asn1.oidToDer(pki.oids.data).getBytes()),\r",
							"      // content\r",
							"      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"        asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"          asn1.toDer(safe).getBytes())\r",
							"      ])\r",
							"    ]),\r",
							"    macData\r",
							"  ]);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Derives a PKCS#12 key.\r",
							" *\r",
							" * @param password the password to derive the key material from, null or\r",
							" *          undefined for none.\r",
							" * @param salt the salt, as a ByteBuffer, to use.\r",
							" * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r",
							" * @param iter the iteration count.\r",
							" * @param n the number of bytes to derive from the password.\r",
							" * @param md the message digest to use, defaults to SHA-1.\r",
							" *\r",
							" * @return a ByteBuffer with the bytes derived from the password.\r",
							" */\r",
							"p12.generateKey = forge.pbe.generatePkcs12Key;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 29 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright (c) 2012-2015 Digital Bazaar, Inc.\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" *\r",
							" * The ASN.1 representation of PKCS#7 is as follows\r",
							" * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):\r",
							" *\r",
							" * A PKCS#7 message consists of a ContentInfo on root level, which may\r",
							" * contain any number of further ContentInfo nested into it.\r",
							" *\r",
							" * ContentInfo ::= SEQUENCE {\r",
							" *   contentType                ContentType,\r",
							" *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL\r",
							" * }\r",
							" *\r",
							" * ContentType ::= OBJECT IDENTIFIER\r",
							" *\r",
							" * EnvelopedData ::= SEQUENCE {\r",
							" *   version                    Version,\r",
							" *   recipientInfos             RecipientInfos,\r",
							" *   encryptedContentInfo       EncryptedContentInfo\r",
							" * }\r",
							" *\r",
							" * EncryptedData ::= SEQUENCE {\r",
							" *   version                    Version,\r",
							" *   encryptedContentInfo       EncryptedContentInfo\r",
							" * }\r",
							" *\r",
							" * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)\r",
							" *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }\r",
							" *\r",
							" * SignedData ::= SEQUENCE {\r",
							" *   version           INTEGER,\r",
							" *   digestAlgorithms  DigestAlgorithmIdentifiers,\r",
							" *   contentInfo       ContentInfo,\r",
							" *   certificates      [0] IMPLICIT Certificates OPTIONAL,\r",
							" *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,\r",
							" *   signerInfos       SignerInfos\r",
							" * }\r",
							" *\r",
							" * SignerInfos ::= SET OF SignerInfo\r",
							" *\r",
							" * SignerInfo ::= SEQUENCE {\r",
							" *   version                    Version,\r",
							" *   issuerAndSerialNumber      IssuerAndSerialNumber,\r",
							" *   digestAlgorithm            DigestAlgorithmIdentifier,\r",
							" *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,\r",
							" *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,\r",
							" *   encryptedDigest            EncryptedDigest,\r",
							" *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL\r",
							" * }\r",
							" *\r",
							" * EncryptedDigest ::= OCTET STRING\r",
							" *\r",
							" * Attributes ::= SET OF Attribute\r",
							" *\r",
							" * Attribute ::= SEQUENCE {\r",
							" *   attrType    OBJECT IDENTIFIER,\r",
							" *   attrValues  SET OF AttributeValue\r",
							" * }\r",
							" *\r",
							" * AttributeValue ::= ANY\r",
							" *\r",
							" * Version ::= INTEGER\r",
							" *\r",
							" * RecipientInfos ::= SET OF RecipientInfo\r",
							" *\r",
							" * EncryptedContentInfo ::= SEQUENCE {\r",
							" *   contentType                 ContentType,\r",
							" *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,\r",
							" *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL\r",
							" * }\r",
							" *\r",
							" * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r",
							" * for the algorithm, if any. In the case of AES and DES3, there is only one,\r",
							" * the IV.\r",
							" *\r",
							" * AlgorithmIdentifer ::= SEQUENCE {\r",
							" *    algorithm OBJECT IDENTIFIER,\r",
							" *    parameters ANY DEFINED BY algorithm OPTIONAL\r",
							" * }\r",
							" *\r",
							" * EncryptedContent ::= OCTET STRING\r",
							" *\r",
							" * RecipientInfo ::= SEQUENCE {\r",
							" *   version                     Version,\r",
							" *   issuerAndSerialNumber       IssuerAndSerialNumber,\r",
							" *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,\r",
							" *   encryptedKey                EncryptedKey\r",
							" * }\r",
							" *\r",
							" * IssuerAndSerialNumber ::= SEQUENCE {\r",
							" *   issuer                      Name,\r",
							" *   serialNumber                CertificateSerialNumber\r",
							" * }\r",
							" *\r",
							" * CertificateSerialNumber ::= INTEGER\r",
							" *\r",
							" * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\r",
							" *\r",
							" * EncryptedKey ::= OCTET STRING\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// shortcut for ASN.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"// shortcut for PKCS#7 API\r",
							"var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};\r",
							"forge.pkcs7 = forge.pkcs7 || {};\r",
							"forge.pkcs7.asn1 = p7v;\r",
							"\r",
							"var contentInfoValidator = {\r",
							"  name: 'ContentInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'ContentInfo.ContentType',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'contentType'\r",
							"  }, {\r",
							"    name: 'ContentInfo.content',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    captureAsn1: 'content'\r",
							"  }]\r",
							"};\r",
							"p7v.contentInfoValidator = contentInfoValidator;\r",
							"\r",
							"var encryptedContentInfoValidator = {\r",
							"  name: 'EncryptedContentInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EncryptedContentInfo.contentType',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OID,\r",
							"    constructed: false,\r",
							"    capture: 'contentType'\r",
							"  }, {\r",
							"    name: 'EncryptedContentInfo.contentEncryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encAlgorithm'\r",
							"    }, {\r",
							"      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      captureAsn1: 'encParameter'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'EncryptedContentInfo.encryptedContent',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    /* The PKCS#7 structure output by OpenSSL somewhat differs from what\r",
							"     * other implementations do generate.\r",
							"     *\r",
							"     * OpenSSL generates a structure like this:\r",
							"     * SEQUENCE {\r",
							"     *    ...\r",
							"     *    [0]\r",
							"     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\r",
							"     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\r",
							"     *       ...\r",
							"     * }\r",
							"     *\r",
							"     * Whereas other implementations (and this PKCS#7 module) generate:\r",
							"     * SEQUENCE {\r",
							"     *    ...\r",
							"     *    [0] {\r",
							"     *       OCTET STRING\r",
							"     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\r",
							"     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\r",
							"     *          ...\r",
							"     *    }\r",
							"     * }\r",
							"     *\r",
							"     * In order to support both, we just capture the context specific\r",
							"     * field here.  The OCTET STRING bit is removed below.\r",
							"     */\r",
							"    capture: 'encryptedContent',\r",
							"    captureAsn1: 'encryptedContentAsn1'\r",
							"  }]\r",
							"};\r",
							"\r",
							"p7v.envelopedDataValidator = {\r",
							"  name: 'EnvelopedData',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EnvelopedData.Version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }, {\r",
							"    name: 'EnvelopedData.RecipientInfos',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'recipientInfos'\r",
							"  }].concat(encryptedContentInfoValidator)\r",
							"};\r",
							"\r",
							"p7v.encryptedDataValidator = {\r",
							"  name: 'EncryptedData',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'EncryptedData.Version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }].concat(encryptedContentInfoValidator)\r",
							"};\r",
							"\r",
							"var signerValidator = {\r",
							"  name: 'SignerInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'SignerInfo.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false\r",
							"  }, {\r",
							"    name: 'SignerInfo.issuerAndSerialNumber',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'SignerInfo.issuerAndSerialNumber.issuer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'issuer'\r",
							"    }, {\r",
							"      name: 'SignerInfo.issuerAndSerialNumber.serialNumber',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'serial'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'SignerInfo.digestAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'SignerInfo.digestAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'digestAlgorithm'\r",
							"    }, {\r",
							"      name: 'SignerInfo.digestAlgorithm.parameter',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      constructed: false,\r",
							"      captureAsn1: 'digestParameter',\r",
							"      optional: true\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'SignerInfo.authenticatedAttributes',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'authenticatedAttributes'\r",
							"  }, {\r",
							"    name: 'SignerInfo.digestEncryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    capture: 'signatureAlgorithm'\r",
							"  }, {\r",
							"    name: 'SignerInfo.encryptedDigest',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'signature'\r",
							"  }, {\r",
							"    name: 'SignerInfo.unauthenticatedAttributes',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 1,\r",
							"    constructed: true,\r",
							"    optional: true,\r",
							"    capture: 'unauthenticatedAttributes'\r",
							"  }]\r",
							"};\r",
							"\r",
							"p7v.signedDataValidator = {\r",
							"  name: 'SignedData',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'SignedData.Version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }, {\r",
							"    name: 'SignedData.DigestAlgorithms',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    constructed: true,\r",
							"    captureAsn1: 'digestAlgorithms'\r",
							"  },\r",
							"  contentInfoValidator,\r",
							"  {\r",
							"    name: 'SignedData.Certificates',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 0,\r",
							"    optional: true,\r",
							"    captureAsn1: 'certificates'\r",
							"  }, {\r",
							"    name: 'SignedData.CertificateRevocationLists',\r",
							"    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r",
							"    type: 1,\r",
							"    optional: true,\r",
							"    captureAsn1: 'crls'\r",
							"  }, {\r",
							"    name: 'SignedData.SignerInfos',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SET,\r",
							"    capture: 'signerInfos',\r",
							"    optional: true,\r",
							"    value: [signerValidator]\r",
							"  }]\r",
							"};\r",
							"\r",
							"p7v.recipientInfoValidator = {\r",
							"  name: 'RecipientInfo',\r",
							"  tagClass: asn1.Class.UNIVERSAL,\r",
							"  type: asn1.Type.SEQUENCE,\r",
							"  constructed: true,\r",
							"  value: [{\r",
							"    name: 'RecipientInfo.version',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.INTEGER,\r",
							"    constructed: false,\r",
							"    capture: 'version'\r",
							"  }, {\r",
							"    name: 'RecipientInfo.issuerAndSerial',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'RecipientInfo.issuerAndSerial.issuer',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.SEQUENCE,\r",
							"      constructed: true,\r",
							"      captureAsn1: 'issuer'\r",
							"    }, {\r",
							"      name: 'RecipientInfo.issuerAndSerial.serialNumber',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.INTEGER,\r",
							"      constructed: false,\r",
							"      capture: 'serial'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'RecipientInfo.keyEncryptionAlgorithm',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.SEQUENCE,\r",
							"    constructed: true,\r",
							"    value: [{\r",
							"      name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      type: asn1.Type.OID,\r",
							"      constructed: false,\r",
							"      capture: 'encAlgorithm'\r",
							"    }, {\r",
							"      name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',\r",
							"      tagClass: asn1.Class.UNIVERSAL,\r",
							"      constructed: false,\r",
							"      captureAsn1: 'encParameter'\r",
							"    }]\r",
							"  }, {\r",
							"    name: 'RecipientInfo.encryptedKey',\r",
							"    tagClass: asn1.Class.UNIVERSAL,\r",
							"    type: asn1.Type.OCTETSTRING,\r",
							"    constructed: false,\r",
							"    capture: 'encKey'\r",
							"  }]\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 30 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of mask generation function MGF1.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" * Copyright (c) 2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"forge.mgf = forge.mgf || {};\r",
							"var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\r",
							"\r",
							"/**\r",
							" * Creates a MGF1 mask generation function object.\r",
							" *\r",
							" * @param md the message digest API to use (eg: forge.md.sha1.create()).\r",
							" *\r",
							" * @return a mask generation function object.\r",
							" */\r",
							"mgf1.create = function(md) {\r",
							"  var mgf = {\r",
							"    /**\r",
							"     * Generate mask of specified length.\r",
							"     *\r",
							"     * @param {String} seed The seed for mask generation.\r",
							"     * @param maskLen Number of bytes to generate.\r",
							"     * @return {String} The generated mask.\r",
							"     */\r",
							"    generate: function(seed, maskLen) {\r",
							"      /* 2. Let T be the empty octet string. */\r",
							"      var t = new forge.util.ByteBuffer();\r",
							"\r",
							"      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */\r",
							"      var len = Math.ceil(maskLen / md.digestLength);\r",
							"      for(var i = 0; i < len; i++) {\r",
							"        /* a. Convert counter to an octet string C of length 4 octets */\r",
							"        var c = new forge.util.ByteBuffer();\r",
							"        c.putInt32(i);\r",
							"\r",
							"        /* b. Concatenate the hash of the seed mgfSeed and C to the octet\r",
							"         * string T: */\r",
							"        md.start();\r",
							"        md.update(seed + c.getBytes());\r",
							"        t.putBuffer(md.digest());\r",
							"      }\r",
							"\r",
							"      /* Output the leading maskLen octets of T as the octet string mask. */\r",
							"      t.truncate(t.length() - maskLen);\r",
							"      return t.getBytes();\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return mgf;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 31 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Debugging support for web applications.\r",
							" *\r",
							" * @author David I. Lehn <dlehn@digitalbazaar.com>\r",
							" *\r",
							" * Copyright 2008-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"\r",
							"/* DEBUG API */\r",
							"module.exports = forge.debug = forge.debug || {};\r",
							"\r",
							"// Private storage for debugging.\r",
							"// Useful to expose data that is otherwise unviewable behind closures.\r",
							"// NOTE: remember that this can hold references to data and cause leaks!\r",
							"// format is \"forge._debug.<modulename>.<dataname> = data\"\r",
							"// Example:\r",
							"// (function() {\r",
							"//   var cat = 'forge.test.Test'; // debugging category\r",
							"//   var sState = {...}; // local state\r",
							"//   forge.debug.set(cat, 'sState', sState);\r",
							"// })();\r",
							"forge.debug.storage = {};\r",
							"\r",
							"/**\r",
							" * Gets debug data. Omit name for all cat data  Omit name and cat for\r",
							" * all data.\r",
							" *\r",
							" * @param cat name of debugging category.\r",
							" * @param name name of data to get (optional).\r",
							" * @return object with requested debug data or undefined.\r",
							" */\r",
							"forge.debug.get = function(cat, name) {\r",
							"  var rval;\r",
							"  if(typeof(cat) === 'undefined') {\r",
							"    rval = forge.debug.storage;\r",
							"  } else if(cat in forge.debug.storage) {\r",
							"    if(typeof(name) === 'undefined') {\r",
							"      rval = forge.debug.storage[cat];\r",
							"    } else {\r",
							"      rval = forge.debug.storage[cat][name];\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets debug data.\r",
							" *\r",
							" * @param cat name of debugging category.\r",
							" * @param name name of data to set.\r",
							" * @param data data to set.\r",
							" */\r",
							"forge.debug.set = function(cat, name, data) {\r",
							"  if(!(cat in forge.debug.storage)) {\r",
							"    forge.debug.storage[cat] = {};\r",
							"  }\r",
							"  forge.debug.storage[cat][name] = data;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Clears debug data. Omit name for all cat data. Omit name and cat for\r",
							" * all data.\r",
							" *\r",
							" * @param cat name of debugging category.\r",
							" * @param name name of data to clear or omit to clear entire category.\r",
							" */\r",
							"forge.debug.clear = function(cat, name) {\r",
							"  if(typeof(cat) === 'undefined') {\r",
							"    forge.debug.storage = {};\r",
							"  } else if(cat in forge.debug.storage) {\r",
							"    if(typeof(name) === 'undefined') {\r",
							"      delete forge.debug.storage[cat];\r",
							"    } else {\r",
							"      delete forge.debug.storage[cat][name];\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 32 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Secure Hash Algorithm with a 1024-bit block size implementation.\r",
							" *\r",
							" * This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For\r",
							" * SHA-256 (block size 512 bits), see sha256.js.\r",
							" *\r",
							" * See FIPS 180-4 for details.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2014-2015 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(4);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var sha512 = module.exports = forge.sha512 = forge.sha512 || {};\r",
							"\r",
							"// SHA-512\r",
							"forge.md.sha512 = forge.md.algorithms.sha512 = sha512;\r",
							"\r",
							"// SHA-384\r",
							"var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};\r",
							"sha384.create = function() {\r",
							"  return sha512.create('SHA-384');\r",
							"};\r",
							"forge.md.sha384 = forge.md.algorithms.sha384 = sha384;\r",
							"\r",
							"// SHA-512/256\r",
							"forge.sha512.sha256 = forge.sha512.sha256 || {\r",
							"  create: function() {\r",
							"    return sha512.create('SHA-512/256');\r",
							"  }\r",
							"};\r",
							"forge.md['sha512/256'] = forge.md.algorithms['sha512/256'] =\r",
							"  forge.sha512.sha256;\r",
							"\r",
							"// SHA-512/224\r",
							"forge.sha512.sha224 = forge.sha512.sha224 || {\r",
							"  create: function() {\r",
							"    return sha512.create('SHA-512/224');\r",
							"  }\r",
							"};\r",
							"forge.md['sha512/224'] = forge.md.algorithms['sha512/224'] =\r",
							"  forge.sha512.sha224;\r",
							"\r",
							"/**\r",
							" * Creates a SHA-2 message digest object.\r",
							" *\r",
							" * @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,\r",
							" *          SHA-512/256).\r",
							" *\r",
							" * @return a message digest object.\r",
							" */\r",
							"sha512.create = function(algorithm) {\r",
							"  // do initialization as necessary\r",
							"  if(!_initialized) {\r",
							"    _init();\r",
							"  }\r",
							"\r",
							"  if(typeof algorithm === 'undefined') {\r",
							"    algorithm = 'SHA-512';\r",
							"  }\r",
							"\r",
							"  if(!(algorithm in _states)) {\r",
							"    throw new Error('Invalid SHA-512 algorithm: ' + algorithm);\r",
							"  }\r",
							"\r",
							"  // SHA-512 state contains eight 64-bit integers (each as two 32-bit ints)\r",
							"  var _state = _states[algorithm];\r",
							"  var _h = null;\r",
							"\r",
							"  // input buffer\r",
							"  var _input = forge.util.createBuffer();\r",
							"\r",
							"  // used for 64-bit word storage\r",
							"  var _w = new Array(80);\r",
							"  for(var wi = 0; wi < 80; ++wi) {\r",
							"    _w[wi] = new Array(2);\r",
							"  }\r",
							"\r",
							"  // determine digest length by algorithm name (default)\r",
							"  var digestLength = 64;\r",
							"  switch (algorithm) {\r",
							"    case 'SHA-384':\r",
							"      digestLength = 48;\r",
							"      break;\r",
							"    case 'SHA-512/256':\r",
							"      digestLength = 32;\r",
							"      break;\r",
							"    case 'SHA-512/224':\r",
							"      digestLength = 28;\r",
							"      break;\r",
							"  }\r",
							"\r",
							"  // message digest object\r",
							"  var md = {\r",
							"    // SHA-512 => sha512\r",
							"    algorithm: algorithm.replace('-', '').toLowerCase(),\r",
							"    blockLength: 128,\r",
							"    digestLength: digestLength,\r",
							"    // 56-bit length of message so far (does not including padding)\r",
							"    messageLength: 0,\r",
							"    // true message length\r",
							"    fullMessageLength: null,\r",
							"    // size of message length in bytes\r",
							"    messageLengthSize: 16\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Starts the digest.\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.start = function() {\r",
							"    // up to 56-bit message length for convenience\r",
							"    md.messageLength = 0;\r",
							"\r",
							"    // full message length (set md.messageLength128 for backwards-compatibility)\r",
							"    md.fullMessageLength = md.messageLength128 = [];\r",
							"    var int32s = md.messageLengthSize / 4;\r",
							"    for(var i = 0; i < int32s; ++i) {\r",
							"      md.fullMessageLength.push(0);\r",
							"    }\r",
							"    _input = forge.util.createBuffer();\r",
							"    _h = new Array(_state.length);\r",
							"    for(var i = 0; i < _state.length; ++i) {\r",
							"      _h[i] = _state[i].slice(0);\r",
							"    }\r",
							"    return md;\r",
							"  };\r",
							"  // start digest automatically for first time\r",
							"  md.start();\r",
							"\r",
							"  /**\r",
							"   * Updates the digest with the given message input. The given input can\r",
							"   * treated as raw input (no encoding will be applied) or an encoding of\r",
							"   * 'utf8' maybe given to encode the input using UTF-8.\r",
							"   *\r",
							"   * @param msg the message input to update with.\r",
							"   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\r",
							"   *\r",
							"   * @return this digest object.\r",
							"   */\r",
							"  md.update = function(msg, encoding) {\r",
							"    if(encoding === 'utf8') {\r",
							"      msg = forge.util.encodeUtf8(msg);\r",
							"    }\r",
							"\r",
							"    // update message length\r",
							"    var len = msg.length;\r",
							"    md.messageLength += len;\r",
							"    len = [(len / 0x100000000) >>> 0, len >>> 0];\r",
							"    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\r",
							"      md.fullMessageLength[i] += len[1];\r",
							"      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\r",
							"      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\r",
							"      len[0] = ((len[1] / 0x100000000) >>> 0);\r",
							"    }\r",
							"\r",
							"    // add bytes to input buffer\r",
							"    _input.putBytes(msg);\r",
							"\r",
							"    // process bytes\r",
							"    _update(_h, _w, _input);\r",
							"\r",
							"    // compact input buffer every 2K or if empty\r",
							"    if(_input.read > 2048 || _input.length() === 0) {\r",
							"      _input.compact();\r",
							"    }\r",
							"\r",
							"    return md;\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Produces the digest.\r",
							"   *\r",
							"   * @return a byte buffer containing the digest value.\r",
							"   */\r",
							"  md.digest = function() {\r",
							"    /* Note: Here we copy the remaining bytes in the input buffer and\r",
							"    add the appropriate SHA-512 padding. Then we do the final update\r",
							"    on a copy of the state so that if the user wants to get\r",
							"    intermediate digests they can do so. */\r",
							"\r",
							"    /* Determine the number of bytes that must be added to the message\r",
							"    to ensure its length is congruent to 896 mod 1024. In other words,\r",
							"    the data to be digested must be a multiple of 1024 bits (or 128 bytes).\r",
							"    This data includes the message, some padding, and the length of the\r",
							"    message. Since the length of the message will be encoded as 16 bytes (128\r",
							"    bits), that means that the last segment of the data must have 112 bytes\r",
							"    (896 bits) of message and padding. Therefore, the length of the message\r",
							"    plus the padding must be congruent to 896 mod 1024 because\r",
							"    1024 - 128 = 896.\r",
							"\r",
							"    In order to fill up the message length it must be filled with\r",
							"    padding that begins with 1 bit followed by all 0 bits. Padding\r",
							"    must *always* be present, so if the message length is already\r",
							"    congruent to 896 mod 1024, then 1024 padding bits must be added. */\r",
							"\r",
							"    var finalBlock = forge.util.createBuffer();\r",
							"    finalBlock.putBytes(_input.bytes());\r",
							"\r",
							"    // compute remaining size to be digested (include message length size)\r",
							"    var remaining = (\r",
							"      md.fullMessageLength[md.fullMessageLength.length - 1] +\r",
							"      md.messageLengthSize);\r",
							"\r",
							"    // add padding for overflow blockSize - overflow\r",
							"    // _padding starts with 1 byte with first bit is set (byte value 128), then\r",
							"    // there may be up to (blockSize - 1) other pad bytes\r",
							"    var overflow = remaining & (md.blockLength - 1);\r",
							"    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\r",
							"\r",
							"    // serialize message length in bits in big-endian order; since length\r",
							"    // is stored in bytes we multiply by 8 and add carry from next int\r",
							"    var next, carry;\r",
							"    var bits = md.fullMessageLength[0] * 8;\r",
							"    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\r",
							"      next = md.fullMessageLength[i + 1] * 8;\r",
							"      carry = (next / 0x100000000) >>> 0;\r",
							"      bits += carry;\r",
							"      finalBlock.putInt32(bits >>> 0);\r",
							"      bits = next >>> 0;\r",
							"    }\r",
							"    finalBlock.putInt32(bits);\r",
							"\r",
							"    var h = new Array(_h.length);\r",
							"    for(var i = 0; i < _h.length; ++i) {\r",
							"      h[i] = _h[i].slice(0);\r",
							"    }\r",
							"    _update(h, _w, finalBlock);\r",
							"    var rval = forge.util.createBuffer();\r",
							"    var hlen;\r",
							"    if(algorithm === 'SHA-512') {\r",
							"      hlen = h.length;\r",
							"    } else if(algorithm === 'SHA-384') {\r",
							"      hlen = h.length - 2;\r",
							"    } else {\r",
							"      hlen = h.length - 4;\r",
							"    }\r",
							"    for(var i = 0; i < hlen; ++i) {\r",
							"      rval.putInt32(h[i][0]);\r",
							"      if(i !== hlen - 1 || algorithm !== 'SHA-512/224') {\r",
							"        rval.putInt32(h[i][1]);\r",
							"      }\r",
							"    }\r",
							"    return rval;\r",
							"  };\r",
							"\r",
							"  return md;\r",
							"};\r",
							"\r",
							"// sha-512 padding bytes not initialized yet\r",
							"var _padding = null;\r",
							"var _initialized = false;\r",
							"\r",
							"// table of constants\r",
							"var _k = null;\r",
							"\r",
							"// initial hash states\r",
							"var _states = null;\r",
							"\r",
							"/**\r",
							" * Initializes the constant tables.\r",
							" */\r",
							"function _init() {\r",
							"  // create padding\r",
							"  _padding = String.fromCharCode(128);\r",
							"  _padding += forge.util.fillString(String.fromCharCode(0x00), 128);\r",
							"\r",
							"  // create K table for SHA-512\r",
							"  _k = [\r",
							"    [0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd],\r",
							"    [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc],\r",
							"    [0x3956c25b, 0xf348b538], [0x59f111f1, 0xb605d019],\r",
							"    [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118],\r",
							"    [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe],\r",
							"    [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2],\r",
							"    [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1],\r",
							"    [0x9bdc06a7, 0x25c71235], [0xc19bf174, 0xcf692694],\r",
							"    [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3],\r",
							"    [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65],\r",
							"    [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483],\r",
							"    [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5],\r",
							"    [0x983e5152, 0xee66dfab], [0xa831c66d, 0x2db43210],\r",
							"    [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4],\r",
							"    [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725],\r",
							"    [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70],\r",
							"    [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926],\r",
							"    [0x4d2c6dfc, 0x5ac42aed], [0x53380d13, 0x9d95b3df],\r",
							"    [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8],\r",
							"    [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b],\r",
							"    [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001],\r",
							"    [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30],\r",
							"    [0xd192e819, 0xd6ef5218], [0xd6990624, 0x5565a910],\r",
							"    [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8],\r",
							"    [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53],\r",
							"    [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8],\r",
							"    [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb],\r",
							"    [0x5b9cca4f, 0x7763e373], [0x682e6ff3, 0xd6b2b8a3],\r",
							"    [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60],\r",
							"    [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec],\r",
							"    [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9],\r",
							"    [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b],\r",
							"    [0xca273ece, 0xea26619c], [0xd186b8c7, 0x21c0c207],\r",
							"    [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178],\r",
							"    [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6],\r",
							"    [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b],\r",
							"    [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493],\r",
							"    [0x3c9ebe0a, 0x15c9bebc], [0x431d67c4, 0x9c100d4c],\r",
							"    [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a],\r",
							"    [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]\r",
							"  ];\r",
							"\r",
							"  // initial hash states\r",
							"  _states = {};\r",
							"  _states['SHA-512'] = [\r",
							"    [0x6a09e667, 0xf3bcc908],\r",
							"    [0xbb67ae85, 0x84caa73b],\r",
							"    [0x3c6ef372, 0xfe94f82b],\r",
							"    [0xa54ff53a, 0x5f1d36f1],\r",
							"    [0x510e527f, 0xade682d1],\r",
							"    [0x9b05688c, 0x2b3e6c1f],\r",
							"    [0x1f83d9ab, 0xfb41bd6b],\r",
							"    [0x5be0cd19, 0x137e2179]\r",
							"  ];\r",
							"  _states['SHA-384'] = [\r",
							"    [0xcbbb9d5d, 0xc1059ed8],\r",
							"    [0x629a292a, 0x367cd507],\r",
							"    [0x9159015a, 0x3070dd17],\r",
							"    [0x152fecd8, 0xf70e5939],\r",
							"    [0x67332667, 0xffc00b31],\r",
							"    [0x8eb44a87, 0x68581511],\r",
							"    [0xdb0c2e0d, 0x64f98fa7],\r",
							"    [0x47b5481d, 0xbefa4fa4]\r",
							"  ];\r",
							"  _states['SHA-512/256'] = [\r",
							"    [0x22312194, 0xFC2BF72C],\r",
							"    [0x9F555FA3, 0xC84C64C2],\r",
							"    [0x2393B86B, 0x6F53B151],\r",
							"    [0x96387719, 0x5940EABD],\r",
							"    [0x96283EE2, 0xA88EFFE3],\r",
							"    [0xBE5E1E25, 0x53863992],\r",
							"    [0x2B0199FC, 0x2C85B8AA],\r",
							"    [0x0EB72DDC, 0x81C52CA2]\r",
							"  ];\r",
							"  _states['SHA-512/224'] = [\r",
							"    [0x8C3D37C8, 0x19544DA2],\r",
							"    [0x73E19966, 0x89DCD4D6],\r",
							"    [0x1DFAB7AE, 0x32FF9C82],\r",
							"    [0x679DD514, 0x582F9FCF],\r",
							"    [0x0F6D2B69, 0x7BD44DA8],\r",
							"    [0x77E36F73, 0x04C48942],\r",
							"    [0x3F9D85A8, 0x6A1D36C8],\r",
							"    [0x1112E6AD, 0x91D692A1]\r",
							"  ];\r",
							"\r",
							"  // now initialized\r",
							"  _initialized = true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Updates a SHA-512 state with the given byte buffer.\r",
							" *\r",
							" * @param s the SHA-512 state to update.\r",
							" * @param w the array to use to store words.\r",
							" * @param bytes the byte buffer to update with.\r",
							" */\r",
							"function _update(s, w, bytes) {\r",
							"  // consume 512 bit (128 byte) chunks\r",
							"  var t1_hi, t1_lo;\r",
							"  var t2_hi, t2_lo;\r",
							"  var s0_hi, s0_lo;\r",
							"  var s1_hi, s1_lo;\r",
							"  var ch_hi, ch_lo;\r",
							"  var maj_hi, maj_lo;\r",
							"  var a_hi, a_lo;\r",
							"  var b_hi, b_lo;\r",
							"  var c_hi, c_lo;\r",
							"  var d_hi, d_lo;\r",
							"  var e_hi, e_lo;\r",
							"  var f_hi, f_lo;\r",
							"  var g_hi, g_lo;\r",
							"  var h_hi, h_lo;\r",
							"  var i, hi, lo, w2, w7, w15, w16;\r",
							"  var len = bytes.length();\r",
							"  while(len >= 128) {\r",
							"    // the w array will be populated with sixteen 64-bit big-endian words\r",
							"    // and then extended into 64 64-bit words according to SHA-512\r",
							"    for(i = 0; i < 16; ++i) {\r",
							"      w[i][0] = bytes.getInt32() >>> 0;\r",
							"      w[i][1] = bytes.getInt32() >>> 0;\r",
							"    }\r",
							"    for(; i < 80; ++i) {\r",
							"      // for word 2 words ago: ROTR 19(x) ^ ROTR 61(x) ^ SHR 6(x)\r",
							"      w2 = w[i - 2];\r",
							"      hi = w2[0];\r",
							"      lo = w2[1];\r",
							"\r",
							"      // high bits\r",
							"      t1_hi = (\r",
							"        ((hi >>> 19) | (lo << 13)) ^ // ROTR 19\r",
							"        ((lo >>> 29) | (hi << 3)) ^ // ROTR 61/(swap + ROTR 29)\r",
							"        (hi >>> 6)) >>> 0; // SHR 6\r",
							"      // low bits\r",
							"      t1_lo = (\r",
							"        ((hi << 13) | (lo >>> 19)) ^ // ROTR 19\r",
							"        ((lo << 3) | (hi >>> 29)) ^ // ROTR 61/(swap + ROTR 29)\r",
							"        ((hi << 26) | (lo >>> 6))) >>> 0; // SHR 6\r",
							"\r",
							"      // for word 15 words ago: ROTR 1(x) ^ ROTR 8(x) ^ SHR 7(x)\r",
							"      w15 = w[i - 15];\r",
							"      hi = w15[0];\r",
							"      lo = w15[1];\r",
							"\r",
							"      // high bits\r",
							"      t2_hi = (\r",
							"        ((hi >>> 1) | (lo << 31)) ^ // ROTR 1\r",
							"        ((hi >>> 8) | (lo << 24)) ^ // ROTR 8\r",
							"        (hi >>> 7)) >>> 0; // SHR 7\r",
							"      // low bits\r",
							"      t2_lo = (\r",
							"        ((hi << 31) | (lo >>> 1)) ^ // ROTR 1\r",
							"        ((hi << 24) | (lo >>> 8)) ^ // ROTR 8\r",
							"        ((hi << 25) | (lo >>> 7))) >>> 0; // SHR 7\r",
							"\r",
							"      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^64 (carry lo overflow)\r",
							"      w7 = w[i - 7];\r",
							"      w16 = w[i - 16];\r",
							"      lo = (t1_lo + w7[1] + t2_lo + w16[1]);\r",
							"      w[i][0] = (t1_hi + w7[0] + t2_hi + w16[0] +\r",
							"        ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      w[i][1] = lo >>> 0;\r",
							"    }\r",
							"\r",
							"    // initialize hash value for this chunk\r",
							"    a_hi = s[0][0];\r",
							"    a_lo = s[0][1];\r",
							"    b_hi = s[1][0];\r",
							"    b_lo = s[1][1];\r",
							"    c_hi = s[2][0];\r",
							"    c_lo = s[2][1];\r",
							"    d_hi = s[3][0];\r",
							"    d_lo = s[3][1];\r",
							"    e_hi = s[4][0];\r",
							"    e_lo = s[4][1];\r",
							"    f_hi = s[5][0];\r",
							"    f_lo = s[5][1];\r",
							"    g_hi = s[6][0];\r",
							"    g_lo = s[6][1];\r",
							"    h_hi = s[7][0];\r",
							"    h_lo = s[7][1];\r",
							"\r",
							"    // round function\r",
							"    for(i = 0; i < 80; ++i) {\r",
							"      // Sum1(e) = ROTR 14(e) ^ ROTR 18(e) ^ ROTR 41(e)\r",
							"      s1_hi = (\r",
							"        ((e_hi >>> 14) | (e_lo << 18)) ^ // ROTR 14\r",
							"        ((e_hi >>> 18) | (e_lo << 14)) ^ // ROTR 18\r",
							"        ((e_lo >>> 9) | (e_hi << 23))) >>> 0; // ROTR 41/(swap + ROTR 9)\r",
							"      s1_lo = (\r",
							"        ((e_hi << 18) | (e_lo >>> 14)) ^ // ROTR 14\r",
							"        ((e_hi << 14) | (e_lo >>> 18)) ^ // ROTR 18\r",
							"        ((e_lo << 23) | (e_hi >>> 9))) >>> 0; // ROTR 41/(swap + ROTR 9)\r",
							"\r",
							"      // Ch(e, f, g) (optimized the same way as SHA-1)\r",
							"      ch_hi = (g_hi ^ (e_hi & (f_hi ^ g_hi))) >>> 0;\r",
							"      ch_lo = (g_lo ^ (e_lo & (f_lo ^ g_lo))) >>> 0;\r",
							"\r",
							"      // Sum0(a) = ROTR 28(a) ^ ROTR 34(a) ^ ROTR 39(a)\r",
							"      s0_hi = (\r",
							"        ((a_hi >>> 28) | (a_lo << 4)) ^ // ROTR 28\r",
							"        ((a_lo >>> 2) | (a_hi << 30)) ^ // ROTR 34/(swap + ROTR 2)\r",
							"        ((a_lo >>> 7) | (a_hi << 25))) >>> 0; // ROTR 39/(swap + ROTR 7)\r",
							"      s0_lo = (\r",
							"        ((a_hi << 4) | (a_lo >>> 28)) ^ // ROTR 28\r",
							"        ((a_lo << 30) | (a_hi >>> 2)) ^ // ROTR 34/(swap + ROTR 2)\r",
							"        ((a_lo << 25) | (a_hi >>> 7))) >>> 0; // ROTR 39/(swap + ROTR 7)\r",
							"\r",
							"      // Maj(a, b, c) (optimized the same way as SHA-1)\r",
							"      maj_hi = ((a_hi & b_hi) | (c_hi & (a_hi ^ b_hi))) >>> 0;\r",
							"      maj_lo = ((a_lo & b_lo) | (c_lo & (a_lo ^ b_lo))) >>> 0;\r",
							"\r",
							"      // main algorithm\r",
							"      // t1 = (h + s1 + ch + _k[i] + _w[i]) modulo 2^64 (carry lo overflow)\r",
							"      lo = (h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1]);\r",
							"      t1_hi = (h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] +\r",
							"        ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      t1_lo = lo >>> 0;\r",
							"\r",
							"      // t2 = s0 + maj modulo 2^64 (carry lo overflow)\r",
							"      lo = s0_lo + maj_lo;\r",
							"      t2_hi = (s0_hi + maj_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      t2_lo = lo >>> 0;\r",
							"\r",
							"      h_hi = g_hi;\r",
							"      h_lo = g_lo;\r",
							"\r",
							"      g_hi = f_hi;\r",
							"      g_lo = f_lo;\r",
							"\r",
							"      f_hi = e_hi;\r",
							"      f_lo = e_lo;\r",
							"\r",
							"      // e = (d + t1) modulo 2^64 (carry lo overflow)\r",
							"      lo = d_lo + t1_lo;\r",
							"      e_hi = (d_hi + t1_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      e_lo = lo >>> 0;\r",
							"\r",
							"      d_hi = c_hi;\r",
							"      d_lo = c_lo;\r",
							"\r",
							"      c_hi = b_hi;\r",
							"      c_lo = b_lo;\r",
							"\r",
							"      b_hi = a_hi;\r",
							"      b_lo = a_lo;\r",
							"\r",
							"      // a = (t1 + t2) modulo 2^64 (carry lo overflow)\r",
							"      lo = t1_lo + t2_lo;\r",
							"      a_hi = (t1_hi + t2_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"      a_lo = lo >>> 0;\r",
							"    }\r",
							"\r",
							"    // update hash state (additional modulo 2^64)\r",
							"    lo = s[0][1] + a_lo;\r",
							"    s[0][0] = (s[0][0] + a_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[0][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[1][1] + b_lo;\r",
							"    s[1][0] = (s[1][0] + b_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[1][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[2][1] + c_lo;\r",
							"    s[2][0] = (s[2][0] + c_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[2][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[3][1] + d_lo;\r",
							"    s[3][0] = (s[3][0] + d_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[3][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[4][1] + e_lo;\r",
							"    s[4][0] = (s[4][0] + e_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[4][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[5][1] + f_lo;\r",
							"    s[5][0] = (s[5][0] + f_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[5][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[6][1] + g_lo;\r",
							"    s[6][0] = (s[6][0] + g_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[6][1] = lo >>> 0;\r",
							"\r",
							"    lo = s[7][1] + h_lo;\r",
							"    s[7][0] = (s[7][0] + h_hi + ((lo / 0x100000000) >>> 0)) >>> 0;\r",
							"    s[7][1] = lo >>> 0;\r",
							"\r",
							"    len -= 128;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 33 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Cross-browser support for logging in a web application.\r",
							" *\r",
							" * @author David I. Lehn <dlehn@digitalbazaar.com>\r",
							" *\r",
							" * Copyright (c) 2008-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"\r",
							"/* LOG API */\r",
							"module.exports = forge.log = forge.log || {};\r",
							"\r",
							"/**\r",
							" * Application logging system.\r",
							" *\r",
							" * Each logger level available as it's own function of the form:\r",
							" *   forge.log.level(category, args...)\r",
							" * The category is an arbitrary string, and the args are the same as\r",
							" * Firebug's console.log API. By default the call will be output as:\r",
							" *   'LEVEL [category] <args[0]>, args[1], ...'\r",
							" * This enables proper % formatting via the first argument.\r",
							" * Each category is enabled by default but can be enabled or disabled with\r",
							" * the setCategoryEnabled() function.\r",
							" */\r",
							"// list of known levels\r",
							"forge.log.levels = [\r",
							"  'none', 'error', 'warning', 'info', 'debug', 'verbose', 'max'];\r",
							"// info on the levels indexed by name:\r",
							"//   index: level index\r",
							"//   name: uppercased display name\r",
							"var sLevelInfo = {};\r",
							"// list of loggers\r",
							"var sLoggers = [];\r",
							"/**\r",
							" * Standard console logger. If no console support is enabled this will\r",
							" * remain null. Check before using.\r",
							" */\r",
							"var sConsoleLogger = null;\r",
							"\r",
							"// logger flags\r",
							"/**\r",
							" * Lock the level at the current value. Used in cases where user config may\r",
							" * set the level such that only critical messages are seen but more verbose\r",
							" * messages are needed for debugging or other purposes.\r",
							" */\r",
							"forge.log.LEVEL_LOCKED = (1 << 1);\r",
							"/**\r",
							" * Always call log function. By default, the logging system will check the\r",
							" * message level against logger.level before calling the log function. This\r",
							" * flag allows the function to do its own check.\r",
							" */\r",
							"forge.log.NO_LEVEL_CHECK = (1 << 2);\r",
							"/**\r",
							" * Perform message interpolation with the passed arguments. \"%\" style\r",
							" * fields in log messages will be replaced by arguments as needed. Some\r",
							" * loggers, such as Firebug, may do this automatically. The original log\r",
							" * message will be available as 'message' and the interpolated version will\r",
							" * be available as 'fullMessage'.\r",
							" */\r",
							"forge.log.INTERPOLATE = (1 << 3);\r",
							"\r",
							"// setup each log level\r",
							"for(var i = 0; i < forge.log.levels.length; ++i) {\r",
							"  var level = forge.log.levels[i];\r",
							"  sLevelInfo[level] = {\r",
							"    index: i,\r",
							"    name: level.toUpperCase()\r",
							"  };\r",
							"}\r",
							"\r",
							"/**\r",
							" * Message logger. Will dispatch a message to registered loggers as needed.\r",
							" *\r",
							" * @param message message object\r",
							" */\r",
							"forge.log.logMessage = function(message) {\r",
							"  var messageLevelIndex = sLevelInfo[message.level].index;\r",
							"  for(var i = 0; i < sLoggers.length; ++i) {\r",
							"    var logger = sLoggers[i];\r",
							"    if(logger.flags & forge.log.NO_LEVEL_CHECK) {\r",
							"      logger.f(message);\r",
							"    } else {\r",
							"      // get logger level\r",
							"      var loggerLevelIndex = sLevelInfo[logger.level].index;\r",
							"      // check level\r",
							"      if(messageLevelIndex <= loggerLevelIndex) {\r",
							"        // message critical enough, call logger\r",
							"        logger.f(logger, message);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets the 'standard' key on a message object to:\r",
							" * \"LEVEL [category] \" + message\r",
							" *\r",
							" * @param message a message log object\r",
							" */\r",
							"forge.log.prepareStandard = function(message) {\r",
							"  if(!('standard' in message)) {\r",
							"    message.standard =\r",
							"      sLevelInfo[message.level].name +\r",
							"      //' ' + +message.timestamp +\r",
							"      ' [' + message.category + '] ' +\r",
							"      message.message;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets the 'full' key on a message object to the original message\r",
							" * interpolated via % formatting with the message arguments.\r",
							" *\r",
							" * @param message a message log object.\r",
							" */\r",
							"forge.log.prepareFull = function(message) {\r",
							"  if(!('full' in message)) {\r",
							"    // copy args and insert message at the front\r",
							"    var args = [message.message];\r",
							"    args = args.concat([] || message['arguments']);\r",
							"    // format the message\r",
							"    message.full = forge.util.format.apply(this, args);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Applies both preparseStandard() and prepareFull() to a message object and\r",
							" * store result in 'standardFull'.\r",
							" *\r",
							" * @param message a message log object.\r",
							" */\r",
							"forge.log.prepareStandardFull = function(message) {\r",
							"  if(!('standardFull' in message)) {\r",
							"    // FIXME implement 'standardFull' logging\r",
							"    forge.log.prepareStandard(message);\r",
							"    message.standardFull = message.standard;\r",
							"  }\r",
							"};\r",
							"\r",
							"// create log level functions\r",
							"if(true) {\r",
							"  // levels for which we want functions\r",
							"  var levels = ['error', 'warning', 'info', 'debug', 'verbose'];\r",
							"  for(var i = 0; i < levels.length; ++i) {\r",
							"    // wrap in a function to ensure proper level var is passed\r",
							"    (function(level) {\r",
							"      // create function for this level\r",
							"      forge.log[level] = function(category, message/*, args...*/) {\r",
							"        // convert arguments to real array, remove category and message\r",
							"        var args = Array.prototype.slice.call(arguments).slice(2);\r",
							"        // create message object\r",
							"        // Note: interpolation and standard formatting is done lazily\r",
							"        var msg = {\r",
							"          timestamp: new Date(),\r",
							"          level: level,\r",
							"          category: category,\r",
							"          message: message,\r",
							"          'arguments': args\r",
							"          /*standard*/\r",
							"          /*full*/\r",
							"          /*fullMessage*/\r",
							"        };\r",
							"        // process this message\r",
							"        forge.log.logMessage(msg);\r",
							"      };\r",
							"    })(levels[i]);\r",
							"  }\r",
							"}\r",
							"\r",
							"/**\r",
							" * Creates a new logger with specified custom logging function.\r",
							" *\r",
							" * The logging function has a signature of:\r",
							" *   function(logger, message)\r",
							" * logger: current logger\r",
							" * message: object:\r",
							" *   level: level id\r",
							" *   category: category\r",
							" *   message: string message\r",
							" *   arguments: Array of extra arguments\r",
							" *   fullMessage: interpolated message and arguments if INTERPOLATE flag set\r",
							" *\r",
							" * @param logFunction a logging function which takes a log message object\r",
							" *          as a parameter.\r",
							" *\r",
							" * @return a logger object.\r",
							" */\r",
							"forge.log.makeLogger = function(logFunction) {\r",
							"  var logger = {\r",
							"    flags: 0,\r",
							"    f: logFunction\r",
							"  };\r",
							"  forge.log.setLevel(logger, 'none');\r",
							"  return logger;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sets the current log level on a logger.\r",
							" *\r",
							" * @param logger the target logger.\r",
							" * @param level the new maximum log level as a string.\r",
							" *\r",
							" * @return true if set, false if not.\r",
							" */\r",
							"forge.log.setLevel = function(logger, level) {\r",
							"  var rval = false;\r",
							"  if(logger && !(logger.flags & forge.log.LEVEL_LOCKED)) {\r",
							"    for(var i = 0; i < forge.log.levels.length; ++i) {\r",
							"      var aValidLevel = forge.log.levels[i];\r",
							"      if(level == aValidLevel) {\r",
							"        // set level\r",
							"        logger.level = level;\r",
							"        rval = true;\r",
							"        break;\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Locks the log level at its current value.\r",
							" *\r",
							" * @param logger the target logger.\r",
							" * @param lock boolean lock value, default to true.\r",
							" */\r",
							"forge.log.lock = function(logger, lock) {\r",
							"  if(typeof lock === 'undefined' || lock) {\r",
							"    logger.flags |= forge.log.LEVEL_LOCKED;\r",
							"  } else {\r",
							"    logger.flags &= ~forge.log.LEVEL_LOCKED;\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds a logger.\r",
							" *\r",
							" * @param logger the logger object.\r",
							" */\r",
							"forge.log.addLogger = function(logger) {\r",
							"  sLoggers.push(logger);\r",
							"};\r",
							"\r",
							"// setup the console logger if possible, else create fake console.log\r",
							"if(typeof(console) !== 'undefined' && 'log' in console) {\r",
							"  var logger;\r",
							"  if(console.error && console.warn && console.info && console.debug) {\r",
							"    // looks like Firebug-style logging is available\r",
							"    // level handlers map\r",
							"    var levelHandlers = {\r",
							"      error: console.error,\r",
							"      warning: console.warn,\r",
							"      info: console.info,\r",
							"      debug: console.debug,\r",
							"      verbose: console.debug\r",
							"    };\r",
							"    var f = function(logger, message) {\r",
							"      forge.log.prepareStandard(message);\r",
							"      var handler = levelHandlers[message.level];\r",
							"      // prepend standard message and concat args\r",
							"      var args = [message.standard];\r",
							"      args = args.concat(message['arguments'].slice());\r",
							"      // apply to low-level console function\r",
							"      handler.apply(console, args);\r",
							"    };\r",
							"    logger = forge.log.makeLogger(f);\r",
							"  } else {\r",
							"    // only appear to have basic console.log\r",
							"    var f = function(logger, message) {\r",
							"      forge.log.prepareStandardFull(message);\r",
							"      console.log(message.standardFull);\r",
							"    };\r",
							"    logger = forge.log.makeLogger(f);\r",
							"  }\r",
							"  forge.log.setLevel(logger, 'debug');\r",
							"  forge.log.addLogger(logger);\r",
							"  sConsoleLogger = logger;\r",
							"} else {\r",
							"  // define fake console.log to avoid potential script errors on\r",
							"  // browsers that do not have console logging\r",
							"  console = {\r",
							"    log: function() {}\r",
							"  };\r",
							"}\r",
							"\r",
							"/*\r",
							" * Check for logging control query vars.\r",
							" *\r",
							" * console.level=<level-name>\r",
							" * Set's the console log level by name.  Useful to override defaults and\r",
							" * allow more verbose logging before a user config is loaded.\r",
							" *\r",
							" * console.lock=<true|false>\r",
							" * Lock the console log level at whatever level it is set at.  This is run\r",
							" * after console.level is processed.  Useful to force a level of verbosity\r",
							" * that could otherwise be limited by a user config.\r",
							" */\r",
							"if(sConsoleLogger !== null) {\r",
							"  var query = forge.util.getQueryVariables();\r",
							"  if('console.level' in query) {\r",
							"    // set with last value\r",
							"    forge.log.setLevel(\r",
							"      sConsoleLogger, query['console.level'].slice(-1)[0]);\r",
							"  }\r",
							"  if('console.lock' in query) {\r",
							"    // set with last value\r",
							"    var lock = query['console.lock'].slice(-1)[0];\r",
							"    if(lock == 'true') {\r",
							"      forge.log.lock(sConsoleLogger);\r",
							"    }\r",
							"  }\r",
							"}\r",
							"\r",
							"// provide public access to console logger\r",
							"forge.log.consoleLogger = sConsoleLogger;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 34 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"module.exports = __webpack_require__(35);\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 35 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2016 Digital Bazaar, Inc.\r",
							" */\r",
							"module.exports = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(37);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(13);\r",
							"__webpack_require__(31);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(39);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(40);\r",
							"__webpack_require__(33);\r",
							"__webpack_require__(41);\r",
							"__webpack_require__(30);\r",
							"__webpack_require__(15);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(26);\r",
							"__webpack_require__(28);\r",
							"__webpack_require__(42);\r",
							"__webpack_require__(20);\r",
							"__webpack_require__(27);\r",
							"__webpack_require__(24);\r",
							"__webpack_require__(17);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(25);\r",
							"__webpack_require__(43);\r",
							"__webpack_require__(44);\r",
							"__webpack_require__(19);\r",
							"__webpack_require__(1);\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 36 */\r",
							"/***/ (function(module, exports) {\r",
							"\r",
							"/**\r",
							" * Base-N/Base-X encoding/decoding functions.\r",
							" *\r",
							" * Original implementation from base-x:\r",
							" * https://github.com/cryptocoinjs/base-x\r",
							" *\r",
							" * Which is MIT licensed:\r",
							" *\r",
							" * The MIT License (MIT)\r",
							" *\r",
							" * Copyright base-x contributors (c) 2016\r",
							" *\r",
							" * Permission is hereby granted, free of charge, to any person obtaining a copy\r",
							" * of this software and associated documentation files (the \"Software\"), to deal\r",
							" * in the Software without restriction, including without limitation the rights\r",
							" * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r",
							" * copies of the Software, and to permit persons to whom the Software is\r",
							" * furnished to do so, subject to the following conditions:\r",
							" *\r",
							" * The above copyright notice and this permission notice shall be included in\r",
							" * all copies or substantial portions of the Software.\r",
							" *\r",
							" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r",
							" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r",
							" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r",
							" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r",
							" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r",
							" * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r",
							" * DEALINGS IN THE SOFTWARE.\r",
							" */\r",
							"var api = {};\r",
							"module.exports = api;\r",
							"\r",
							"// baseN alphabet indexes\r",
							"var _reverseAlphabets = {};\r",
							"\r",
							"/**\r",
							" * BaseN-encodes a Uint8Array using the given alphabet.\r",
							" *\r",
							" * @param input the Uint8Array to encode.\r",
							" * @param maxline the maximum number of encoded characters per line to use,\r",
							" *          defaults to none.\r",
							" *\r",
							" * @return the baseN-encoded output string.\r",
							" */\r",
							"api.encode = function(input, alphabet, maxline) {\r",
							"  if(typeof alphabet !== 'string') {\r",
							"    throw new TypeError('\"alphabet\" must be a string.');\r",
							"  }\r",
							"  if(maxline !== undefined && typeof maxline !== 'number') {\r",
							"    throw new TypeError('\"maxline\" must be a number.');\r",
							"  }\r",
							"\r",
							"  var output = '';\r",
							"\r",
							"  if(!(input instanceof Uint8Array)) {\r",
							"    // assume forge byte buffer\r",
							"    output = _encodeWithByteBuffer(input, alphabet);\r",
							"  } else {\r",
							"    var i = 0;\r",
							"    var base = alphabet.length;\r",
							"    var first = alphabet.charAt(0);\r",
							"    var digits = [0];\r",
							"    for(i = 0; i < input.length; ++i) {\r",
							"      for(var j = 0, carry = input[i]; j < digits.length; ++j) {\r",
							"        carry += digits[j] << 8;\r",
							"        digits[j] = carry % base;\r",
							"        carry = (carry / base) | 0;\r",
							"      }\r",
							"\r",
							"      while(carry > 0) {\r",
							"        digits.push(carry % base);\r",
							"        carry = (carry / base) | 0;\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // deal with leading zeros\r",
							"    for(i = 0; input[i] === 0 && i < input.length - 1; ++i) {\r",
							"      output += first;\r",
							"    }\r",
							"    // convert digits to a string\r",
							"    for(i = digits.length - 1; i >= 0; --i) {\r",
							"      output += alphabet[digits[i]];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(maxline) {\r",
							"    var regex = new RegExp('.{1,' + maxline + '}', 'g');\r",
							"    output = output.match(regex).join('\\r\\n');\r",
							"  }\r",
							"\r",
							"  return output;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Decodes a baseN-encoded (using the given alphabet) string to a\r",
							" * Uint8Array.\r",
							" *\r",
							" * @param input the baseN-encoded input string.\r",
							" *\r",
							" * @return the Uint8Array.\r",
							" */\r",
							"api.decode = function(input, alphabet) {\r",
							"  if(typeof input !== 'string') {\r",
							"    throw new TypeError('\"input\" must be a string.');\r",
							"  }\r",
							"  if(typeof alphabet !== 'string') {\r",
							"    throw new TypeError('\"alphabet\" must be a string.');\r",
							"  }\r",
							"\r",
							"  var table = _reverseAlphabets[alphabet];\r",
							"  if(!table) {\r",
							"    // compute reverse alphabet\r",
							"    table = _reverseAlphabets[alphabet] = [];\r",
							"    for(var i = 0; i < alphabet.length; ++i) {\r",
							"      table[alphabet.charCodeAt(i)] = i;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // remove whitespace characters\r",
							"  input = input.replace(/\\s/g, '');\r",
							"\r",
							"  var base = alphabet.length;\r",
							"  var first = alphabet.charAt(0);\r",
							"  var bytes = [0];\r",
							"  for(var i = 0; i < input.length; i++) {\r",
							"    var value = table[input.charCodeAt(i)];\r",
							"    if(value === undefined) {\r",
							"      return;\r",
							"    }\r",
							"\r",
							"    for(var j = 0, carry = value; j < bytes.length; ++j) {\r",
							"      carry += bytes[j] * base;\r",
							"      bytes[j] = carry & 0xff;\r",
							"      carry >>= 8;\r",
							"    }\r",
							"\r",
							"    while(carry > 0) {\r",
							"      bytes.push(carry & 0xff);\r",
							"      carry >>= 8;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // deal with leading zeros\r",
							"  for(var k = 0; input[k] === first && k < input.length - 1; ++k) {\r",
							"    bytes.push(0);\r",
							"  }\r",
							"\r",
							"  if(typeof Buffer !== 'undefined') {\r",
							"    return Buffer.from(bytes.reverse());\r",
							"  }\r",
							"\r",
							"  return new Uint8Array(bytes.reverse());\r",
							"};\r",
							"\r",
							"function _encodeWithByteBuffer(input, alphabet) {\r",
							"  var i = 0;\r",
							"  var base = alphabet.length;\r",
							"  var first = alphabet.charAt(0);\r",
							"  var digits = [0];\r",
							"  for(i = 0; i < input.length(); ++i) {\r",
							"    for(var j = 0, carry = input.at(i); j < digits.length; ++j) {\r",
							"      carry += digits[j] << 8;\r",
							"      digits[j] = carry % base;\r",
							"      carry = (carry / base) | 0;\r",
							"    }\r",
							"\r",
							"    while(carry > 0) {\r",
							"      digits.push(carry % base);\r",
							"      carry = (carry / base) | 0;\r",
							"    }\r",
							"  }\r",
							"\r",
							"  var output = '';\r",
							"\r",
							"  // deal with leading zeros\r",
							"  for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {\r",
							"    output += first;\r",
							"  }\r",
							"  // convert digits to a string\r",
							"  for(i = digits.length - 1; i >= 0; --i) {\r",
							"    output += alphabet[digits[i]];\r",
							"  }\r",
							"\r",
							"  return output;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 37 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * A Javascript implementation of AES Cipher Suites for TLS.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2009-2015 Digital Bazaar, Inc.\r",
							" *\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(19);\r",
							"\r",
							"var tls = module.exports = forge.tls;\r",
							"\r",
							"/**\r",
							" * Supported cipher suites.\r",
							" */\r",
							"tls.CipherSuites['TLS_RSA_WITH_AES_128_CBC_SHA'] = {\r",
							"  id: [0x00,0x2f],\r",
							"  name: 'TLS_RSA_WITH_AES_128_CBC_SHA',\r",
							"  initSecurityParameters: function(sp) {\r",
							"    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\r",
							"    sp.cipher_type = tls.CipherType.block;\r",
							"    sp.enc_key_length = 16;\r",
							"    sp.block_length = 16;\r",
							"    sp.fixed_iv_length = 16;\r",
							"    sp.record_iv_length = 16;\r",
							"    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\r",
							"    sp.mac_length = 20;\r",
							"    sp.mac_key_length = 20;\r",
							"  },\r",
							"  initConnectionState: initConnectionState\r",
							"};\r",
							"tls.CipherSuites['TLS_RSA_WITH_AES_256_CBC_SHA'] = {\r",
							"  id: [0x00,0x35],\r",
							"  name: 'TLS_RSA_WITH_AES_256_CBC_SHA',\r",
							"  initSecurityParameters: function(sp) {\r",
							"    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\r",
							"    sp.cipher_type = tls.CipherType.block;\r",
							"    sp.enc_key_length = 32;\r",
							"    sp.block_length = 16;\r",
							"    sp.fixed_iv_length = 16;\r",
							"    sp.record_iv_length = 16;\r",
							"    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\r",
							"    sp.mac_length = 20;\r",
							"    sp.mac_key_length = 20;\r",
							"  },\r",
							"  initConnectionState: initConnectionState\r",
							"};\r",
							"\r",
							"function initConnectionState(state, c, sp) {\r",
							"  var client = (c.entity === forge.tls.ConnectionEnd.client);\r",
							"\r",
							"  // cipher setup\r",
							"  state.read.cipherState = {\r",
							"    init: false,\r",
							"    cipher: forge.cipher.createDecipher('AES-CBC', client ?\r",
							"      sp.keys.server_write_key : sp.keys.client_write_key),\r",
							"    iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV\r",
							"  };\r",
							"  state.write.cipherState = {\r",
							"    init: false,\r",
							"    cipher: forge.cipher.createCipher('AES-CBC', client ?\r",
							"      sp.keys.client_write_key : sp.keys.server_write_key),\r",
							"    iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV\r",
							"  };\r",
							"  state.read.cipherFunction = decrypt_aes_cbc_sha1;\r",
							"  state.write.cipherFunction = encrypt_aes_cbc_sha1;\r",
							"\r",
							"  // MAC setup\r",
							"  state.read.macLength = state.write.macLength = sp.mac_length;\r",
							"  state.read.macFunction = state.write.macFunction = tls.hmac_sha1;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Encrypts the TLSCompressed record into a TLSCipherText record using AES\r",
							" * in CBC mode.\r",
							" *\r",
							" * @param record the TLSCompressed record to encrypt.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"function encrypt_aes_cbc_sha1(record, s) {\r",
							"  var rval = false;\r",
							"\r",
							"  // append MAC to fragment, update sequence number\r",
							"  var mac = s.macFunction(s.macKey, s.sequenceNumber, record);\r",
							"  record.fragment.putBytes(mac);\r",
							"  s.updateSequenceNumber();\r",
							"\r",
							"  // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\r",
							"  var iv;\r",
							"  if(record.version.minor === tls.Versions.TLS_1_0.minor) {\r",
							"    // use the pre-generated IV when initializing for TLS 1.0, otherwise use\r",
							"    // the residue from the previous encryption\r",
							"    iv = s.cipherState.init ? null : s.cipherState.iv;\r",
							"  } else {\r",
							"    iv = forge.random.getBytesSync(16);\r",
							"  }\r",
							"\r",
							"  s.cipherState.init = true;\r",
							"\r",
							"  // start cipher\r",
							"  var cipher = s.cipherState.cipher;\r",
							"  cipher.start({iv: iv});\r",
							"\r",
							"  // TLS 1.1+ write IV into output\r",
							"  if(record.version.minor >= tls.Versions.TLS_1_1.minor) {\r",
							"    cipher.output.putBytes(iv);\r",
							"  }\r",
							"\r",
							"  // do encryption (default padding is appropriate)\r",
							"  cipher.update(record.fragment);\r",
							"  if(cipher.finish(encrypt_aes_cbc_sha1_padding)) {\r",
							"    // set record fragment to encrypted output\r",
							"    record.fragment = cipher.output;\r",
							"    record.length = record.fragment.length();\r",
							"    rval = true;\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Handles padding for aes_cbc_sha1 in encrypt mode.\r",
							" *\r",
							" * @param blockSize the block size.\r",
							" * @param input the input buffer.\r",
							" * @param decrypt true in decrypt mode, false in encrypt mode.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {\r",
							"  /* The encrypted data length (TLSCiphertext.length) is one more than the sum\r",
							"   of SecurityParameters.block_length, TLSCompressed.length,\r",
							"   SecurityParameters.mac_length, and padding_length.\r",
							"\r",
							"   The padding may be any length up to 255 bytes long, as long as it results in\r",
							"   the TLSCiphertext.length being an integral multiple of the block length.\r",
							"   Lengths longer than necessary might be desirable to frustrate attacks on a\r",
							"   protocol based on analysis of the lengths of exchanged messages. Each uint8\r",
							"   in the padding data vector must be filled with the padding length value.\r",
							"\r",
							"   The padding length should be such that the total size of the\r",
							"   GenericBlockCipher structure is a multiple of the cipher's block length.\r",
							"   Legal values range from zero to 255, inclusive. This length specifies the\r",
							"   length of the padding field exclusive of the padding_length field itself.\r",
							"\r",
							"   This is slightly different from PKCS#7 because the padding value is 1\r",
							"   less than the actual number of padding bytes if you include the\r",
							"   padding_length uint8 itself as a padding byte. */\r",
							"  if(!decrypt) {\r",
							"    // get the number of padding bytes required to reach the blockSize and\r",
							"    // subtract 1 for the padding value (to make room for the padding_length\r",
							"    // uint8)\r",
							"    var padding = blockSize - (input.length() % blockSize);\r",
							"    input.fillWithByte(padding - 1, padding);\r",
							"  }\r",
							"  return true;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Handles padding for aes_cbc_sha1 in decrypt mode.\r",
							" *\r",
							" * @param blockSize the block size.\r",
							" * @param output the output buffer.\r",
							" * @param decrypt true in decrypt mode, false in encrypt mode.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {\r",
							"  var rval = true;\r",
							"  if(decrypt) {\r",
							"    /* The last byte in the output specifies the number of padding bytes not\r",
							"      including itself. Each of the padding bytes has the same value as that\r",
							"      last byte (known as the padding_length). Here we check all padding\r",
							"      bytes to ensure they have the value of padding_length even if one of\r",
							"      them is bad in order to ward-off timing attacks. */\r",
							"    var len = output.length();\r",
							"    var paddingLength = output.last();\r",
							"    for(var i = len - 1 - paddingLength; i < len - 1; ++i) {\r",
							"      rval = rval && (output.at(i) == paddingLength);\r",
							"    }\r",
							"    if(rval) {\r",
							"      // trim off padding bytes and last padding length byte\r",
							"      output.truncate(paddingLength + 1);\r",
							"    }\r",
							"  }\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decrypts a TLSCipherText record into a TLSCompressed record using\r",
							" * AES in CBC mode.\r",
							" *\r",
							" * @param record the TLSCipherText record to decrypt.\r",
							" * @param s the ConnectionState to use.\r",
							" *\r",
							" * @return true on success, false on failure.\r",
							" */\r",
							"var count = 0;\r",
							"function decrypt_aes_cbc_sha1(record, s) {\r",
							"  var rval = false;\r",
							"  ++count;\r",
							"\r",
							"  var iv;\r",
							"  if(record.version.minor === tls.Versions.TLS_1_0.minor) {\r",
							"    // use pre-generated IV when initializing for TLS 1.0, otherwise use the\r",
							"    // residue from the previous decryption\r",
							"    iv = s.cipherState.init ? null : s.cipherState.iv;\r",
							"  } else {\r",
							"    // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\r",
							"    // that is appended to the record fragment\r",
							"    iv = record.fragment.getBytes(16);\r",
							"  }\r",
							"\r",
							"  s.cipherState.init = true;\r",
							"\r",
							"  // start cipher\r",
							"  var cipher = s.cipherState.cipher;\r",
							"  cipher.start({iv: iv});\r",
							"\r",
							"  // do decryption\r",
							"  cipher.update(record.fragment);\r",
							"  rval = cipher.finish(decrypt_aes_cbc_sha1_padding);\r",
							"\r",
							"  // even if decryption fails, keep going to minimize timing attacks\r",
							"\r",
							"  // decrypted data:\r",
							"  // first (len - 20) bytes = application data\r",
							"  // last 20 bytes          = MAC\r",
							"  var macLen = s.macLength;\r",
							"\r",
							"  // create a random MAC to check against should the mac length check fail\r",
							"  // Note: do this regardless of the failure to keep timing consistent\r",
							"  var mac = forge.random.getBytesSync(macLen);\r",
							"\r",
							"  // get fragment and mac\r",
							"  var len = cipher.output.length();\r",
							"  if(len >= macLen) {\r",
							"    record.fragment = cipher.output.getBytes(len - macLen);\r",
							"    mac = cipher.output.getBytes(macLen);\r",
							"  } else {\r",
							"    // bad data, but get bytes anyway to try to keep timing consistent\r",
							"    record.fragment = cipher.output.getBytes();\r",
							"  }\r",
							"  record.fragment = forge.util.createBuffer(record.fragment);\r",
							"  record.length = record.fragment.length();\r",
							"\r",
							"  // see if data integrity checks out, update sequence number\r",
							"  var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);\r",
							"  s.updateSequenceNumber();\r",
							"  rval = compareMacs(s.macKey, mac, mac2) && rval;\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Safely compare two MACs. This function will compare two MACs in a way\r",
							" * that protects against timing attacks.\r",
							" *\r",
							" * TODO: Expose elsewhere as a utility API.\r",
							" *\r",
							" * See: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/\r",
							" *\r",
							" * @param key the MAC key to use.\r",
							" * @param mac1 as a binary-encoded string of bytes.\r",
							" * @param mac2 as a binary-encoded string of bytes.\r",
							" *\r",
							" * @return true if the MACs are the same, false if not.\r",
							" */\r",
							"function compareMacs(key, mac1, mac2) {\r",
							"  var hmac = forge.hmac.create();\r",
							"\r",
							"  hmac.start('SHA1', key);\r",
							"  hmac.update(mac1);\r",
							"  mac1 = hmac.digest().getBytes();\r",
							"\r",
							"  hmac.start(null, null);\r",
							"  hmac.update(mac2);\r",
							"  mac2 = hmac.digest().getBytes();\r",
							"\r",
							"  return mac1 === mac2;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 38 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for Forge mask generation functions.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" *\r",
							" * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(30);\r",
							"\r",
							"module.exports = forge.mgf = forge.mgf || {};\r",
							"forge.mgf.mgf1 = forge.mgf1;\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 39 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * JavaScript implementation of Ed25519.\r",
							" *\r",
							" * Copyright (c) 2017-2018 Digital Bazaar, Inc.\r",
							" *\r",
							" * This implementation is based on the most excellent TweetNaCl which is\r",
							" * in the public domain. Many thanks to its contributors:\r",
							" *\r",
							" * https://github.com/dchest/tweetnacl-js\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(12);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(32);\r",
							"__webpack_require__(1);\r",
							"\r",
							"if(typeof BigInteger === 'undefined') {\r",
							"  var BigInteger = forge.jsbn.BigInteger;\r",
							"}\r",
							"\r",
							"var ByteBuffer = forge.util.ByteBuffer;\r",
							"var NativeBuffer = typeof Buffer === 'undefined' ? Uint8Array : Buffer;\r",
							"\r",
							"/*\r",
							" * Ed25519 algorithms, see RFC 8032:\r",
							" * https://tools.ietf.org/html/rfc8032\r",
							" */\r",
							"forge.pki = forge.pki || {};\r",
							"module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};\r",
							"var ed25519 = forge.ed25519;\r",
							"\r",
							"ed25519.constants = {};\r",
							"ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;\r",
							"ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;\r",
							"ed25519.constants.SEED_BYTE_LENGTH = 32;\r",
							"ed25519.constants.SIGN_BYTE_LENGTH = 64;\r",
							"ed25519.constants.HASH_BYTE_LENGTH = 64;\r",
							"\r",
							"ed25519.generateKeyPair = function(options) {\r",
							"  options = options || {};\r",
							"  var seed = options.seed;\r",
							"  if(seed === undefined) {\r",
							"    // generate seed\r",
							"    seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);\r",
							"  } else if(typeof seed === 'string') {\r",
							"    if(seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {\r",
							"      throw new TypeError(\r",
							"        '\"seed\" must be ' + ed25519.constants.SEED_BYTE_LENGTH +\r",
							"        ' bytes in length.');\r",
							"    }\r",
							"  } else if(!(seed instanceof Uint8Array)) {\r",
							"    throw new TypeError(\r",
							"      '\"seed\" must be a node.js Buffer, Uint8Array, or a binary string.');\r",
							"  }\r",
							"\r",
							"  seed = messageToNativeBuffer({message: seed, encoding: 'binary'});\r",
							"\r",
							"  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\r",
							"  var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\r",
							"  for(var i = 0; i < 32; ++i) {\r",
							"    sk[i] = seed[i];\r",
							"  }\r",
							"  crypto_sign_keypair(pk, sk);\r",
							"  return {publicKey: pk, privateKey: sk};\r",
							"};\r",
							"\r",
							"ed25519.publicKeyFromPrivateKey = function(options) {\r",
							"  options = options || {};\r",
							"  var privateKey = messageToNativeBuffer({\r",
							"    message: options.privateKey, encoding: 'binary'\r",
							"  });\r",
							"  if(privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.privateKey\" must have a byte length of ' +\r",
							"      ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\r",
							"  }\r",
							"\r",
							"  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\r",
							"  for(var i = 0; i < pk.length; ++i) {\r",
							"    pk[i] = privateKey[32 + i];\r",
							"  }\r",
							"  return pk;\r",
							"};\r",
							"\r",
							"ed25519.sign = function(options) {\r",
							"  options = options || {};\r",
							"  var msg = messageToNativeBuffer(options);\r",
							"  var privateKey = messageToNativeBuffer({\r",
							"    message: options.privateKey,\r",
							"    encoding: 'binary'\r",
							"  });\r",
							"  if(privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.privateKey\" must have a byte length of ' +\r",
							"      ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\r",
							"  }\r",
							"\r",
							"  var signedMsg = new NativeBuffer(\r",
							"    ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\r",
							"  crypto_sign(signedMsg, msg, msg.length, privateKey);\r",
							"\r",
							"  var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);\r",
							"  for(var i = 0; i < sig.length; ++i) {\r",
							"    sig[i] = signedMsg[i];\r",
							"  }\r",
							"  return sig;\r",
							"};\r",
							"\r",
							"ed25519.verify = function(options) {\r",
							"  options = options || {};\r",
							"  var msg = messageToNativeBuffer(options);\r",
							"  if(options.signature === undefined) {\r",
							"    throw new TypeError(\r",
							"      '\"options.signature\" must be a node.js Buffer, a Uint8Array, a forge ' +\r",
							"      'ByteBuffer, or a binary string.');\r",
							"  }\r",
							"  var sig = messageToNativeBuffer({\r",
							"    message: options.signature,\r",
							"    encoding: 'binary'\r",
							"  });\r",
							"  if(sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.signature\" must have a byte length of ' +\r",
							"      ed25519.constants.SIGN_BYTE_LENGTH);\r",
							"  }\r",
							"  var publicKey = messageToNativeBuffer({\r",
							"    message: options.publicKey,\r",
							"    encoding: 'binary'\r",
							"  });\r",
							"  if(publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {\r",
							"    throw new TypeError(\r",
							"      '\"options.publicKey\" must have a byte length of ' +\r",
							"      ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\r",
							"  }\r",
							"\r",
							"  var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\r",
							"  var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\r",
							"  var i;\r",
							"  for(i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {\r",
							"    sm[i] = sig[i];\r",
							"  }\r",
							"  for(i = 0; i < msg.length; ++i) {\r",
							"    sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];\r",
							"  }\r",
							"  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\r",
							"};\r",
							"\r",
							"function messageToNativeBuffer(options) {\r",
							"  var message = options.message;\r",
							"  if(message instanceof Uint8Array) {\r",
							"    return message;\r",
							"  }\r",
							"\r",
							"  var encoding = options.encoding;\r",
							"  if(message === undefined) {\r",
							"    if(options.md) {\r",
							"      // TODO: more rigorous validation that `md` is a MessageDigest\r",
							"      message = options.md.digest().getBytes();\r",
							"      encoding = 'binary';\r",
							"    } else {\r",
							"      throw new TypeError('\"options.message\" or \"options.md\" not specified.');\r",
							"    }\r",
							"  }\r",
							"\r",
							"  if(typeof message === 'string' && !encoding) {\r",
							"    throw new TypeError('\"options.encoding\" must be \"binary\" or \"utf8\".');\r",
							"  }\r",
							"\r",
							"  if(typeof message === 'string') {\r",
							"    if(typeof Buffer !== 'undefined') {\r",
							"      return new Buffer(message, encoding);\r",
							"    }\r",
							"    message = new ByteBuffer(message, encoding);\r",
							"  } else if(!(message instanceof ByteBuffer)) {\r",
							"    throw new TypeError(\r",
							"      '\"options.message\" must be a node.js Buffer, a Uint8Array, a forge ' +\r",
							"      'ByteBuffer, or a string with \"options.encoding\" specifying its ' +\r",
							"      'encoding.');\r",
							"  }\r",
							"\r",
							"  // convert to native buffer\r",
							"  var buffer = new NativeBuffer(message.length());\r",
							"  for(var i = 0; i < buffer.length; ++i) {\r",
							"    buffer[i] = message.at(i);\r",
							"  }\r",
							"  return buffer;\r",
							"}\r",
							"\r",
							"var gf0 = gf();\r",
							"var gf1 = gf([1]);\r",
							"var D = gf([\r",
							"  0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,\r",
							"  0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]);\r",
							"var D2 = gf([\r",
							"  0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,\r",
							"  0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]);\r",
							"var X = gf([\r",
							"  0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,\r",
							"  0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]);\r",
							"var Y = gf([\r",
							"  0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,\r",
							"  0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]);\r",
							"var L = new Float64Array([\r",
							"  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\r",
							"  0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\r",
							"  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\r",
							"var I = gf([\r",
							"  0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,\r",
							"  0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\r",
							"\r",
							"// TODO: update forge buffer implementation to use `Buffer` or `Uint8Array`,\r",
							"// whichever is available, to improve performance\r",
							"function sha512(msg, msgLen) {\r",
							"  // Note: `out` and `msg` are NativeBuffer\r",
							"  var md = forge.md.sha512.create();\r",
							"  var buffer = new ByteBuffer(msg);\r",
							"  md.update(buffer.getBytes(msgLen), 'binary');\r",
							"  var hash = md.digest().getBytes();\r",
							"  if(typeof Buffer !== 'undefined') {\r",
							"    return new Buffer(hash, 'binary');\r",
							"  }\r",
							"  var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);\r",
							"  for(var i = 0; i < 64; ++i) {\r",
							"    out[i] = hash.charCodeAt(i);\r",
							"  }\r",
							"  return out;\r",
							"}\r",
							"\r",
							"function crypto_sign_keypair(pk, sk) {\r",
							"  var p = [gf(), gf(), gf(), gf()];\r",
							"  var i;\r",
							"\r",
							"  var d = sha512(sk, 32);\r",
							"  d[0] &= 248;\r",
							"  d[31] &= 127;\r",
							"  d[31] |= 64;\r",
							"\r",
							"  scalarbase(p, d);\r",
							"  pack(pk, p);\r",
							"\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    sk[i + 32] = pk[i];\r",
							"  }\r",
							"  return 0;\r",
							"}\r",
							"\r",
							"// Note: difference from C - smlen returned, not passed as argument.\r",
							"function crypto_sign(sm, m, n, sk) {\r",
							"  var i, j, x = new Float64Array(64);\r",
							"  var p = [gf(), gf(), gf(), gf()];\r",
							"\r",
							"  var d = sha512(sk, 32);\r",
							"  d[0] &= 248;\r",
							"  d[31] &= 127;\r",
							"  d[31] |= 64;\r",
							"\r",
							"  var smlen = n + 64;\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    sm[64 + i] = m[i];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    sm[32 + i] = d[32 + i];\r",
							"  }\r",
							"\r",
							"  var r = sha512(sm.subarray(32), n + 32);\r",
							"  reduce(r);\r",
							"  scalarbase(p, r);\r",
							"  pack(sm, p);\r",
							"\r",
							"  for(i = 32; i < 64; ++i) {\r",
							"    sm[i] = sk[i];\r",
							"  }\r",
							"  var h = sha512(sm, n + 64);\r",
							"  reduce(h);\r",
							"\r",
							"  for(i = 32; i < 64; ++i) {\r",
							"    x[i] = 0;\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    x[i] = r[i];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    for(j = 0; j < 32; j++) {\r",
							"      x[i + j] += h[i] * d[j];\r",
							"    }\r",
							"  }\r",
							"\r",
							"  modL(sm.subarray(32), x);\r",
							"  return smlen;\r",
							"}\r",
							"\r",
							"function crypto_sign_open(m, sm, n, pk) {\r",
							"  var i, mlen;\r",
							"  var t = new NativeBuffer(32);\r",
							"  var p = [gf(), gf(), gf(), gf()],\r",
							"      q = [gf(), gf(), gf(), gf()];\r",
							"\r",
							"  mlen = -1;\r",
							"  if(n < 64) {\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  if(unpackneg(q, pk)) {\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    m[i] = sm[i];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    m[i + 32] = pk[i];\r",
							"  }\r",
							"  var h = sha512(m, n);\r",
							"  reduce(h);\r",
							"  scalarmult(p, q, h);\r",
							"\r",
							"  scalarbase(q, sm.subarray(32));\r",
							"  add(p, q);\r",
							"  pack(t, p);\r",
							"\r",
							"  n -= 64;\r",
							"  if(crypto_verify_32(sm, 0, t, 0)) {\r",
							"    for(i = 0; i < n; ++i) {\r",
							"      m[i] = 0;\r",
							"    }\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    m[i] = sm[i + 64];\r",
							"  }\r",
							"  mlen = n;\r",
							"  return mlen;\r",
							"}\r",
							"\r",
							"function modL(r, x) {\r",
							"  var carry, i, j, k;\r",
							"  for(i = 63; i >= 32; --i) {\r",
							"    carry = 0;\r",
							"    for(j = i - 32, k = i - 12; j < k; ++j) {\r",
							"      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\r",
							"      carry = (x[j] + 128) >> 8;\r",
							"      x[j] -= carry * 256;\r",
							"    }\r",
							"    x[j] += carry;\r",
							"    x[i] = 0;\r",
							"  }\r",
							"  carry = 0;\r",
							"  for(j = 0; j < 32; ++j) {\r",
							"    x[j] += carry - (x[31] >> 4) * L[j];\r",
							"    carry = x[j] >> 8;\r",
							"    x[j] &= 255;\r",
							"  }\r",
							"  for(j = 0; j < 32; ++j) {\r",
							"    x[j] -= carry * L[j];\r",
							"  }\r",
							"  for(i = 0; i < 32; ++i) {\r",
							"    x[i + 1] += x[i] >> 8;\r",
							"    r[i] = x[i] & 255;\r",
							"  }\r",
							"}\r",
							"\r",
							"function reduce(r) {\r",
							"  var x = new Float64Array(64);\r",
							"  for(var i = 0; i < 64; ++i) {\r",
							"    x[i] = r[i];\r",
							"    r[i] = 0;\r",
							"  }\r",
							"  modL(r, x);\r",
							"}\r",
							"\r",
							"function add(p, q) {\r",
							"  var a = gf(), b = gf(), c = gf(),\r",
							"      d = gf(), e = gf(), f = gf(),\r",
							"      g = gf(), h = gf(), t = gf();\r",
							"\r",
							"  Z(a, p[1], p[0]);\r",
							"  Z(t, q[1], q[0]);\r",
							"  M(a, a, t);\r",
							"  A(b, p[0], p[1]);\r",
							"  A(t, q[0], q[1]);\r",
							"  M(b, b, t);\r",
							"  M(c, p[3], q[3]);\r",
							"  M(c, c, D2);\r",
							"  M(d, p[2], q[2]);\r",
							"  A(d, d, d);\r",
							"  Z(e, b, a);\r",
							"  Z(f, d, c);\r",
							"  A(g, d, c);\r",
							"  A(h, b, a);\r",
							"\r",
							"  M(p[0], e, f);\r",
							"  M(p[1], h, g);\r",
							"  M(p[2], g, f);\r",
							"  M(p[3], e, h);\r",
							"}\r",
							"\r",
							"function cswap(p, q, b) {\r",
							"  for(var i = 0; i < 4; ++i) {\r",
							"    sel25519(p[i], q[i], b);\r",
							"  }\r",
							"}\r",
							"\r",
							"function pack(r, p) {\r",
							"  var tx = gf(), ty = gf(), zi = gf();\r",
							"  inv25519(zi, p[2]);\r",
							"  M(tx, p[0], zi);\r",
							"  M(ty, p[1], zi);\r",
							"  pack25519(r, ty);\r",
							"  r[31] ^= par25519(tx) << 7;\r",
							"}\r",
							"\r",
							"function pack25519(o, n) {\r",
							"  var i, j, b;\r",
							"  var m = gf(), t = gf();\r",
							"  for(i = 0; i < 16; ++i) {\r",
							"    t[i] = n[i];\r",
							"  }\r",
							"  car25519(t);\r",
							"  car25519(t);\r",
							"  car25519(t);\r",
							"  for(j = 0; j < 2; ++j) {\r",
							"    m[0] = t[0] - 0xffed;\r",
							"    for(i = 1; i < 15; ++i) {\r",
							"      m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);\r",
							"      m[i-1] &= 0xffff;\r",
							"    }\r",
							"    m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);\r",
							"    b = (m[15] >> 16) & 1;\r",
							"    m[14] &= 0xffff;\r",
							"    sel25519(t, m, 1 - b);\r",
							"  }\r",
							"  for (i = 0; i < 16; i++) {\r",
							"    o[2 * i] = t[i] & 0xff;\r",
							"    o[2 * i + 1] = t[i] >> 8;\r",
							"  }\r",
							"}\r",
							"\r",
							"function unpackneg(r, p) {\r",
							"  var t = gf(), chk = gf(), num = gf(),\r",
							"      den = gf(), den2 = gf(), den4 = gf(),\r",
							"      den6 = gf();\r",
							"\r",
							"  set25519(r[2], gf1);\r",
							"  unpack25519(r[1], p);\r",
							"  S(num, r[1]);\r",
							"  M(den, num, D);\r",
							"  Z(num, num, r[2]);\r",
							"  A(den, r[2], den);\r",
							"\r",
							"  S(den2, den);\r",
							"  S(den4, den2);\r",
							"  M(den6, den4, den2);\r",
							"  M(t, den6, num);\r",
							"  M(t, t, den);\r",
							"\r",
							"  pow2523(t, t);\r",
							"  M(t, t, num);\r",
							"  M(t, t, den);\r",
							"  M(t, t, den);\r",
							"  M(r[0], t, den);\r",
							"\r",
							"  S(chk, r[0]);\r",
							"  M(chk, chk, den);\r",
							"  if(neq25519(chk, num)) {\r",
							"    M(r[0], r[0], I);\r",
							"  }\r",
							"\r",
							"  S(chk, r[0]);\r",
							"  M(chk, chk, den);\r",
							"  if(neq25519(chk, num)) {\r",
							"    return -1;\r",
							"  }\r",
							"\r",
							"  if(par25519(r[0]) === (p[31] >> 7)) {\r",
							"    Z(r[0], gf0, r[0]);\r",
							"  }\r",
							"\r",
							"  M(r[3], r[0], r[1]);\r",
							"  return 0;\r",
							"}\r",
							"\r",
							"function unpack25519(o, n) {\r",
							"  var i;\r",
							"  for(i = 0; i < 16; ++i) {\r",
							"    o[i] = n[2 * i] + (n[2 * i + 1] << 8);\r",
							"  }\r",
							"  o[15] &= 0x7fff;\r",
							"}\r",
							"\r",
							"function pow2523(o, i) {\r",
							"  var c = gf();\r",
							"  var a;\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    c[a] = i[a];\r",
							"  }\r",
							"  for(a = 250; a >= 0; --a) {\r",
							"    S(c, c);\r",
							"    if(a !== 1) {\r",
							"      M(c, c, i);\r",
							"    }\r",
							"  }\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    o[a] = c[a];\r",
							"  }\r",
							"}\r",
							"\r",
							"function neq25519(a, b) {\r",
							"  var c = new NativeBuffer(32);\r",
							"  var d = new NativeBuffer(32);\r",
							"  pack25519(c, a);\r",
							"  pack25519(d, b);\r",
							"  return crypto_verify_32(c, 0, d, 0);\r",
							"}\r",
							"\r",
							"function crypto_verify_32(x, xi, y, yi) {\r",
							"  return vn(x, xi, y, yi, 32);\r",
							"}\r",
							"\r",
							"function vn(x, xi, y, yi, n) {\r",
							"  var i, d = 0;\r",
							"  for(i = 0; i < n; ++i) {\r",
							"    d |= x[xi + i] ^ y[yi + i];\r",
							"  }\r",
							"  return (1 & ((d - 1) >>> 8)) - 1;\r",
							"}\r",
							"\r",
							"function par25519(a) {\r",
							"  var d = new NativeBuffer(32);\r",
							"  pack25519(d, a);\r",
							"  return d[0] & 1;\r",
							"}\r",
							"\r",
							"function scalarmult(p, q, s) {\r",
							"  var b, i;\r",
							"  set25519(p[0], gf0);\r",
							"  set25519(p[1], gf1);\r",
							"  set25519(p[2], gf1);\r",
							"  set25519(p[3], gf0);\r",
							"  for(i = 255; i >= 0; --i) {\r",
							"    b = (s[(i / 8)|0] >> (i & 7)) & 1;\r",
							"    cswap(p, q, b);\r",
							"    add(q, p);\r",
							"    add(p, p);\r",
							"    cswap(p, q, b);\r",
							"  }\r",
							"}\r",
							"\r",
							"function scalarbase(p, s) {\r",
							"  var q = [gf(), gf(), gf(), gf()];\r",
							"  set25519(q[0], X);\r",
							"  set25519(q[1], Y);\r",
							"  set25519(q[2], gf1);\r",
							"  M(q[3], X, Y);\r",
							"  scalarmult(p, q, s);\r",
							"}\r",
							"\r",
							"function set25519(r, a) {\r",
							"  var i;\r",
							"  for(i = 0; i < 16; i++) {\r",
							"    r[i] = a[i] | 0;\r",
							"  }\r",
							"}\r",
							"\r",
							"function inv25519(o, i) {\r",
							"  var c = gf();\r",
							"  var a;\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    c[a] = i[a];\r",
							"  }\r",
							"  for(a = 253; a >= 0; --a) {\r",
							"    S(c, c);\r",
							"    if(a !== 2 && a !== 4) {\r",
							"      M(c, c, i);\r",
							"    }\r",
							"  }\r",
							"  for(a = 0; a < 16; ++a) {\r",
							"    o[a] = c[a];\r",
							"  }\r",
							"}\r",
							"\r",
							"function car25519(o) {\r",
							"  var i, v, c = 1;\r",
							"  for(i = 0; i < 16; ++i) {\r",
							"    v = o[i] + c + 65535;\r",
							"    c = Math.floor(v / 65536);\r",
							"    o[i] = v - c * 65536;\r",
							"  }\r",
							"  o[0] += c - 1 + 37 * (c - 1);\r",
							"}\r",
							"\r",
							"function sel25519(p, q, b) {\r",
							"  var t, c = ~(b - 1);\r",
							"  for(var i = 0; i < 16; ++i) {\r",
							"    t = c & (p[i] ^ q[i]);\r",
							"    p[i] ^= t;\r",
							"    q[i] ^= t;\r",
							"  }\r",
							"}\r",
							"\r",
							"function gf(init) {\r",
							"  var i, r = new Float64Array(16);\r",
							"  if(init) {\r",
							"    for(i = 0; i < init.length; ++i) {\r",
							"      r[i] = init[i];\r",
							"    }\r",
							"  }\r",
							"  return r;\r",
							"}\r",
							"\r",
							"function A(o, a, b) {\r",
							"  for(var i = 0; i < 16; ++i) {\r",
							"    o[i] = a[i] + b[i];\r",
							"  }\r",
							"}\r",
							"\r",
							"function Z(o, a, b) {\r",
							"  for(var i = 0; i < 16; ++i) {\r",
							"    o[i] = a[i] - b[i];\r",
							"  }\r",
							"}\r",
							"\r",
							"function S(o, a) {\r",
							"  M(o, a, a);\r",
							"}\r",
							"\r",
							"function M(o, a, b) {\r",
							"  var v, c,\r",
							"     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\r",
							"     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\r",
							"    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\r",
							"    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\r",
							"    b0 = b[0],\r",
							"    b1 = b[1],\r",
							"    b2 = b[2],\r",
							"    b3 = b[3],\r",
							"    b4 = b[4],\r",
							"    b5 = b[5],\r",
							"    b6 = b[6],\r",
							"    b7 = b[7],\r",
							"    b8 = b[8],\r",
							"    b9 = b[9],\r",
							"    b10 = b[10],\r",
							"    b11 = b[11],\r",
							"    b12 = b[12],\r",
							"    b13 = b[13],\r",
							"    b14 = b[14],\r",
							"    b15 = b[15];\r",
							"\r",
							"  v = a[0];\r",
							"  t0 += v * b0;\r",
							"  t1 += v * b1;\r",
							"  t2 += v * b2;\r",
							"  t3 += v * b3;\r",
							"  t4 += v * b4;\r",
							"  t5 += v * b5;\r",
							"  t6 += v * b6;\r",
							"  t7 += v * b7;\r",
							"  t8 += v * b8;\r",
							"  t9 += v * b9;\r",
							"  t10 += v * b10;\r",
							"  t11 += v * b11;\r",
							"  t12 += v * b12;\r",
							"  t13 += v * b13;\r",
							"  t14 += v * b14;\r",
							"  t15 += v * b15;\r",
							"  v = a[1];\r",
							"  t1 += v * b0;\r",
							"  t2 += v * b1;\r",
							"  t3 += v * b2;\r",
							"  t4 += v * b3;\r",
							"  t5 += v * b4;\r",
							"  t6 += v * b5;\r",
							"  t7 += v * b6;\r",
							"  t8 += v * b7;\r",
							"  t9 += v * b8;\r",
							"  t10 += v * b9;\r",
							"  t11 += v * b10;\r",
							"  t12 += v * b11;\r",
							"  t13 += v * b12;\r",
							"  t14 += v * b13;\r",
							"  t15 += v * b14;\r",
							"  t16 += v * b15;\r",
							"  v = a[2];\r",
							"  t2 += v * b0;\r",
							"  t3 += v * b1;\r",
							"  t4 += v * b2;\r",
							"  t5 += v * b3;\r",
							"  t6 += v * b4;\r",
							"  t7 += v * b5;\r",
							"  t8 += v * b6;\r",
							"  t9 += v * b7;\r",
							"  t10 += v * b8;\r",
							"  t11 += v * b9;\r",
							"  t12 += v * b10;\r",
							"  t13 += v * b11;\r",
							"  t14 += v * b12;\r",
							"  t15 += v * b13;\r",
							"  t16 += v * b14;\r",
							"  t17 += v * b15;\r",
							"  v = a[3];\r",
							"  t3 += v * b0;\r",
							"  t4 += v * b1;\r",
							"  t5 += v * b2;\r",
							"  t6 += v * b3;\r",
							"  t7 += v * b4;\r",
							"  t8 += v * b5;\r",
							"  t9 += v * b6;\r",
							"  t10 += v * b7;\r",
							"  t11 += v * b8;\r",
							"  t12 += v * b9;\r",
							"  t13 += v * b10;\r",
							"  t14 += v * b11;\r",
							"  t15 += v * b12;\r",
							"  t16 += v * b13;\r",
							"  t17 += v * b14;\r",
							"  t18 += v * b15;\r",
							"  v = a[4];\r",
							"  t4 += v * b0;\r",
							"  t5 += v * b1;\r",
							"  t6 += v * b2;\r",
							"  t7 += v * b3;\r",
							"  t8 += v * b4;\r",
							"  t9 += v * b5;\r",
							"  t10 += v * b6;\r",
							"  t11 += v * b7;\r",
							"  t12 += v * b8;\r",
							"  t13 += v * b9;\r",
							"  t14 += v * b10;\r",
							"  t15 += v * b11;\r",
							"  t16 += v * b12;\r",
							"  t17 += v * b13;\r",
							"  t18 += v * b14;\r",
							"  t19 += v * b15;\r",
							"  v = a[5];\r",
							"  t5 += v * b0;\r",
							"  t6 += v * b1;\r",
							"  t7 += v * b2;\r",
							"  t8 += v * b3;\r",
							"  t9 += v * b4;\r",
							"  t10 += v * b5;\r",
							"  t11 += v * b6;\r",
							"  t12 += v * b7;\r",
							"  t13 += v * b8;\r",
							"  t14 += v * b9;\r",
							"  t15 += v * b10;\r",
							"  t16 += v * b11;\r",
							"  t17 += v * b12;\r",
							"  t18 += v * b13;\r",
							"  t19 += v * b14;\r",
							"  t20 += v * b15;\r",
							"  v = a[6];\r",
							"  t6 += v * b0;\r",
							"  t7 += v * b1;\r",
							"  t8 += v * b2;\r",
							"  t9 += v * b3;\r",
							"  t10 += v * b4;\r",
							"  t11 += v * b5;\r",
							"  t12 += v * b6;\r",
							"  t13 += v * b7;\r",
							"  t14 += v * b8;\r",
							"  t15 += v * b9;\r",
							"  t16 += v * b10;\r",
							"  t17 += v * b11;\r",
							"  t18 += v * b12;\r",
							"  t19 += v * b13;\r",
							"  t20 += v * b14;\r",
							"  t21 += v * b15;\r",
							"  v = a[7];\r",
							"  t7 += v * b0;\r",
							"  t8 += v * b1;\r",
							"  t9 += v * b2;\r",
							"  t10 += v * b3;\r",
							"  t11 += v * b4;\r",
							"  t12 += v * b5;\r",
							"  t13 += v * b6;\r",
							"  t14 += v * b7;\r",
							"  t15 += v * b8;\r",
							"  t16 += v * b9;\r",
							"  t17 += v * b10;\r",
							"  t18 += v * b11;\r",
							"  t19 += v * b12;\r",
							"  t20 += v * b13;\r",
							"  t21 += v * b14;\r",
							"  t22 += v * b15;\r",
							"  v = a[8];\r",
							"  t8 += v * b0;\r",
							"  t9 += v * b1;\r",
							"  t10 += v * b2;\r",
							"  t11 += v * b3;\r",
							"  t12 += v * b4;\r",
							"  t13 += v * b5;\r",
							"  t14 += v * b6;\r",
							"  t15 += v * b7;\r",
							"  t16 += v * b8;\r",
							"  t17 += v * b9;\r",
							"  t18 += v * b10;\r",
							"  t19 += v * b11;\r",
							"  t20 += v * b12;\r",
							"  t21 += v * b13;\r",
							"  t22 += v * b14;\r",
							"  t23 += v * b15;\r",
							"  v = a[9];\r",
							"  t9 += v * b0;\r",
							"  t10 += v * b1;\r",
							"  t11 += v * b2;\r",
							"  t12 += v * b3;\r",
							"  t13 += v * b4;\r",
							"  t14 += v * b5;\r",
							"  t15 += v * b6;\r",
							"  t16 += v * b7;\r",
							"  t17 += v * b8;\r",
							"  t18 += v * b9;\r",
							"  t19 += v * b10;\r",
							"  t20 += v * b11;\r",
							"  t21 += v * b12;\r",
							"  t22 += v * b13;\r",
							"  t23 += v * b14;\r",
							"  t24 += v * b15;\r",
							"  v = a[10];\r",
							"  t10 += v * b0;\r",
							"  t11 += v * b1;\r",
							"  t12 += v * b2;\r",
							"  t13 += v * b3;\r",
							"  t14 += v * b4;\r",
							"  t15 += v * b5;\r",
							"  t16 += v * b6;\r",
							"  t17 += v * b7;\r",
							"  t18 += v * b8;\r",
							"  t19 += v * b9;\r",
							"  t20 += v * b10;\r",
							"  t21 += v * b11;\r",
							"  t22 += v * b12;\r",
							"  t23 += v * b13;\r",
							"  t24 += v * b14;\r",
							"  t25 += v * b15;\r",
							"  v = a[11];\r",
							"  t11 += v * b0;\r",
							"  t12 += v * b1;\r",
							"  t13 += v * b2;\r",
							"  t14 += v * b3;\r",
							"  t15 += v * b4;\r",
							"  t16 += v * b5;\r",
							"  t17 += v * b6;\r",
							"  t18 += v * b7;\r",
							"  t19 += v * b8;\r",
							"  t20 += v * b9;\r",
							"  t21 += v * b10;\r",
							"  t22 += v * b11;\r",
							"  t23 += v * b12;\r",
							"  t24 += v * b13;\r",
							"  t25 += v * b14;\r",
							"  t26 += v * b15;\r",
							"  v = a[12];\r",
							"  t12 += v * b0;\r",
							"  t13 += v * b1;\r",
							"  t14 += v * b2;\r",
							"  t15 += v * b3;\r",
							"  t16 += v * b4;\r",
							"  t17 += v * b5;\r",
							"  t18 += v * b6;\r",
							"  t19 += v * b7;\r",
							"  t20 += v * b8;\r",
							"  t21 += v * b9;\r",
							"  t22 += v * b10;\r",
							"  t23 += v * b11;\r",
							"  t24 += v * b12;\r",
							"  t25 += v * b13;\r",
							"  t26 += v * b14;\r",
							"  t27 += v * b15;\r",
							"  v = a[13];\r",
							"  t13 += v * b0;\r",
							"  t14 += v * b1;\r",
							"  t15 += v * b2;\r",
							"  t16 += v * b3;\r",
							"  t17 += v * b4;\r",
							"  t18 += v * b5;\r",
							"  t19 += v * b6;\r",
							"  t20 += v * b7;\r",
							"  t21 += v * b8;\r",
							"  t22 += v * b9;\r",
							"  t23 += v * b10;\r",
							"  t24 += v * b11;\r",
							"  t25 += v * b12;\r",
							"  t26 += v * b13;\r",
							"  t27 += v * b14;\r",
							"  t28 += v * b15;\r",
							"  v = a[14];\r",
							"  t14 += v * b0;\r",
							"  t15 += v * b1;\r",
							"  t16 += v * b2;\r",
							"  t17 += v * b3;\r",
							"  t18 += v * b4;\r",
							"  t19 += v * b5;\r",
							"  t20 += v * b6;\r",
							"  t21 += v * b7;\r",
							"  t22 += v * b8;\r",
							"  t23 += v * b9;\r",
							"  t24 += v * b10;\r",
							"  t25 += v * b11;\r",
							"  t26 += v * b12;\r",
							"  t27 += v * b13;\r",
							"  t28 += v * b14;\r",
							"  t29 += v * b15;\r",
							"  v = a[15];\r",
							"  t15 += v * b0;\r",
							"  t16 += v * b1;\r",
							"  t17 += v * b2;\r",
							"  t18 += v * b3;\r",
							"  t19 += v * b4;\r",
							"  t20 += v * b5;\r",
							"  t21 += v * b6;\r",
							"  t22 += v * b7;\r",
							"  t23 += v * b8;\r",
							"  t24 += v * b9;\r",
							"  t25 += v * b10;\r",
							"  t26 += v * b11;\r",
							"  t27 += v * b12;\r",
							"  t28 += v * b13;\r",
							"  t29 += v * b14;\r",
							"  t30 += v * b15;\r",
							"\r",
							"  t0  += 38 * t16;\r",
							"  t1  += 38 * t17;\r",
							"  t2  += 38 * t18;\r",
							"  t3  += 38 * t19;\r",
							"  t4  += 38 * t20;\r",
							"  t5  += 38 * t21;\r",
							"  t6  += 38 * t22;\r",
							"  t7  += 38 * t23;\r",
							"  t8  += 38 * t24;\r",
							"  t9  += 38 * t25;\r",
							"  t10 += 38 * t26;\r",
							"  t11 += 38 * t27;\r",
							"  t12 += 38 * t28;\r",
							"  t13 += 38 * t29;\r",
							"  t14 += 38 * t30;\r",
							"  // t15 left as is\r",
							"\r",
							"  // first car\r",
							"  c = 1;\r",
							"  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\r",
							"  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\r",
							"  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\r",
							"  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\r",
							"  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\r",
							"  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\r",
							"  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\r",
							"  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\r",
							"  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\r",
							"  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\r",
							"  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\r",
							"  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\r",
							"  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\r",
							"  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\r",
							"  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\r",
							"  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\r",
							"  t0 += c-1 + 37 * (c-1);\r",
							"\r",
							"  // second car\r",
							"  c = 1;\r",
							"  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\r",
							"  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\r",
							"  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\r",
							"  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\r",
							"  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\r",
							"  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\r",
							"  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\r",
							"  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\r",
							"  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\r",
							"  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\r",
							"  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\r",
							"  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\r",
							"  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\r",
							"  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\r",
							"  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\r",
							"  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\r",
							"  t0 += c-1 + 37 * (c-1);\r",
							"\r",
							"  o[ 0] = t0;\r",
							"  o[ 1] = t1;\r",
							"  o[ 2] = t2;\r",
							"  o[ 3] = t3;\r",
							"  o[ 4] = t4;\r",
							"  o[ 5] = t5;\r",
							"  o[ 6] = t6;\r",
							"  o[ 7] = t7;\r",
							"  o[ 8] = t8;\r",
							"  o[ 9] = t9;\r",
							"  o[10] = t10;\r",
							"  o[11] = t11;\r",
							"  o[12] = t12;\r",
							"  o[13] = t13;\r",
							"  o[14] = t14;\r",
							"  o[15] = t15;\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 40 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of RSA-KEM.\r",
							" *\r",
							" * @author Lautaro Cozzani Rodriguez\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\r",
							" * Copyright (c) 2014 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(12);\r",
							"\r",
							"module.exports = forge.kem = forge.kem || {};\r",
							"\r",
							"var BigInteger = forge.jsbn.BigInteger;\r",
							"\r",
							"/**\r",
							" * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\r",
							" */\r",
							"forge.kem.rsa = {};\r",
							"\r",
							"/**\r",
							" * Creates an RSA KEM API object for generating a secret asymmetric key.\r",
							" *\r",
							" * The symmetric key may be generated via a call to 'encrypt', which will\r",
							" * produce a ciphertext to be transmitted to the recipient and a key to be\r",
							" * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\r",
							" * will produce the same secret key for the recipient to use to decrypt a\r",
							" * message that was encrypted with the secret key.\r",
							" *\r",
							" * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\r",
							" * @param options the options to use.\r",
							" *          [prng] a custom crypto-secure pseudo-random number generator to use,\r",
							" *            that must define \"getBytesSync\".\r",
							" */\r",
							"forge.kem.rsa.create = function(kdf, options) {\r",
							"  options = options || {};\r",
							"  var prng = options.prng || forge.random;\r",
							"\r",
							"  var kem = {};\r",
							"\r",
							"  /**\r",
							"   * Generates a secret key and its encapsulation.\r",
							"   *\r",
							"   * @param publicKey the RSA public key to encrypt with.\r",
							"   * @param keyLength the length, in bytes, of the secret key to generate.\r",
							"   *\r",
							"   * @return an object with:\r",
							"   *   encapsulation: the ciphertext for generating the secret key, as a\r",
							"   *     binary-encoded string of bytes.\r",
							"   *   key: the secret key to use for encrypting a message.\r",
							"   */\r",
							"  kem.encrypt = function(publicKey, keyLength) {\r",
							"    // generate a random r where 1 > r > n\r",
							"    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\r",
							"    var r;\r",
							"    do {\r",
							"      r = new BigInteger(\r",
							"        forge.util.bytesToHex(prng.getBytesSync(byteLength)),\r",
							"        16).mod(publicKey.n);\r",
							"    } while(r.equals(BigInteger.ZERO));\r",
							"\r",
							"    // prepend r with zeros\r",
							"    r = forge.util.hexToBytes(r.toString(16));\r",
							"    var zeros = byteLength - r.length;\r",
							"    if(zeros > 0) {\r",
							"      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\r",
							"    }\r",
							"\r",
							"    // encrypt the random\r",
							"    var encapsulation = publicKey.encrypt(r, 'NONE');\r",
							"\r",
							"    // generate the secret key\r",
							"    var key = kdf.generate(r, keyLength);\r",
							"\r",
							"    return {encapsulation: encapsulation, key: key};\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Decrypts an encapsulated secret key.\r",
							"   *\r",
							"   * @param privateKey the RSA private key to decrypt with.\r",
							"   * @param encapsulation the ciphertext for generating the secret key, as\r",
							"   *          a binary-encoded string of bytes.\r",
							"   * @param keyLength the length, in bytes, of the secret key to generate.\r",
							"   *\r",
							"   * @return the secret key as a binary-encoded string of bytes.\r",
							"   */\r",
							"  kem.decrypt = function(privateKey, encapsulation, keyLength) {\r",
							"    // decrypt the encapsulation and generate the secret key\r",
							"    var r = privateKey.decrypt(encapsulation, 'NONE');\r",
							"    return kdf.generate(r, keyLength);\r",
							"  };\r",
							"\r",
							"  return kem;\r",
							"};\r",
							"\r",
							"// TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\r",
							"\r",
							"/**\r",
							" * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\r",
							" *\r",
							" * @param md the hash API to use.\r",
							" * @param [digestLength] an optional digest length that must be positive and\r",
							" *          less than or equal to md.digestLength.\r",
							" *\r",
							" * @return a KDF1 API object.\r",
							" */\r",
							"forge.kem.kdf1 = function(md, digestLength) {\r",
							"  _createKDF(this, md, 0, digestLength || md.digestLength);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\r",
							" *\r",
							" * @param md the hash API to use.\r",
							" * @param [digestLength] an optional digest length that must be positive and\r",
							" *          less than or equal to md.digestLength.\r",
							" *\r",
							" * @return a KDF2 API object.\r",
							" */\r",
							"forge.kem.kdf2 = function(md, digestLength) {\r",
							"  _createKDF(this, md, 1, digestLength || md.digestLength);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a KDF1 or KDF2 API object.\r",
							" *\r",
							" * @param md the hash API to use.\r",
							" * @param counterStart the starting index for the counter.\r",
							" * @param digestLength the digest length to use.\r",
							" *\r",
							" * @return the KDF API object.\r",
							" */\r",
							"function _createKDF(kdf, md, counterStart, digestLength) {\r",
							"  /**\r",
							"   * Generate a key of the specified length.\r",
							"   *\r",
							"   * @param x the binary-encoded byte string to generate a key from.\r",
							"   * @param length the number of bytes to generate (the size of the key).\r",
							"   *\r",
							"   * @return the key as a binary-encoded string.\r",
							"   */\r",
							"  kdf.generate = function(x, length) {\r",
							"    var key = new forge.util.ByteBuffer();\r",
							"\r",
							"    // run counter from counterStart to ceil(length / Hash.len)\r",
							"    var k = Math.ceil(length / digestLength) + counterStart;\r",
							"\r",
							"    var c = new forge.util.ByteBuffer();\r",
							"    for(var i = counterStart; i < k; ++i) {\r",
							"      // I2OSP(i, 4): convert counter to an octet string of 4 octets\r",
							"      c.putInt32(i);\r",
							"\r",
							"      // digest 'x' and the counter and add the result to the key\r",
							"      md.start();\r",
							"      md.update(x + c.getBytes());\r",
							"      var hash = md.digest();\r",
							"      key.putBytes(hash.getBytes(digestLength));\r",
							"    }\r",
							"\r",
							"    // truncate to the correct key length\r",
							"    key.truncate(key.length() - length);\r",
							"    return key.getBytes();\r",
							"  };\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 41 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Node.js module for all known Forge message digests.\r",
							" *\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright 2011-2017 Digital Bazaar, Inc.\r",
							" */\r",
							"module.exports = __webpack_require__(4);\r",
							"\r",
							"__webpack_require__(14);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(23);\r",
							"__webpack_require__(32);\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 42 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Javascript implementation of PKCS#7 v1.5.\r",
							" *\r",
							" * @author Stefan Siegl\r",
							" * @author Dave Longley\r",
							" *\r",
							" * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r",
							" * Copyright (c) 2012-2015 Digital Bazaar, Inc.\r",
							" *\r",
							" * Currently this implementation only supports ContentType of EnvelopedData,\r",
							" * EncryptedData, or SignedData at the root level. The top level elements may\r",
							" * contain only a ContentInfo of ContentType Data, i.e. plain data. Further\r",
							" * nesting is not (yet) supported.\r",
							" *\r",
							" * The Forge validators for PKCS #7's ASN.1 structures are available from\r",
							" * a separate file pkcs7asn1.js, since those are referenced from other\r",
							" * PKCS standards like PKCS #12.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(3);\r",
							"__webpack_require__(10);\r",
							"__webpack_require__(6);\r",
							"__webpack_require__(7);\r",
							"__webpack_require__(29);\r",
							"__webpack_require__(2);\r",
							"__webpack_require__(1);\r",
							"__webpack_require__(16);\r",
							"\r",
							"// shortcut for ASN.1 API\r",
							"var asn1 = forge.asn1;\r",
							"\r",
							"// shortcut for PKCS#7 API\r",
							"var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#7 message from PEM format.\r",
							" *\r",
							" * @param pem the PEM-formatted PKCS#7 message.\r",
							" *\r",
							" * @return the PKCS#7 message.\r",
							" */\r",
							"p7.messageFromPem = function(pem) {\r",
							"  var msg = forge.pem.decode(pem)[0];\r",
							"\r",
							"  if(msg.type !== 'PKCS7') {\r",
							"    var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' +\r",
							"      'header type is not \"PKCS#7\".');\r",
							"    error.headerType = msg.type;\r",
							"    throw error;\r",
							"  }\r",
							"  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\r",
							"    throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');\r",
							"  }\r",
							"\r",
							"  // convert DER to ASN.1 object\r",
							"  var obj = asn1.fromDer(msg.body);\r",
							"\r",
							"  return p7.messageFromAsn1(obj);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#7 message to PEM format.\r",
							" *\r",
							" * @param msg The PKCS#7 message object\r",
							" * @param maxline The maximum characters per line, defaults to 64.\r",
							" *\r",
							" * @return The PEM-formatted PKCS#7 message.\r",
							" */\r",
							"p7.messageToPem = function(msg, maxline) {\r",
							"  // convert to ASN.1, then DER, then PEM-encode\r",
							"  var pemObj = {\r",
							"    type: 'PKCS7',\r",
							"    body: asn1.toDer(msg.toAsn1()).getBytes()\r",
							"  };\r",
							"  return forge.pem.encode(pemObj, {maxline: maxline});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a PKCS#7 message from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 representation of a ContentInfo.\r",
							" *\r",
							" * @return the PKCS#7 message.\r",
							" */\r",
							"p7.messageFromAsn1 = function(obj) {\r",
							"  // validate root level ContentInfo and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 message. ' +\r",
							"      'ASN.1 object is not an PKCS#7 ContentInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var contentType = asn1.derToOid(capture.contentType);\r",
							"  var msg;\r",
							"\r",
							"  switch(contentType) {\r",
							"    case forge.pki.oids.envelopedData:\r",
							"      msg = p7.createEnvelopedData();\r",
							"      break;\r",
							"\r",
							"    case forge.pki.oids.encryptedData:\r",
							"      msg = p7.createEncryptedData();\r",
							"      break;\r",
							"\r",
							"    case forge.pki.oids.signedData:\r",
							"      msg = p7.createSignedData();\r",
							"      break;\r",
							"\r",
							"    default:\r",
							"      throw new Error('Cannot read PKCS#7 message. ContentType with OID ' +\r",
							"        contentType + ' is not (yet) supported.');\r",
							"  }\r",
							"\r",
							"  msg.fromAsn1(capture.content.value[0]);\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"p7.createSignedData = function() {\r",
							"  var msg = null;\r",
							"  msg = {\r",
							"    type: forge.pki.oids.signedData,\r",
							"    version: 1,\r",
							"    certificates: [],\r",
							"    crls: [],\r",
							"    // TODO: add json-formatted signer stuff here?\r",
							"    signers: [],\r",
							"    // populated during sign()\r",
							"    digestAlgorithmIdentifiers: [],\r",
							"    contentInfo: null,\r",
							"    signerInfos: [],\r",
							"\r",
							"    fromAsn1: function(obj) {\r",
							"      // validate SignedData content block and capture data.\r",
							"      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);\r",
							"      msg.certificates = [];\r",
							"      msg.crls = [];\r",
							"      msg.digestAlgorithmIdentifiers = [];\r",
							"      msg.contentInfo = null;\r",
							"      msg.signerInfos = [];\r",
							"\r",
							"      if(msg.rawCapture.certificates) {\r",
							"        var certs = msg.rawCapture.certificates.value;\r",
							"        for(var i = 0; i < certs.length; ++i) {\r",
							"          msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // TODO: parse crls\r",
							"    },\r",
							"\r",
							"    toAsn1: function() {\r",
							"      // degenerate case with no content\r",
							"      if(!msg.contentInfo) {\r",
							"        msg.sign();\r",
							"      }\r",
							"\r",
							"      var certs = [];\r",
							"      for(var i = 0; i < msg.certificates.length; ++i) {\r",
							"        certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));\r",
							"      }\r",
							"\r",
							"      var crls = [];\r",
							"      // TODO: implement CRLs\r",
							"\r",
							"      // [0] SignedData\r",
							"      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // Version\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"            asn1.integerToDer(msg.version).getBytes()),\r",
							"          // DigestAlgorithmIdentifiers\r",
							"          asn1.create(\r",
							"            asn1.Class.UNIVERSAL, asn1.Type.SET, true,\r",
							"            msg.digestAlgorithmIdentifiers),\r",
							"          // ContentInfo\r",
							"          msg.contentInfo\r",
							"        ])\r",
							"      ]);\r",
							"      if(certs.length > 0) {\r",
							"        // [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL\r",
							"        signedData.value[0].value.push(\r",
							"          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));\r",
							"      }\r",
							"      if(crls.length > 0) {\r",
							"        // [1] IMPLICIT CertificateRevocationLists OPTIONAL\r",
							"        signedData.value[0].value.push(\r",
							"          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));\r",
							"      }\r",
							"      // SignerInfos\r",
							"      signedData.value[0].value.push(\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,\r",
							"          msg.signerInfos));\r",
							"\r",
							"      // ContentInfo\r",
							"      return asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // ContentType\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(msg.type).getBytes()),\r",
							"          // [0] SignedData\r",
							"          signedData\r",
							"        ]);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add (another) entity to list of signers.\r",
							"     *\r",
							"     * Note: If authenticatedAttributes are provided, then, per RFC 2315,\r",
							"     * they must include at least two attributes: content type and\r",
							"     * message digest. The message digest attribute value will be\r",
							"     * auto-calculated during signing and will be ignored if provided.\r",
							"     *\r",
							"     * Here's an example of providing these two attributes:\r",
							"     *\r",
							"     * forge.pkcs7.createSignedData();\r",
							"     * p7.addSigner({\r",
							"     *   issuer: cert.issuer.attributes,\r",
							"     *   serialNumber: cert.serialNumber,\r",
							"     *   key: privateKey,\r",
							"     *   digestAlgorithm: forge.pki.oids.sha1,\r",
							"     *   authenticatedAttributes: [{\r",
							"     *     type: forge.pki.oids.contentType,\r",
							"     *     value: forge.pki.oids.data\r",
							"     *   }, {\r",
							"     *     type: forge.pki.oids.messageDigest\r",
							"     *   }]\r",
							"     * });\r",
							"     *\r",
							"     * TODO: Support [subjectKeyIdentifier] as signer's ID.\r",
							"     *\r",
							"     * @param signer the signer information:\r",
							"     *          key the signer's private key.\r",
							"     *          [certificate] a certificate containing the public key\r",
							"     *            associated with the signer's private key; use this option as\r",
							"     *            an alternative to specifying signer.issuer and\r",
							"     *            signer.serialNumber.\r",
							"     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).\r",
							"     *          [serialNumber] the signer's certificate's serial number in\r",
							"     *           hexadecimal (eg: cert.serialNumber).\r",
							"     *          [digestAlgorithm] the message digest OID, as a string, to use\r",
							"     *            (eg: forge.pki.oids.sha1).\r",
							"     *          [authenticatedAttributes] an optional array of attributes\r",
							"     *            to also sign along with the content.\r",
							"     */\r",
							"    addSigner: function(signer) {\r",
							"      var issuer = signer.issuer;\r",
							"      var serialNumber = signer.serialNumber;\r",
							"      if(signer.certificate) {\r",
							"        var cert = signer.certificate;\r",
							"        if(typeof cert === 'string') {\r",
							"          cert = forge.pki.certificateFromPem(cert);\r",
							"        }\r",
							"        issuer = cert.issuer.attributes;\r",
							"        serialNumber = cert.serialNumber;\r",
							"      }\r",
							"      var key = signer.key;\r",
							"      if(!key) {\r",
							"        throw new Error(\r",
							"          'Could not add PKCS#7 signer; no private key specified.');\r",
							"      }\r",
							"      if(typeof key === 'string') {\r",
							"        key = forge.pki.privateKeyFromPem(key);\r",
							"      }\r",
							"\r",
							"      // ensure OID known for digest algorithm\r",
							"      var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;\r",
							"      switch(digestAlgorithm) {\r",
							"      case forge.pki.oids.sha1:\r",
							"      case forge.pki.oids.sha256:\r",
							"      case forge.pki.oids.sha384:\r",
							"      case forge.pki.oids.sha512:\r",
							"      case forge.pki.oids.md5:\r",
							"        break;\r",
							"      default:\r",
							"        throw new Error(\r",
							"          'Could not add PKCS#7 signer; unknown message digest algorithm: ' +\r",
							"          digestAlgorithm);\r",
							"      }\r",
							"\r",
							"      // if authenticatedAttributes is present, then the attributes\r",
							"      // must contain at least PKCS #9 content-type and message-digest\r",
							"      var authenticatedAttributes = signer.authenticatedAttributes || [];\r",
							"      if(authenticatedAttributes.length > 0) {\r",
							"        var contentType = false;\r",
							"        var messageDigest = false;\r",
							"        for(var i = 0; i < authenticatedAttributes.length; ++i) {\r",
							"          var attr = authenticatedAttributes[i];\r",
							"          if(!contentType && attr.type === forge.pki.oids.contentType) {\r",
							"            contentType = true;\r",
							"            if(messageDigest) {\r",
							"              break;\r",
							"            }\r",
							"            continue;\r",
							"          }\r",
							"          if(!messageDigest && attr.type === forge.pki.oids.messageDigest) {\r",
							"            messageDigest = true;\r",
							"            if(contentType) {\r",
							"              break;\r",
							"            }\r",
							"            continue;\r",
							"          }\r",
							"        }\r",
							"\r",
							"        if(!contentType || !messageDigest) {\r",
							"          throw new Error('Invalid signer.authenticatedAttributes. If ' +\r",
							"            'signer.authenticatedAttributes is specified, then it must ' +\r",
							"            'contain at least two attributes, PKCS #9 content-type and ' +\r",
							"            'PKCS #9 message-digest.');\r",
							"        }\r",
							"      }\r",
							"\r",
							"      msg.signers.push({\r",
							"        key: key,\r",
							"        version: 1,\r",
							"        issuer: issuer,\r",
							"        serialNumber: serialNumber,\r",
							"        digestAlgorithm: digestAlgorithm,\r",
							"        signatureAlgorithm: forge.pki.oids.rsaEncryption,\r",
							"        signature: null,\r",
							"        authenticatedAttributes: authenticatedAttributes,\r",
							"        unauthenticatedAttributes: []\r",
							"      });\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Signs the content.\r",
							"     */\r",
							"    sign: function() {\r",
							"      // auto-generate content info\r",
							"      if(typeof msg.content !== 'object' || msg.contentInfo === null) {\r",
							"        // use Data ContentInfo\r",
							"        msg.contentInfo = asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            // ContentType\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"              asn1.oidToDer(forge.pki.oids.data).getBytes())\r",
							"          ]);\r",
							"\r",
							"        // add actual content, if present\r",
							"        if('content' in msg) {\r",
							"          var content;\r",
							"          if(msg.content instanceof forge.util.ByteBuffer) {\r",
							"            content = msg.content.bytes();\r",
							"          } else if(typeof msg.content === 'string') {\r",
							"            content = forge.util.encodeUtf8(msg.content);\r",
							"          }\r",
							"\r",
							"          msg.contentInfo.value.push(\r",
							"            // [0] EXPLICIT content\r",
							"            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"                content)\r",
							"            ]));\r",
							"        }\r",
							"      }\r",
							"\r",
							"      // no signers, return early (degenerate case for certificate container)\r",
							"      if(msg.signers.length === 0) {\r",
							"        return;\r",
							"      }\r",
							"\r",
							"      // generate digest algorithm identifiers\r",
							"      var mds = addDigestAlgorithmIds();\r",
							"\r",
							"      // generate signerInfos\r",
							"      addSignerInfos(mds);\r",
							"    },\r",
							"\r",
							"    verify: function() {\r",
							"      throw new Error('PKCS#7 signature verification not yet implemented.');\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add a certificate.\r",
							"     *\r",
							"     * @param cert the certificate to add.\r",
							"     */\r",
							"    addCertificate: function(cert) {\r",
							"      // convert from PEM\r",
							"      if(typeof cert === 'string') {\r",
							"        cert = forge.pki.certificateFromPem(cert);\r",
							"      }\r",
							"      msg.certificates.push(cert);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add a certificate revokation list.\r",
							"     *\r",
							"     * @param crl the certificate revokation list to add.\r",
							"     */\r",
							"    addCertificateRevokationList: function(crl) {\r",
							"      throw new Error('PKCS#7 CRL support not yet implemented.');\r",
							"    }\r",
							"  };\r",
							"  return msg;\r",
							"\r",
							"  function addDigestAlgorithmIds() {\r",
							"    var mds = {};\r",
							"\r",
							"    for(var i = 0; i < msg.signers.length; ++i) {\r",
							"      var signer = msg.signers[i];\r",
							"      var oid = signer.digestAlgorithm;\r",
							"      if(!(oid in mds)) {\r",
							"        // content digest\r",
							"        mds[oid] = forge.md[forge.pki.oids[oid]].create();\r",
							"      }\r",
							"      if(signer.authenticatedAttributes.length === 0) {\r",
							"        // no custom attributes to digest; use content message digest\r",
							"        signer.md = mds[oid];\r",
							"      } else {\r",
							"        // custom attributes to be digested; use own message digest\r",
							"        // TODO: optimize to just copy message digest state if that\r",
							"        // feature is ever supported with message digests\r",
							"        signer.md = forge.md[forge.pki.oids[oid]].create();\r",
							"      }\r",
							"    }\r",
							"\r",
							"    // add unique digest algorithm identifiers\r",
							"    msg.digestAlgorithmIdentifiers = [];\r",
							"    for(var oid in mds) {\r",
							"      msg.digestAlgorithmIdentifiers.push(\r",
							"        // AlgorithmIdentifier\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"          // algorithm\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"            asn1.oidToDer(oid).getBytes()),\r",
							"          // parameters (null)\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"        ]));\r",
							"    }\r",
							"\r",
							"    return mds;\r",
							"  }\r",
							"\r",
							"  function addSignerInfos(mds) {\r",
							"    // Note: ContentInfo is a SEQUENCE with 2 values, second value is\r",
							"    // the content field and is optional for a ContentInfo but required here\r",
							"    // since signers are present\r",
							"    if(msg.contentInfo.value.length < 2) {\r",
							"      throw new Error(\r",
							"        'Could not sign PKCS#7 message; there is no content to sign.');\r",
							"    }\r",
							"\r",
							"    // get ContentInfo content type\r",
							"    var contentType = asn1.derToOid(msg.contentInfo.value[0].value);\r",
							"\r",
							"    // get ContentInfo content\r",
							"    var content = msg.contentInfo.value[1];\r",
							"    // skip [0] EXPLICIT content wrapper\r",
							"    content = content.value[0];\r",
							"\r",
							"    // serialize content\r",
							"    var bytes = asn1.toDer(content);\r",
							"\r",
							"    // skip identifier and length per RFC 2315 9.3\r",
							"    // skip identifier (1 byte)\r",
							"    bytes.getByte();\r",
							"    // read and discard length bytes\r",
							"    asn1.getBerValueLength(bytes);\r",
							"    bytes = bytes.getBytes();\r",
							"\r",
							"    // digest content DER value bytes\r",
							"    for(var oid in mds) {\r",
							"      mds[oid].start().update(bytes);\r",
							"    }\r",
							"\r",
							"    // sign content\r",
							"    var signingTime = new Date();\r",
							"    for(var i = 0; i < msg.signers.length; ++i) {\r",
							"      var signer = msg.signers[i];\r",
							"\r",
							"      if(signer.authenticatedAttributes.length === 0) {\r",
							"        // if ContentInfo content type is not \"Data\", then\r",
							"        // authenticatedAttributes must be present per RFC 2315\r",
							"        if(contentType !== forge.pki.oids.data) {\r",
							"          throw new Error(\r",
							"            'Invalid signer; authenticatedAttributes must be present ' +\r",
							"            'when the ContentInfo content type is not PKCS#7 Data.');\r",
							"        }\r",
							"      } else {\r",
							"        // process authenticated attributes\r",
							"        // [0] IMPLICIT\r",
							"        signer.authenticatedAttributesAsn1 = asn1.create(\r",
							"          asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\r",
							"\r",
							"        // per RFC 2315, attributes are to be digested using a SET container\r",
							"        // not the above [0] IMPLICIT container\r",
							"        var attrsAsn1 = asn1.create(\r",
							"          asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);\r",
							"\r",
							"        for(var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {\r",
							"          var attr = signer.authenticatedAttributes[ai];\r",
							"          if(attr.type === forge.pki.oids.messageDigest) {\r",
							"            // use content message digest as value\r",
							"            attr.value = mds[signer.digestAlgorithm].digest();\r",
							"          } else if(attr.type === forge.pki.oids.signingTime) {\r",
							"            // auto-populate signing time if not already set\r",
							"            if(!attr.value) {\r",
							"              attr.value = signingTime;\r",
							"            }\r",
							"          }\r",
							"\r",
							"          // convert to ASN.1 and push onto Attributes SET (for signing) and\r",
							"          // onto authenticatedAttributesAsn1 to complete SignedData ASN.1\r",
							"          // TODO: optimize away duplication\r",
							"          attrsAsn1.value.push(_attributeToAsn1(attr));\r",
							"          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));\r",
							"        }\r",
							"\r",
							"        // DER-serialize and digest SET OF attributes only\r",
							"        bytes = asn1.toDer(attrsAsn1).getBytes();\r",
							"        signer.md.start().update(bytes);\r",
							"      }\r",
							"\r",
							"      // sign digest\r",
							"      signer.signature = signer.key.sign(signer.md, 'RSASSA-PKCS1-V1_5');\r",
							"    }\r",
							"\r",
							"    // add signer info\r",
							"    msg.signerInfos = _signersToAsn1(msg.signers);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty PKCS#7 message of type EncryptedData.\r",
							" *\r",
							" * @return the message.\r",
							" */\r",
							"p7.createEncryptedData = function() {\r",
							"  var msg = null;\r",
							"  msg = {\r",
							"    type: forge.pki.oids.encryptedData,\r",
							"    version: 0,\r",
							"    encryptedContent: {\r",
							"      algorithm: forge.pki.oids['aes256-CBC']\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Reads an EncryptedData content block (in ASN.1 format)\r",
							"     *\r",
							"     * @param obj The ASN.1 representation of the EncryptedData content block\r",
							"     */\r",
							"    fromAsn1: function(obj) {\r",
							"      // Validate EncryptedData content block and capture data.\r",
							"      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Decrypt encrypted content\r",
							"     *\r",
							"     * @param key The (symmetric) key as a byte buffer\r",
							"     */\r",
							"    decrypt: function(key) {\r",
							"      if(key !== undefined) {\r",
							"        msg.encryptedContent.key = key;\r",
							"      }\r",
							"      _decryptContent(msg);\r",
							"    }\r",
							"  };\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates an empty PKCS#7 message of type EnvelopedData.\r",
							" *\r",
							" * @return the message.\r",
							" */\r",
							"p7.createEnvelopedData = function() {\r",
							"  var msg = null;\r",
							"  msg = {\r",
							"    type: forge.pki.oids.envelopedData,\r",
							"    version: 0,\r",
							"    recipients: [],\r",
							"    encryptedContent: {\r",
							"      algorithm: forge.pki.oids['aes256-CBC']\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Reads an EnvelopedData content block (in ASN.1 format)\r",
							"     *\r",
							"     * @param obj the ASN.1 representation of the EnvelopedData content block.\r",
							"     */\r",
							"    fromAsn1: function(obj) {\r",
							"      // validate EnvelopedData content block and capture data\r",
							"      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);\r",
							"      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);\r",
							"    },\r",
							"\r",
							"    toAsn1: function() {\r",
							"      // ContentInfo\r",
							"      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"        // ContentType\r",
							"        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"          asn1.oidToDer(msg.type).getBytes()),\r",
							"        // [0] EnvelopedData\r",
							"        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"            // Version\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"              asn1.integerToDer(msg.version).getBytes()),\r",
							"            // RecipientInfos\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,\r",
							"              _recipientsToAsn1(msg.recipients)),\r",
							"            // EncryptedContentInfo\r",
							"            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true,\r",
							"              _encryptedContentToAsn1(msg.encryptedContent))\r",
							"          ])\r",
							"        ])\r",
							"      ]);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Find recipient by X.509 certificate's issuer.\r",
							"     *\r",
							"     * @param cert the certificate with the issuer to look for.\r",
							"     *\r",
							"     * @return the recipient object.\r",
							"     */\r",
							"    findRecipient: function(cert) {\r",
							"      var sAttr = cert.issuer.attributes;\r",
							"\r",
							"      for(var i = 0; i < msg.recipients.length; ++i) {\r",
							"        var r = msg.recipients[i];\r",
							"        var rAttr = r.issuer;\r",
							"\r",
							"        if(r.serialNumber !== cert.serialNumber) {\r",
							"          continue;\r",
							"        }\r",
							"\r",
							"        if(rAttr.length !== sAttr.length) {\r",
							"          continue;\r",
							"        }\r",
							"\r",
							"        var match = true;\r",
							"        for(var j = 0; j < sAttr.length; ++j) {\r",
							"          if(rAttr[j].type !== sAttr[j].type ||\r",
							"            rAttr[j].value !== sAttr[j].value) {\r",
							"            match = false;\r",
							"            break;\r",
							"          }\r",
							"        }\r",
							"\r",
							"        if(match) {\r",
							"          return r;\r",
							"        }\r",
							"      }\r",
							"\r",
							"      return null;\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Decrypt enveloped content\r",
							"     *\r",
							"     * @param recipient The recipient object related to the private key\r",
							"     * @param privKey The (RSA) private key object\r",
							"     */\r",
							"    decrypt: function(recipient, privKey) {\r",
							"      if(msg.encryptedContent.key === undefined && recipient !== undefined &&\r",
							"        privKey !== undefined) {\r",
							"        switch(recipient.encryptedContent.algorithm) {\r",
							"          case forge.pki.oids.rsaEncryption:\r",
							"          case forge.pki.oids.desCBC:\r",
							"            var key = privKey.decrypt(recipient.encryptedContent.content);\r",
							"            msg.encryptedContent.key = forge.util.createBuffer(key);\r",
							"            break;\r",
							"\r",
							"          default:\r",
							"            throw new Error('Unsupported asymmetric cipher, ' +\r",
							"              'OID ' + recipient.encryptedContent.algorithm);\r",
							"        }\r",
							"      }\r",
							"\r",
							"      _decryptContent(msg);\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Add (another) entity to list of recipients.\r",
							"     *\r",
							"     * @param cert The certificate of the entity to add.\r",
							"     */\r",
							"    addRecipient: function(cert) {\r",
							"      msg.recipients.push({\r",
							"        version: 0,\r",
							"        issuer: cert.issuer.attributes,\r",
							"        serialNumber: cert.serialNumber,\r",
							"        encryptedContent: {\r",
							"          // We simply assume rsaEncryption here, since forge.pki only\r",
							"          // supports RSA so far.  If the PKI module supports other\r",
							"          // ciphers one day, we need to modify this one as well.\r",
							"          algorithm: forge.pki.oids.rsaEncryption,\r",
							"          key: cert.publicKey\r",
							"        }\r",
							"      });\r",
							"    },\r",
							"\r",
							"    /**\r",
							"     * Encrypt enveloped content.\r",
							"     *\r",
							"     * This function supports two optional arguments, cipher and key, which\r",
							"     * can be used to influence symmetric encryption.  Unless cipher is\r",
							"     * provided, the cipher specified in encryptedContent.algorithm is used\r",
							"     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key\r",
							"     * is (re-)used.  If that one's not set, a random key will be generated\r",
							"     * automatically.\r",
							"     *\r",
							"     * @param [key] The key to be used for symmetric encryption.\r",
							"     * @param [cipher] The OID of the symmetric cipher to use.\r",
							"     */\r",
							"    encrypt: function(key, cipher) {\r",
							"      // Part 1: Symmetric encryption\r",
							"      if(msg.encryptedContent.content === undefined) {\r",
							"        cipher = cipher || msg.encryptedContent.algorithm;\r",
							"        key = key || msg.encryptedContent.key;\r",
							"\r",
							"        var keyLen, ivLen, ciphFn;\r",
							"        switch(cipher) {\r",
							"          case forge.pki.oids['aes128-CBC']:\r",
							"            keyLen = 16;\r",
							"            ivLen = 16;\r",
							"            ciphFn = forge.aes.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          case forge.pki.oids['aes192-CBC']:\r",
							"            keyLen = 24;\r",
							"            ivLen = 16;\r",
							"            ciphFn = forge.aes.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          case forge.pki.oids['aes256-CBC']:\r",
							"            keyLen = 32;\r",
							"            ivLen = 16;\r",
							"            ciphFn = forge.aes.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          case forge.pki.oids['des-EDE3-CBC']:\r",
							"            keyLen = 24;\r",
							"            ivLen = 8;\r",
							"            ciphFn = forge.des.createEncryptionCipher;\r",
							"            break;\r",
							"\r",
							"          default:\r",
							"            throw new Error('Unsupported symmetric cipher, OID ' + cipher);\r",
							"        }\r",
							"\r",
							"        if(key === undefined) {\r",
							"          key = forge.util.createBuffer(forge.random.getBytes(keyLen));\r",
							"        } else if(key.length() != keyLen) {\r",
							"          throw new Error('Symmetric key has wrong length; ' +\r",
							"            'got ' + key.length() + ' bytes, expected ' + keyLen + '.');\r",
							"        }\r",
							"\r",
							"        // Keep a copy of the key & IV in the object, so the caller can\r",
							"        // use it for whatever reason.\r",
							"        msg.encryptedContent.algorithm = cipher;\r",
							"        msg.encryptedContent.key = key;\r",
							"        msg.encryptedContent.parameter = forge.util.createBuffer(\r",
							"          forge.random.getBytes(ivLen));\r",
							"\r",
							"        var ciph = ciphFn(key);\r",
							"        ciph.start(msg.encryptedContent.parameter.copy());\r",
							"        ciph.update(msg.content);\r",
							"\r",
							"        // The finish function does PKCS#7 padding by default, therefore\r",
							"        // no action required by us.\r",
							"        if(!ciph.finish()) {\r",
							"          throw new Error('Symmetric encryption failed.');\r",
							"        }\r",
							"\r",
							"        msg.encryptedContent.content = ciph.output;\r",
							"      }\r",
							"\r",
							"      // Part 2: asymmetric encryption for each recipient\r",
							"      for(var i = 0; i < msg.recipients.length; ++i) {\r",
							"        var recipient = msg.recipients[i];\r",
							"\r",
							"        // Nothing to do, encryption already done.\r",
							"        if(recipient.encryptedContent.content !== undefined) {\r",
							"          continue;\r",
							"        }\r",
							"\r",
							"        switch(recipient.encryptedContent.algorithm) {\r",
							"          case forge.pki.oids.rsaEncryption:\r",
							"            recipient.encryptedContent.content =\r",
							"              recipient.encryptedContent.key.encrypt(\r",
							"                msg.encryptedContent.key.data);\r",
							"            break;\r",
							"\r",
							"          default:\r",
							"            throw new Error('Unsupported asymmetric cipher, OID ' +\r",
							"              recipient.encryptedContent.algorithm);\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"  return msg;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Converts a single recipient from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 RecipientInfo.\r",
							" *\r",
							" * @return the recipient object.\r",
							" */\r",
							"function _recipientFromAsn1(obj) {\r",
							"  // validate EnvelopedData content block and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 RecipientInfo. ' +\r",
							"      'ASN.1 object is not an PKCS#7 RecipientInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  return {\r",
							"    version: capture.version.charCodeAt(0),\r",
							"    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\r",
							"    serialNumber: forge.util.createBuffer(capture.serial).toHex(),\r",
							"    encryptedContent: {\r",
							"      algorithm: asn1.derToOid(capture.encAlgorithm),\r",
							"      parameter: capture.encParameter.value,\r",
							"      content: capture.encKey\r",
							"    }\r",
							"  };\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a single recipient object to an ASN.1 object.\r",
							" *\r",
							" * @param obj the recipient object.\r",
							" *\r",
							" * @return the ASN.1 RecipientInfo.\r",
							" */\r",
							"function _recipientToAsn1(obj) {\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // Version\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(obj.version).getBytes()),\r",
							"    // IssuerAndSerialNumber\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // Name\r",
							"      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),\r",
							"      // Serial\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        forge.util.hexToBytes(obj.serialNumber))\r",
							"    ]),\r",
							"    // KeyEncryptionAlgorithmIdentifier\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // Algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),\r",
							"      // Parameter, force NULL, only RSA supported for now.\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ]),\r",
							"    // EncryptedKey\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"      obj.encryptedContent.content)\r",
							"  ]);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map a set of RecipientInfo ASN.1 objects to recipient objects.\r",
							" *\r",
							" * @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).\r",
							" *\r",
							" * @return an array of recipient objects.\r",
							" */\r",
							"function _recipientsFromAsn1(infos) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < infos.length; ++i) {\r",
							"    ret.push(_recipientFromAsn1(infos[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map an array of recipient objects to ASN.1 RecipientInfo objects.\r",
							" *\r",
							" * @param recipients an array of recipientInfo objects.\r",
							" *\r",
							" * @return an array of ASN.1 RecipientInfos.\r",
							" */\r",
							"function _recipientsToAsn1(recipients) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < recipients.length; ++i) {\r",
							"    ret.push(_recipientToAsn1(recipients[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a single signer from an ASN.1 object.\r",
							" *\r",
							" * @param obj the ASN.1 representation of a SignerInfo.\r",
							" *\r",
							" * @return the signer object.\r",
							" */\r",
							"function _signerFromAsn1(obj) {\r",
							"  // validate EnvelopedData content block and capture data\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 SignerInfo. ' +\r",
							"      'ASN.1 object is not an PKCS#7 SignerInfo.');\r",
							"    error.errors = errors;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  var rval = {\r",
							"    version: capture.version.charCodeAt(0),\r",
							"    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\r",
							"    serialNumber: forge.util.createBuffer(capture.serial).toHex(),\r",
							"    digestAlgorithm: asn1.derToOid(capture.digestAlgorithm),\r",
							"    signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm),\r",
							"    signature: capture.signature,\r",
							"    authenticatedAttributes: [],\r",
							"    unauthenticatedAttributes: []\r",
							"  };\r",
							"\r",
							"  // TODO: convert attributes\r",
							"  var authenticatedAttributes = capture.authenticatedAttributes || [];\r",
							"  var unauthenticatedAttributes = capture.unauthenticatedAttributes || [];\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Converts a single signerInfo object to an ASN.1 object.\r",
							" *\r",
							" * @param obj the signerInfo object.\r",
							" *\r",
							" * @return the ASN.1 representation of a SignerInfo.\r",
							" */\r",
							"function _signerToAsn1(obj) {\r",
							"  // SignerInfo\r",
							"  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // version\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"      asn1.integerToDer(obj.version).getBytes()),\r",
							"    // issuerAndSerialNumber\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // name\r",
							"      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),\r",
							"      // serial\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r",
							"        forge.util.hexToBytes(obj.serialNumber))\r",
							"    ]),\r",
							"    // digestAlgorithm\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(obj.digestAlgorithm).getBytes()),\r",
							"      // parameters (null)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"    ])\r",
							"  ]);\r",
							"\r",
							"  // authenticatedAttributes (OPTIONAL)\r",
							"  if(obj.authenticatedAttributesAsn1) {\r",
							"    // add ASN.1 previously generated during signing\r",
							"    rval.value.push(obj.authenticatedAttributesAsn1);\r",
							"  }\r",
							"\r",
							"  // digestEncryptionAlgorithm\r",
							"  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // algorithm\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(obj.signatureAlgorithm).getBytes()),\r",
							"    // parameters (null)\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r",
							"  ]));\r",
							"\r",
							"  // encryptedDigest\r",
							"  rval.value.push(asn1.create(\r",
							"    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));\r",
							"\r",
							"  // unauthenticatedAttributes (OPTIONAL)\r",
							"  if(obj.unauthenticatedAttributes.length > 0) {\r",
							"    // [1] IMPLICIT\r",
							"    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);\r",
							"    for(var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {\r",
							"      var attr = obj.unauthenticatedAttributes[i];\r",
							"      attrsAsn1.values.push(_attributeToAsn1(attr));\r",
							"    }\r",
							"    rval.value.push(attrsAsn1);\r",
							"  }\r",
							"\r",
							"  return rval;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map a set of SignerInfo ASN.1 objects to an array of signer objects.\r",
							" *\r",
							" * @param signerInfoAsn1s an array of ASN.1 SignerInfos (i.e. SET OF).\r",
							" *\r",
							" * @return an array of signers objects.\r",
							" */\r",
							"function _signersFromAsn1(signerInfoAsn1s) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < signerInfoAsn1s.length; ++i) {\r",
							"    ret.push(_signerFromAsn1(signerInfoAsn1s[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map an array of signer objects to ASN.1 objects.\r",
							" *\r",
							" * @param signers an array of signer objects.\r",
							" *\r",
							" * @return an array of ASN.1 SignerInfos.\r",
							" */\r",
							"function _signersToAsn1(signers) {\r",
							"  var ret = [];\r",
							"  for(var i = 0; i < signers.length; ++i) {\r",
							"    ret.push(_signerToAsn1(signers[i]));\r",
							"  }\r",
							"  return ret;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Convert an attribute object to an ASN.1 Attribute.\r",
							" *\r",
							" * @param attr the attribute object.\r",
							" *\r",
							" * @return the ASN.1 Attribute.\r",
							" */\r",
							"function _attributeToAsn1(attr) {\r",
							"  var value;\r",
							"\r",
							"  // TODO: generalize to support more attributes\r",
							"  if(attr.type === forge.pki.oids.contentType) {\r",
							"    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(attr.value).getBytes());\r",
							"  } else if(attr.type === forge.pki.oids.messageDigest) {\r",
							"    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"      attr.value.bytes());\r",
							"  } else if(attr.type === forge.pki.oids.signingTime) {\r",
							"    /* Note per RFC 2985: Dates between 1 January 1950 and 31 December 2049\r",
							"      (inclusive) MUST be encoded as UTCTime. Any dates with year values\r",
							"      before 1950 or after 2049 MUST be encoded as GeneralizedTime. [Further,]\r",
							"      UTCTime values MUST be expressed in Greenwich Mean Time (Zulu) and MUST\r",
							"      include seconds (i.e., times are YYMMDDHHMMSSZ), even where the\r",
							"      number of seconds is zero.  Midnight (GMT) must be represented as\r",
							"      \"YYMMDD000000Z\". */\r",
							"    // TODO: make these module-level constants\r",
							"    var jan_1_1950 = new Date('1950-01-01T00:00:00Z');\r",
							"    var jan_1_2050 = new Date('2050-01-01T00:00:00Z');\r",
							"    var date = attr.value;\r",
							"    if(typeof date === 'string') {\r",
							"      // try to parse date\r",
							"      var timestamp = Date.parse(date);\r",
							"      if(!isNaN(timestamp)) {\r",
							"        date = new Date(timestamp);\r",
							"      } else if(date.length === 13) {\r",
							"        // YYMMDDHHMMSSZ (13 chars for UTCTime)\r",
							"        date = asn1.utcTimeToDate(date);\r",
							"      } else {\r",
							"        // assume generalized time\r",
							"        date = asn1.generalizedTimeToDate(date);\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(date >= jan_1_1950 && date < jan_1_2050) {\r",
							"      value = asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\r",
							"        asn1.dateToUtcTime(date));\r",
							"    } else {\r",
							"      value = asn1.create(\r",
							"        asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,\r",
							"        asn1.dateToGeneralizedTime(date));\r",
							"    }\r",
							"  }\r",
							"\r",
							"  // TODO: expose as common API call\r",
							"  // create a RelativeDistinguishedName set\r",
							"  // each value in the set is an AttributeTypeAndValue first\r",
							"  // containing the type (an OID) and second the value\r",
							"  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"    // AttributeType\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(attr.type).getBytes()),\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r",
							"      // AttributeValue\r",
							"      value\r",
							"    ])\r",
							"  ]);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Map messages encrypted content to ASN.1 objects.\r",
							" *\r",
							" * @param ec The encryptedContent object of the message.\r",
							" *\r",
							" * @return ASN.1 representation of the encryptedContent object (SEQUENCE).\r",
							" */\r",
							"function _encryptedContentToAsn1(ec) {\r",
							"  return [\r",
							"    // ContentType, always Data for the moment\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"      asn1.oidToDer(forge.pki.oids.data).getBytes()),\r",
							"    // ContentEncryptionAlgorithmIdentifier\r",
							"    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r",
							"      // Algorithm\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r",
							"        asn1.oidToDer(ec.algorithm).getBytes()),\r",
							"      // Parameters (IV)\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"        ec.parameter.getBytes())\r",
							"    ]),\r",
							"    // [0] EncryptedContent\r",
							"    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r",
							"      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r",
							"        ec.content.getBytes())\r",
							"    ])\r",
							"  ];\r",
							"}\r",
							"\r",
							"/**\r",
							" * Reads the \"common part\" of an PKCS#7 content block (in ASN.1 format)\r",
							" *\r",
							" * This function reads the \"common part\" of the PKCS#7 content blocks\r",
							" * EncryptedData and EnvelopedData, i.e. version number and symmetrically\r",
							" * encrypted content block.\r",
							" *\r",
							" * The result of the ASN.1 validate and capture process is returned\r",
							" * to allow the caller to extract further data, e.g. the list of recipients\r",
							" * in case of a EnvelopedData object.\r",
							" *\r",
							" * @param msg the PKCS#7 object to read the data to.\r",
							" * @param obj the ASN.1 representation of the content block.\r",
							" * @param validator the ASN.1 structure validator object to use.\r",
							" *\r",
							" * @return the value map captured by validator object.\r",
							" */\r",
							"function _fromAsn1(msg, obj, validator) {\r",
							"  var capture = {};\r",
							"  var errors = [];\r",
							"  if(!asn1.validate(obj, validator, capture, errors)) {\r",
							"    var error = new Error('Cannot read PKCS#7 message. ' +\r",
							"      'ASN.1 object is not a supported PKCS#7 message.');\r",
							"    error.errors = error;\r",
							"    throw error;\r",
							"  }\r",
							"\r",
							"  // Check contentType, so far we only support (raw) Data.\r",
							"  var contentType = asn1.derToOid(capture.contentType);\r",
							"  if(contentType !== forge.pki.oids.data) {\r",
							"    throw new Error('Unsupported PKCS#7 message. ' +\r",
							"      'Only wrapped ContentType Data supported.');\r",
							"  }\r",
							"\r",
							"  if(capture.encryptedContent) {\r",
							"    var content = '';\r",
							"    if(forge.util.isArray(capture.encryptedContent)) {\r",
							"      for(var i = 0; i < capture.encryptedContent.length; ++i) {\r",
							"        if(capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {\r",
							"          throw new Error('Malformed PKCS#7 message, expecting encrypted ' +\r",
							"            'content constructed of only OCTET STRING objects.');\r",
							"        }\r",
							"        content += capture.encryptedContent[i].value;\r",
							"      }\r",
							"    } else {\r",
							"      content = capture.encryptedContent;\r",
							"    }\r",
							"    msg.encryptedContent = {\r",
							"      algorithm: asn1.derToOid(capture.encAlgorithm),\r",
							"      parameter: forge.util.createBuffer(capture.encParameter.value),\r",
							"      content: forge.util.createBuffer(content)\r",
							"    };\r",
							"  }\r",
							"\r",
							"  if(capture.content) {\r",
							"    var content = '';\r",
							"    if(forge.util.isArray(capture.content)) {\r",
							"      for(var i = 0; i < capture.content.length; ++i) {\r",
							"        if(capture.content[i].type !== asn1.Type.OCTETSTRING) {\r",
							"          throw new Error('Malformed PKCS#7 message, expecting ' +\r",
							"            'content constructed of only OCTET STRING objects.');\r",
							"        }\r",
							"        content += capture.content[i].value;\r",
							"      }\r",
							"    } else {\r",
							"      content = capture.content;\r",
							"    }\r",
							"    msg.content = forge.util.createBuffer(content);\r",
							"  }\r",
							"\r",
							"  msg.version = capture.version.charCodeAt(0);\r",
							"  msg.rawCapture = capture;\r",
							"\r",
							"  return capture;\r",
							"}\r",
							"\r",
							"/**\r",
							" * Decrypt the symmetrically encrypted content block of the PKCS#7 message.\r",
							" *\r",
							" * Decryption is skipped in case the PKCS#7 message object already has a\r",
							" * (decrypted) content attribute.  The algorithm, key and cipher parameters\r",
							" * (probably the iv) are taken from the encryptedContent attribute of the\r",
							" * message object.\r",
							" *\r",
							" * @param The PKCS#7 message object.\r",
							" */\r",
							"function _decryptContent(msg) {\r",
							"  if(msg.encryptedContent.key === undefined) {\r",
							"    throw new Error('Symmetric key not available.');\r",
							"  }\r",
							"\r",
							"  if(msg.content === undefined) {\r",
							"    var ciph;\r",
							"\r",
							"    switch(msg.encryptedContent.algorithm) {\r",
							"      case forge.pki.oids['aes128-CBC']:\r",
							"      case forge.pki.oids['aes192-CBC']:\r",
							"      case forge.pki.oids['aes256-CBC']:\r",
							"        ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);\r",
							"        break;\r",
							"\r",
							"      case forge.pki.oids['desCBC']:\r",
							"      case forge.pki.oids['des-EDE3-CBC']:\r",
							"        ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);\r",
							"        break;\r",
							"\r",
							"      default:\r",
							"        throw new Error('Unsupported symmetric cipher, OID ' +\r",
							"          msg.encryptedContent.algorithm);\r",
							"    }\r",
							"    ciph.start(msg.encryptedContent.parameter);\r",
							"    ciph.update(msg.encryptedContent.content);\r",
							"\r",
							"    if(!ciph.finish()) {\r",
							"      throw new Error('Symmetric decryption failed.');\r",
							"    }\r",
							"\r",
							"    msg.content = ciph.output;\r",
							"  }\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 43 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Functions to output keys in SSH-friendly formats.\r",
							" *\r",
							" * This is part of the Forge project which may be used under the terms of\r",
							" * either the BSD License or the GNU General Public License (GPL) Version 2.\r",
							" *\r",
							" * See: https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE\r",
							" *\r",
							" * @author https://github.com/shellac\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(5);\r",
							"__webpack_require__(8);\r",
							"__webpack_require__(14);\r",
							"__webpack_require__(9);\r",
							"__webpack_require__(1);\r",
							"\r",
							"var ssh = module.exports = forge.ssh = forge.ssh || {};\r",
							"\r",
							"/**\r",
							" * Encodes (and optionally encrypts) a private RSA key as a Putty PPK file.\r",
							" *\r",
							" * @param privateKey the key.\r",
							" * @param passphrase a passphrase to protect the key (falsy for no encryption).\r",
							" * @param comment a comment to include in the key file.\r",
							" *\r",
							" * @return the PPK file as a string.\r",
							" */\r",
							"ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {\r",
							"  comment = comment || '';\r",
							"  passphrase = passphrase || '';\r",
							"  var algorithm = 'ssh-rsa';\r",
							"  var encryptionAlgorithm = (passphrase === '') ? 'none' : 'aes256-cbc';\r",
							"\r",
							"  var ppk = 'PuTTY-User-Key-File-2: ' + algorithm + '\\r\\n';\r",
							"  ppk += 'Encryption: ' + encryptionAlgorithm + '\\r\\n';\r",
							"  ppk += 'Comment: ' + comment + '\\r\\n';\r",
							"\r",
							"  // public key into buffer for ppk\r",
							"  var pubbuffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(pubbuffer, algorithm);\r",
							"  _addBigIntegerToBuffer(pubbuffer, privateKey.e);\r",
							"  _addBigIntegerToBuffer(pubbuffer, privateKey.n);\r",
							"\r",
							"  // write public key\r",
							"  var pub = forge.util.encode64(pubbuffer.bytes(), 64);\r",
							"  var length = Math.floor(pub.length / 66) + 1; // 66 = 64 + \\r\\n\r",
							"  ppk += 'Public-Lines: ' + length + '\\r\\n';\r",
							"  ppk += pub;\r",
							"\r",
							"  // private key into a buffer\r",
							"  var privbuffer = forge.util.createBuffer();\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.d);\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.p);\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.q);\r",
							"  _addBigIntegerToBuffer(privbuffer, privateKey.qInv);\r",
							"\r",
							"  // optionally encrypt the private key\r",
							"  var priv;\r",
							"  if(!passphrase) {\r",
							"    // use the unencrypted buffer\r",
							"    priv = forge.util.encode64(privbuffer.bytes(), 64);\r",
							"  } else {\r",
							"    // encrypt RSA key using passphrase\r",
							"    var encLen = privbuffer.length() + 16 - 1;\r",
							"    encLen -= encLen % 16;\r",
							"\r",
							"    // pad private key with sha1-d data -- needs to be a multiple of 16\r",
							"    var padding = _sha1(privbuffer.bytes());\r",
							"\r",
							"    padding.truncate(padding.length() - encLen + privbuffer.length());\r",
							"    privbuffer.putBuffer(padding);\r",
							"\r",
							"    var aeskey = forge.util.createBuffer();\r",
							"    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x00', passphrase));\r",
							"    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x01', passphrase));\r",
							"\r",
							"    // encrypt some bytes using CBC mode\r",
							"    // key is 40 bytes, so truncate *by* 8 bytes\r",
							"    var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), 'CBC');\r",
							"    cipher.start(forge.util.createBuffer().fillWithByte(0, 16));\r",
							"    cipher.update(privbuffer.copy());\r",
							"    cipher.finish();\r",
							"    var encrypted = cipher.output;\r",
							"\r",
							"    // Note: this appears to differ from Putty -- is forge wrong, or putty?\r",
							"    // due to padding we finish as an exact multiple of 16\r",
							"    encrypted.truncate(16); // all padding\r",
							"\r",
							"    priv = forge.util.encode64(encrypted.bytes(), 64);\r",
							"  }\r",
							"\r",
							"  // output private key\r",
							"  length = Math.floor(priv.length / 66) + 1; // 64 + \\r\\n\r",
							"  ppk += '\\r\\nPrivate-Lines: ' + length + '\\r\\n';\r",
							"  ppk += priv;\r",
							"\r",
							"  // MAC\r",
							"  var mackey = _sha1('putty-private-key-file-mac-key', passphrase);\r",
							"\r",
							"  var macbuffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(macbuffer, algorithm);\r",
							"  _addStringToBuffer(macbuffer, encryptionAlgorithm);\r",
							"  _addStringToBuffer(macbuffer, comment);\r",
							"  macbuffer.putInt32(pubbuffer.length());\r",
							"  macbuffer.putBuffer(pubbuffer);\r",
							"  macbuffer.putInt32(privbuffer.length());\r",
							"  macbuffer.putBuffer(privbuffer);\r",
							"\r",
							"  var hmac = forge.hmac.create();\r",
							"  hmac.start('sha1', mackey);\r",
							"  hmac.update(macbuffer.bytes());\r",
							"\r",
							"  ppk += '\\r\\nPrivate-MAC: ' + hmac.digest().toHex() + '\\r\\n';\r",
							"\r",
							"  return ppk;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a public RSA key as an OpenSSH file.\r",
							" *\r",
							" * @param key the key.\r",
							" * @param comment a comment.\r",
							" *\r",
							" * @return the public key in OpenSSH format.\r",
							" */\r",
							"ssh.publicKeyToOpenSSH = function(key, comment) {\r",
							"  var type = 'ssh-rsa';\r",
							"  comment = comment || '';\r",
							"\r",
							"  var buffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(buffer, type);\r",
							"  _addBigIntegerToBuffer(buffer, key.e);\r",
							"  _addBigIntegerToBuffer(buffer, key.n);\r",
							"\r",
							"  return type + ' ' + forge.util.encode64(buffer.bytes()) + ' ' + comment;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Encodes a private RSA key as an OpenSSH file.\r",
							" *\r",
							" * @param key the key.\r",
							" * @param passphrase a passphrase to protect the key (falsy for no encryption).\r",
							" *\r",
							" * @return the public key in OpenSSH format.\r",
							" */\r",
							"ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {\r",
							"  if(!passphrase) {\r",
							"    return forge.pki.privateKeyToPem(privateKey);\r",
							"  }\r",
							"  // OpenSSH private key is just a legacy format, it seems\r",
							"  return forge.pki.encryptRsaPrivateKey(privateKey, passphrase,\r",
							"    {legacy: true, algorithm: 'aes128'});\r",
							"};\r",
							"\r",
							"/**\r",
							" * Gets the SSH fingerprint for the given public key.\r",
							" *\r",
							" * @param options the options to use.\r",
							" *          [md] the message digest object to use (defaults to forge.md.md5).\r",
							" *          [encoding] an alternative output encoding, such as 'hex'\r",
							" *            (defaults to none, outputs a byte buffer).\r",
							" *          [delimiter] the delimiter to use between bytes for 'hex' encoded\r",
							" *            output, eg: ':' (defaults to none).\r",
							" *\r",
							" * @return the fingerprint as a byte buffer or other encoding based on options.\r",
							" */\r",
							"ssh.getPublicKeyFingerprint = function(key, options) {\r",
							"  options = options || {};\r",
							"  var md = options.md || forge.md.md5.create();\r",
							"\r",
							"  var type = 'ssh-rsa';\r",
							"  var buffer = forge.util.createBuffer();\r",
							"  _addStringToBuffer(buffer, type);\r",
							"  _addBigIntegerToBuffer(buffer, key.e);\r",
							"  _addBigIntegerToBuffer(buffer, key.n);\r",
							"\r",
							"  // hash public key bytes\r",
							"  md.start();\r",
							"  md.update(buffer.getBytes());\r",
							"  var digest = md.digest();\r",
							"  if(options.encoding === 'hex') {\r",
							"    var hex = digest.toHex();\r",
							"    if(options.delimiter) {\r",
							"      return hex.match(/.{2}/g).join(options.delimiter);\r",
							"    }\r",
							"    return hex;\r",
							"  } else if(options.encoding === 'binary') {\r",
							"    return digest.getBytes();\r",
							"  } else if(options.encoding) {\r",
							"    throw new Error('Unknown encoding \"' + options.encoding + '\".');\r",
							"  }\r",
							"  return digest;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds len(val) then val to a buffer.\r",
							" *\r",
							" * @param buffer the buffer to add to.\r",
							" * @param val a big integer.\r",
							" */\r",
							"function _addBigIntegerToBuffer(buffer, val) {\r",
							"  var hexVal = val.toString(16);\r",
							"  // ensure 2s complement +ve\r",
							"  if(hexVal[0] >= '8') {\r",
							"    hexVal = '00' + hexVal;\r",
							"  }\r",
							"  var bytes = forge.util.hexToBytes(hexVal);\r",
							"  buffer.putInt32(bytes.length);\r",
							"  buffer.putBytes(bytes);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Adds len(val) then val to a buffer.\r",
							" *\r",
							" * @param buffer the buffer to add to.\r",
							" * @param val a string.\r",
							" */\r",
							"function _addStringToBuffer(buffer, val) {\r",
							"  buffer.putInt32(val.length);\r",
							"  buffer.putString(val);\r",
							"}\r",
							"\r",
							"/**\r",
							" * Hashes the arguments into one value using SHA-1.\r",
							" *\r",
							" * @return the sha1 hash of the provided arguments.\r",
							" */\r",
							"function _sha1() {\r",
							"  var sha = forge.md.sha1.create();\r",
							"  var num = arguments.length;\r",
							"  for (var i = 0; i < num; ++i) {\r",
							"    sha.update(arguments[i]);\r",
							"  }\r",
							"  return sha.digest();\r",
							"}\r",
							"\r",
							"\r",
							"/***/ }),\r",
							"/* 44 */\r",
							"/***/ (function(module, exports, __webpack_require__) {\r",
							"\r",
							"/**\r",
							" * Support for concurrent task management and synchronization in web\r",
							" * applications.\r",
							" *\r",
							" * @author Dave Longley\r",
							" * @author David I. Lehn <dlehn@digitalbazaar.com>\r",
							" *\r",
							" * Copyright (c) 2009-2013 Digital Bazaar, Inc.\r",
							" */\r",
							"var forge = __webpack_require__(0);\r",
							"__webpack_require__(31);\r",
							"__webpack_require__(33);\r",
							"__webpack_require__(1);\r",
							"\r",
							"// logging category\r",
							"var cat = 'forge.task';\r",
							"\r",
							"// verbose level\r",
							"// 0: off, 1: a little, 2: a whole lot\r",
							"// Verbose debug logging is surrounded by a level check to avoid the\r",
							"// performance issues with even calling the logging code regardless if it\r",
							"// is actually logged.  For performance reasons this should not be set to 2\r",
							"// for production use.\r",
							"// ex: if(sVL >= 2) forge.log.verbose(....)\r",
							"var sVL = 0;\r",
							"\r",
							"// track tasks for debugging\r",
							"var sTasks = {};\r",
							"var sNextTaskId = 0;\r",
							"// debug access\r",
							"forge.debug.set(cat, 'tasks', sTasks);\r",
							"\r",
							"// a map of task type to task queue\r",
							"var sTaskQueues = {};\r",
							"// debug access\r",
							"forge.debug.set(cat, 'queues', sTaskQueues);\r",
							"\r",
							"// name for unnamed tasks\r",
							"var sNoTaskName = '?';\r",
							"\r",
							"// maximum number of doNext() recursions before a context swap occurs\r",
							"// FIXME: might need to tweak this based on the browser\r",
							"var sMaxRecursions = 30;\r",
							"\r",
							"// time slice for doing tasks before a context swap occurs\r",
							"// FIXME: might need to tweak this based on the browser\r",
							"var sTimeSlice = 20;\r",
							"\r",
							"/**\r",
							" * Task states.\r",
							" *\r",
							" * READY: ready to start processing\r",
							" * RUNNING: task or a subtask is running\r",
							" * BLOCKED: task is waiting to acquire N permits to continue\r",
							" * SLEEPING: task is sleeping for a period of time\r",
							" * DONE: task is done\r",
							" * ERROR: task has an error\r",
							" */\r",
							"var READY = 'ready';\r",
							"var RUNNING = 'running';\r",
							"var BLOCKED = 'blocked';\r",
							"var SLEEPING = 'sleeping';\r",
							"var DONE = 'done';\r",
							"var ERROR = 'error';\r",
							"\r",
							"/**\r",
							" * Task actions.  Used to control state transitions.\r",
							" *\r",
							" * STOP: stop processing\r",
							" * START: start processing tasks\r",
							" * BLOCK: block task from continuing until 1 or more permits are released\r",
							" * UNBLOCK: release one or more permits\r",
							" * SLEEP: sleep for a period of time\r",
							" * WAKEUP: wakeup early from SLEEPING state\r",
							" * CANCEL: cancel further tasks\r",
							" * FAIL: a failure occured\r",
							" */\r",
							"var STOP = 'stop';\r",
							"var START = 'start';\r",
							"var BLOCK = 'block';\r",
							"var UNBLOCK = 'unblock';\r",
							"var SLEEP = 'sleep';\r",
							"var WAKEUP = 'wakeup';\r",
							"var CANCEL = 'cancel';\r",
							"var FAIL = 'fail';\r",
							"\r",
							"/**\r",
							" * State transition table.\r",
							" *\r",
							" * nextState = sStateTable[currentState][action]\r",
							" */\r",
							"var sStateTable = {};\r",
							"\r",
							"sStateTable[READY] = {};\r",
							"sStateTable[READY][STOP] = READY;\r",
							"sStateTable[READY][START] = RUNNING;\r",
							"sStateTable[READY][CANCEL] = DONE;\r",
							"sStateTable[READY][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[RUNNING] = {};\r",
							"sStateTable[RUNNING][STOP] = READY;\r",
							"sStateTable[RUNNING][START] = RUNNING;\r",
							"sStateTable[RUNNING][BLOCK] = BLOCKED;\r",
							"sStateTable[RUNNING][UNBLOCK] = RUNNING;\r",
							"sStateTable[RUNNING][SLEEP] = SLEEPING;\r",
							"sStateTable[RUNNING][WAKEUP] = RUNNING;\r",
							"sStateTable[RUNNING][CANCEL] = DONE;\r",
							"sStateTable[RUNNING][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[BLOCKED] = {};\r",
							"sStateTable[BLOCKED][STOP] = BLOCKED;\r",
							"sStateTable[BLOCKED][START] = BLOCKED;\r",
							"sStateTable[BLOCKED][BLOCK] = BLOCKED;\r",
							"sStateTable[BLOCKED][UNBLOCK] = BLOCKED;\r",
							"sStateTable[BLOCKED][SLEEP] = BLOCKED;\r",
							"sStateTable[BLOCKED][WAKEUP] = BLOCKED;\r",
							"sStateTable[BLOCKED][CANCEL] = DONE;\r",
							"sStateTable[BLOCKED][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[SLEEPING] = {};\r",
							"sStateTable[SLEEPING][STOP] = SLEEPING;\r",
							"sStateTable[SLEEPING][START] = SLEEPING;\r",
							"sStateTable[SLEEPING][BLOCK] = SLEEPING;\r",
							"sStateTable[SLEEPING][UNBLOCK] = SLEEPING;\r",
							"sStateTable[SLEEPING][SLEEP] = SLEEPING;\r",
							"sStateTable[SLEEPING][WAKEUP] = SLEEPING;\r",
							"sStateTable[SLEEPING][CANCEL] = DONE;\r",
							"sStateTable[SLEEPING][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[DONE] = {};\r",
							"sStateTable[DONE][STOP] = DONE;\r",
							"sStateTable[DONE][START] = DONE;\r",
							"sStateTable[DONE][BLOCK] = DONE;\r",
							"sStateTable[DONE][UNBLOCK] = DONE;\r",
							"sStateTable[DONE][SLEEP] = DONE;\r",
							"sStateTable[DONE][WAKEUP] = DONE;\r",
							"sStateTable[DONE][CANCEL] = DONE;\r",
							"sStateTable[DONE][FAIL] = ERROR;\r",
							"\r",
							"sStateTable[ERROR] = {};\r",
							"sStateTable[ERROR][STOP] = ERROR;\r",
							"sStateTable[ERROR][START] = ERROR;\r",
							"sStateTable[ERROR][BLOCK] = ERROR;\r",
							"sStateTable[ERROR][UNBLOCK] = ERROR;\r",
							"sStateTable[ERROR][SLEEP] = ERROR;\r",
							"sStateTable[ERROR][WAKEUP] = ERROR;\r",
							"sStateTable[ERROR][CANCEL] = ERROR;\r",
							"sStateTable[ERROR][FAIL] = ERROR;\r",
							"\r",
							"/**\r",
							" * Creates a new task.\r",
							" *\r",
							" * @param options options for this task\r",
							" *   run: the run function for the task (required)\r",
							" *   name: the run function for the task (optional)\r",
							" *   parent: parent of this task (optional)\r",
							" *\r",
							" * @return the empty task.\r",
							" */\r",
							"var Task = function(options) {\r",
							"  // task id\r",
							"  this.id = -1;\r",
							"\r",
							"  // task name\r",
							"  this.name = options.name || sNoTaskName;\r",
							"\r",
							"  // task has no parent\r",
							"  this.parent = options.parent || null;\r",
							"\r",
							"  // save run function\r",
							"  this.run = options.run;\r",
							"\r",
							"  // create a queue of subtasks to run\r",
							"  this.subtasks = [];\r",
							"\r",
							"  // error flag\r",
							"  this.error = false;\r",
							"\r",
							"  // state of the task\r",
							"  this.state = READY;\r",
							"\r",
							"  // number of times the task has been blocked (also the number\r",
							"  // of permits needed to be released to continue running)\r",
							"  this.blocks = 0;\r",
							"\r",
							"  // timeout id when sleeping\r",
							"  this.timeoutId = null;\r",
							"\r",
							"  // no swap time yet\r",
							"  this.swapTime = null;\r",
							"\r",
							"  // no user data\r",
							"  this.userData = null;\r",
							"\r",
							"  // initialize task\r",
							"  // FIXME: deal with overflow\r",
							"  this.id = sNextTaskId++;\r",
							"  sTasks[this.id] = this;\r",
							"  if(sVL >= 1) {\r",
							"    forge.log.verbose(cat, '[%s][%s] init', this.id, this.name, this);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Logs debug information on this task and the system state.\r",
							" */\r",
							"Task.prototype.debug = function(msg) {\r",
							"  msg = msg || '';\r",
							"  forge.log.debug(cat, msg,\r",
							"    '[%s][%s] task:', this.id, this.name, this,\r",
							"    'subtasks:', this.subtasks.length,\r",
							"    'queue:', sTaskQueues);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds a subtask to run after task.doNext() or task.fail() is called.\r",
							" *\r",
							" * @param name human readable name for this task (optional).\r",
							" * @param subrun a function to run that takes the current task as\r",
							" *          its first parameter.\r",
							" *\r",
							" * @return the current task (useful for chaining next() calls).\r",
							" */\r",
							"Task.prototype.next = function(name, subrun) {\r",
							"  // juggle parameters if it looks like no name is given\r",
							"  if(typeof(name) === 'function') {\r",
							"    subrun = name;\r",
							"\r",
							"    // inherit parent's name\r",
							"    name = this.name;\r",
							"  }\r",
							"  // create subtask, set parent to this task, propagate callbacks\r",
							"  var subtask = new Task({\r",
							"    run: subrun,\r",
							"    name: name,\r",
							"    parent: this\r",
							"  });\r",
							"  // start subtasks running\r",
							"  subtask.state = RUNNING;\r",
							"  subtask.type = this.type;\r",
							"  subtask.successCallback = this.successCallback || null;\r",
							"  subtask.failureCallback = this.failureCallback || null;\r",
							"\r",
							"  // queue a new subtask\r",
							"  this.subtasks.push(subtask);\r",
							"\r",
							"  return this;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Adds subtasks to run in parallel after task.doNext() or task.fail()\r",
							" * is called.\r",
							" *\r",
							" * @param name human readable name for this task (optional).\r",
							" * @param subrun functions to run that take the current task as\r",
							" *          their first parameter.\r",
							" *\r",
							" * @return the current task (useful for chaining next() calls).\r",
							" */\r",
							"Task.prototype.parallel = function(name, subrun) {\r",
							"  // juggle parameters if it looks like no name is given\r",
							"  if(forge.util.isArray(name)) {\r",
							"    subrun = name;\r",
							"\r",
							"    // inherit parent's name\r",
							"    name = this.name;\r",
							"  }\r",
							"  // Wrap parallel tasks in a regular task so they are started at the\r",
							"  // proper time.\r",
							"  return this.next(name, function(task) {\r",
							"    // block waiting for subtasks\r",
							"    var ptask = task;\r",
							"    ptask.block(subrun.length);\r",
							"\r",
							"    // we pass the iterator from the loop below as a parameter\r",
							"    // to a function because it is otherwise included in the\r",
							"    // closure and changes as the loop changes -- causing i\r",
							"    // to always be set to its highest value\r",
							"    var startParallelTask = function(pname, pi) {\r",
							"      forge.task.start({\r",
							"        type: pname,\r",
							"        run: function(task) {\r",
							"           subrun[pi](task);\r",
							"        },\r",
							"        success: function(task) {\r",
							"           ptask.unblock();\r",
							"        },\r",
							"        failure: function(task) {\r",
							"           ptask.unblock();\r",
							"        }\r",
							"      });\r",
							"    };\r",
							"\r",
							"    for(var i = 0; i < subrun.length; i++) {\r",
							"      // Type must be unique so task starts in parallel:\r",
							"      //    name + private string + task id + sub-task index\r",
							"      // start tasks in parallel and unblock when the finish\r",
							"      var pname = name + '__parallel-' + task.id + '-' + i;\r",
							"      var pi = i;\r",
							"      startParallelTask(pname, pi);\r",
							"    }\r",
							"  });\r",
							"};\r",
							"\r",
							"/**\r",
							" * Stops a running task.\r",
							" */\r",
							"Task.prototype.stop = function() {\r",
							"  this.state = sStateTable[this.state][STOP];\r",
							"};\r",
							"\r",
							"/**\r",
							" * Starts running a task.\r",
							" */\r",
							"Task.prototype.start = function() {\r",
							"  this.error = false;\r",
							"  this.state = sStateTable[this.state][START];\r",
							"\r",
							"  // try to restart\r",
							"  if(this.state === RUNNING) {\r",
							"    this.start = new Date();\r",
							"    this.run(this);\r",
							"    runNext(this, 0);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Blocks a task until it one or more permits have been released. The\r",
							" * task will not resume until the requested number of permits have\r",
							" * been released with call(s) to unblock().\r",
							" *\r",
							" * @param n number of permits to wait for(default: 1).\r",
							" */\r",
							"Task.prototype.block = function(n) {\r",
							"  n = typeof(n) === 'undefined' ? 1 : n;\r",
							"  this.blocks += n;\r",
							"  if(this.blocks > 0) {\r",
							"    this.state = sStateTable[this.state][BLOCK];\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Releases a permit to unblock a task. If a task was blocked by\r",
							" * requesting N permits via block(), then it will only continue\r",
							" * running once enough permits have been released via unblock() calls.\r",
							" *\r",
							" * If multiple processes need to synchronize with a single task then\r",
							" * use a condition variable (see forge.task.createCondition). It is\r",
							" * an error to unblock a task more times than it has been blocked.\r",
							" *\r",
							" * @param n number of permits to release (default: 1).\r",
							" *\r",
							" * @return the current block count (task is unblocked when count is 0)\r",
							" */\r",
							"Task.prototype.unblock = function(n) {\r",
							"  n = typeof(n) === 'undefined' ? 1 : n;\r",
							"  this.blocks -= n;\r",
							"  if(this.blocks === 0 && this.state !== DONE) {\r",
							"    this.state = RUNNING;\r",
							"    runNext(this, 0);\r",
							"  }\r",
							"  return this.blocks;\r",
							"};\r",
							"\r",
							"/**\r",
							" * Sleep for a period of time before resuming tasks.\r",
							" *\r",
							" * @param n number of milliseconds to sleep (default: 0).\r",
							" */\r",
							"Task.prototype.sleep = function(n) {\r",
							"  n = typeof(n) === 'undefined' ? 0 : n;\r",
							"  this.state = sStateTable[this.state][SLEEP];\r",
							"  var self = this;\r",
							"  this.timeoutId = setTimeout(function() {\r",
							"    self.timeoutId = null;\r",
							"    self.state = RUNNING;\r",
							"    runNext(self, 0);\r",
							"  }, n);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Waits on a condition variable until notified. The next task will\r",
							" * not be scheduled until notification. A condition variable can be\r",
							" * created with forge.task.createCondition().\r",
							" *\r",
							" * Once cond.notify() is called, the task will continue.\r",
							" *\r",
							" * @param cond the condition variable to wait on.\r",
							" */\r",
							"Task.prototype.wait = function(cond) {\r",
							"  cond.wait(this);\r",
							"};\r",
							"\r",
							"/**\r",
							" * If sleeping, wakeup and continue running tasks.\r",
							" */\r",
							"Task.prototype.wakeup = function() {\r",
							"  if(this.state === SLEEPING) {\r",
							"    cancelTimeout(this.timeoutId);\r",
							"    this.timeoutId = null;\r",
							"    this.state = RUNNING;\r",
							"    runNext(this, 0);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Cancel all remaining subtasks of this task.\r",
							" */\r",
							"Task.prototype.cancel = function() {\r",
							"  this.state = sStateTable[this.state][CANCEL];\r",
							"  // remove permits needed\r",
							"  this.permitsNeeded = 0;\r",
							"  // cancel timeouts\r",
							"  if(this.timeoutId !== null) {\r",
							"    cancelTimeout(this.timeoutId);\r",
							"    this.timeoutId = null;\r",
							"  }\r",
							"  // remove subtasks\r",
							"  this.subtasks = [];\r",
							"};\r",
							"\r",
							"/**\r",
							" * Finishes this task with failure and sets error flag. The entire\r",
							" * task will be aborted unless the next task that should execute\r",
							" * is passed as a parameter. This allows levels of subtasks to be\r",
							" * skipped. For instance, to abort only this tasks's subtasks, then\r",
							" * call fail(task.parent). To abort this task's subtasks and its\r",
							" * parent's subtasks, call fail(task.parent.parent). To abort\r",
							" * all tasks and simply call the task callback, call fail() or\r",
							" * fail(null).\r",
							" *\r",
							" * The task callback (success or failure) will always, eventually, be\r",
							" * called.\r",
							" *\r",
							" * @param next the task to continue at, or null to abort entirely.\r",
							" */\r",
							"Task.prototype.fail = function(next) {\r",
							"  // set error flag\r",
							"  this.error = true;\r",
							"\r",
							"  // finish task\r",
							"  finish(this, true);\r",
							"\r",
							"  if(next) {\r",
							"    // propagate task info\r",
							"    next.error = this.error;\r",
							"    next.swapTime = this.swapTime;\r",
							"    next.userData = this.userData;\r",
							"\r",
							"    // do next task as specified\r",
							"    runNext(next, 0);\r",
							"  } else {\r",
							"    if(this.parent !== null) {\r",
							"      // finish root task (ensures it is removed from task queue)\r",
							"      var parent = this.parent;\r",
							"      while(parent.parent !== null) {\r",
							"        // propagate task info\r",
							"        parent.error = this.error;\r",
							"        parent.swapTime = this.swapTime;\r",
							"        parent.userData = this.userData;\r",
							"        parent = parent.parent;\r",
							"      }\r",
							"      finish(parent, true);\r",
							"    }\r",
							"\r",
							"    // call failure callback if one exists\r",
							"    if(this.failureCallback) {\r",
							"      this.failureCallback(this);\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Asynchronously start a task.\r",
							" *\r",
							" * @param task the task to start.\r",
							" */\r",
							"var start = function(task) {\r",
							"  task.error = false;\r",
							"  task.state = sStateTable[task.state][START];\r",
							"  setTimeout(function() {\r",
							"    if(task.state === RUNNING) {\r",
							"      task.swapTime = +new Date();\r",
							"      task.run(task);\r",
							"      runNext(task, 0);\r",
							"    }\r",
							"  }, 0);\r",
							"};\r",
							"\r",
							"/**\r",
							" * Run the next subtask or finish this task.\r",
							" *\r",
							" * @param task the task to process.\r",
							" * @param recurse the recursion count.\r",
							" */\r",
							"var runNext = function(task, recurse) {\r",
							"  // get time since last context swap (ms), if enough time has passed set\r",
							"  // swap to true to indicate that doNext was performed asynchronously\r",
							"  // also, if recurse is too high do asynchronously\r",
							"  var swap =\r",
							"    (recurse > sMaxRecursions) ||\r",
							"    (+new Date() - task.swapTime) > sTimeSlice;\r",
							"\r",
							"  var doNext = function(recurse) {\r",
							"    recurse++;\r",
							"    if(task.state === RUNNING) {\r",
							"      if(swap) {\r",
							"        // update swap time\r",
							"        task.swapTime = +new Date();\r",
							"      }\r",
							"\r",
							"      if(task.subtasks.length > 0) {\r",
							"        // run next subtask\r",
							"        var subtask = task.subtasks.shift();\r",
							"        subtask.error = task.error;\r",
							"        subtask.swapTime = task.swapTime;\r",
							"        subtask.userData = task.userData;\r",
							"        subtask.run(subtask);\r",
							"        if(!subtask.error) {\r",
							"           runNext(subtask, recurse);\r",
							"        }\r",
							"      } else {\r",
							"        finish(task);\r",
							"\r",
							"        if(!task.error) {\r",
							"          // chain back up and run parent\r",
							"          if(task.parent !== null) {\r",
							"            // propagate task info\r",
							"            task.parent.error = task.error;\r",
							"            task.parent.swapTime = task.swapTime;\r",
							"            task.parent.userData = task.userData;\r",
							"\r",
							"            // no subtasks left, call run next subtask on parent\r",
							"            runNext(task.parent, recurse);\r",
							"          }\r",
							"        }\r",
							"      }\r",
							"    }\r",
							"  };\r",
							"\r",
							"  if(swap) {\r",
							"    // we're swapping, so run asynchronously\r",
							"    setTimeout(doNext, 0);\r",
							"  } else {\r",
							"    // not swapping, so run synchronously\r",
							"    doNext(recurse);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Finishes a task and looks for the next task in the queue to start.\r",
							" *\r",
							" * @param task the task to finish.\r",
							" * @param suppressCallbacks true to suppress callbacks.\r",
							" */\r",
							"var finish = function(task, suppressCallbacks) {\r",
							"  // subtask is now done\r",
							"  task.state = DONE;\r",
							"\r",
							"  delete sTasks[task.id];\r",
							"  if(sVL >= 1) {\r",
							"    forge.log.verbose(cat, '[%s][%s] finish',\r",
							"      task.id, task.name, task);\r",
							"  }\r",
							"\r",
							"  // only do queue processing for root tasks\r",
							"  if(task.parent === null) {\r",
							"    // report error if queue is missing\r",
							"    if(!(task.type in sTaskQueues)) {\r",
							"      forge.log.error(cat,\r",
							"        '[%s][%s] task queue missing [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    } else if(sTaskQueues[task.type].length === 0) {\r",
							"      // report error if queue is empty\r",
							"      forge.log.error(cat,\r",
							"        '[%s][%s] task queue empty [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    } else if(sTaskQueues[task.type][0] !== task) {\r",
							"      // report error if this task isn't the first in the queue\r",
							"      forge.log.error(cat,\r",
							"        '[%s][%s] task not first in queue [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    } else {\r",
							"      // remove ourselves from the queue\r",
							"      sTaskQueues[task.type].shift();\r",
							"      // clean up queue if it is empty\r",
							"      if(sTaskQueues[task.type].length === 0) {\r",
							"        if(sVL >= 1) {\r",
							"          forge.log.verbose(cat, '[%s][%s] delete queue [%s]',\r",
							"            task.id, task.name, task.type);\r",
							"        }\r",
							"        /* Note: Only a task can delete a queue of its own type. This\r",
							"         is used as a way to synchronize tasks. If a queue for a certain\r",
							"         task type exists, then a task of that type is running.\r",
							"         */\r",
							"        delete sTaskQueues[task.type];\r",
							"      } else {\r",
							"        // dequeue the next task and start it\r",
							"        if(sVL >= 1) {\r",
							"          forge.log.verbose(cat,\r",
							"            '[%s][%s] queue start next [%s] remain:%s',\r",
							"            task.id, task.name, task.type,\r",
							"            sTaskQueues[task.type].length);\r",
							"        }\r",
							"        sTaskQueues[task.type][0].start();\r",
							"      }\r",
							"    }\r",
							"\r",
							"    if(!suppressCallbacks) {\r",
							"      // call final callback if one exists\r",
							"      if(task.error && task.failureCallback) {\r",
							"        task.failureCallback(task);\r",
							"      } else if(!task.error && task.successCallback) {\r",
							"        task.successCallback(task);\r",
							"      }\r",
							"    }\r",
							"  }\r",
							"};\r",
							"\r",
							"/* Tasks API */\r",
							"module.exports = forge.task = forge.task || {};\r",
							"\r",
							"/**\r",
							" * Starts a new task that will run the passed function asynchronously.\r",
							" *\r",
							" * In order to finish the task, either task.doNext() or task.fail()\r",
							" * *must* be called.\r",
							" *\r",
							" * The task must have a type (a string identifier) that can be used to\r",
							" * synchronize it with other tasks of the same type. That type can also\r",
							" * be used to cancel tasks that haven't started yet.\r",
							" *\r",
							" * To start a task, the following object must be provided as a parameter\r",
							" * (each function takes a task object as its first parameter):\r",
							" *\r",
							" * {\r",
							" *   type: the type of task.\r",
							" *   run: the function to run to execute the task.\r",
							" *   success: a callback to call when the task succeeds (optional).\r",
							" *   failure: a callback to call when the task fails (optional).\r",
							" * }\r",
							" *\r",
							" * @param options the object as described above.\r",
							" */\r",
							"forge.task.start = function(options) {\r",
							"  // create a new task\r",
							"  var task = new Task({\r",
							"    run: options.run,\r",
							"    name: options.name || sNoTaskName\r",
							"  });\r",
							"  task.type = options.type;\r",
							"  task.successCallback = options.success || null;\r",
							"  task.failureCallback = options.failure || null;\r",
							"\r",
							"  // append the task onto the appropriate queue\r",
							"  if(!(task.type in sTaskQueues)) {\r",
							"    if(sVL >= 1) {\r",
							"      forge.log.verbose(cat, '[%s][%s] create queue [%s]',\r",
							"        task.id, task.name, task.type);\r",
							"    }\r",
							"    // create the queue with the new task\r",
							"    sTaskQueues[task.type] = [task];\r",
							"    start(task);\r",
							"  } else {\r",
							"    // push the task onto the queue, it will be run after a task\r",
							"    // with the same type completes\r",
							"    sTaskQueues[options.type].push(task);\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Cancels all tasks of the given type that haven't started yet.\r",
							" *\r",
							" * @param type the type of task to cancel.\r",
							" */\r",
							"forge.task.cancel = function(type) {\r",
							"  // find the task queue\r",
							"  if(type in sTaskQueues) {\r",
							"    // empty all but the current task from the queue\r",
							"    sTaskQueues[type] = [sTaskQueues[type][0]];\r",
							"  }\r",
							"};\r",
							"\r",
							"/**\r",
							" * Creates a condition variable to synchronize tasks. To make a task wait\r",
							" * on the condition variable, call task.wait(condition). To notify all\r",
							" * tasks that are waiting, call condition.notify().\r",
							" *\r",
							" * @return the condition variable.\r",
							" */\r",
							"forge.task.createCondition = function() {\r",
							"  var cond = {\r",
							"    // all tasks that are blocked\r",
							"    tasks: {}\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Causes the given task to block until notify is called. If the task\r",
							"   * is already waiting on this condition then this is a no-op.\r",
							"   *\r",
							"   * @param task the task to cause to wait.\r",
							"   */\r",
							"  cond.wait = function(task) {\r",
							"    // only block once\r",
							"    if(!(task.id in cond.tasks)) {\r",
							"       task.block();\r",
							"       cond.tasks[task.id] = task;\r",
							"    }\r",
							"  };\r",
							"\r",
							"  /**\r",
							"   * Notifies all waiting tasks to wake up.\r",
							"   */\r",
							"  cond.notify = function() {\r",
							"    // since unblock() will run the next task from here, make sure to\r",
							"    // clear the condition's blocked task list before unblocking\r",
							"    var tmp = cond.tasks;\r",
							"    cond.tasks = {};\r",
							"    for(var id in tmp) {\r",
							"      tmp[id].unblock();\r",
							"    }\r",
							"  };\r",
							"\r",
							"  return cond;\r",
							"};\r",
							"\r",
							"\r",
							"/***/ })\r",
							"/******/ ]); \r",
							" \r",
							" \r",
							" \r",
							"// Signature generation section bellow\r",
							" \r",
							" // Common\r",
							"function getHeaderValue(headerName) {\r",
							"    const headerValue = request.headers[headerName];\r",
							"    if (headerValue === undefined) {\r",
							"        throw new Error(`Required header: ${headerName} is not defined`);\r",
							"    }\r",
							"    //return resolveVariables(headerValue);\r",
							"    return headerValue;\r",
							"}\r",
							"  \r",
							"function resolveVariables(textWithPossibleVariables) {\r",
							"    return textWithPossibleVariables.replace  (/{{(\\w*)}}/,g, (str, key) => {\r",
							"        const value = environment[key];\r",
							"        return value === null ? \"\" : value;\r",
							"    });\r",
							"}\r",
							"  \r",
							" // Digest Calculation\r",
							"function resolveRequestBody() {\r",
							"    const contentType = getHeaderValue(\"content-type\");\r",
							"      \r",
							"    if (contentType === \"application/x-www-form-urlencoded\") {\r",
							"        const data = Object.keys(request.data)\r",
							"            .sort((a, b) => {\r",
							"                if(a < b) { return -1; }\r",
							"                if(a > b) { return 1; }\r",
							"                return 0;\r",
							"            })\r",
							"            .map(key => key + \"=\" + request.data[key])\r",
							"            .join('&');\r",
							"        return resolveVariables(data);\r",
							"    } else if (Object.entries(request.data).length === 0 && request.data.constructor === Object) {\r",
							"        return \"\";\r",
							"    }\r",
							"  \r",
							"    //return resolveVariables(request.data.toString());\r",
							"    return (request.data.toString());\r",
							"}\r",
							"  \r",
							"function calculateDigest() {\r",
							"    const requestData = resolveRequestBody();\r",
							"    const sha256digest = CryptoJS.SHA256(requestData);\r",
							"    const base64sha256 = CryptoJS.enc.Base64.stringify(sha256digest);\r",
							"    const calculatedDigest = 'sha-256=' + base64sha256;\r",
							"    pm.environment.set(\"Digest\", calculatedDigest);\r",
							"    return calculatedDigest;\r",
							"}\r",
							"  \r",
							"  // Signature Calculation\r",
							"  \r",
							"const sdk = require(\"postman-collection\");\r",
							"const moment = require(\"moment\");\r",
							"  \r",
							"const requestWithoutContentHeaders = \"(request-target) x-nordea-originating-host x-nordea-originating-date\";\r",
							"const requestWithContentHeaders = \"(request-target) x-nordea-originating-host x-nordea-originating-date content-type digest\";\r",
							"  \r",
							"function getSignatureBaseOnRequest() {\r",
							"    const url = new sdk.Url(request.url);\r",
							"    const host = url.getHost().toLowerCase();\r",
							"    const path = url.getPathWithQuery().toLowerCase();\r",
							"    const method = request.method.toLowerCase();\r",
							"    const date = moment().utc().format(\"ddd, DD MMM YYYY HH:mm:ss\") + \" GMT\";\r",
							"  \r",
							"    let headers = requestWithoutContentHeaders;\r",
							"  \r",
							"    let normalizedString =\r",
							"        `(request-target): ${method} ${path}\\n` +\r",
							"        `x-nordea-originating-host: ${host}\\n` +\r",
							"        `x-nordea-originating-date: ${date}`;\r",
							"  \r",
							"    if (method === \"post\" || method === \"put\" || method === \"patch\") {\r",
							"        const contentType = getHeaderValue(\"content-type\");\r",
							"        const digest = calculateDigest();\r",
							"        normalizedString += `\\ncontent-type: ${contentType}\\ndigest: ${digest}`\r",
							"  \r",
							"        headers = requestWithContentHeaders;\r",
							"    }\r",
							"    return {host, path, method, date, headers, normalizedString};\r",
							"}\r",
							"\r",
							"function encryptSignature(normalizedSignatureString) {\r",
							"    const messageDigest = forge.md.sha256.create();\r",
							"    messageDigest.update(normalizedSignatureString,\"utf-8\");\r",
							"    return forge.util.encode64(getPrivateKey().sign(messageDigest));           \r",
							"}\r",
							"  \r",
							"function getPrivateKey() {\r",
							"    let eidasPrivateKey = pm.environment.get(\"eidasPrivateKey\");\r",
							"     \r",
							"    if (!eidasPrivateKey.includes('PRIVATE KEY')) {\r",
							"        eidasPrivateKey = \"-----BEGIN RSA PRIVATE KEY-----\\n\" + eidasPrivateKey + \"\\n\" + \"-----END RSA PRIVATE KEY-----\";\r",
							"    }\r",
							"    return forge.pki.privateKeyFromPem(eidasPrivateKey);\r",
							"}\r",
							"const clientId = getHeaderValue(\"x-ibm-client-id\");\r",
							"const signature = getSignatureBaseOnRequest();\r",
							"const encryptedSignature = encryptSignature(signature.normalizedString);\r",
							"const signatureHeader = `keyId=\"${clientId}\",algorithm=\"rsa-sha256\",headers=\"${signature.headers}\",signature=\"${encryptedSignature}\"`;\r",
							"  \r",
							"pm.environment.set(\"Signature\", signatureHeader);\r",
							"pm.environment.set(\"X-Nordea-Originating-Host\", signature.host);\r",
							"pm.environment.set(\"X-Nordea-Originating-Date\", signature.date);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"var jsonData = pm.response.json();\r",
							"pm.environment.set(\"payment_id\", jsonData.refund_payment.id);"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disabledSystemHeaders": {
					"content-type": true
				}
			},
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Digest",
						"value": "{{Digest}}",
						"type": "text"
					},
					{
						"key": "Signature",
						"value": "{{Signature}}",
						"type": "text"
					},
					{
						"key": "Technical-user-id",
						"value": "1234567",
						"type": "text"
					},
					{
						"key": "X-IBM-Client-Secret",
						"value": "{{X-IBM-Client-Secret}}",
						"type": "text"
					},
					{
						"key": "X-Nordea-Originating-Date",
						"value": "{{X-Nordea-Originating-Date}}",
						"type": "text"
					},
					{
						"key": "X-Nordea-Originating-Host",
						"value": "{{X-Nordea-Originating-Host}}",
						"type": "text"
					},
					{
						"key": "X-IBM-Client-Id",
						"value": "{{X-IBM-Client-Id}}",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"payment_archive_id\": \"202103152588CEP10001\",\r\n    \"payment_account\": \"FI1410093000123458\",\r\n    \"amount\": \"18\",\r\n    \"message\": \"This is a sample message!\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://api.nordeaopenbanking.com/corporate/payment-refunds/v1/refunds",
					"protocol": "https",
					"host": [
						"api",
						"nordeaopenbanking",
						"com"
					],
					"path": [
						"corporate",
						"payment-refunds",
						"v1",
						"refunds"
					]
				}
			},
			"response": []
		}
	]
}
